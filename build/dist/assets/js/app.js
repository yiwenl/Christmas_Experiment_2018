/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		;
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(requestTimeout) { // eslint-disable-line no-unused-vars
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if(typeof XMLHttpRequest === "undefined")
/******/ 				return reject(new Error("No browser support"));
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch(err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if(request.readyState !== 4) return;
/******/ 				if(request.status === 0) {
/******/ 					// timeout
/******/ 					reject(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 				} else if(request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if(request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch(e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "42b8b225464e354a5c1f"; // eslint-disable-line no-unused-vars
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if(me.children.indexOf(request) < 0)
/******/ 					me.children.push(request);
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name) && name !== "e") {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/ 	
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if(hotStatus === "prepare") {
/******/ 					if(!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if(!deferred) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve().then(function() {
/******/ 				return hotApply(hotApplyOnUpdate);
/******/ 			}).then(
/******/ 				function(result) {
/******/ 					deferred.resolve(result);
/******/ 				},
/******/ 				function(err) {
/******/ 					deferred.reject(err);
/******/ 				}
/******/ 			);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/ 	
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/ 	
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while(queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if(module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(!parent) continue;
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 	
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn("[HMR] unexpected require(" + result.moduleId + ") to disposed module");
/******/ 		};
/******/ 	
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				var result;
/******/ 				if(hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if(result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch(result.type) {
/******/ 					case "self-declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of self decline: " + result.moduleId + chainInfo);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of declined dependency: " + result.moduleId + " in " + result.parentId + chainInfo);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if(options.onUnaccepted)
/******/ 							options.onUnaccepted(result);
/******/ 						if(!options.ignoreUnaccepted)
/******/ 							abortError = new Error("Aborted because " + moduleId + " is not accepted" + chainInfo);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if(options.onAccepted)
/******/ 							options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if(options.onDisposed)
/******/ 							options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if(abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if(doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for(moduleId in result.outdatedDependencies) {
/******/ 						if(Object.prototype.hasOwnProperty.call(result.outdatedDependencies, moduleId)) {
/******/ 							if(!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if(doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if(hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/ 	
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for(j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if(idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for(i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if(cb) {
/******/ 							if(callbacks.indexOf(cb) >= 0) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for(i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch(err) {
/******/ 							if(options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if(!options.ignoreErrored) {
/******/ 								if(!error)
/******/ 									error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err2) {
/******/ 						if(options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								orginalError: err, // TODO remove in webpack 4
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if(!options.ignoreErrored) {
/******/ 							if(!error)
/******/ 								error = err2;
/******/ 						}
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if(options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if(!options.ignoreErrored) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(14)(__webpack_require__.s = 14);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

!function(root,factory){ true?module.exports=factory():"function"==typeof define&&define.amd?define("alfrid",[],factory):"object"==typeof exports?exports.alfrid=factory():root.alfrid=factory()}(this,function(){return function(modules){function __webpack_require__(moduleId){if(installedModules[moduleId])return installedModules[moduleId].exports;var module=installedModules[moduleId]={i:moduleId,l:!1,exports:{}};return modules[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.l=!0,module.exports}var installedModules={};return __webpack_require__.m=modules,__webpack_require__.c=installedModules,__webpack_require__.d=function(exports,name,getter){__webpack_require__.o(exports,name)||Object.defineProperty(exports,name,{configurable:!1,enumerable:!0,get:getter})},__webpack_require__.n=function(module){var getter=module&&module.__esModule?function(){return module.default}:function(){return module};return __webpack_require__.d(getter,"a",getter),getter},__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=41)}([function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_glMatrix=__webpack_require__(1),_getAndApplyExtension=__webpack_require__(47),_getAndApplyExtension2=_interopRequireDefault(_getAndApplyExtension),_exposeAttributes=__webpack_require__(48),_exposeAttributes2=_interopRequireDefault(_exposeAttributes),_getFloat=__webpack_require__(49),_getFloat2=_interopRequireDefault(_getFloat),_getHalfFloat=__webpack_require__(50),_getHalfFloat2=_interopRequireDefault(_getHalfFloat),_getAttribLoc=__webpack_require__(24),_ExtensionsList=(_interopRequireDefault(_getAttribLoc),__webpack_require__(51)),_ExtensionsList2=_interopRequireDefault(_ExtensionsList),gl=void 0,GLTool=function(){function GLTool(){_classCallCheck(this,GLTool),this.canvas,this._viewport=[0,0,0,0],this._enabledVertexAttribute=[],this.identityMatrix=_glMatrix.mat4.create(),this._normalMatrix=_glMatrix.mat3.create(),this._inverseModelViewMatrix=_glMatrix.mat3.create(),this._modelMatrix=_glMatrix.mat4.create(),this._matrix=_glMatrix.mat4.create(),this._matrixStacks=[],this._lastMesh=null,this._useWebGL2=!1,this._hasArrayInstance,this._extArrayInstance,this._hasCheckedExt=!1,_glMatrix.mat4.identity(this.identityMatrix,this.identityMatrix),this.isMobile=!1,/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)&&(this.isMobile=!0)}return _createClass(GLTool,[{key:"init",value:function(mCanvas){var mParameters=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(null===mCanvas||void 0===mCanvas)return void console.error("Canvas not exist");void 0!==this.canvas&&null!==this.canvas&&this.destroy(),this.canvas=mCanvas,this.setSize(window.innerWidth,window.innerHeight),mParameters.useWebgl2=mParameters.useWebgl2||!1;var ctx=void 0;mParameters.useWebgl2?(ctx=this.canvas.getContext("experimental-webgl2",mParameters)||this.canvas.getContext("webgl2",mParameters),ctx?this._useWebGL2=!0:(ctx=this.canvas.getContext("webgl",mParameters)||this.canvas.getContext("experimental-webgl",mParameters),this._useWebGL2=!1)):(ctx=this.canvas.getContext("webgl",mParameters)||this.canvas.getContext("experimental-webgl",mParameters),this._useWebGL2=!1),console.log("Using WebGL 2 ?",this.webgl2),this.initWithGL(ctx)}},{key:"initWithGL",value:function(ctx){this.canvas||(this.canvas=ctx.canvas),gl=this.gl=ctx,this.extensions={};for(var i=0;i<_ExtensionsList2.default.length;i++)this.extensions[_ExtensionsList2.default[i]]=gl.getExtension(_ExtensionsList2.default[i]);(0,_exposeAttributes2.default)(),(0,_getAndApplyExtension2.default)(gl,"OES_vertex_array_object"),(0,_getAndApplyExtension2.default)(gl,"ANGLE_instanced_arrays"),(0,_getAndApplyExtension2.default)(gl,"WEBGL_draw_buffers"),this.enable(this.DEPTH_TEST),this.enable(this.CULL_FACE),this.enable(this.BLEND),this.enableAlphaBlending()}},{key:"setViewport",value:function(x,y,w,h){var hasChanged=!1;x!==this._viewport[0]&&(hasChanged=!0),y!==this._viewport[1]&&(hasChanged=!0),w!==this._viewport[2]&&(hasChanged=!0),h!==this._viewport[3]&&(hasChanged=!0),hasChanged&&(gl.viewport(x,y,w,h),this._viewport=[x,y,w,h])}},{key:"scissor",value:function(x,y,w,h){gl.scissor(x,y,w,h)}},{key:"clear",value:function(r,g,b,a){gl.clearColor(r,g,b,a),gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT)}},{key:"cullFace",value:function(mValue){gl.cullFace(mValue)}},{key:"setMatrices",value:function(mCamera){this.camera=mCamera,this.rotate(this.identityMatrix)}},{key:"useShader",value:function(mShader){this.shader=mShader,this.shaderProgram=this.shader.shaderProgram}},{key:"rotate",value:function(mRotation){_glMatrix.mat4.copy(this._modelMatrix,mRotation),_glMatrix.mat4.multiply(this._matrix,this.camera.matrix,this._modelMatrix),_glMatrix.mat3.fromMat4(this._normalMatrix,this._matrix),_glMatrix.mat3.invert(this._normalMatrix,this._normalMatrix),_glMatrix.mat3.transpose(this._normalMatrix,this._normalMatrix),_glMatrix.mat3.fromMat4(this._inverseModelViewMatrix,this._matrix),_glMatrix.mat3.invert(this._inverseModelViewMatrix,this._inverseModelViewMatrix)}},{key:"draw",value:function(mMesh,mDrawingType){if(mMesh.length)for(var i=0;i<mMesh.length;i++)this.draw(mMesh[i]);else{mMesh.bind(this.shaderProgram),void 0!==this.camera&&(this.shader.uniform("uProjectionMatrix","mat4",this.camera.projection),this.shader.uniform("uViewMatrix","mat4",this.camera.matrix)),this.shader.uniform("uModelMatrix","mat4",this._modelMatrix),this.shader.uniform("uNormalMatrix","mat3",this._normalMatrix),this.shader.uniform("uModelViewMatrixInverse","mat3",this._inverseModelViewMatrix);var drawType=mMesh.drawType;void 0!==mDrawingType&&(drawType=mDrawingType),mMesh.isInstanced?gl.drawElementsInstanced(mMesh.drawType,mMesh.iBuffer.numItems,gl.UNSIGNED_SHORT,0,mMesh.numInstance):drawType===gl.POINTS?gl.drawArrays(drawType,0,mMesh.vertexSize):gl.drawElements(drawType,mMesh.iBuffer.numItems,gl.UNSIGNED_SHORT,0),mMesh.unbind()}}},{key:"drawTransformFeedback",value:function(mTransformObject){var meshSource=mTransformObject.meshSource,meshDestination=mTransformObject.meshDestination,numPoints=mTransformObject.numPoints,transformFeedback=mTransformObject.transformFeedback;meshSource.bind(this.shaderProgram),meshDestination.generateBuffers(this.shaderProgram),gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK,transformFeedback),meshDestination.attributes.forEach(function(attr,i){gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER,i,attr.buffer)}),gl.enable(gl.RASTERIZER_DISCARD),gl.beginTransformFeedback(gl.POINTS),gl.drawArrays(gl.POINTS,0,numPoints),gl.endTransformFeedback(),gl.disable(gl.RASTERIZER_DISCARD),gl.useProgram(null),gl.bindBuffer(gl.ARRAY_BUFFER,null),meshDestination.attributes.forEach(function(attr,i){gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER,i,null)}),gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK,null),meshSource.unbind()}},{key:"setSize",value:function(mWidth,mHeight){this._width=mWidth,this._height=mHeight,this.canvas.width=this._width,this.canvas.height=this._height,this._aspectRatio=this._width/this._height,gl&&this.viewport(0,0,this._width,this._height)}},{key:"showExtensions",value:function(){console.log("Extensions : ",this.extensions);for(var ext in this.extensions)this.extensions[ext]&&console.log(ext,":",this.extensions[ext])}},{key:"checkExtension",value:function(mExtension){return!!this.extensions[mExtension]}},{key:"getExtension",value:function(mExtension){return this.extensions[mExtension]}},{key:"enableAlphaBlending",value:function(){gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA)}},{key:"enableAdditiveBlending",value:function(){gl.blendFunc(gl.ONE,gl.ONE)}},{key:"pushMatrix",value:function(){var mtx=_glMatrix.mat4.clone(this._modelMatrix);this._matrixStacks.push(mtx)}},{key:"popMatrix",value:function(){if(0==this._matrixStacks.length)return null;var mtx=this._matrixStacks.pop();this.rotate(mtx)}},{key:"enable",value:function(mParameter){gl.enable(mParameter)}},{key:"disable",value:function(mParameter){gl.disable(mParameter)}},{key:"viewport",value:function(x,y,w,h){this.setViewport(x,y,w,h)}},{key:"destroy",value:function(){if(this.canvas.parentNode)try{this.canvas.parentNode.removeChild(this.canvas)}catch(e){console.log("Error : ",e)}this.canvas=null}},{key:"FLOAT",get:function(){return(0,_getFloat2.default)()}},{key:"HALF_FLOAT",get:function(){return(0,_getHalfFloat2.default)()}},{key:"width",get:function(){return this._width}},{key:"height",get:function(){return this._height}},{key:"aspectRatio",get:function(){return this._aspectRatio}},{key:"webgl2",get:function(){return this._useWebGL2}}]),GLTool}(),GL=new GLTool;exports.default=GL},function(module,exports,__webpack_require__){"use strict";function _interopRequireWildcard(obj){if(obj&&obj.__esModule)return obj;var newObj={};if(null!=obj)for(var key in obj)Object.prototype.hasOwnProperty.call(obj,key)&&(newObj[key]=obj[key]);return newObj.default=obj,newObj}Object.defineProperty(exports,"__esModule",{value:!0}),exports.vec4=exports.vec3=exports.vec2=exports.quat=exports.mat4=exports.mat3=exports.mat2d=exports.mat2=exports.glMatrix=void 0;var _common=__webpack_require__(3),glMatrix=_interopRequireWildcard(_common),_mat=__webpack_require__(42),mat2=_interopRequireWildcard(_mat),_mat2d=__webpack_require__(43),mat2d=_interopRequireWildcard(_mat2d),_mat2=__webpack_require__(20),mat3=_interopRequireWildcard(_mat2),_mat3=__webpack_require__(44),mat4=_interopRequireWildcard(_mat3),_quat=__webpack_require__(45),quat=_interopRequireWildcard(_quat),_vec=__webpack_require__(46),vec2=_interopRequireWildcard(_vec),_vec2=__webpack_require__(21),vec3=_interopRequireWildcard(_vec2),_vec3=__webpack_require__(22),vec4=_interopRequireWildcard(_vec3);exports.glMatrix=glMatrix,exports.mat2=mat2,exports.mat2d=mat2d,exports.mat3=mat3,exports.mat4=mat4,exports.quat=quat,exports.vec2=vec2,exports.vec3=vec3,exports.vec4=vec4},function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_GLTool=__webpack_require__(0),_GLTool2=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(_GLTool),isSame=(__webpack_require__(52),function(array1,array2){if(array1.length!==array2.length)return!1;for(var i=0;i<array1.length;i++)if(array1[i]!==array2[i])return!1;return!0}),addLineNumbers=function(string){for(var lines=string.split("\n"),i=0;i<lines.length;i++)lines[i]=i+1+": "+lines[i];return lines.join("\n")},cloneArray=function(mArray){return mArray.slice?mArray.slice(0):new Float32Array(mArray)},gl=void 0,defaultVertexShader=__webpack_require__(11),defaultFragmentShader=__webpack_require__(53),uniformMapping={float:"uniform1f",vec2:"uniform2fv",vec3:"uniform3fv",vec4:"uniform4fv",int:"uniform1i",mat3:"uniformMatrix3fv",mat4:"uniformMatrix4fv"},GLShader=function(){function GLShader(){var strVertexShader=arguments.length>0&&void 0!==arguments[0]?arguments[0]:defaultVertexShader,strFragmentShader=arguments.length>1&&void 0!==arguments[1]?arguments[1]:defaultFragmentShader,mVaryings=arguments[2];_classCallCheck(this,GLShader),gl=_GLTool2.default.gl,this.parameters=[],this.uniformTextures=[],this._varyings=mVaryings,strVertexShader||(strVertexShader=defaultVertexShader),strFragmentShader||(strFragmentShader=defaultVertexShader);var vsShader=this._createShaderProgram(strVertexShader,!0),fsShader=this._createShaderProgram(strFragmentShader,!1);this._attachShaderProgram(vsShader,fsShader)}return _createClass(GLShader,[{key:"bind",value:function(){_GLTool2.default.shader!==this&&(gl.useProgram(this.shaderProgram),_GLTool2.default.useShader(this),this.uniformTextures=[])}},{key:"uniform",value:function(mName,mType,mValue){if("object"===(void 0===mName?"undefined":_typeof(mName)))return void this.uniformObject(mName);for(var uniformType=uniformMapping[mType]||mType,hasUniform=!1,oUniform=void 0,parameterIndex=-1,i=0;i<this.parameters.length;i++)if(oUniform=this.parameters[i],oUniform.name===mName){hasUniform=!0,parameterIndex=i;break}var isNumber=!1;if(hasUniform?(this.shaderProgram[mName]=oUniform.uniformLoc,isNumber=oUniform.isNumber):(isNumber="uniform1i"===uniformType||"uniform1f"===uniformType,this.shaderProgram[mName]=gl.getUniformLocation(this.shaderProgram,mName),isNumber?this.parameters.push({name:mName,type:uniformType,value:mValue,uniformLoc:this.shaderProgram[mName],isNumber:isNumber}):this.parameters.push({name:mName,type:uniformType,value:cloneArray(mValue),uniformLoc:this.shaderProgram[mName],isNumber:isNumber}),parameterIndex=this.parameters.length-1),this.parameters[parameterIndex].uniformLoc)if(-1===uniformType.indexOf("Matrix"))if(isNumber){var needUpdate=this.parameters[parameterIndex].value!==mValue||!hasUniform;needUpdate&&(gl[uniformType](this.shaderProgram[mName],mValue),this.parameters[parameterIndex].value=mValue)}else isSame(this.parameters[parameterIndex].value,mValue)&&hasUniform||(gl[uniformType](this.shaderProgram[mName],mValue),this.parameters[parameterIndex].value=cloneArray(mValue));else isSame(this.parameters[parameterIndex].value,mValue)&&hasUniform||(gl[uniformType](this.shaderProgram[mName],!1,mValue),this.parameters[parameterIndex].value=cloneArray(mValue))}},{key:"uniformObject",value:function(mUniformObj){for(var uniformName in mUniformObj){var uniformValue=mUniformObj[uniformName],uniformType=GLShader.getUniformType(uniformValue);if(uniformValue.concat&&uniformValue[0].concat){for(var tmp=[],i=0;i<uniformValue.length;i++)tmp=tmp.concat(uniformValue[i]);uniformValue=tmp}this.uniform(uniformName,uniformType,uniformValue)}}},{key:"_createShaderProgram",value:function(mShaderStr,isVertexShader){var shaderType=isVertexShader?_GLTool2.default.VERTEX_SHADER:_GLTool2.default.FRAGMENT_SHADER,shader=gl.createShader(shaderType);return gl.shaderSource(shader,mShaderStr),gl.compileShader(shader),gl.getShaderParameter(shader,gl.COMPILE_STATUS)?shader:(console.warn("Error in Shader : ",gl.getShaderInfoLog(shader)),console.log(addLineNumbers(mShaderStr)),null)}},{key:"_attachShaderProgram",value:function(mVertexShader,mFragmentShader){this.shaderProgram=gl.createProgram(),gl.attachShader(this.shaderProgram,mVertexShader),gl.attachShader(this.shaderProgram,mFragmentShader),gl.deleteShader(mVertexShader),gl.deleteShader(mFragmentShader),this._varyings&&(console.log("Transform feedback setup : ",this._varyings),gl.transformFeedbackVaryings(this.shaderProgram,this._varyings,gl.SEPARATE_ATTRIBS)),gl.linkProgram(this.shaderProgram)}}]),GLShader}();GLShader.getUniformType=function(mValue){var isArray=!!mValue.concat,getArrayUniformType=function(mValue){return 9===mValue.length?"uniformMatrix3fv":16===mValue.length?"uniformMatrix4fv":"vec"+mValue.length};return isArray?getArrayUniformType(mValue[0].concat?mValue[0]:mValue):"float"},exports.default=GLShader},function(module,exports,__webpack_require__){"use strict";function setMatrixArrayType(type){exports.ARRAY_TYPE=ARRAY_TYPE=type}function toRadian(a){return a*degree}function equals(a,b){return Math.abs(a-b)<=EPSILON*Math.max(1,Math.abs(a),Math.abs(b))}Object.defineProperty(exports,"__esModule",{value:!0}),exports.setMatrixArrayType=setMatrixArrayType,exports.toRadian=toRadian,exports.equals=equals;var EPSILON=exports.EPSILON=1e-6,ARRAY_TYPE=exports.ARRAY_TYPE="undefined"!=typeof Float32Array?Float32Array:Array,degree=(exports.RANDOM=Math.random,Math.PI/180)},function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_GLTool=__webpack_require__(0),_GLTool2=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(_GLTool),Batch=function(){function Batch(mMesh,mShader){_classCallCheck(this,Batch),this._mesh=mMesh,this._shader=mShader}return _createClass(Batch,[{key:"draw",value:function(){this._shader.bind(),_GLTool2.default.draw(this.mesh)}},{key:"mesh",get:function(){return this._mesh}},{key:"shader",get:function(){return this._shader}}]),Batch}();exports.default=Batch},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_glMatrix=__webpack_require__(1),_getAttribLoc=__webpack_require__(24),_getAttribLoc2=_interopRequireDefault(_getAttribLoc),gl=void 0,getBuffer=function(attr){var buffer=void 0;return void 0!==attr.buffer?buffer=attr.buffer:(buffer=gl.createBuffer(),attr.buffer=buffer),buffer},formBuffer=function(mData,mNum){for(var ary=[],i=0;i<mData.length;i+=mNum){for(var o=[],j=0;j<mNum;j++)o.push(mData[i+j]);ary.push(o)}return ary},Mesh=function(){function Mesh(){var mDrawingType=arguments.length>0&&void 0!==arguments[0]?arguments[0]:4,mUseVao=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];_classCallCheck(this,Mesh),gl=_GLTool2.default.gl,this.drawType=mDrawingType,this._attributes=[],this._numInstance=-1,this._enabledVertexAttribute=[],this._indices=[],this._faces=[],this._bufferChanged=[],this._hasIndexBufferChanged=!1,this._hasVAO=!1,this._isInstanced=!1,this._extVAO=!!_GLTool2.default.gl.createVertexArray,this._useVAO=!!this._extVAO&&mUseVao}return _createClass(Mesh,[{key:"bufferVertex",value:function(mArrayVertices){var mDrawType=arguments.length>1&&void 0!==arguments[1]?arguments[1]:35044;return this.bufferData(mArrayVertices,"aVertexPosition",3,mDrawType),this.normals.length<this.vertices.length&&this.bufferNormal(mArrayVertices,mDrawType),this}},{key:"bufferTexCoord",value:function(mArrayTexCoords){var mDrawType=arguments.length>1&&void 0!==arguments[1]?arguments[1]:35044;return this.bufferData(mArrayTexCoords,"aTextureCoord",2,mDrawType),this}},{key:"bufferNormal",value:function(mNormals){var mDrawType=arguments.length>1&&void 0!==arguments[1]?arguments[1]:35044;return this.bufferData(mNormals,"aNormal",3,mDrawType),this}},{key:"bufferIndex",value:function(mArrayIndices){var isDynamic=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return this._drawType=isDynamic?gl.DYNAMIC_DRAW:gl.STATIC_DRAW,this._indices=new Uint16Array(mArrayIndices),this._numItems=this._indices.length,this}},{key:"bufferFlattenData",value:function(mData,mName,mItemSize){var data=(arguments.length>3&&void 0!==arguments[3]&&arguments[3],arguments.length>4&&void 0!==arguments[4]&&arguments[4],formBuffer(mData,mItemSize));return this.bufferData(data,mName,mItemSize,35044,!1),this}},{key:"bufferData",value:function(mData,mName,mItemSize){var mDrawType=arguments.length>3&&void 0!==arguments[3]?arguments[3]:35044,isInstanced=arguments.length>4&&void 0!==arguments[4]&&arguments[4],i=0,drawType=mDrawType,bufferData=[];for(mItemSize||(mItemSize=mData[0].length),this._isInstanced=isInstanced||this._isInstanced,i=0;i<mData.length;i++)for(var j=0;j<mData[i].length;j++)bufferData.push(mData[i][j]);var dataArray=new Float32Array(bufferData),attribute=this.getAttribute(mName);return attribute?(attribute.itemSize=mItemSize,attribute.dataArray=dataArray,attribute.source=mData):this._attributes.push({name:mName,source:mData,itemSize:mItemSize,drawType:drawType,dataArray:dataArray,isInstanced:isInstanced}),this._bufferChanged.push(mName),this}},{key:"bufferInstance",value:function(mData,mName){if(!_GLTool2.default.gl.vertexAttribDivisor)return void console.error("Extension : ANGLE_instanced_arrays is not supported with this device !");var itemSize=mData[0].length;this._numInstance=mData.length,this.bufferData(mData,mName,itemSize,35044,!0)}},{key:"bind",value:function(mShaderProgram){this.generateBuffers(mShaderProgram),this.hasVAO?gl.bindVertexArray(this.vao):(this.attributes.forEach(function(attribute){gl.bindBuffer(gl.ARRAY_BUFFER,attribute.buffer);var attrPosition=attribute.attrPosition;gl.vertexAttribPointer(attrPosition,attribute.itemSize,gl.FLOAT,!1,0,0),attribute.isInstanced&&gl.vertexAttribDivisor(attrPosition,1)}),gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.iBuffer))}},{key:"generateBuffers",value:function(mShaderProgram){var _this=this;0!=this._bufferChanged.length&&(this._useVAO?(this._vao||(this._vao=gl.createVertexArray()),gl.bindVertexArray(this._vao),this._attributes.forEach(function(attrObj){if(-1!==_this._bufferChanged.indexOf(attrObj.name)){var buffer=getBuffer(attrObj);gl.bindBuffer(gl.ARRAY_BUFFER,buffer),gl.bufferData(gl.ARRAY_BUFFER,attrObj.dataArray,attrObj.drawType);var attrPosition=(0,_getAttribLoc2.default)(gl,mShaderProgram,attrObj.name);gl.enableVertexAttribArray(attrPosition),gl.vertexAttribPointer(attrPosition,attrObj.itemSize,gl.FLOAT,!1,0,0),attrObj.attrPosition=attrPosition,attrObj.isInstanced&&gl.vertexAttribDivisor(attrPosition,1)}}),this._updateIndexBuffer(),gl.bindVertexArray(null),this._hasVAO=!0):(this._attributes.forEach(function(attrObj){if(-1!==_this._bufferChanged.indexOf(attrObj.name)){var buffer=getBuffer(attrObj);gl.bindBuffer(gl.ARRAY_BUFFER,buffer),gl.bufferData(gl.ARRAY_BUFFER,attrObj.dataArray,attrObj.drawType);var attrPosition=(0,_getAttribLoc2.default)(gl,mShaderProgram,attrObj.name);gl.enableVertexAttribArray(attrPosition),gl.vertexAttribPointer(attrPosition,attrObj.itemSize,gl.FLOAT,!1,0,0),attrObj.attrPosition=attrPosition,attrObj.isInstanced&&gl.vertexAttribDivisor(attrPosition,1)}}),this._updateIndexBuffer()),this._hasIndexBufferChanged=!1,this._bufferChanged=[])}},{key:"unbind",value:function(){this._useVAO&&gl.bindVertexArray(null),this._attributes.forEach(function(attribute){attribute.isInstanced&&gl.vertexAttribDivisor(attribute.attrPosition,0)})}},{key:"_updateIndexBuffer",value:function(){this._hasIndexBufferChanged||(this.iBuffer||(this.iBuffer=gl.createBuffer()),gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.iBuffer),gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,this._indices,this._drawType),this.iBuffer.itemSize=1,this.iBuffer.numItems=this._numItems)}},{key:"computeNormals",value:function(){var usingFaceNormals=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.generateFaces(),usingFaceNormals?this._computeFaceNormals():this._computeVertexNormals()}},{key:"_computeFaceNormals",value:function(){for(var faceIndex=void 0,face=void 0,normals=[],i=0;i<this._indices.length;i+=3){faceIndex=i/3,face=this._faces[faceIndex];var N=face.normal;normals[face.indices[0]]=N,normals[face.indices[1]]=N,normals[face.indices[2]]=N}this.bufferNormal(normals)}},{key:"_computeVertexNormals",value:function(){for(var face=void 0,sumNormal=_glMatrix.vec3.create(),normals=[],vertices=this.vertices,i=0;i<vertices.length;i++){_glMatrix.vec3.set(sumNormal,0,0,0);for(var j=0;j<this._faces.length;j++)face=this._faces[j],face.indices.indexOf(i)>=0&&(sumNormal[0]+=face.normal[0],sumNormal[1]+=face.normal[1],sumNormal[2]+=face.normal[2]);_glMatrix.vec3.normalize(sumNormal,sumNormal),normals.push([sumNormal[0],sumNormal[1],sumNormal[2]])}this.bufferNormal(normals)}},{key:"generateFaces",value:function(){for(var ia=void 0,ib=void 0,ic=void 0,a=void 0,b=void 0,c=void 0,vertices=(_glMatrix.vec3.create(),_glMatrix.vec3.create(),_glMatrix.vec3.create(),this.vertices),i=0;i<this._indices.length;i+=3){ia=this._indices[i],ib=this._indices[i+1],ic=this._indices[i+2],a=vertices[ia],b=vertices[ib],c=vertices[ic];var face={indices:[ia,ib,ic],vertices:[a,b,c]};this._faces.push(face)}}},{key:"getAttribute",value:function(mName){return this._attributes.find(function(a){return a.name===mName})}},{key:"getSource",value:function(mName){var attr=this.getAttribute(mName);return attr?attr.source:[]}},{key:"vertices",get:function(){return this.getSource("aVertexPosition")}},{key:"normals",get:function(){return this.getSource("aNormal")}},{key:"coords",get:function(){return this.getSource("aTextureCoord")}},{key:"indices",get:function(){return this._indices}},{key:"vertexSize",get:function(){return this.vertices.length}},{key:"faces",get:function(){return this._faces}},{key:"attributes",get:function(){return this._attributes}},{key:"hasVAO",get:function(){return this._hasVAO}},{key:"vao",get:function(){return this._vao}},{key:"numInstance",get:function(){return this._numInstance}},{key:"isInstanced",get:function(){return this._isInstanced}}]),Mesh}();exports.default=Mesh},function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),Scheduler=function(){function Scheduler(){_classCallCheck(this,Scheduler),this._delayTasks=[],this._nextTasks=[],this._deferTasks=[],this._highTasks=[],this._usurpTask=[],this._enterframeTasks=[],this._idTable=0,this._startTime=(new Date).getTime(),this._deltaTime=0,this._loop()}return _createClass(Scheduler,[{key:"addEF",value:function(func,params){params=params||[];var id=this._idTable;return this._enterframeTasks[id]={func:func,params:params},this._idTable++,id}},{key:"removeEF",value:function(id){return void 0!==this._enterframeTasks[id]&&(this._enterframeTasks[id]=null),-1}},{key:"delay",value:function(func,params,_delay){var time=(new Date).getTime(),t={func:func,params:params,delay:_delay,time:time};this._delayTasks.push(t)}},{key:"defer",value:function(func,params){var t={func:func,params:params};this._deferTasks.push(t)}},{key:"next",value:function(func,params){var t={func:func,params:params};this._nextTasks.push(t)}},{key:"usurp",value:function(func,params){var t={func:func,params:params};this._usurpTask.push(t)}},{key:"_process",value:function(){var i=0,task=void 0,interval=void 0;for(i=0;i<this._enterframeTasks.length;i++)null!==(task=this._enterframeTasks[i])&&void 0!==task&&task.func(task.params);for(;this._highTasks.length>0;)task=this._highTasks.pop(),task.func(task.params);var startTime=(new Date).getTime();for(this._deltaTime=(startTime-this._startTime)/1e3,i=0;i<this._delayTasks.length;i++)task=this._delayTasks[i],startTime-task.time>task.delay&&(task.func(task.params),this._delayTasks.splice(i,1));for(startTime=(new Date).getTime(),this._deltaTime=(startTime-this._startTime)/1e3,interval=1e3/60;this._deferTasks.length>0;){if(task=this._deferTasks.shift(),!((new Date).getTime()-startTime<interval)){this._deferTasks.unshift(task);break}task.func(task.params)}for(startTime=(new Date).getTime(),this._deltaTime=(startTime-this._startTime)/1e3,interval=1e3/60;this._usurpTask.length>0;)task=this._usurpTask.shift(),(new Date).getTime()-startTime<interval&&task.func(task.params);this._highTasks=this._highTasks.concat(this._nextTasks),this._nextTasks=[],this._usurpTask=[]}},{key:"_loop",value:function(){var _this=this;this._process(),window.requestAnimationFrame(function(){return _this._loop()})}},{key:"deltaTime",get:function(){return this._deltaTime}}]),Scheduler}(),scheduler=new Scheduler;exports.default=scheduler},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _Mesh=__webpack_require__(5),_Mesh2=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(_Mesh),Geom={},meshTri=void 0;Geom.plane=function(width,height,numSegments){for(var axis=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"xy",drawType=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4,positions=[],coords=[],indices=[],normals=[],gapX=width/numSegments,gapY=height/numSegments,gapUV=1/numSegments,sx=.5*-width,sy=.5*-height,index=0,i=0;i<numSegments;i++)for(var j=0;j<numSegments;j++){var tx=gapX*i+sx,ty=gapY*j+sy,u=i/numSegments,v=j/numSegments;"xz"===axis?(positions.push([tx,0,ty+gapY]),positions.push([tx+gapX,0,ty+gapY]),positions.push([tx+gapX,0,ty]),positions.push([tx,0,ty]),coords.push([u,1-(v+gapUV)]),coords.push([u+gapUV,1-(v+gapUV)]),coords.push([u+gapUV,1-v]),coords.push([u,1-v]),normals.push([0,1,0]),normals.push([0,1,0]),normals.push([0,1,0]),normals.push([0,1,0])):"yz"===axis?(positions.push([0,ty,tx]),positions.push([0,ty,tx+gapX]),positions.push([0,ty+gapY,tx+gapX]),positions.push([0,ty+gapY,tx]),coords.push([u,v]),coords.push([u+gapUV,v]),coords.push([u+gapUV,v+gapUV]),coords.push([u,v+gapUV]),normals.push([1,0,0]),normals.push([1,0,0]),normals.push([1,0,0]),normals.push([1,0,0])):(positions.push([tx,ty,0]),positions.push([tx+gapX,ty,0]),positions.push([tx+gapX,ty+gapY,0]),positions.push([tx,ty+gapY,0]),coords.push([u,v]),coords.push([u+gapUV,v]),coords.push([u+gapUV,v+gapUV]),coords.push([u,v+gapUV]),normals.push([0,0,1]),normals.push([0,0,1]),normals.push([0,0,1]),normals.push([0,0,1])),indices.push(4*index+0),indices.push(4*index+1),indices.push(4*index+2),indices.push(4*index+0),indices.push(4*index+2),indices.push(4*index+3),index++}var mesh=new _Mesh2.default(drawType);return mesh.bufferVertex(positions),mesh.bufferTexCoord(coords),mesh.bufferIndex(indices),mesh.bufferNormal(normals),mesh},Geom.sphere=function(size,numSegments){function getPosition(i,j){var isNormal=arguments.length>2&&void 0!==arguments[2]&&arguments[2],rx=i/numSegments*Math.PI-.5*Math.PI,ry=j/numSegments*Math.PI*2,r=isNormal?1:size,pos=[];pos[1]=Math.sin(rx)*r;var t=Math.cos(rx)*r;pos[0]=Math.cos(ry)*t,pos[2]=Math.sin(ry)*t;return pos[0]=Math.floor(1e4*pos[0])/1e4,pos[1]=Math.floor(1e4*pos[1])/1e4,pos[2]=Math.floor(1e4*pos[2])/1e4,pos}for(var isInvert=arguments.length>2&&void 0!==arguments[2]&&arguments[2],drawType=arguments.length>3&&void 0!==arguments[3]?arguments[3]:4,positions=[],coords=[],indices=[],normals=[],gapUV=1/numSegments,index=0,i=0;i<numSegments;i++)for(var j=0;j<numSegments;j++){positions.push(getPosition(i,j)),positions.push(getPosition(i+1,j)),positions.push(getPosition(i+1,j+1)),positions.push(getPosition(i,j+1)),normals.push(getPosition(i,j,!0)),normals.push(getPosition(i+1,j,!0)),normals.push(getPosition(i+1,j+1,!0)),normals.push(getPosition(i,j+1,!0));var u=j/numSegments,v=i/numSegments;coords.push([1-u,v]),coords.push([1-u,v+gapUV]),coords.push([1-u-gapUV,v+gapUV]),coords.push([1-u-gapUV,v]),indices.push(4*index+0),indices.push(4*index+1),indices.push(4*index+2),indices.push(4*index+0),indices.push(4*index+2),indices.push(4*index+3),index++}isInvert&&indices.reverse();var mesh=new _Mesh2.default(drawType);return mesh.bufferVertex(positions),mesh.bufferTexCoord(coords),mesh.bufferIndex(indices),mesh.bufferNormal(normals),mesh},Geom.cube=function(w,h,d){var drawType=arguments.length>3&&void 0!==arguments[3]?arguments[3]:4;h=h||w,d=d||w;var x=w/2,y=h/2,z=d/2,positions=[],coords=[],indices=[],normals=[],count=0;positions.push([-x,y,-z]),positions.push([x,y,-z]),positions.push([x,-y,-z]),positions.push([-x,-y,-z]),normals.push([0,0,-1]),normals.push([0,0,-1]),normals.push([0,0,-1]),normals.push([0,0,-1]),coords.push([0,0]),coords.push([1,0]),coords.push([1,1]),coords.push([0,1]),indices.push(4*count+0),indices.push(4*count+1),indices.push(4*count+2),indices.push(4*count+0),indices.push(4*count+2),indices.push(4*count+3),count++,positions.push([x,y,-z]),positions.push([x,y,z]),positions.push([x,-y,z]),positions.push([x,-y,-z]),normals.push([1,0,0]),normals.push([1,0,0]),normals.push([1,0,0]),normals.push([1,0,0]),coords.push([0,0]),coords.push([1,0]),coords.push([1,1]),coords.push([0,1]),indices.push(4*count+0),indices.push(4*count+1),indices.push(4*count+2),indices.push(4*count+0),indices.push(4*count+2),indices.push(4*count+3),count++,positions.push([x,y,z]),positions.push([-x,y,z]),positions.push([-x,-y,z]),positions.push([x,-y,z]),normals.push([0,0,1]),normals.push([0,0,1]),normals.push([0,0,1]),normals.push([0,0,1]),coords.push([0,0]),coords.push([1,0]),coords.push([1,1]),coords.push([0,1]),indices.push(4*count+0),indices.push(4*count+1),indices.push(4*count+2),indices.push(4*count+0),indices.push(4*count+2),indices.push(4*count+3),count++,positions.push([-x,y,z]),positions.push([-x,y,-z]),positions.push([-x,-y,-z]),positions.push([-x,-y,z]),normals.push([-1,0,0]),normals.push([-1,0,0]),normals.push([-1,0,0]),normals.push([-1,0,0]),coords.push([0,0]),coords.push([1,0]),coords.push([1,1]),coords.push([0,1]),indices.push(4*count+0),indices.push(4*count+1),indices.push(4*count+2),indices.push(4*count+0),indices.push(4*count+2),indices.push(4*count+3),count++,positions.push([x,y,-z]),positions.push([-x,y,-z]),positions.push([-x,y,z]),positions.push([x,y,z]),normals.push([0,1,0]),normals.push([0,1,0]),normals.push([0,1,0]),normals.push([0,1,0]),coords.push([0,0]),coords.push([1,0]),coords.push([1,1]),coords.push([0,1]),indices.push(4*count+0),indices.push(4*count+1),indices.push(4*count+2),indices.push(4*count+0),indices.push(4*count+2),indices.push(4*count+3),count++,positions.push([x,-y,z]),positions.push([-x,-y,z]),positions.push([-x,-y,-z]),positions.push([x,-y,-z]),normals.push([0,-1,0]),normals.push([0,-1,0]),normals.push([0,-1,0]),normals.push([0,-1,0]),coords.push([0,0]),coords.push([1,0]),coords.push([1,1]),coords.push([0,1]),indices.push(4*count+0),indices.push(4*count+1),indices.push(4*count+2),indices.push(4*count+0),indices.push(4*count+2),indices.push(4*count+3),count++;var mesh=new _Mesh2.default(drawType);return mesh.bufferVertex(positions),mesh.bufferTexCoord(coords),mesh.bufferIndex(indices),mesh.bufferNormal(normals),mesh},Geom.skybox=function(size){var drawType=arguments.length>1&&void 0!==arguments[1]?arguments[1]:4,positions=[],coords=[],indices=[],normals=[],count=0;positions.push([size,size,-size]),positions.push([-size,size,-size]),positions.push([-size,-size,-size]),positions.push([size,-size,-size]),normals.push([0,0,-1]),normals.push([0,0,-1]),normals.push([0,0,-1]),normals.push([0,0,-1]),coords.push([0,0]),coords.push([1,0]),coords.push([1,1]),coords.push([0,1]),indices.push(4*count+0),indices.push(4*count+1),indices.push(4*count+2),indices.push(4*count+0),indices.push(4*count+2),indices.push(4*count+3),count++,positions.push([size,-size,-size]),positions.push([size,-size,size]),positions.push([size,size,size]),positions.push([size,size,-size]),normals.push([1,0,0]),normals.push([1,0,0]),normals.push([1,0,0]),normals.push([1,0,0]),coords.push([0,0]),coords.push([1,0]),coords.push([1,1]),coords.push([0,1]),indices.push(4*count+0),indices.push(4*count+1),indices.push(4*count+2),indices.push(4*count+0),indices.push(4*count+2),indices.push(4*count+3),count++,positions.push([-size,size,size]),positions.push([size,size,size]),positions.push([size,-size,size]),positions.push([-size,-size,size]),normals.push([0,0,1]),normals.push([0,0,1]),normals.push([0,0,1]),normals.push([0,0,1]),coords.push([0,0]),coords.push([1,0]),coords.push([1,1]),coords.push([0,1]),indices.push(4*count+0),indices.push(4*count+1),indices.push(4*count+2),indices.push(4*count+0),indices.push(4*count+2),indices.push(4*count+3),count++,positions.push([-size,-size,size]),positions.push([-size,-size,-size]),positions.push([-size,size,-size]),positions.push([-size,size,size]),normals.push([-1,0,0]),normals.push([-1,0,0]),normals.push([-1,0,0]),normals.push([-1,0,0]),coords.push([0,0]),coords.push([1,0]),coords.push([1,1]),coords.push([0,1]),indices.push(4*count+0),indices.push(4*count+1),indices.push(4*count+2),indices.push(4*count+0),indices.push(4*count+2),indices.push(4*count+3),count++,positions.push([size,size,size]),positions.push([-size,size,size]),positions.push([-size,size,-size]),positions.push([size,size,-size]),normals.push([0,1,0]),normals.push([0,1,0]),normals.push([0,1,0]),normals.push([0,1,0]),coords.push([0,0]),coords.push([1,0]),coords.push([1,1]),coords.push([0,1]),indices.push(4*count+0),indices.push(4*count+1),indices.push(4*count+2),indices.push(4*count+0),indices.push(4*count+2),indices.push(4*count+3),count++,positions.push([size,-size,-size]),positions.push([-size,-size,-size]),positions.push([-size,-size,size]),positions.push([size,-size,size]),normals.push([0,-1,0]),normals.push([0,-1,0]),normals.push([0,-1,0]),normals.push([0,-1,0]),coords.push([0,0]),coords.push([1,0]),coords.push([1,1]),coords.push([0,1]),indices.push(4*count+0),indices.push(4*count+1),indices.push(4*count+2),indices.push(4*count+0),indices.push(4*count+2),indices.push(4*count+3);var mesh=new _Mesh2.default(drawType);return mesh.bufferVertex(positions),mesh.bufferTexCoord(coords),mesh.bufferIndex(indices),mesh.bufferNormal(normals),mesh},Geom.bigTriangle=function(){if(!meshTri){var indices=[2,1,0],positions=[[-1,-1],[-1,4],[4,-1]];meshTri=new _Mesh2.default,meshTri.bufferData(positions,"aPosition",2),meshTri.bufferIndex(indices)}return meshTri},exports.default=Geom},function(module,exports,__webpack_require__){"use strict";module.exports={0:"NONE",1:"ONE",2:"LINE_LOOP",3:"LINE_STRIP",4:"TRIANGLES",5:"TRIANGLE_STRIP",6:"TRIANGLE_FAN",256:"DEPTH_BUFFER_BIT",512:"NEVER",513:"LESS",514:"EQUAL",515:"LEQUAL",516:"GREATER",517:"NOTEQUAL",518:"GEQUAL",519:"ALWAYS",768:"SRC_COLOR",769:"ONE_MINUS_SRC_COLOR",770:"SRC_ALPHA",771:"ONE_MINUS_SRC_ALPHA",772:"DST_ALPHA",773:"ONE_MINUS_DST_ALPHA",774:"DST_COLOR",775:"ONE_MINUS_DST_COLOR",776:"SRC_ALPHA_SATURATE",1024:"STENCIL_BUFFER_BIT",1028:"FRONT",1029:"BACK",1032:"FRONT_AND_BACK",1280:"INVALID_ENUM",1281:"INVALID_VALUE",1282:"INVALID_OPERATION",1285:"OUT_OF_MEMORY",1286:"INVALID_FRAMEBUFFER_OPERATION",2304:"CW",2305:"CCW",2849:"LINE_WIDTH",2884:"CULL_FACE",2885:"CULL_FACE_MODE",2886:"FRONT_FACE",2928:"DEPTH_RANGE",2929:"DEPTH_TEST",2930:"DEPTH_WRITEMASK",2931:"DEPTH_CLEAR_VALUE",2932:"DEPTH_FUNC",2960:"STENCIL_TEST",2961:"STENCIL_CLEAR_VALUE",2962:"STENCIL_FUNC",2963:"STENCIL_VALUE_MASK",2964:"STENCIL_FAIL",2965:"STENCIL_PASS_DEPTH_FAIL",2966:"STENCIL_PASS_DEPTH_PASS",2967:"STENCIL_REF",2968:"STENCIL_WRITEMASK",2978:"VIEWPORT",3024:"DITHER",3042:"BLEND",3088:"SCISSOR_BOX",3089:"SCISSOR_TEST",3106:"COLOR_CLEAR_VALUE",3107:"COLOR_WRITEMASK",3317:"UNPACK_ALIGNMENT",3333:"PACK_ALIGNMENT",3379:"MAX_TEXTURE_SIZE",3386:"MAX_VIEWPORT_DIMS",3408:"SUBPIXEL_BITS",3410:"RED_BITS",3411:"GREEN_BITS",3412:"BLUE_BITS",3413:"ALPHA_BITS",3414:"DEPTH_BITS",3415:"STENCIL_BITS",3553:"TEXTURE_2D",4352:"DONT_CARE",4353:"FASTEST",4354:"NICEST",5120:"BYTE",5121:"UNSIGNED_BYTE",5122:"SHORT",5123:"UNSIGNED_SHORT",5124:"INT",5125:"UNSIGNED_INT",5126:"FLOAT",5386:"INVERT",5890:"TEXTURE",6401:"STENCIL_INDEX",6402:"DEPTH_COMPONENT",6403:"RED",6406:"ALPHA",6407:"RGB",6408:"RGBA",6409:"LUMINANCE",6410:"LUMINANCE_ALPHA",7680:"KEEP",7681:"REPLACE",7682:"INCR",7683:"DECR",7936:"VENDOR",7937:"RENDERER",7938:"VERSION",9728:"NEAREST",9729:"LINEAR",9984:"NEAREST_MIPMAP_NEAREST",9985:"LINEAR_MIPMAP_NEAREST",9986:"NEAREST_MIPMAP_LINEAR",9987:"LINEAR_MIPMAP_LINEAR",10240:"TEXTURE_MAG_FILTER",10241:"TEXTURE_MIN_FILTER",10242:"TEXTURE_WRAP_S",10243:"TEXTURE_WRAP_T",10497:"REPEAT",10752:"POLYGON_OFFSET_UNITS",16384:"COLOR_BUFFER_BIT",32769:"CONSTANT_COLOR",32770:"ONE_MINUS_CONSTANT_COLOR",32771:"CONSTANT_ALPHA",32772:"ONE_MINUS_CONSTANT_ALPHA",32773:"BLEND_COLOR",32774:"FUNC_ADD",32777:"BLEND_EQUATION_RGB",32778:"FUNC_SUBTRACT",32779:"FUNC_REVERSE_SUBTRACT",32819:"UNSIGNED_SHORT_4_4_4_4",32820:"UNSIGNED_SHORT_5_5_5_1",32823:"POLYGON_OFFSET_FILL",32824:"POLYGON_OFFSET_FACTOR",32854:"RGBA4",32855:"RGB5_A1",32873:"TEXTURE_BINDING_2D",32926:"SAMPLE_ALPHA_TO_COVERAGE",32928:"SAMPLE_COVERAGE",32936:"SAMPLE_BUFFERS",32937:"SAMPLES",32938:"SAMPLE_COVERAGE_VALUE",32939:"SAMPLE_COVERAGE_INVERT",32968:"BLEND_DST_RGB",32969:"BLEND_SRC_RGB",32970:"BLEND_DST_ALPHA",32971:"BLEND_SRC_ALPHA",33071:"CLAMP_TO_EDGE",33170:"GENERATE_MIPMAP_HINT",33189:"DEPTH_COMPONENT16",33306:"DEPTH_STENCIL_ATTACHMENT",33321:"R8",33635:"UNSIGNED_SHORT_5_6_5",33648:"MIRRORED_REPEAT",33901:"ALIASED_POINT_SIZE_RANGE",33902:"ALIASED_LINE_WIDTH_RANGE",33984:"TEXTURE0",33985:"TEXTURE1",33986:"TEXTURE2",33987:"TEXTURE3",33988:"TEXTURE4",33989:"TEXTURE5",33990:"TEXTURE6",33991:"TEXTURE7",33992:"TEXTURE8",33993:"TEXTURE9",33994:"TEXTURE10",33995:"TEXTURE11",33996:"TEXTURE12",33997:"TEXTURE13",33998:"TEXTURE14",33999:"TEXTURE15",34e3:"TEXTURE16",34001:"TEXTURE17",34002:"TEXTURE18",34003:"TEXTURE19",34004:"TEXTURE20",34005:"TEXTURE21",34006:"TEXTURE22",34007:"TEXTURE23",34008:"TEXTURE24",34009:"TEXTURE25",34010:"TEXTURE26",34011:"TEXTURE27",34012:"TEXTURE28",34013:"TEXTURE29",34014:"TEXTURE30",34015:"TEXTURE31",34016:"ACTIVE_TEXTURE",34024:"MAX_RENDERBUFFER_SIZE",34041:"DEPTH_STENCIL",34055:"INCR_WRAP",34056:"DECR_WRAP",34067:"TEXTURE_CUBE_MAP",34068:"TEXTURE_BINDING_CUBE_MAP",34069:"TEXTURE_CUBE_MAP_POSITIVE_X",34070:"TEXTURE_CUBE_MAP_NEGATIVE_X",34071:"TEXTURE_CUBE_MAP_POSITIVE_Y",34072:"TEXTURE_CUBE_MAP_NEGATIVE_Y",34073:"TEXTURE_CUBE_MAP_POSITIVE_Z",34074:"TEXTURE_CUBE_MAP_NEGATIVE_Z",34076:"MAX_CUBE_MAP_TEXTURE_SIZE",34338:"VERTEX_ATTRIB_ARRAY_ENABLED",34339:"VERTEX_ATTRIB_ARRAY_SIZE",34340:"VERTEX_ATTRIB_ARRAY_STRIDE",34341:"VERTEX_ATTRIB_ARRAY_TYPE",34342:"CURRENT_VERTEX_ATTRIB",34373:"VERTEX_ATTRIB_ARRAY_POINTER",34466:"NUM_COMPRESSED_TEXTURE_FORMATS",34467:"COMPRESSED_TEXTURE_FORMATS",34660:"BUFFER_SIZE",34661:"BUFFER_USAGE",34816:"STENCIL_BACK_FUNC",34817:"STENCIL_BACK_FAIL",34818:"STENCIL_BACK_PASS_DEPTH_FAIL",34819:"STENCIL_BACK_PASS_DEPTH_PASS",34877:"BLEND_EQUATION_ALPHA",34921:"MAX_VERTEX_ATTRIBS",34922:"VERTEX_ATTRIB_ARRAY_NORMALIZED",34930:"MAX_TEXTURE_IMAGE_UNITS",34962:"ARRAY_BUFFER",34963:"ELEMENT_ARRAY_BUFFER",34964:"ARRAY_BUFFER_BINDING",34965:"ELEMENT_ARRAY_BUFFER_BINDING",34975:"VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",35040:"STREAM_DRAW",35044:"STATIC_DRAW",35048:"DYNAMIC_DRAW",35632:"FRAGMENT_SHADER",35633:"VERTEX_SHADER",35660:"MAX_VERTEX_TEXTURE_IMAGE_UNITS",35661:"MAX_COMBINED_TEXTURE_IMAGE_UNITS",35663:"SHADER_TYPE",35664:"FLOAT_VEC2",35665:"FLOAT_VEC3",35666:"FLOAT_VEC4",35667:"INT_VEC2",35668:"INT_VEC3",35669:"INT_VEC4",35670:"BOOL",35671:"BOOL_VEC2",35672:"BOOL_VEC3",35673:"BOOL_VEC4",35674:"FLOAT_MAT2",35675:"FLOAT_MAT3",35676:"FLOAT_MAT4",35678:"SAMPLER_2D",35680:"SAMPLER_CUBE",35712:"DELETE_STATUS",35713:"COMPILE_STATUS",35714:"LINK_STATUS",35715:"VALIDATE_STATUS",35716:"INFO_LOG_LENGTH",35717:"ATTACHED_SHADERS",35718:"ACTIVE_UNIFORMS",35719:"ACTIVE_UNIFORM_MAX_LENGTH",35720:"SHADER_SOURCE_LENGTH",35721:"ACTIVE_ATTRIBUTES",35722:"ACTIVE_ATTRIBUTE_MAX_LENGTH",35724:"SHADING_LANGUAGE_VERSION",35725:"CURRENT_PROGRAM",36003:"STENCIL_BACK_REF",36004:"STENCIL_BACK_VALUE_MASK",36005:"STENCIL_BACK_WRITEMASK",36006:"FRAMEBUFFER_BINDING",36007:"RENDERBUFFER_BINDING",36048:"FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",36049:"FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",36050:"FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",36051:"FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",36053:"FRAMEBUFFER_COMPLETE",36054:"FRAMEBUFFER_INCOMPLETE_ATTACHMENT",36055:"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",36057:"FRAMEBUFFER_INCOMPLETE_DIMENSIONS",36061:"FRAMEBUFFER_UNSUPPORTED",36064:"COLOR_ATTACHMENT0",36096:"DEPTH_ATTACHMENT",36128:"STENCIL_ATTACHMENT",36160:"FRAMEBUFFER",36161:"RENDERBUFFER",36162:"RENDERBUFFER_WIDTH",36163:"RENDERBUFFER_HEIGHT",36164:"RENDERBUFFER_INTERNAL_FORMAT",36168:"STENCIL_INDEX8",36176:"RENDERBUFFER_RED_SIZE",36177:"RENDERBUFFER_GREEN_SIZE",36178:"RENDERBUFFER_BLUE_SIZE",36179:"RENDERBUFFER_ALPHA_SIZE",36180:"RENDERBUFFER_DEPTH_SIZE",36181:"RENDERBUFFER_STENCIL_SIZE",36194:"RGB565",36336:"LOW_FLOAT",36337:"MEDIUM_FLOAT",36338:"HIGH_FLOAT",36339:"LOW_INT",36340:"MEDIUM_INT",36341:"HIGH_INT",36346:"SHADER_COMPILER",36347:"MAX_VERTEX_UNIFORM_VECTORS",36348:"MAX_VARYING_VECTORS",36349:"MAX_FRAGMENT_UNIFORM_VECTORS",37440:"UNPACK_FLIP_Y_WEBGL",37441:"UNPACK_PREMULTIPLY_ALPHA_WEBGL",37442:"CONTEXT_LOST_WEBGL",37443:"UNPACK_COLORSPACE_CONVERSION_WEBGL",37444:"BROWSER_DEFAULT_WEBGL"}},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_GLShader=__webpack_require__(2),_GLShader2=_interopRequireDefault(_GLShader),_FrameBuffer=__webpack_require__(12),_FrameBuffer2=_interopRequireDefault(_FrameBuffer),_ShaderLibs=__webpack_require__(32),_ShaderLibs2=_interopRequireDefault(_ShaderLibs),Pass=function(){function Pass(mSource){var mWidth=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,mHeight=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;arguments.length>3&&void 0!==arguments[3]&&arguments[3];_classCallCheck(this,Pass),this.shader=new _GLShader2.default(_ShaderLibs2.default.bigTriangleVert,mSource),this._width=mWidth,this._height=mHeight,this._uniforms={},this._hasOwnFbo=this._width>0&&this._width>0,this._uniforms={},this._hasOwnFbo&&(this._fbo=new _FrameBuffer2.default(this._width,this.height,mParmas))}return _createClass(Pass,[{key:"uniform",value:function(mName,mValue){this._uniforms[mName]=mValue}},{key:"render",value:function(texture){this.shader.bind(),this.shader.uniform("texture","uniform1i",0),texture.bind(0),this.shader.uniform(this._uniforms)}},{key:"width",get:function(){return this._width}},{key:"height",get:function(){return this._height}},{key:"fbo",get:function(){return this._fbo}},{key:"hasFbo",get:function(){return this._hasOwnFbo}}]),Pass}();exports.default=Pass},function(module,exports){module.exports="// simpleColor.frag\n\n#define SHADER_NAME SIMPLE_COLOR\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform vec3 color;\nuniform float opacity;\n\nvoid main(void) {\n    gl_FragColor = vec4(color, opacity);\n}"},function(module,exports){module.exports="// basic.vert\n\n#define SHADER_NAME BASIC_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vTextureCoord = aTextureCoord;\n    vNormal = aNormal;\n}"},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_GLTexture=__webpack_require__(26),_GLTexture2=_interopRequireDefault(_GLTexture),_WebglNumber=__webpack_require__(8),_WebglNumber2=_interopRequireDefault(_WebglNumber),gl=void 0,webglDepthTexture=void 0,hasCheckedMultiRenderSupport=!1,extDrawBuffer=void 0,checkMultiRender=function(){return!!_GLTool2.default.webgl2||!!(extDrawBuffer=_GLTool2.default.getExtension("WEBGL_draw_buffers"))},FrameBuffer=function(){function FrameBuffer(mWidth,mHeight){var mParameters=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},mNumTargets=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;_classCallCheck(this,FrameBuffer),gl=_GLTool2.default.gl,webglDepthTexture=_GLTool2.default.checkExtension("WEBGL_depth_texture"),this.width=mWidth,this.height=mHeight,this._numTargets=mNumTargets,this._multipleTargets=mNumTargets>1,this._parameters=mParameters,hasCheckedMultiRenderSupport||checkMultiRender(),this._multipleTargets&&this._checkMaxNumRenderTarget(),this._init()}return _createClass(FrameBuffer,[{key:"_init",value:function(){if(this._initTextures(),this.frameBuffer=gl.createFramebuffer(),gl.bindFramebuffer(gl.FRAMEBUFFER,this.frameBuffer),_GLTool2.default.webgl2){for(var buffers=[],i=0;i<this._numTargets;i++)gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER,gl.COLOR_ATTACHMENT0+i,gl.TEXTURE_2D,this._textures[i].texture,0),buffers.push(gl["COLOR_ATTACHMENT"+i]);gl.drawBuffers(buffers),gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER,gl.DEPTH_ATTACHMENT,gl.TEXTURE_2D,this.glDepthTexture.texture,0)}else{for(var _i=0;_i<this._numTargets;_i++)gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0+_i,gl.TEXTURE_2D,this._textures[_i].texture,0);if(this._multipleTargets){for(var drawBuffers=[],_i2=0;_i2<this._numTargets;_i2++)drawBuffers.push(extDrawBuffer["COLOR_ATTACHMENT"+_i2+"_WEBGL"]);extDrawBuffer.drawBuffersWEBGL(drawBuffers)}webglDepthTexture&&gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.DEPTH_ATTACHMENT,gl.TEXTURE_2D,this.glDepthTexture.texture,0)}var FBOstatus=gl.checkFramebufferStatus(gl.FRAMEBUFFER);FBOstatus!=gl.FRAMEBUFFER_COMPLETE&&console.error("GL_FRAMEBUFFER_COMPLETE failed, CANNOT use Framebuffer",_WebglNumber2.default[FBOstatus]),gl.bindTexture(gl.TEXTURE_2D,null),gl.bindRenderbuffer(gl.RENDERBUFFER,null),gl.bindFramebuffer(gl.FRAMEBUFFER,null),this.clear()}},{key:"_checkMaxNumRenderTarget",value:function(){var maxNumDrawBuffers=_GLTool2.default.gl.getParameter(extDrawBuffer.MAX_DRAW_BUFFERS_WEBGL);this._numTargets>maxNumDrawBuffers&&(console.error("Over max number of draw buffers supported : ",maxNumDrawBuffers),this._numTargets=maxNumDrawBuffers)}},{key:"_initTextures",value:function(){this._textures=[];for(var i=0;i<this._numTargets;i++){var glt=this._createTexture();this._textures.push(glt)}_GLTool2.default.webgl2?this.glDepthTexture=this._createTexture(gl.DEPTH_COMPONENT16,gl.UNSIGNED_SHORT,gl.DEPTH_COMPONENT,!0):this.glDepthTexture=this._createTexture(gl.DEPTH_COMPONENT,gl.UNSIGNED_SHORT,gl.DEPTH_COMPONENT,{minFilter:_GLTool2.default.LINEAR})}},{key:"_createTexture",value:function(mInternalformat,mTexelType,mFormat){var mParameters=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},parameters=Object.assign({},this._parameters);mFormat||(mFormat=mInternalformat),parameters.internalFormat=mInternalformat||gl.RGBA,parameters.format=mFormat,parameters.type=mTexelType||parameters.type||_GLTool2.default.UNSIGNED_BYTE;for(var s in mParameters)parameters[s]=mParameters[s];return new _GLTexture2.default(null,parameters,this.width,this.height)}},{key:"bind",value:function(){(!(arguments.length>0&&void 0!==arguments[0])||arguments[0])&&_GLTool2.default.viewport(0,0,this.width,this.height),gl.bindFramebuffer(gl.FRAMEBUFFER,this.frameBuffer)}},{key:"unbind",value:function(){(!(arguments.length>0&&void 0!==arguments[0])||arguments[0])&&_GLTool2.default.viewport(0,0,_GLTool2.default.width,_GLTool2.default.height),gl.bindFramebuffer(gl.FRAMEBUFFER,null),this._textures.forEach(function(texture){texture.generateMipmap()})}},{key:"clear",value:function(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.bind(),_GLTool2.default.clear(r,g,b,a),this.unbind()}},{key:"getTexture",value:function(){var mIndex=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this._textures[mIndex]}},{key:"getDepthTexture",value:function(){return this.glDepthTexture}},{key:"showParameters",value:function(){this._textures[0].showParameters()}},{key:"minFilter",get:function(){return this._textures[0].minFilter},set:function(mValue){this._textures.forEach(function(texture){texture.minFilter=mValue})}},{key:"magFilter",get:function(){return this._textures[0].magFilter},set:function(mValue){this._textures.forEach(function(texture){texture.magFilter=mValue})}},{key:"wrapS",get:function(){return this._textures[0].wrapS},set:function(mValue){this._textures.forEach(function(texture){texture.wrapS=mValue})}},{key:"wrapT",get:function(){return this._textures[0].wrapT},set:function(mValue){this._textures.forEach(function(texture){texture.wrapT=mValue})}},{key:"numTargets",get:function(){return this._numTargets}}]),FrameBuffer}();exports.default=FrameBuffer},function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_scheduling=__webpack_require__(6),_scheduling2=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(_scheduling),EaseNumber=function(){function EaseNumber(mValue){var _this=this,mEasing=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;_classCallCheck(this,EaseNumber),this.easing=mEasing,this._value=mValue,this._targetValue=mValue,this._efIndex=_scheduling2.default.addEF(function(){return _this._update()})}return _createClass(EaseNumber,[{key:"_update",value:function(){this._checkLimit(),this._value+=(this._targetValue-this._value)*this.easing,Math.abs(this._targetValue-this._value)<1e-4&&(this._value=this._targetValue)}},{key:"setTo",value:function(mValue){this._targetValue=this._value=mValue}},{key:"add",value:function(mAdd){this._targetValue+=mAdd}},{key:"limit",value:function(mMin,mMax){if(mMin>mMax)return void this.limit(mMax,mMin);this._min=mMin,this._max=mMax,this._checkLimit()}},{key:"_checkLimit",value:function(){void 0!==this._min&&this._targetValue<this._min&&(this._targetValue=this._min),void 0!==this._max&&this._targetValue>this._max&&(this._targetValue=this._max)}},{key:"destroy",value:function(){_scheduling2.default.removeEF(this._efIndex)}},{key:"value",set:function(mValue){this._targetValue=mValue},get:function(){return this._value}},{key:"targetValue",get:function(){return this._targetValue}}]),EaseNumber}();exports.default=EaseNumber},function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_glMatrix=__webpack_require__(1),a=_glMatrix.vec3.create(),b=_glMatrix.vec3.create(),c=_glMatrix.vec3.create(),target=_glMatrix.vec3.create(),edge1=_glMatrix.vec3.create(),edge2=_glMatrix.vec3.create(),normal=_glMatrix.vec3.create(),diff=_glMatrix.vec3.create(),Ray=function(){function Ray(mOrigin,mDirection){_classCallCheck(this,Ray),this.origin=_glMatrix.vec3.clone(mOrigin),this.direction=_glMatrix.vec3.clone(mDirection)}return _createClass(Ray,[{key:"at",value:function(t){return _glMatrix.vec3.copy(target,this.direction),_glMatrix.vec3.scale(target,target,t),_glMatrix.vec3.add(target,target,this.origin),target}},{key:"lookAt",value:function(mTarget){_glMatrix.vec3.sub(this.direction,mTarget,this.origin),_glMatrix.vec3.normalize(this.origin,this.origin)}},{key:"closestPointToPoint",value:function(mPoint){var result=_glMatrix.vec3.create();_glMatrix.vec3.sub(mPoint,this.origin);var directionDistance=_glMatrix.vec3.dot(result,this.direction);return directionDistance<0?_glMatrix.vec3.clone(this.origin):(_glMatrix.vec3.copy(result,this.direction),_glMatrix.vec3.scale(result,result,directionDistance),_glMatrix.vec3.add(result,result,this.origin),result)}},{key:"distanceToPoint",value:function(mPoint){return Math.sqrt(this.distanceSqToPoint(mPoint))}},{key:"distanceSqToPoint",value:function(mPoint){var v1=_glMatrix.vec3.create();_glMatrix.vec3.sub(v1,mPoint,this.origin);var directionDistance=_glMatrix.vec3.dot(v1,this.direction);return directionDistance<0?_glMatrix.vec3.squaredDistance(this.origin,mPoint):(_glMatrix.vec3.copy(v1,this.direction),_glMatrix.vec3.scale(v1,v1,directionDistance),_glMatrix.vec3.add(v1,v1,this.origin),_glMatrix.vec3.squaredDistance(v1,mPoint))}},{key:"intersectsSphere",value:function(mCenter,mRadius){return this.distanceToPoint(mCenter)<=mRadius}},{key:"intersectSphere",value:function(mCenter,mRadius){var v1=_glMatrix.vec3.create();_glMatrix.vec3.sub(v1,mCenter,this.origin);var tca=_glMatrix.vec3.dot(v1,this.direction),d2=_glMatrix.vec3.dot(v1,v1)-tca*tca,radius2=mRadius*mRadius;if(d2>radius2)return null;var thc=Math.sqrt(radius2-d2),t0=tca-thc,t1=tca+thc;return t0<0&&t1<0?null:t0<0?this.at(t1):this.at(t0)}},{key:"distanceToPlane",value:function(mPlaneCenter,mNormal){_glMatrix.vec3.dot(mNormal,this.direction)}},{key:"intersectTriangle",value:function(mPA,mPB,mPC){var backfaceCulling=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];_glMatrix.vec3.copy(a,mPA),_glMatrix.vec3.copy(b,mPB),_glMatrix.vec3.copy(c,mPC),_glMatrix.vec3.sub(edge1,b,a),_glMatrix.vec3.sub(edge2,c,a),_glMatrix.vec3.cross(normal,edge1,edge2);var DdN=_glMatrix.vec3.dot(this.direction,normal),sign=void 0;if(DdN>0){if(backfaceCulling)return null;sign=1}else{if(!(DdN<0))return null;sign=-1,DdN=-DdN}_glMatrix.vec3.sub(diff,this.origin,a),_glMatrix.vec3.cross(edge2,diff,edge2);var DdQxE2=sign*_glMatrix.vec3.dot(this.direction,edge2);if(DdQxE2<0)return null;_glMatrix.vec3.cross(edge1,edge1,diff);var DdE1xQ=sign*_glMatrix.vec3.dot(this.direction,edge1);if(DdE1xQ<0)return null;if(DdQxE2+DdE1xQ>DdN)return null;var Qdn=-sign*_glMatrix.vec3.dot(diff,normal);return Qdn<0?null:this.at(Qdn/DdN)}}]),Ray}();exports.default=Ray},function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_glMatrix=__webpack_require__(1),Camera=function(){function Camera(){_classCallCheck(this,Camera),this._matrix=_glMatrix.mat4.create(),this._quat=_glMatrix.quat.create(),this._orientation=_glMatrix.mat4.create(),this._projection=_glMatrix.mat4.create(),this.position=vec3.create()}return _createClass(Camera,[{key:"lookAt",value:function(aEye,aCenter){var aUp=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[0,1,0];this._eye=vec3.clone(aEye),this._center=vec3.clone(aCenter),vec3.copy(this.position,aEye),_glMatrix.mat4.identity(this._matrix),_glMatrix.mat4.lookAt(this._matrix,aEye,aCenter,aUp)}},{key:"setFromOrientation",value:function(x,y,z,w){_glMatrix.quat.set(this._quat,x,y,z,w),_glMatrix.mat4.fromQuat(this._orientation,this._quat),_glMatrix.mat4.translate(this._matrix,this._orientation,this.positionOffset)}},{key:"setProjection",value:function(mProj){this._projection=_glMatrix.mat4.clone(mProj)}},{key:"setView",value:function(mView){this._matrix=_glMatrix.mat4.clone(mView)}},{key:"setFromViewProj",value:function(mView,mProj){this.setView(mView),this.setProjection(mProj)}},{key:"matrix",get:function(){return this._matrix}},{key:"viewMatrix",get:function(){return this._matrix}},{key:"projection",get:function(){return this._projection}},{key:"projectionMatrix",get:function(){return this._projection}},{key:"eye",get:function(){return this._eye}},{key:"center",get:function(){return this._center}}]),Camera}();exports.default=Camera},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_Camera2=__webpack_require__(15),_Camera3=_interopRequireDefault(_Camera2),_Ray=__webpack_require__(14),_Ray2=_interopRequireDefault(_Ray),_glMatrix=__webpack_require__(1),mInverseViewProj=_glMatrix.mat4.create(),cameraDir=_glMatrix.vec3.create(),CameraPerspective=function(_Camera){function CameraPerspective(){return _classCallCheck(this,CameraPerspective),_possibleConstructorReturn(this,(CameraPerspective.__proto__||Object.getPrototypeOf(CameraPerspective)).apply(this,arguments))}return _inherits(CameraPerspective,_Camera),_createClass(CameraPerspective,[{key:"setPerspective",value:function(mFov,mAspectRatio,mNear,mFar){this._fov=mFov,this._near=mNear,this._far=mFar,this._aspectRatio=mAspectRatio,_glMatrix.mat4.perspective(this._projection,mFov,mAspectRatio,mNear,mFar)}},{key:"setAspectRatio",value:function(mAspectRatio){this._aspectRatio=mAspectRatio,_glMatrix.mat4.perspective(this.projection,this._fov,mAspectRatio,this._near,this._far)}},{key:"generateRay",value:function(mScreenPosition,mRay){var proj=this.projectionMatrix,view=this.viewMatrix;return _glMatrix.mat4.multiply(mInverseViewProj,proj,view),_glMatrix.mat4.invert(mInverseViewProj,mInverseViewProj),_glMatrix.vec3.transformMat4(cameraDir,mScreenPosition,mInverseViewProj),_glMatrix.vec3.sub(cameraDir,cameraDir,this.position),_glMatrix.vec3.normalize(cameraDir,cameraDir),mRay?(mRay.origin=this.position,mRay.direction=cameraDir):mRay=new _Ray2.default(this.position,cameraDir),mRay}}]),CameraPerspective}(_Camera3.default);exports.default=CameraPerspective},function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),BinaryLoader=function(){function BinaryLoader(){var _this=this,isArrayBuffer=arguments.length>0&&void 0!==arguments[0]&&arguments[0];_classCallCheck(this,BinaryLoader),this._req=new XMLHttpRequest,this._req.addEventListener("load",function(e){return _this._onLoaded(e)}),this._req.addEventListener("progress",function(e){return _this._onProgress(e)}),isArrayBuffer&&(this._req.responseType="arraybuffer")}return _createClass(BinaryLoader,[{key:"load",value:function(url,callback){console.log("Loading : ",url),this._callback=callback,this._req.open("GET",url),this._req.send()}},{key:"_onLoaded",value:function(){this._callback(this._req.response)}},{key:"_onProgress",value:function(){}}]),BinaryLoader}();exports.default=BinaryLoader},function(module,exports){module.exports="// bigTriangle.vert\n\n#define SHADER_NAME BIG_TRIANGLE_VERTEX\n\nprecision mediump float;\n#define GLSLIFY 1\nattribute vec2 aPosition;\nvarying vec2 vTextureCoord;\n\nvoid main(void) {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n    vTextureCoord = aPosition * .5 + .5;\n}"},function(module,exports){module.exports="// copy.frag\n\n#define SHADER_NAME COPY_FRAGMENT\n\nprecision mediump float;\n#define GLSLIFY 1\n\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\n\nvoid main(void) {\n    gl_FragColor = texture2D(texture, vTextureCoord);\n}"},function(module,exports,__webpack_require__){"use strict";function create(){var out=new glMatrix.ARRAY_TYPE(9);return out[0]=1,out[1]=0,out[2]=0,out[3]=0,out[4]=1,out[5]=0,out[6]=0,out[7]=0,out[8]=1,out}function fromMat4(out,a){return out[0]=a[0],out[1]=a[1],out[2]=a[2],out[3]=a[4],out[4]=a[5],out[5]=a[6],out[6]=a[8],out[7]=a[9],out[8]=a[10],out}function clone(a){var out=new glMatrix.ARRAY_TYPE(9);return out[0]=a[0],out[1]=a[1],out[2]=a[2],out[3]=a[3],out[4]=a[4],out[5]=a[5],out[6]=a[6],out[7]=a[7],out[8]=a[8],out}function copy(out,a){return out[0]=a[0],out[1]=a[1],out[2]=a[2],out[3]=a[3],out[4]=a[4],out[5]=a[5],out[6]=a[6],out[7]=a[7],out[8]=a[8],out}function fromValues(m00,m01,m02,m10,m11,m12,m20,m21,m22){var out=new glMatrix.ARRAY_TYPE(9);return out[0]=m00,out[1]=m01,out[2]=m02,out[3]=m10,out[4]=m11,out[5]=m12,out[6]=m20,out[7]=m21,out[8]=m22,out}function set(out,m00,m01,m02,m10,m11,m12,m20,m21,m22){return out[0]=m00,out[1]=m01,out[2]=m02,out[3]=m10,out[4]=m11,out[5]=m12,out[6]=m20,out[7]=m21,out[8]=m22,out}function identity(out){return out[0]=1,out[1]=0,out[2]=0,out[3]=0,out[4]=1,out[5]=0,out[6]=0,out[7]=0,out[8]=1,out}function transpose(out,a){if(out===a){var a01=a[1],a02=a[2],a12=a[5];out[1]=a[3],out[2]=a[6],out[3]=a01,out[5]=a[7],out[6]=a02,out[7]=a12}else out[0]=a[0],out[1]=a[3],out[2]=a[6],out[3]=a[1],out[4]=a[4],out[5]=a[7],out[6]=a[2],out[7]=a[5],out[8]=a[8];return out}function invert(out,a){var a00=a[0],a01=a[1],a02=a[2],a10=a[3],a11=a[4],a12=a[5],a20=a[6],a21=a[7],a22=a[8],b01=a22*a11-a12*a21,b11=-a22*a10+a12*a20,b21=a21*a10-a11*a20,det=a00*b01+a01*b11+a02*b21;return det?(det=1/det,out[0]=b01*det,out[1]=(-a22*a01+a02*a21)*det,out[2]=(a12*a01-a02*a11)*det,out[3]=b11*det,out[4]=(a22*a00-a02*a20)*det,out[5]=(-a12*a00+a02*a10)*det,out[6]=b21*det,out[7]=(-a21*a00+a01*a20)*det,out[8]=(a11*a00-a01*a10)*det,out):null}function adjoint(out,a){var a00=a[0],a01=a[1],a02=a[2],a10=a[3],a11=a[4],a12=a[5],a20=a[6],a21=a[7],a22=a[8];return out[0]=a11*a22-a12*a21,out[1]=a02*a21-a01*a22,out[2]=a01*a12-a02*a11,out[3]=a12*a20-a10*a22,out[4]=a00*a22-a02*a20,out[5]=a02*a10-a00*a12,out[6]=a10*a21-a11*a20,out[7]=a01*a20-a00*a21,out[8]=a00*a11-a01*a10,out}function determinant(a){var a00=a[0],a01=a[1],a02=a[2],a10=a[3],a11=a[4],a12=a[5],a20=a[6],a21=a[7],a22=a[8];return a00*(a22*a11-a12*a21)+a01*(-a22*a10+a12*a20)+a02*(a21*a10-a11*a20)}function multiply(out,a,b){var a00=a[0],a01=a[1],a02=a[2],a10=a[3],a11=a[4],a12=a[5],a20=a[6],a21=a[7],a22=a[8],b00=b[0],b01=b[1],b02=b[2],b10=b[3],b11=b[4],b12=b[5],b20=b[6],b21=b[7],b22=b[8];return out[0]=b00*a00+b01*a10+b02*a20,out[1]=b00*a01+b01*a11+b02*a21,out[2]=b00*a02+b01*a12+b02*a22,out[3]=b10*a00+b11*a10+b12*a20,out[4]=b10*a01+b11*a11+b12*a21,out[5]=b10*a02+b11*a12+b12*a22,out[6]=b20*a00+b21*a10+b22*a20,out[7]=b20*a01+b21*a11+b22*a21,out[8]=b20*a02+b21*a12+b22*a22,out}function translate(out,a,v){var a00=a[0],a01=a[1],a02=a[2],a10=a[3],a11=a[4],a12=a[5],a20=a[6],a21=a[7],a22=a[8],x=v[0],y=v[1];return out[0]=a00,out[1]=a01,out[2]=a02,out[3]=a10,out[4]=a11,out[5]=a12,out[6]=x*a00+y*a10+a20,out[7]=x*a01+y*a11+a21,out[8]=x*a02+y*a12+a22,out}function rotate(out,a,rad){var a00=a[0],a01=a[1],a02=a[2],a10=a[3],a11=a[4],a12=a[5],a20=a[6],a21=a[7],a22=a[8],s=Math.sin(rad),c=Math.cos(rad);return out[0]=c*a00+s*a10,out[1]=c*a01+s*a11,out[2]=c*a02+s*a12,out[3]=c*a10-s*a00,out[4]=c*a11-s*a01,out[5]=c*a12-s*a02,out[6]=a20,out[7]=a21,out[8]=a22,out}function scale(out,a,v){var x=v[0],y=v[1];return out[0]=x*a[0],out[1]=x*a[1],out[2]=x*a[2],out[3]=y*a[3],out[4]=y*a[4],out[5]=y*a[5],out[6]=a[6],out[7]=a[7],out[8]=a[8],out}function fromTranslation(out,v){return out[0]=1,out[1]=0,out[2]=0,out[3]=0,out[4]=1,out[5]=0,out[6]=v[0],out[7]=v[1],out[8]=1,out}function fromRotation(out,rad){var s=Math.sin(rad),c=Math.cos(rad);return out[0]=c,out[1]=s,out[2]=0,out[3]=-s,out[4]=c,out[5]=0,out[6]=0,out[7]=0,out[8]=1,out}function fromScaling(out,v){return out[0]=v[0],out[1]=0,out[2]=0,out[3]=0,out[4]=v[1],out[5]=0,out[6]=0,out[7]=0,out[8]=1,out}function fromMat2d(out,a){return out[0]=a[0],out[1]=a[1],out[2]=0,out[3]=a[2],out[4]=a[3],out[5]=0,out[6]=a[4],out[7]=a[5],out[8]=1,out}function fromQuat(out,q){var x=q[0],y=q[1],z=q[2],w=q[3],x2=x+x,y2=y+y,z2=z+z,xx=x*x2,yx=y*x2,yy=y*y2,zx=z*x2,zy=z*y2,zz=z*z2,wx=w*x2,wy=w*y2,wz=w*z2;return out[0]=1-yy-zz,out[3]=yx-wz,out[6]=zx+wy,out[1]=yx+wz,out[4]=1-xx-zz,out[7]=zy-wx,out[2]=zx-wy,out[5]=zy+wx,out[8]=1-xx-yy,out}function normalFromMat4(out,a){var a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11],a30=a[12],a31=a[13],a32=a[14],a33=a[15],b00=a00*a11-a01*a10,b01=a00*a12-a02*a10,b02=a00*a13-a03*a10,b03=a01*a12-a02*a11,b04=a01*a13-a03*a11,b05=a02*a13-a03*a12,b06=a20*a31-a21*a30,b07=a20*a32-a22*a30,b08=a20*a33-a23*a30,b09=a21*a32-a22*a31,b10=a21*a33-a23*a31,b11=a22*a33-a23*a32,det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;return det?(det=1/det,out[0]=(a11*b11-a12*b10+a13*b09)*det,out[1]=(a12*b08-a10*b11-a13*b07)*det,out[2]=(a10*b10-a11*b08+a13*b06)*det,out[3]=(a02*b10-a01*b11-a03*b09)*det,out[4]=(a00*b11-a02*b08+a03*b07)*det,out[5]=(a01*b08-a00*b10-a03*b06)*det,out[6]=(a31*b05-a32*b04+a33*b03)*det,out[7]=(a32*b02-a30*b05-a33*b01)*det,out[8]=(a30*b04-a31*b02+a33*b00)*det,out):null}function projection(out,width,height){return out[0]=2/width,out[1]=0,out[2]=0,out[3]=0,out[4]=-2/height,out[5]=0,out[6]=-1,out[7]=1,out[8]=1,out}function str(a){return"mat3("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+", "+a[6]+", "+a[7]+", "+a[8]+")"}function frob(a){return Math.sqrt(Math.pow(a[0],2)+Math.pow(a[1],2)+Math.pow(a[2],2)+Math.pow(a[3],2)+Math.pow(a[4],2)+Math.pow(a[5],2)+Math.pow(a[6],2)+Math.pow(a[7],2)+Math.pow(a[8],2))}function add(out,a,b){return out[0]=a[0]+b[0],out[1]=a[1]+b[1],out[2]=a[2]+b[2],out[3]=a[3]+b[3],out[4]=a[4]+b[4],out[5]=a[5]+b[5],out[6]=a[6]+b[6],out[7]=a[7]+b[7],out[8]=a[8]+b[8],out}function subtract(out,a,b){return out[0]=a[0]-b[0],out[1]=a[1]-b[1],out[2]=a[2]-b[2],out[3]=a[3]-b[3],out[4]=a[4]-b[4],out[5]=a[5]-b[5],out[6]=a[6]-b[6],out[7]=a[7]-b[7],out[8]=a[8]-b[8],out}function multiplyScalar(out,a,b){return out[0]=a[0]*b,out[1]=a[1]*b,out[2]=a[2]*b,out[3]=a[3]*b,out[4]=a[4]*b,out[5]=a[5]*b,out[6]=a[6]*b,out[7]=a[7]*b,out[8]=a[8]*b,out}function multiplyScalarAndAdd(out,a,b,scale){return out[0]=a[0]+b[0]*scale,out[1]=a[1]+b[1]*scale,out[2]=a[2]+b[2]*scale,out[3]=a[3]+b[3]*scale,out[4]=a[4]+b[4]*scale,out[5]=a[5]+b[5]*scale,out[6]=a[6]+b[6]*scale,out[7]=a[7]+b[7]*scale,out[8]=a[8]+b[8]*scale,out}function exactEquals(a,b){return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2]&&a[3]===b[3]&&a[4]===b[4]&&a[5]===b[5]&&a[6]===b[6]&&a[7]===b[7]&&a[8]===b[8]}function equals(a,b){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],a4=a[4],a5=a[5],a6=a[6],a7=a[7],a8=a[8],b0=b[0],b1=b[1],b2=b[2],b3=b[3],b4=b[4],b5=b[5],b6=b[6],b7=b[7],b8=b[8];return Math.abs(a0-b0)<=glMatrix.EPSILON*Math.max(1,Math.abs(a0),Math.abs(b0))&&Math.abs(a1-b1)<=glMatrix.EPSILON*Math.max(1,Math.abs(a1),Math.abs(b1))&&Math.abs(a2-b2)<=glMatrix.EPSILON*Math.max(1,Math.abs(a2),Math.abs(b2))&&Math.abs(a3-b3)<=glMatrix.EPSILON*Math.max(1,Math.abs(a3),Math.abs(b3))&&Math.abs(a4-b4)<=glMatrix.EPSILON*Math.max(1,Math.abs(a4),Math.abs(b4))&&Math.abs(a5-b5)<=glMatrix.EPSILON*Math.max(1,Math.abs(a5),Math.abs(b5))&&Math.abs(a6-b6)<=glMatrix.EPSILON*Math.max(1,Math.abs(a6),Math.abs(b6))&&Math.abs(a7-b7)<=glMatrix.EPSILON*Math.max(1,Math.abs(a7),Math.abs(b7))&&Math.abs(a8-b8)<=glMatrix.EPSILON*Math.max(1,Math.abs(a8),Math.abs(b8))}Object.defineProperty(exports,"__esModule",{value:!0}),exports.sub=exports.mul=void 0,exports.create=create,exports.fromMat4=fromMat4,exports.clone=clone,exports.copy=copy,exports.fromValues=fromValues,exports.set=set,exports.identity=identity,exports.transpose=transpose,exports.invert=invert,exports.adjoint=adjoint,exports.determinant=determinant,exports.multiply=multiply,exports.translate=translate,exports.rotate=rotate,exports.scale=scale,exports.fromTranslation=fromTranslation,exports.fromRotation=fromRotation,exports.fromScaling=fromScaling,exports.fromMat2d=fromMat2d,exports.fromQuat=fromQuat,exports.normalFromMat4=normalFromMat4,exports.projection=projection,exports.str=str,exports.frob=frob,exports.add=add,exports.subtract=subtract,exports.multiplyScalar=multiplyScalar,exports.multiplyScalarAndAdd=multiplyScalarAndAdd,exports.exactEquals=exactEquals,exports.equals=equals;var _common=__webpack_require__(3),glMatrix=function(obj){if(obj&&obj.__esModule)return obj;var newObj={};if(null!=obj)for(var key in obj)Object.prototype.hasOwnProperty.call(obj,key)&&(newObj[key]=obj[key]);return newObj.default=obj,newObj}(_common);exports.mul=multiply,exports.sub=subtract},function(module,exports,__webpack_require__){"use strict";function create(){var out=new glMatrix.ARRAY_TYPE(3);return out[0]=0,out[1]=0,out[2]=0,out}function clone(a){var out=new glMatrix.ARRAY_TYPE(3);return out[0]=a[0],out[1]=a[1],out[2]=a[2],out}function length(a){var x=a[0],y=a[1],z=a[2];return Math.sqrt(x*x+y*y+z*z)}function fromValues(x,y,z){var out=new glMatrix.ARRAY_TYPE(3);return out[0]=x,out[1]=y,out[2]=z,out}function copy(out,a){return out[0]=a[0],out[1]=a[1],out[2]=a[2],out}function set(out,x,y,z){return out[0]=x,out[1]=y,out[2]=z,out}function add(out,a,b){return out[0]=a[0]+b[0],out[1]=a[1]+b[1],out[2]=a[2]+b[2],out}function subtract(out,a,b){return out[0]=a[0]-b[0],out[1]=a[1]-b[1],out[2]=a[2]-b[2],out}function multiply(out,a,b){return out[0]=a[0]*b[0],out[1]=a[1]*b[1],out[2]=a[2]*b[2],out}function divide(out,a,b){return out[0]=a[0]/b[0],out[1]=a[1]/b[1],out[2]=a[2]/b[2],out}function ceil(out,a){return out[0]=Math.ceil(a[0]),out[1]=Math.ceil(a[1]),out[2]=Math.ceil(a[2]),out}function floor(out,a){return out[0]=Math.floor(a[0]),out[1]=Math.floor(a[1]),out[2]=Math.floor(a[2]),out}function min(out,a,b){return out[0]=Math.min(a[0],b[0]),out[1]=Math.min(a[1],b[1]),out[2]=Math.min(a[2],b[2]),out}function max(out,a,b){return out[0]=Math.max(a[0],b[0]),out[1]=Math.max(a[1],b[1]),out[2]=Math.max(a[2],b[2]),out}function round(out,a){return out[0]=Math.round(a[0]),out[1]=Math.round(a[1]),out[2]=Math.round(a[2]),out}function scale(out,a,b){return out[0]=a[0]*b,out[1]=a[1]*b,out[2]=a[2]*b,out}function scaleAndAdd(out,a,b,scale){return out[0]=a[0]+b[0]*scale,out[1]=a[1]+b[1]*scale,out[2]=a[2]+b[2]*scale,out}function distance(a,b){var x=b[0]-a[0],y=b[1]-a[1],z=b[2]-a[2];return Math.sqrt(x*x+y*y+z*z)}function squaredDistance(a,b){var x=b[0]-a[0],y=b[1]-a[1],z=b[2]-a[2];return x*x+y*y+z*z}function squaredLength(a){var x=a[0],y=a[1],z=a[2];return x*x+y*y+z*z}function negate(out,a){return out[0]=-a[0],out[1]=-a[1],out[2]=-a[2],out}function inverse(out,a){return out[0]=1/a[0],out[1]=1/a[1],out[2]=1/a[2],out}function normalize(out,a){var x=a[0],y=a[1],z=a[2],len=x*x+y*y+z*z;return len>0&&(len=1/Math.sqrt(len),out[0]=a[0]*len,out[1]=a[1]*len,out[2]=a[2]*len),out}function dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]}function cross(out,a,b){var ax=a[0],ay=a[1],az=a[2],bx=b[0],by=b[1],bz=b[2];return out[0]=ay*bz-az*by,out[1]=az*bx-ax*bz,out[2]=ax*by-ay*bx,out}function lerp(out,a,b,t){var ax=a[0],ay=a[1],az=a[2];return out[0]=ax+t*(b[0]-ax),out[1]=ay+t*(b[1]-ay),out[2]=az+t*(b[2]-az),out}function hermite(out,a,b,c,d,t){var factorTimes2=t*t,factor1=factorTimes2*(2*t-3)+1,factor2=factorTimes2*(t-2)+t,factor3=factorTimes2*(t-1),factor4=factorTimes2*(3-2*t);return out[0]=a[0]*factor1+b[0]*factor2+c[0]*factor3+d[0]*factor4,out[1]=a[1]*factor1+b[1]*factor2+c[1]*factor3+d[1]*factor4,out[2]=a[2]*factor1+b[2]*factor2+c[2]*factor3+d[2]*factor4,out}function bezier(out,a,b,c,d,t){var inverseFactor=1-t,inverseFactorTimesTwo=inverseFactor*inverseFactor,factorTimes2=t*t,factor1=inverseFactorTimesTwo*inverseFactor,factor2=3*t*inverseFactorTimesTwo,factor3=3*factorTimes2*inverseFactor,factor4=factorTimes2*t;return out[0]=a[0]*factor1+b[0]*factor2+c[0]*factor3+d[0]*factor4,out[1]=a[1]*factor1+b[1]*factor2+c[1]*factor3+d[1]*factor4,out[2]=a[2]*factor1+b[2]*factor2+c[2]*factor3+d[2]*factor4,out}function random(out,scale){scale=scale||1;var r=2*glMatrix.RANDOM()*Math.PI,z=2*glMatrix.RANDOM()-1,zScale=Math.sqrt(1-z*z)*scale;return out[0]=Math.cos(r)*zScale,out[1]=Math.sin(r)*zScale,out[2]=z*scale,out}function transformMat4(out,a,m){var x=a[0],y=a[1],z=a[2],w=m[3]*x+m[7]*y+m[11]*z+m[15];return w=w||1,out[0]=(m[0]*x+m[4]*y+m[8]*z+m[12])/w,out[1]=(m[1]*x+m[5]*y+m[9]*z+m[13])/w,out[2]=(m[2]*x+m[6]*y+m[10]*z+m[14])/w,out}function transformMat3(out,a,m){var x=a[0],y=a[1],z=a[2];return out[0]=x*m[0]+y*m[3]+z*m[6],out[1]=x*m[1]+y*m[4]+z*m[7],out[2]=x*m[2]+y*m[5]+z*m[8],out}function transformQuat(out,a,q){var x=a[0],y=a[1],z=a[2],qx=q[0],qy=q[1],qz=q[2],qw=q[3],ix=qw*x+qy*z-qz*y,iy=qw*y+qz*x-qx*z,iz=qw*z+qx*y-qy*x,iw=-qx*x-qy*y-qz*z;return out[0]=ix*qw+iw*-qx+iy*-qz-iz*-qy,out[1]=iy*qw+iw*-qy+iz*-qx-ix*-qz,out[2]=iz*qw+iw*-qz+ix*-qy-iy*-qx,out}function rotateX(out,a,b,c){var p=[],r=[];return p[0]=a[0]-b[0],p[1]=a[1]-b[1],p[2]=a[2]-b[2],r[0]=p[0],r[1]=p[1]*Math.cos(c)-p[2]*Math.sin(c),r[2]=p[1]*Math.sin(c)+p[2]*Math.cos(c),out[0]=r[0]+b[0],out[1]=r[1]+b[1],out[2]=r[2]+b[2],out}function rotateY(out,a,b,c){var p=[],r=[];return p[0]=a[0]-b[0],p[1]=a[1]-b[1],p[2]=a[2]-b[2],r[0]=p[2]*Math.sin(c)+p[0]*Math.cos(c),r[1]=p[1],r[2]=p[2]*Math.cos(c)-p[0]*Math.sin(c),out[0]=r[0]+b[0],out[1]=r[1]+b[1],out[2]=r[2]+b[2],out}function rotateZ(out,a,b,c){var p=[],r=[];return p[0]=a[0]-b[0],p[1]=a[1]-b[1],p[2]=a[2]-b[2],r[0]=p[0]*Math.cos(c)-p[1]*Math.sin(c),r[1]=p[0]*Math.sin(c)+p[1]*Math.cos(c),r[2]=p[2],out[0]=r[0]+b[0],out[1]=r[1]+b[1],out[2]=r[2]+b[2],out}function angle(a,b){var tempA=fromValues(a[0],a[1],a[2]),tempB=fromValues(b[0],b[1],b[2]);normalize(tempA,tempA),normalize(tempB,tempB);var cosine=dot(tempA,tempB);return cosine>1?0:cosine<-1?Math.PI:Math.acos(cosine)}function str(a){return"vec3("+a[0]+", "+a[1]+", "+a[2]+")"}function exactEquals(a,b){return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2]}function equals(a,b){var a0=a[0],a1=a[1],a2=a[2],b0=b[0],b1=b[1],b2=b[2];return Math.abs(a0-b0)<=glMatrix.EPSILON*Math.max(1,Math.abs(a0),Math.abs(b0))&&Math.abs(a1-b1)<=glMatrix.EPSILON*Math.max(1,Math.abs(a1),Math.abs(b1))&&Math.abs(a2-b2)<=glMatrix.EPSILON*Math.max(1,Math.abs(a2),Math.abs(b2))}Object.defineProperty(exports,"__esModule",{value:!0}),exports.forEach=exports.sqrLen=exports.len=exports.sqrDist=exports.dist=exports.div=exports.mul=exports.sub=void 0,exports.create=create,exports.clone=clone,exports.length=length,exports.fromValues=fromValues,exports.copy=copy,exports.set=set,exports.add=add,exports.subtract=subtract,exports.multiply=multiply,exports.divide=divide,exports.ceil=ceil,exports.floor=floor,exports.min=min,exports.max=max,exports.round=round,exports.scale=scale,exports.scaleAndAdd=scaleAndAdd,exports.distance=distance,exports.squaredDistance=squaredDistance,exports.squaredLength=squaredLength,exports.negate=negate,exports.inverse=inverse,exports.normalize=normalize,exports.dot=dot,exports.cross=cross,exports.lerp=lerp,exports.hermite=hermite,exports.bezier=bezier,exports.random=random,exports.transformMat4=transformMat4,exports.transformMat3=transformMat3,exports.transformQuat=transformQuat,exports.rotateX=rotateX,exports.rotateY=rotateY,exports.rotateZ=rotateZ,exports.angle=angle,exports.str=str,exports.exactEquals=exactEquals,exports.equals=equals;var _common=__webpack_require__(3),glMatrix=function(obj){if(obj&&obj.__esModule)return obj;var newObj={};if(null!=obj)for(var key in obj)Object.prototype.hasOwnProperty.call(obj,key)&&(newObj[key]=obj[key]);return newObj.default=obj,newObj}(_common);exports.sub=subtract,exports.mul=multiply,exports.div=divide,exports.dist=distance,exports.sqrDist=squaredDistance,exports.len=length,exports.sqrLen=squaredLength,exports.forEach=function(){var vec=create();return function(a,stride,offset,count,fn,arg){var i=void 0,l=void 0;for(stride||(stride=3),offset||(offset=0),l=count?Math.min(count*stride+offset,a.length):a.length,i=offset;i<l;i+=stride)vec[0]=a[i],vec[1]=a[i+1],vec[2]=a[i+2],fn(vec,vec,arg),a[i]=vec[0],a[i+1]=vec[1],a[i+2]=vec[2];return a}}()},function(module,exports,__webpack_require__){"use strict";function create(){var out=new glMatrix.ARRAY_TYPE(4);return out[0]=0,out[1]=0,out[2]=0,out[3]=0,out}function clone(a){var out=new glMatrix.ARRAY_TYPE(4);return out[0]=a[0],out[1]=a[1],out[2]=a[2],out[3]=a[3],out}function fromValues(x,y,z,w){var out=new glMatrix.ARRAY_TYPE(4);return out[0]=x,out[1]=y,out[2]=z,out[3]=w,out}function copy(out,a){return out[0]=a[0],out[1]=a[1],out[2]=a[2],out[3]=a[3],out}function set(out,x,y,z,w){return out[0]=x,out[1]=y,out[2]=z,out[3]=w,out}function add(out,a,b){return out[0]=a[0]+b[0],out[1]=a[1]+b[1],out[2]=a[2]+b[2],out[3]=a[3]+b[3],out}function subtract(out,a,b){return out[0]=a[0]-b[0],out[1]=a[1]-b[1],out[2]=a[2]-b[2],out[3]=a[3]-b[3],out}function multiply(out,a,b){return out[0]=a[0]*b[0],out[1]=a[1]*b[1],out[2]=a[2]*b[2],out[3]=a[3]*b[3],out}function divide(out,a,b){return out[0]=a[0]/b[0],out[1]=a[1]/b[1],out[2]=a[2]/b[2],out[3]=a[3]/b[3],out}function ceil(out,a){return out[0]=Math.ceil(a[0]),out[1]=Math.ceil(a[1]),out[2]=Math.ceil(a[2]),out[3]=Math.ceil(a[3]),out}function floor(out,a){return out[0]=Math.floor(a[0]),out[1]=Math.floor(a[1]),out[2]=Math.floor(a[2]),out[3]=Math.floor(a[3]),out}function min(out,a,b){return out[0]=Math.min(a[0],b[0]),out[1]=Math.min(a[1],b[1]),out[2]=Math.min(a[2],b[2]),out[3]=Math.min(a[3],b[3]),out}function max(out,a,b){return out[0]=Math.max(a[0],b[0]),out[1]=Math.max(a[1],b[1]),out[2]=Math.max(a[2],b[2]),out[3]=Math.max(a[3],b[3]),out}function round(out,a){return out[0]=Math.round(a[0]),out[1]=Math.round(a[1]),out[2]=Math.round(a[2]),out[3]=Math.round(a[3]),out}function scale(out,a,b){return out[0]=a[0]*b,out[1]=a[1]*b,out[2]=a[2]*b,out[3]=a[3]*b,out}function scaleAndAdd(out,a,b,scale){return out[0]=a[0]+b[0]*scale,out[1]=a[1]+b[1]*scale,out[2]=a[2]+b[2]*scale,out[3]=a[3]+b[3]*scale,out}function distance(a,b){var x=b[0]-a[0],y=b[1]-a[1],z=b[2]-a[2],w=b[3]-a[3];return Math.sqrt(x*x+y*y+z*z+w*w)}function squaredDistance(a,b){var x=b[0]-a[0],y=b[1]-a[1],z=b[2]-a[2],w=b[3]-a[3];return x*x+y*y+z*z+w*w}function length(a){var x=a[0],y=a[1],z=a[2],w=a[3];return Math.sqrt(x*x+y*y+z*z+w*w)}function squaredLength(a){var x=a[0],y=a[1],z=a[2],w=a[3];return x*x+y*y+z*z+w*w}function negate(out,a){return out[0]=-a[0],out[1]=-a[1],out[2]=-a[2],out[3]=-a[3],out}function inverse(out,a){return out[0]=1/a[0],out[1]=1/a[1],out[2]=1/a[2],out[3]=1/a[3],out}function normalize(out,a){var x=a[0],y=a[1],z=a[2],w=a[3],len=x*x+y*y+z*z+w*w;return len>0&&(len=1/Math.sqrt(len),out[0]=x*len,out[1]=y*len,out[2]=z*len,out[3]=w*len),out}function dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3]}function lerp(out,a,b,t){var ax=a[0],ay=a[1],az=a[2],aw=a[3];return out[0]=ax+t*(b[0]-ax),out[1]=ay+t*(b[1]-ay),out[2]=az+t*(b[2]-az),out[3]=aw+t*(b[3]-aw),out}function random(out,vectorScale){return vectorScale=vectorScale||1,out[0]=glMatrix.RANDOM(),out[1]=glMatrix.RANDOM(),out[2]=glMatrix.RANDOM(),out[3]=glMatrix.RANDOM(),normalize(out,out),scale(out,out,vectorScale),out}function transformMat4(out,a,m){var x=a[0],y=a[1],z=a[2],w=a[3];return out[0]=m[0]*x+m[4]*y+m[8]*z+m[12]*w,out[1]=m[1]*x+m[5]*y+m[9]*z+m[13]*w,out[2]=m[2]*x+m[6]*y+m[10]*z+m[14]*w,out[3]=m[3]*x+m[7]*y+m[11]*z+m[15]*w,out}function transformQuat(out,a,q){var x=a[0],y=a[1],z=a[2],qx=q[0],qy=q[1],qz=q[2],qw=q[3],ix=qw*x+qy*z-qz*y,iy=qw*y+qz*x-qx*z,iz=qw*z+qx*y-qy*x,iw=-qx*x-qy*y-qz*z;return out[0]=ix*qw+iw*-qx+iy*-qz-iz*-qy,out[1]=iy*qw+iw*-qy+iz*-qx-ix*-qz,out[2]=iz*qw+iw*-qz+ix*-qy-iy*-qx,out[3]=a[3],out}function str(a){return"vec4("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+")"}function exactEquals(a,b){return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2]&&a[3]===b[3]}function equals(a,b){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],b0=b[0],b1=b[1],b2=b[2],b3=b[3];return Math.abs(a0-b0)<=glMatrix.EPSILON*Math.max(1,Math.abs(a0),Math.abs(b0))&&Math.abs(a1-b1)<=glMatrix.EPSILON*Math.max(1,Math.abs(a1),Math.abs(b1))&&Math.abs(a2-b2)<=glMatrix.EPSILON*Math.max(1,Math.abs(a2),Math.abs(b2))&&Math.abs(a3-b3)<=glMatrix.EPSILON*Math.max(1,Math.abs(a3),Math.abs(b3))}Object.defineProperty(exports,"__esModule",{value:!0}),exports.forEach=exports.sqrLen=exports.len=exports.sqrDist=exports.dist=exports.div=exports.mul=exports.sub=void 0,exports.create=create,exports.clone=clone,exports.fromValues=fromValues,exports.copy=copy,exports.set=set,exports.add=add,exports.subtract=subtract,exports.multiply=multiply,exports.divide=divide,exports.ceil=ceil,exports.floor=floor,exports.min=min,exports.max=max,exports.round=round,exports.scale=scale,exports.scaleAndAdd=scaleAndAdd,exports.distance=distance,exports.squaredDistance=squaredDistance,exports.length=length,exports.squaredLength=squaredLength,exports.negate=negate,exports.inverse=inverse,exports.normalize=normalize,exports.dot=dot,exports.lerp=lerp,exports.random=random,exports.transformMat4=transformMat4,exports.transformQuat=transformQuat,exports.str=str,exports.exactEquals=exactEquals,exports.equals=equals;var _common=__webpack_require__(3),glMatrix=function(obj){if(obj&&obj.__esModule)return obj;var newObj={};if(null!=obj)for(var key in obj)Object.prototype.hasOwnProperty.call(obj,key)&&(newObj[key]=obj[key]);return newObj.default=obj,newObj}(_common);exports.sub=subtract,exports.mul=multiply,exports.div=divide,exports.dist=distance,exports.sqrDist=squaredDistance,exports.len=length,exports.sqrLen=squaredLength,exports.forEach=function(){var vec=create();return function(a,stride,offset,count,fn,arg){var i=void 0,l=void 0;for(stride||(stride=4),offset||(offset=0),l=count?Math.min(count*stride+offset,a.length):a.length,i=offset;i<l;i+=stride)vec[0]=a[i],vec[1]=a[i+1],vec[2]=a[i+2],vec[3]=a[i+3],fn(vec,vec,arg),a[i]=vec[0],a[i+1]=vec[1],a[i+2]=vec[2],a[i+3]=vec[3];return a}}()},function(module,exports,__webpack_require__){"use strict";module.exports={ACTIVE_ATTRIBUTES:35721,ACTIVE_ATTRIBUTE_MAX_LENGTH:35722,ACTIVE_TEXTURE:34016,ACTIVE_UNIFORMS:35718,ACTIVE_UNIFORM_MAX_LENGTH:35719,ALIASED_LINE_WIDTH_RANGE:33902,ALIASED_POINT_SIZE_RANGE:33901,ALPHA:6406,ALPHA_BITS:3413,ALWAYS:519,ARRAY_BUFFER:34962,ARRAY_BUFFER_BINDING:34964,ATTACHED_SHADERS:35717,BACK:1029,BLEND:3042,BLEND_COLOR:32773,BLEND_DST_ALPHA:32970,BLEND_DST_RGB:32968,BLEND_EQUATION:32777,BLEND_EQUATION_ALPHA:34877,BLEND_EQUATION_RGB:32777,BLEND_SRC_ALPHA:32971,BLEND_SRC_RGB:32969,BLUE_BITS:3412,BOOL:35670,BOOL_VEC2:35671,BOOL_VEC3:35672,BOOL_VEC4:35673,BROWSER_DEFAULT_WEBGL:37444,BUFFER_SIZE:34660,BUFFER_USAGE:34661,BYTE:5120,CCW:2305,CLAMP_TO_EDGE:33071,COLOR_ATTACHMENT0:36064,COLOR_BUFFER_BIT:16384,COLOR_CLEAR_VALUE:3106,COLOR_WRITEMASK:3107,COMPILE_STATUS:35713,COMPRESSED_TEXTURE_FORMATS:34467,CONSTANT_ALPHA:32771,CONSTANT_COLOR:32769,CONTEXT_LOST_WEBGL:37442,CULL_FACE:2884,CULL_FACE_MODE:2885,CURRENT_PROGRAM:35725,CURRENT_VERTEX_ATTRIB:34342,CW:2304,DECR:7683,DECR_WRAP:34056,DELETE_STATUS:35712,DEPTH_ATTACHMENT:36096,DEPTH_BITS:3414,DEPTH_BUFFER_BIT:256,DEPTH_CLEAR_VALUE:2931,DEPTH_COMPONENT:6402,RED:6403,DEPTH_COMPONENT16:33189,DEPTH_FUNC:2932,DEPTH_RANGE:2928,DEPTH_STENCIL:34041,DEPTH_STENCIL_ATTACHMENT:33306,DEPTH_TEST:2929,DEPTH_WRITEMASK:2930,DITHER:3024,DONT_CARE:4352,DST_ALPHA:772,DST_COLOR:774,DYNAMIC_DRAW:35048,ELEMENT_ARRAY_BUFFER:34963,ELEMENT_ARRAY_BUFFER_BINDING:34965,EQUAL:514,FASTEST:4353,FLOAT:5126,FLOAT_MAT2:35674,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,FRAGMENT_SHADER:35632,FRAMEBUFFER:36160,FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:36049,FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:36048,FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:36051,FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:36050,FRAMEBUFFER_BINDING:36006,FRAMEBUFFER_COMPLETE:36053,FRAMEBUFFER_INCOMPLETE_ATTACHMENT:36054,FRAMEBUFFER_INCOMPLETE_DIMENSIONS:36057,FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:36055,FRAMEBUFFER_UNSUPPORTED:36061,FRONT:1028,FRONT_AND_BACK:1032,FRONT_FACE:2886,FUNC_ADD:32774,FUNC_REVERSE_SUBTRACT:32779,FUNC_SUBTRACT:32778,GENERATE_MIPMAP_HINT:33170,GEQUAL:518,GREATER:516,GREEN_BITS:3411,HIGH_FLOAT:36338,HIGH_INT:36341,INCR:7682,INCR_WRAP:34055,INFO_LOG_LENGTH:35716,INT:5124,INT_VEC2:35667,INT_VEC3:35668,INT_VEC4:35669,INVALID_ENUM:1280,INVALID_FRAMEBUFFER_OPERATION:1286,INVALID_OPERATION:1282,INVALID_VALUE:1281,INVERT:5386,KEEP:7680,LEQUAL:515,LESS:513,LINEAR:9729,LINEAR_MIPMAP_LINEAR:9987,LINEAR_MIPMAP_NEAREST:9985,LINES:1,LINE_LOOP:2,LINE_STRIP:3,LINE_WIDTH:2849,LINK_STATUS:35714,LOW_FLOAT:36336,LOW_INT:36339,LUMINANCE:6409,LUMINANCE_ALPHA:6410,MAX_COMBINED_TEXTURE_IMAGE_UNITS:35661,MAX_CUBE_MAP_TEXTURE_SIZE:34076,MAX_FRAGMENT_UNIFORM_VECTORS:36349,MAX_RENDERBUFFER_SIZE:34024,MAX_TEXTURE_IMAGE_UNITS:34930,MAX_TEXTURE_SIZE:3379,MAX_VARYING_VECTORS:36348,MAX_VERTEX_ATTRIBS:34921,MAX_VERTEX_TEXTURE_IMAGE_UNITS:35660,MAX_VERTEX_UNIFORM_VECTORS:36347,MAX_VIEWPORT_DIMS:3386,MEDIUM_FLOAT:36337,MEDIUM_INT:36340,MIRRORED_REPEAT:33648,NEAREST:9728,NEAREST_MIPMAP_LINEAR:9986,NEAREST_MIPMAP_NEAREST:9984,NEVER:512,NICEST:4354,NONE:0,NOTEQUAL:517,NO_ERROR:0,NUM_COMPRESSED_TEXTURE_FORMATS:34466,ONE:1,ONE_MINUS_CONSTANT_ALPHA:32772,ONE_MINUS_CONSTANT_COLOR:32770,ONE_MINUS_DST_ALPHA:773,ONE_MINUS_DST_COLOR:775,ONE_MINUS_SRC_ALPHA:771,ONE_MINUS_SRC_COLOR:769,OUT_OF_MEMORY:1285,PACK_ALIGNMENT:3333,POINTS:0,POLYGON_OFFSET_FACTOR:32824,POLYGON_OFFSET_FILL:32823,POLYGON_OFFSET_UNITS:10752,RED_BITS:3410,RENDERBUFFER:36161,RENDERBUFFER_ALPHA_SIZE:36179,RENDERBUFFER_BINDING:36007,RENDERBUFFER_BLUE_SIZE:36178,RENDERBUFFER_DEPTH_SIZE:36180,RENDERBUFFER_GREEN_SIZE:36177,RENDERBUFFER_HEIGHT:36163,RENDERBUFFER_INTERNAL_FORMAT:36164,RENDERBUFFER_RED_SIZE:36176,RENDERBUFFER_STENCIL_SIZE:36181,RENDERBUFFER_WIDTH:36162,RENDERER:7937,REPEAT:10497,REPLACE:7681,RGB:6407,RGB5_A1:32855,RGB565:36194,RGBA:6408,RGBA4:32854,SAMPLER_2D:35678,SAMPLER_CUBE:35680,SAMPLES:32937,SAMPLE_ALPHA_TO_COVERAGE:32926,SAMPLE_BUFFERS:32936,SAMPLE_COVERAGE:32928,SAMPLE_COVERAGE_INVERT:32939,SAMPLE_COVERAGE_VALUE:32938,SCISSOR_BOX:3088,SCISSOR_TEST:3089,SHADER_COMPILER:36346,SHADER_SOURCE_LENGTH:35720,SHADER_TYPE:35663,SHADING_LANGUAGE_VERSION:35724,SHORT:5122,SRC_ALPHA:770,SRC_ALPHA_SATURATE:776,SRC_COLOR:768,STATIC_DRAW:35044,STENCIL_ATTACHMENT:36128,STENCIL_BACK_FAIL:34817,STENCIL_BACK_FUNC:34816,STENCIL_BACK_PASS_DEPTH_FAIL:34818,STENCIL_BACK_PASS_DEPTH_PASS:34819,STENCIL_BACK_REF:36003,STENCIL_BACK_VALUE_MASK:36004,STENCIL_BACK_WRITEMASK:36005,STENCIL_BITS:3415,STENCIL_BUFFER_BIT:1024,STENCIL_CLEAR_VALUE:2961,STENCIL_FAIL:2964,STENCIL_FUNC:2962,STENCIL_INDEX:6401,STENCIL_INDEX8:36168,STENCIL_PASS_DEPTH_FAIL:2965,STENCIL_PASS_DEPTH_PASS:2966,STENCIL_REF:2967,STENCIL_TEST:2960,STENCIL_VALUE_MASK:2963,STENCIL_WRITEMASK:2968,STREAM_DRAW:35040,SUBPIXEL_BITS:3408,TEXTURE:5890,TEXTURE0:33984,TEXTURE1:33985,TEXTURE2:33986,TEXTURE3:33987,TEXTURE4:33988,TEXTURE5:33989,TEXTURE6:33990,TEXTURE7:33991,TEXTURE8:33992,TEXTURE9:33993,TEXTURE10:33994,TEXTURE11:33995,TEXTURE12:33996,TEXTURE13:33997,TEXTURE14:33998,TEXTURE15:33999,TEXTURE16:34e3,TEXTURE17:34001,TEXTURE18:34002,TEXTURE19:34003,TEXTURE20:34004,TEXTURE21:34005,TEXTURE22:34006,TEXTURE23:34007,TEXTURE24:34008,TEXTURE25:34009,TEXTURE26:34010,TEXTURE27:34011,TEXTURE28:34012,TEXTURE29:34013,TEXTURE30:34014,TEXTURE31:34015,TEXTURE_2D:3553,TEXTURE_BINDING_2D:32873,TEXTURE_BINDING_CUBE_MAP:34068,TEXTURE_CUBE_MAP:34067,TEXTURE_CUBE_MAP_NEGATIVE_X:34070,TEXTURE_CUBE_MAP_NEGATIVE_Y:34072,TEXTURE_CUBE_MAP_NEGATIVE_Z:34074,TEXTURE_CUBE_MAP_POSITIVE_X:34069,TEXTURE_CUBE_MAP_POSITIVE_Y:34071,TEXTURE_CUBE_MAP_POSITIVE_Z:34073,TEXTURE_MAG_FILTER:10240,TEXTURE_MIN_FILTER:10241,TEXTURE_WRAP_S:10242,TEXTURE_WRAP_T:10243,TRIANGLES:4,TRIANGLE_FAN:6,TRIANGLE_STRIP:5,UNPACK_ALIGNMENT:3317,UNPACK_COLORSPACE_CONVERSION_WEBGL:37443,UNPACK_FLIP_Y_WEBGL:37440,UNPACK_PREMULTIPLY_ALPHA_WEBGL:37441,UNSIGNED_BYTE:5121,UNSIGNED_INT:5125,UNSIGNED_SHORT:5123,UNSIGNED_SHORT_4_4_4_4:32819,UNSIGNED_SHORT_5_5_5_1:32820,UNSIGNED_SHORT_5_6_5:33635,VALIDATE_STATUS:35715,VENDOR:7936,VERSION:7938,VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:34975,VERTEX_ATTRIB_ARRAY_ENABLED:34338,VERTEX_ATTRIB_ARRAY_NORMALIZED:34922,VERTEX_ATTRIB_ARRAY_POINTER:34373,VERTEX_ATTRIB_ARRAY_SIZE:34339,VERTEX_ATTRIB_ARRAY_STRIDE:34340,VERTEX_ATTRIB_ARRAY_TYPE:34341,VERTEX_SHADER:35633,VIEWPORT:2978,ZERO:0,R8:33321}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(gl,shaderProgram,name){return void 0===shaderProgram.cacheAttribLoc&&(shaderProgram.cacheAttribLoc={}),void 0===shaderProgram.cacheAttribLoc[name]&&(shaderProgram.cacheAttribLoc[name]=gl.getAttribLocation(shaderProgram,name)),shaderProgram.cacheAttribLoc[name]}},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function isPowerOfTwo(x){return 0!==x&&!(x&x-1)}function isSourcePowerOfTwo(obj){var w=obj.width||obj.videoWidth,h=obj.height||obj.videoHeight;return!(!w||!h)&&(isPowerOfTwo(w)&&isPowerOfTwo(h))}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_WebglNumber=__webpack_require__(8),gl=(_interopRequireDefault(_WebglNumber),void 0),GLTexture=function(){function GLTexture(mSource){var isTexture=arguments.length>1&&void 0!==arguments[1]&&arguments[1],mParameters=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(_classCallCheck(this,GLTexture),gl=_GLTool2.default.gl,isTexture)this._texture=mSource;else{this._mSource=mSource,this._texture=gl.createTexture(),this._isVideo="VIDEO"===mSource.tagName,this._premultiplyAlpha=!0,this._magFilter=mParameters.magFilter||gl.LINEAR,this._minFilter=mParameters.minFilter||gl.NEAREST_MIPMAP_LINEAR,this._wrapS=mParameters.wrapS||gl.MIRRORED_REPEAT,this._wrapT=mParameters.wrapT||gl.MIRRORED_REPEAT;mSource.width||mSource.videoWidth?isSourcePowerOfTwo(mSource)||(this._wrapS=this._wrapT=gl.CLAMP_TO_EDGE,this._minFilter===gl.NEAREST_MIPMAP_LINEAR&&(this._minFilter=gl.LINEAR)):(this._wrapS=this._wrapT=gl.CLAMP_TO_EDGE,this._minFilter===gl.NEAREST_MIPMAP_LINEAR&&(this._minFilter=gl.LINEAR)),gl.bindTexture(gl.TEXTURE_2D,this._texture),gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,!0),mSource.exposure?gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,mSource.shape[0],mSource.shape[1],0,gl.RGBA,gl.FLOAT,mSource.data):gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,mSource),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,this._magFilter),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,this._minFilter),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,this._wrapS),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,this._wrapT);var ext=_GLTool2.default.getExtension("EXT_texture_filter_anisotropic");if(ext){var max=gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);gl.texParameterf(gl.TEXTURE_2D,ext.TEXTURE_MAX_ANISOTROPY_EXT,max)}this._canGenerateMipmap()&&gl.generateMipmap(gl.TEXTURE_2D),gl.bindTexture(gl.TEXTURE_2D,null)}}return _createClass(GLTexture,[{key:"generateMipmap",value:function(){this._canGenerateMipmap()&&(gl.bindTexture(gl.TEXTURE_2D,this._texture),gl.generateMipmap(gl.TEXTURE_2D),gl.bindTexture(gl.TEXTURE_2D,null))}},{key:"updateTexture",value:function(mSource){mSource&&(this._mSource=mSource),gl.bindTexture(gl.TEXTURE_2D,this._texture),gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,!0),gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,this._mSource),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,this._magFilter),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,this._minFilter),this._canGenerateMipmap()&&gl.generateMipmap(gl.TEXTURE_2D),gl.bindTexture(gl.TEXTURE_2D,null)}},{key:"bind",value:function(index){void 0===index&&(index=0),_GLTool2.default.shader&&(gl.activeTexture(gl.TEXTURE0+index),gl.bindTexture(gl.TEXTURE_2D,this._texture),this._bindIndex=index)}},{key:"_canGenerateMipmap",value:function(){return this._minFilter===gl.LINEAR_MIPMAP_NEAREST||this._minFilter===gl.NEAREST_MIPMAP_LINEAR||this._minFilter===gl.LINEAR_MIPMAP_LINEAR||this._minFilter===gl.NEAREST_MIPMAP_NEAREST}},{key:"minFilter",set:function(mValue){if(mValue!==gl.LINEAR&&mValue!==gl.NEAREST&&mValue!==gl.NEAREST_MIPMAP_LINEAR&&mValue!==gl.NEAREST_MIPMAP_LINEAR&&mValue!==gl.LINEAR_MIPMAP_LINEAR&&mValue!==gl.NEAREST_MIPMAP_NEAREST)return this;this._minFilter=mValue,gl.bindTexture(gl.TEXTURE_2D,this._texture),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,this._minFilter),gl.bindTexture(gl.TEXTURE_2D,null)},get:function(){return this._minFilter}},{key:"magFilter",set:function(mValue){if(mValue!==gl.LINEAR&&mValue!==gl.NEAREST)return this;this._magFilter=mValue,gl.bindTexture(gl.TEXTURE_2D,this._texture),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,this._magFilter),gl.bindTexture(gl.TEXTURE_2D,null)},get:function(){return this._magFilter}},{key:"wrapS",set:function(mValue){if(mValue!==gl.CLAMP_TO_EDGE&&mValue!==gl.REPEAT&&mValue!==gl.MIRRORED_REPEAT)return this;this._wrapS=mValue,gl.bindTexture(gl.TEXTURE_2D,this._texture),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,this._wrapS),gl.bindTexture(gl.TEXTURE_2D,null)},get:function(){return this._wrapS}},{key:"wrapT",set:function(mValue){if(mValue!==gl.CLAMP_TO_EDGE&&mValue!==gl.REPEAT&&mValue!==gl.MIRRORED_REPEAT)return this;this._wrapT=mValue,gl.bindTexture(gl.TEXTURE_2D,this._texture),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,this._wrapT),gl.bindTexture(gl.TEXTURE_2D,null)},get:function(){return this._wrapT}},{key:"premultiplyAlpha",set:function(mValue){this._premultiplyAlpha=mValue,gl.bindTexture(gl.TEXTURE_2D,this._texture),console.log("premultiplyAlpha:",mValue),gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this._premultiplyAlpha),gl.bindTexture(gl.TEXTURE_2D,null)},get:function(){return this._premultiplyAlpha}},{key:"texture",get:function(){return this._texture}}]),GLTexture}(),_whiteTexture=void 0,_greyTexture=void 0,_blackTexture=void 0;GLTexture.whiteTexture=function(){if(void 0===_whiteTexture){var canvas=document.createElement("canvas");canvas.width=canvas.height=4;var ctx=canvas.getContext("2d");ctx.fillStyle="#fff",ctx.fillRect(0,0,4,4),_whiteTexture=new GLTexture(canvas)}return _whiteTexture},GLTexture.greyTexture=function(){if(void 0===_greyTexture){var canvas=document.createElement("canvas");canvas.width=canvas.height=4;var ctx=canvas.getContext("2d");ctx.fillStyle="rgb(127, 127, 127)",ctx.fillRect(0,0,4,4),_greyTexture=new GLTexture(canvas)}return _greyTexture},GLTexture.blackTexture=function(){if(void 0===_blackTexture){var canvas=document.createElement("canvas");canvas.width=canvas.height=4;var ctx=canvas.getContext("2d");ctx.fillStyle="rgb(127, 127, 127)",ctx.fillRect(0,0,4,4),_blackTexture=new GLTexture(canvas)}return _blackTexture},exports.default=GLTexture},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function isPowerOfTwo(x){return 0!==x&&!(x&x-1)}function getSourceType(mSource){var type=_GLTool2.default.UNSIGNED_BYTE;return mSource instanceof Array?type=_GLTool2.default.UNSIGNED_BYTE:mSource instanceof Uint8Array?type=_GLTool2.default.UNSIGNED_BYTE:mSource instanceof Float32Array?type=_GLTool2.default.FLOAT:mSource instanceof HTMLImageElement?type="image":mSource instanceof HTMLCanvasElement?type="canvas":mSource instanceof HTMLVideoElement&&(type="video"),type}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_getTextureParameters=__webpack_require__(54),_getTextureParameters2=_interopRequireDefault(_getTextureParameters),_WebglNumber=__webpack_require__(8),_WebglNumber2=_interopRequireDefault(_WebglNumber),_GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_scheduling=__webpack_require__(6),_scheduling2=_interopRequireDefault(_scheduling),gl=void 0,GLTexture=function(){function GLTexture(mSource){var mParam=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_this=this,mWidth=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,mHeight=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;_classCallCheck(this,GLTexture),gl=_GLTool2.default.gl,this._source=mSource,this._getDimension(mSource,mWidth,mHeight),this._sourceType=mParam.type||getSourceType(mSource),this._checkSource(),this._texelType=this._getTexelType(),this._isTextureReady=!0,this._params=(0,_getTextureParameters2.default)(mParam,mSource,this._width,this._height),this._checkMipmap(),this._checkWrapping(),this._texture=gl.createTexture(),"video"===this._sourceType?(this._isTextureReady=!1,_scheduling2.default.addEF(function(){return _this._loop()})):this._uploadTexture()}return _createClass(GLTexture,[{key:"_loop",value:function(){4==this._source.readyState&&(this._isTextureReady=!0,this._uploadTexture())}},{key:"_uploadTexture",value:function(){if(gl.bindTexture(gl.TEXTURE_2D,this._texture),gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,!0),this._isSourceHtmlElement()?gl.texImage2D(gl.TEXTURE_2D,0,this._params.internalFormat,this._params.format,this._texelType,this._source):gl.texImage2D(gl.TEXTURE_2D,0,this._params.internalFormat,this._width,this._height,0,this._params.format,this._texelType,this._source),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,this._params.magFilter),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,this._params.minFilter),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,this._params.wrapS),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,this._params.wrapT),gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this._params.premultiplyAlpha),this._params.anisotropy>0){var ext=_GLTool2.default.getExtension("EXT_texture_filter_anisotropic");if(ext){var max=gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT),level=Math.min(max,this._params.anisotropy);gl.texParameterf(gl.TEXTURE_2D,ext.TEXTURE_MAX_ANISOTROPY_EXT,level)}}this._generateMipmap&&gl.generateMipmap(gl.TEXTURE_2D),gl.bindTexture(gl.TEXTURE_2D,null)}},{key:"bind",value:function(index){void 0===index&&(index=0),_GLTool2.default.shader&&(gl.activeTexture(gl.TEXTURE0+index),this._isTextureReady?gl.bindTexture(gl.TEXTURE_2D,this._texture):gl.bindTexture(gl.TEXTURE_2D,GLTexture.blackTexture().texture),this._bindIndex=index)}},{key:"updateTexture",value:function(mSource){this._source=mSource,this._checkSource(),this._uploadTexture()}},{key:"generateMipmap",value:function(){this._generateMipmap&&(gl.bindTexture(gl.TEXTURE_2D,this._texture),gl.generateMipmap(gl.TEXTURE_2D),gl.bindTexture(gl.TEXTURE_2D,null))}},{key:"showParameters",value:function(){console.log("Source type : ",_WebglNumber2.default[this._sourceType]||this._sourceType),console.log("Texel type:",_WebglNumber2.default[this.texelType]),console.log("Dimension :",this._width,this._height);for(var s in this._params)console.log(s,_WebglNumber2.default[this._params[s]]||this._params[s]);console.log("Mipmapping :",this._generateMipmap)}},{key:"_getDimension",value:function(mSource,mWidth,mHeight){mSource?(this._width=mSource.width||mSource.videoWidth,this._height=mSource.height||mSource.videoWidth,this._width=this._width||mWidth,this._height=this._height||mHeight,this._width&&this._height||(this._width=this._height=Math.sqrt(mSource.length/4))):(this._width=mWidth,this._height=mHeight)}},{key:"_checkSource",value:function(){this._source&&(this._sourceType===_GLTool2.default.UNSIGNED_BYTE?this._source instanceof Uint8Array||(this._source=new Uint8Array(this._source)):this._sourceType===_GLTool2.default.FLOAT&&(this._source instanceof Float32Array||(this._source=new Float32Array(this._source))))}},{key:"_getTexelType",value:function(){return this._isSourceHtmlElement()?_GLTool2.default.UNSIGNED_BYTE:_GLTool2.default[_WebglNumber2.default[this._sourceType]]||this._sourceType}},{key:"_checkMipmap",value:function(){this._generateMipmap=this._params.mipmap,isPowerOfTwo(this._width)&&isPowerOfTwo(this._height)||(this._generateMipmap=!1),-1==_WebglNumber2.default[this._params.minFilter].indexOf("MIPMAP")&&(this._generateMipmap=!1)}},{key:"_checkWrapping",value:function(){this._generateMipmap||(this._params.wrapS=_GLTool2.default.CLAMP_TO_EDGE,this._params.wrapT=_GLTool2.default.CLAMP_TO_EDGE)}},{key:"_isSourceHtmlElement",value:function(){return"image"===this._sourceType||"video"===this._sourceType||"canvas"===this._sourceType}},{key:"minFilter",get:function(){return this._params.minFilter},set:function(mValue){this._params.minFilter=mValue,this._checkMipmap(),gl.bindTexture(gl.TEXTURE_2D,this._texture),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,this._params.minFilter),gl.bindTexture(gl.TEXTURE_2D,null),this.generateMipmap()}},{key:"magFilter",get:function(){return this._params.minFilter},set:function(mValue){this._params.magFilter=mValue,gl.bindTexture(gl.TEXTURE_2D,this._texture),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,this._params.magFilter),gl.bindTexture(gl.TEXTURE_2D,null)}},{key:"wrapS",get:function(){return this._params.wrapS},set:function(mValue){this._params.wrapS=mValue,this._checkWrapping(),gl.bindTexture(gl.TEXTURE_2D,this._texture),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,this._params.wrapS),gl.bindTexture(gl.TEXTURE_2D,null)}},{key:"wrapT",get:function(){return this._params.wrapT},set:function(mValue){this._params.wrapT=mValue,this._checkWrapping(),gl.bindTexture(gl.TEXTURE_2D,this._texture),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,this._params.wrapT),gl.bindTexture(gl.TEXTURE_2D,null)}},{key:"texelType",get:function(){return this._texelType}},{key:"width",get:function(){return this._width}},{key:"height",get:function(){return this._height}},{key:"texture",get:function(){return this._texture}},{key:"isTextureReady",get:function(){return this._isTextureReady}}]),GLTexture}(),_whiteTexture=void 0,_greyTexture=void 0,_blackTexture=void 0;GLTexture.whiteTexture=function(){if(void 0===_whiteTexture){var canvas=document.createElement("canvas");canvas.width=canvas.height=2;var ctx=canvas.getContext("2d");ctx.fillStyle="#fff",ctx.fillRect(0,0,2,2),_whiteTexture=new GLTexture(canvas)}return _whiteTexture},GLTexture.greyTexture=function(){if(void 0===_greyTexture){var canvas=document.createElement("canvas");canvas.width=canvas.height=2;var ctx=canvas.getContext("2d");ctx.fillStyle="rgb(127, 127, 127)",ctx.fillRect(0,0,2,2),_greyTexture=new GLTexture(canvas)}return _greyTexture},GLTexture.blackTexture=function(){if(void 0===_blackTexture){var canvas=document.createElement("canvas");canvas.width=canvas.height=2;var ctx=canvas.getContext("2d");ctx.fillStyle="rgb(0, 0, 0)",ctx.fillRect(0,0,2,2),_blackTexture=new GLTexture(canvas)}return _blackTexture},exports.default=GLTexture},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_parseDds=__webpack_require__(55),_parseDds2=_interopRequireDefault(_parseDds),gl=void 0,GLCubeTexture=function(){function GLCubeTexture(mSource){var mParameters=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},isCubeTexture=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(_classCallCheck(this,GLCubeTexture),gl=_GLTool2.default.gl,isCubeTexture)return void(this.texture=mSource);var hasMipmaps=mSource.length>6;mSource[0].mipmapCount&&(hasMipmaps=mSource[0].mipmapCount>1),this.texture=gl.createTexture(),this.magFilter=mParameters.magFilter||gl.LINEAR,this.minFilter=mParameters.minFilter||gl.LINEAR_MIPMAP_LINEAR,this.wrapS=mParameters.wrapS||gl.CLAMP_TO_EDGE,this.wrapT=mParameters.wrapT||gl.CLAMP_TO_EDGE,hasMipmaps||this.minFilter!=gl.LINEAR_MIPMAP_LINEAR||(this.minFilter=gl.LINEAR),gl.bindTexture(gl.TEXTURE_CUBE_MAP,this.texture);var targets=[gl.TEXTURE_CUBE_MAP_POSITIVE_X,gl.TEXTURE_CUBE_MAP_NEGATIVE_X,gl.TEXTURE_CUBE_MAP_POSITIVE_Y,gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,gl.TEXTURE_CUBE_MAP_POSITIVE_Z,gl.TEXTURE_CUBE_MAP_NEGATIVE_Z],numLevels=1,index=0;if(numLevels=mSource.length/6,this.numLevels=numLevels,hasMipmaps)for(var j=0;j<6;j++)for(var i=0;i<numLevels;i++)gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,!1),index=j*numLevels+i,mSource[index].shape?gl.texImage2D(targets[j],i,gl.RGBA,mSource[index].shape[0],mSource[index].shape[1],0,gl.RGBA,gl.FLOAT,mSource[index].data):gl.texImage2D(targets[j],i,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,mSource[index]),gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_WRAP_S,this.wrapS),gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_WRAP_T,this.wrapT),gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_MAG_FILTER,this.magFilter),gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_MIN_FILTER,this.minFilter);else{for(var _index=0,_j=0;_j<6;_j++)_index=_j*numLevels,gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,!1),mSource[_index].shape?gl.texImage2D(targets[_j],0,gl.RGBA,mSource[_index].shape[0],mSource[_index].shape[1],0,gl.RGBA,gl.FLOAT,mSource[_index].data):gl.texImage2D(targets[_j],0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,mSource[_index]),gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_WRAP_S,this.wrapS),gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_WRAP_T,this.wrapT),gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_MAG_FILTER,this.magFilter),gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_MIN_FILTER,this.minFilter);gl.generateMipmap(gl.TEXTURE_CUBE_MAP)}gl.bindTexture(gl.TEXTURE_CUBE_MAP,null)}return _createClass(GLCubeTexture,[{key:"bind",value:function(){var index=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;_GLTool2.default.shader&&(gl.activeTexture(gl.TEXTURE0+index),gl.bindTexture(gl.TEXTURE_CUBE_MAP,this.texture),gl.uniform1i(_GLTool2.default.shader.uniformTextures[index],index),this._bindIndex=index)}},{key:"unbind",value:function(){gl.bindTexture(gl.TEXTURE_CUBE_MAP,null)}}]),GLCubeTexture}();GLCubeTexture.parseDDS=function(mArrayBuffer){var ddsInfos=(0,_parseDds2.default)(mArrayBuffer),flags=ddsInfos.flags,header=new Int32Array(mArrayBuffer,0,31),mipmapCount=1;131072&flags&&(mipmapCount=Math.max(1,header[7]));var sources=ddsInfos.images.map(function(img){return{data:new Float32Array(mArrayBuffer.slice(img.offset,img.offset+img.length)),shape:img.shape,mipmapCount:mipmapCount}});return new GLCubeTexture(sources)},exports.default=GLCubeTexture},function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),supportsCustomEvents=!0;try{document.createEvent("CustomEvent");null}catch(e){supportsCustomEvents=!1}var EventDispatcher=function(){function EventDispatcher(){_classCallCheck(this,EventDispatcher),this._eventListeners={}}return _createClass(EventDispatcher,[{key:"addEventListener",value:function(aEventType,aFunction){return null!==this._eventListeners&&void 0!==this._eventListeners||(this._eventListeners={}),this._eventListeners[aEventType]||(this._eventListeners[aEventType]=[]),this._eventListeners[aEventType].push(aFunction),this}},{key:"on",value:function(aEventType,aFunction){return this.addEventListener(aEventType,aFunction)}},{key:"removeEventListener",value:function(aEventType,aFunction){null!==this._eventListeners&&void 0!==this._eventListeners||(this._eventListeners={});var currentArray=this._eventListeners[aEventType];if(void 0===currentArray)return this;for(var currentArrayLength=currentArray.length,i=0;i<currentArrayLength;i++)currentArray[i]===aFunction&&(currentArray.splice(i,1),i--,currentArrayLength--);return this}},{key:"off",value:function(aEventType,aFunction){return this.removeEventListener(aEventType,aFunction)}},{key:"dispatchEvent",value:function(aEvent){null!==this._eventListeners&&void 0!==this._eventListeners||(this._eventListeners={});var eventType=aEvent.type;try{null===aEvent.target&&(aEvent.target=this),aEvent.currentTarget=this}catch(theError){var newEvent={type:eventType,detail:aEvent.detail,dispatcher:this};return this.dispatchEvent(newEvent)}var currentEventListeners=this._eventListeners[eventType];if(null!==currentEventListeners&&void 0!==currentEventListeners)for(var currentArray=this._copyArray(currentEventListeners),currentArrayLength=currentArray.length,i=0;i<currentArrayLength;i++){var currentFunction=currentArray[i];currentFunction.call(this,aEvent)}return this}},{key:"dispatchCustomEvent",value:function(aEventType,aDetail){var newEvent=void 0;return supportsCustomEvents?(newEvent=document.createEvent("CustomEvent"),newEvent.dispatcher=this,newEvent.initCustomEvent(aEventType,!1,!1,aDetail)):newEvent={type:aEventType,detail:aDetail,dispatcher:this},this.dispatchEvent(newEvent)}},{key:"trigger",value:function(aEventType,aDetail){return this.dispatchCustomEvent(aEventType,aDetail)}},{key:"_destroy",value:function(){if(null!==this._eventListeners){for(var objectName in this._eventListeners)if(this._eventListeners.hasOwnProperty(objectName)){for(var currentArray=this._eventListeners[objectName],currentArrayLength=currentArray.length,i=0;i<currentArrayLength;i++)currentArray[i]=null;delete this._eventListeners[objectName]}this._eventListeners=null}}},{key:"_copyArray",value:function(aArray){for(var currentArray=new Array(aArray.length),currentArrayLength=currentArray.length,i=0;i<currentArrayLength;i++)currentArray[i]=aArray[i];return currentArray}}]),EventDispatcher}();exports.default=EventDispatcher},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_EaseNumber=__webpack_require__(13),_EaseNumber2=_interopRequireDefault(_EaseNumber),_scheduling=__webpack_require__(6),_scheduling2=_interopRequireDefault(_scheduling),_glMatrix=__webpack_require__(1),getMouse=function(mEvent,mTarget){var o=mTarget||{};return mEvent.touches?(o.x=mEvent.touches[0].pageX,o.y=mEvent.touches[0].pageY):(o.x=mEvent.clientX,o.y=mEvent.clientY),o},OrbitalControl=function(){function OrbitalControl(mTarget){var _this=this,mListenerTarget=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window,mRadius=arguments.length>2&&void 0!==arguments[2]?arguments[2]:500;_classCallCheck(this,OrbitalControl),this._target=mTarget,this._listenerTarget=mListenerTarget,this._mouse={},this._preMouse={},this.center=_glMatrix.vec3.create(),this._up=_glMatrix.vec3.fromValues(0,1,0),this.radius=new _EaseNumber2.default(mRadius),this.position=_glMatrix.vec3.fromValues(0,0,this.radius.value),this.positionOffset=_glMatrix.vec3.create(),this._rx=new _EaseNumber2.default(0),this._rx.limit(-Math.PI/2,Math.PI/2),this._ry=new _EaseNumber2.default(0),this._preRX=0,this._preRY=0,this._isLockZoom=!1,this._isLockRotation=!1,this._isInvert=!1,this.sensitivity=1,this._wheelBind=function(e){return _this._onWheel(e)},this._downBind=function(e){return _this._onDown(e)},this._moveBind=function(e){return _this._onMove(e)},this._upBind=function(){return _this._onUp()},this.connect(),_scheduling2.default.addEF(function(){return _this._loop()})}return _createClass(OrbitalControl,[{key:"connect",value:function(){this.disconnect(),this._listenerTarget.addEventListener("mousewheel",this._wheelBind),this._listenerTarget.addEventListener("DOMMouseScroll",this._wheelBind),this._listenerTarget.addEventListener("mousedown",this._downBind),this._listenerTarget.addEventListener("touchstart",this._downBind),this._listenerTarget.addEventListener("mousemove",this._moveBind),this._listenerTarget.addEventListener("touchmove",this._moveBind),window.addEventListener("touchend",this._upBind),window.addEventListener("mouseup",this._upBind)}},{key:"disconnect",value:function(){this._listenerTarget.removeEventListener("mousewheel",this._wheelBind),this._listenerTarget.removeEventListener("DOMMouseScroll",this._wheelBind),this._listenerTarget.removeEventListener("mousedown",this._downBind),this._listenerTarget.removeEventListener("touchstart",this._downBind),this._listenerTarget.removeEventListener("mousemove",this._moveBind),this._listenerTarget.removeEventListener("touchmove",this._moveBind),window.removeEventListener("touchend",this._upBind),window.removeEventListener("mouseup",this._upBind)}},{key:"lock",value:function(){var mValue=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this._isLockZoom=mValue,this._isLockRotation=mValue,this._isMouseDown=!1}},{key:"lockZoom",value:function(){var mValue=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this._isLockZoom=mValue}},{key:"lockRotation",value:function(){var mValue=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this._isLockRotation=mValue}},{key:"inverseControl",value:function(){var isInvert=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this._isInvert=isInvert}},{key:"_onDown",value:function(mEvent){this._isLockRotation||(this._isMouseDown=!0,getMouse(mEvent,this._mouse),getMouse(mEvent,this._preMouse),this._preRX=this._rx.targetValue,this._preRY=this._ry.targetValue)}},{key:"_onMove",value:function(mEvent){if(!this._isLockRotation&&(getMouse(mEvent,this._mouse),mEvent.touches&&mEvent.preventDefault(),this._isMouseDown)){var diffX=-(this._mouse.x-this._preMouse.x);this._isInvert&&(diffX*=-1),this._ry.value=this._preRY-.01*diffX*this.sensitivity;var diffY=-(this._mouse.y-this._preMouse.y);this._isInvert&&(diffY*=-1),this._rx.value=this._preRX-.01*diffY*this.sensitivity}}},{key:"_onUp",value:function(){this._isLockRotation||(this._isMouseDown=!1)}},{key:"_onWheel",value:function(mEvent){if(!this._isLockZoom){var w=mEvent.wheelDelta,d=mEvent.detail,value=0;value=d?w?w/d/40*d>0?1:-1:-d/3:w/120,this.radius.add(2*-value)}}},{key:"_loop",value:function(){this._updatePosition(),this._target&&this._updateCamera()}},{key:"_updatePosition",value:function(){this.position[1]=Math.sin(this._rx.value)*this.radius.value;var tr=Math.cos(this._rx.value)*this.radius.value;this.position[0]=Math.cos(this._ry.value+.5*Math.PI)*tr,this.position[2]=Math.sin(this._ry.value+.5*Math.PI)*tr,_glMatrix.vec3.add(this.position,this.position,this.positionOffset)}},{key:"_updateCamera",value:function(){this._target.lookAt(this.position,this.center,this._up)}},{key:"rx",get:function(){return this._rx}},{key:"ry",get:function(){return this._ry}}]),OrbitalControl}();exports.default=OrbitalControl},function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_Camera2=__webpack_require__(15),_Camera3=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(_Camera2),_glMatrix=__webpack_require__(1),CameraOrtho=function(_Camera){function CameraOrtho(){_classCallCheck(this,CameraOrtho);var _this=_possibleConstructorReturn(this,(CameraOrtho.__proto__||Object.getPrototypeOf(CameraOrtho)).call(this)),eye=_glMatrix.vec3.clone([0,0,15]),center=_glMatrix.vec3.create(),up=_glMatrix.vec3.clone([0,-1,0]);return _this.lookAt(eye,center,up),_this.ortho(1,-1,1,-1),_this}return _inherits(CameraOrtho,_Camera),_createClass(CameraOrtho,[{key:"setBoundary",value:function(left,right,top,bottom){var near=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.1,far=arguments.length>5&&void 0!==arguments[5]?arguments[5]:100;this.ortho(left,right,top,bottom,near,far)}},{key:"ortho",value:function(left,right,top,bottom){var near=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.1,far=arguments.length>5&&void 0!==arguments[5]?arguments[5]:100;this.left=left,this.right=right,this.top=top,this.bottom=bottom,mat4.ortho(this._projection,left,right,top,bottom,near,far)}}]),CameraOrtho}(_Camera3.default);exports.default=CameraOrtho},function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_glMatrix=__webpack_require__(1),Object3D=function(){function Object3D(){_classCallCheck(this,Object3D),this._needUpdate=!0,this._x=0,this._y=0,this._z=0,this._sx=1,this._sy=1,this._sz=1,this._rx=0,this._ry=0,this._rz=0,this._position=_glMatrix.vec3.create(),this._scale=_glMatrix.vec3.fromValues(1,1,1),this._rotation=_glMatrix.vec3.create(),this._matrix=_glMatrix.mat4.create(),this._matrixRotation=_glMatrix.mat4.create(),this._matrixScale=_glMatrix.mat4.create(),this._matrixTranslation=_glMatrix.mat4.create(),this._matrixQuaternion=_glMatrix.mat4.create(),this._quat=_glMatrix.quat.create()}return _createClass(Object3D,[{key:"_update",value:function(){_glMatrix.vec3.set(this._scale,this._sx,this._sy,this._sz),_glMatrix.vec3.set(this._rotation,this._rx,this._ry,this._rz),_glMatrix.vec3.set(this._position,this._x,this._y,this._z),_glMatrix.mat4.identity(this._matrixTranslation,this._matrixTranslation),_glMatrix.mat4.identity(this._matrixScale,this._matrixScale),_glMatrix.mat4.identity(this._matrixRotation,this._matrixRotation),_glMatrix.mat4.rotateX(this._matrixRotation,this._matrixRotation,this._rx),_glMatrix.mat4.rotateY(this._matrixRotation,this._matrixRotation,this._ry),_glMatrix.mat4.rotateZ(this._matrixRotation,this._matrixRotation,this._rz),_glMatrix.mat4.fromQuat(this._matrixQuaternion,this._quat),_glMatrix.mat4.mul(this._matrixRotation,this._matrixQuaternion,this._matrixRotation),_glMatrix.mat4.scale(this._matrixScale,this._matrixScale,this._scale),_glMatrix.mat4.translate(this._matrixTranslation,this._matrixTranslation,this._position),_glMatrix.mat4.mul(this._matrix,this._matrixTranslation,this._matrixRotation),_glMatrix.mat4.mul(this._matrix,this._matrix,this._matrixScale),this._needUpdate=!1}},{key:"setRotationFromQuaternion",value:function(mQuat){_glMatrix.quat.copy(this._quat,mQuat),this._needUpdate=!0}},{key:"matrix",get:function(){return this._needUpdate&&this._update(),this._matrix}},{key:"x",get:function(){return this._x},set:function(mValue){this._needUpdate=!0,this._x=mValue}},{key:"y",get:function(){return this._y},set:function(mValue){this._needUpdate=!0,this._y=mValue}},{key:"z",get:function(){return this._z},set:function(mValue){this._needUpdate=!0,this._z=mValue}},{key:"scaleX",get:function(){return this._sx},set:function(mValue){this._needUpdate=!0,this._sx=mValue}},{key:"scaleY",get:function(){return this._sy},set:function(mValue){this._needUpdate=!0,this._sy=mValue}},{key:"scaleZ",get:function(){return this._sz},set:function(mValue){this._needUpdate=!0,this._sz=mValue}},{key:"rotationX",get:function(){return this._rx},set:function(mValue){this._needUpdate=!0,this._rx=mValue}},{key:"rotationY",get:function(){return this._ry},set:function(mValue){this._needUpdate=!0,this._ry=mValue}},{key:"rotationZ",get:function(){return this._rz},set:function(mValue){this._needUpdate=!0,this._rz=mValue}}]),Object3D}();exports.default=Object3D},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}Object.defineProperty(exports,"__esModule",{value:!0});var _simpleColor=__webpack_require__(10),_simpleColor2=_interopRequireDefault(_simpleColor),_bigTriangle=__webpack_require__(18),_bigTriangle2=_interopRequireDefault(_bigTriangle),_general=__webpack_require__(33),_general2=_interopRequireDefault(_general),_copy=__webpack_require__(19),_copy2=_interopRequireDefault(_copy),_basic=__webpack_require__(11),_basic2=_interopRequireDefault(_basic),_skybox=__webpack_require__(34),_skybox2=_interopRequireDefault(_skybox),_skybox3=__webpack_require__(35),_skybox4=_interopRequireDefault(_skybox3),ShaderLibs={simpleColorFrag:_simpleColor2.default,bigTriangleVert:_bigTriangle2.default,generalVert:_general2.default,copyFrag:_copy2.default,basicVert:_basic2.default,skyboxVert:_skybox2.default,skyboxFrag:_skybox4.default};exports.default=ShaderLibs},function(module,exports){module.exports="// generalWithNormal.vert\n\n#define SHADER_NAME GENERAL_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nuniform vec3 position;\nuniform vec3 scale;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tvec3 pos      = aVertexPosition * scale;\n\tpos           += position;\n\tgl_Position   = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(pos, 1.0);\n\t\n\tvTextureCoord = aTextureCoord;\n\tvNormal       = normalize(uNormalMatrix * aNormal);\n}"},function(module,exports){module.exports="// basic.vert\n\n#define SHADER_NAME SKYBOX_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vVertex;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tmat4 matView = uViewMatrix;\n\tmatView[3][0] = 0.0;\n\tmatView[3][1] = 0.0;\n\tmatView[3][2] = 0.0;\n\t\n\tgl_Position = uProjectionMatrix * matView * uModelMatrix * vec4(aVertexPosition, 1.0);\n\tvTextureCoord = aTextureCoord;\n\t\n\tvVertex = aVertexPosition;\n\tvNormal = aNormal;\n}"},function(module,exports){module.exports="// basic.frag\n\n#define SHADER_NAME SKYBOX_FRAGMENT\n\nprecision mediump float;\n#define GLSLIFY 1\nuniform samplerCube texture;\nvarying vec2 vTextureCoord;\nvarying vec3 vVertex;\n\nvoid main(void) {\n    gl_FragColor = textureCube(texture, vVertex);\n}"},function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),PassMacro=function(){function PassMacro(){_classCallCheck(this,PassMacro),this._passes=[]}return _createClass(PassMacro,[{key:"addPass",value:function(pass){this._passes.push(pass)}},{key:"passes",get:function(){return this._passes}}]),PassMacro}();exports.default=PassMacro},function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _PassBlurBase2=__webpack_require__(38),_PassBlurBase3=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(_PassBlurBase2),PassVBlur=function(_PassBlurBase){function PassVBlur(){var mQuality=arguments.length>0&&void 0!==arguments[0]?arguments[0]:9,mWidth=arguments[1],mHeight=arguments[2],mParams=arguments[3];return _classCallCheck(this,PassVBlur),_possibleConstructorReturn(this,(PassVBlur.__proto__||Object.getPrototypeOf(PassVBlur)).call(this,mQuality,[0,1],mWidth,mHeight,mParams))}return _inherits(PassVBlur,_PassBlurBase),PassVBlur}(_PassBlurBase3.default);exports.default=PassVBlur},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_Pass2=__webpack_require__(9),_Pass3=_interopRequireDefault(_Pass2),fsBlur5=__webpack_require__(73),fsBlur9=__webpack_require__(74),fsBlur13=__webpack_require__(75),PassBlurBase=function(_Pass){function PassBlurBase(){var mQuality=arguments.length>0&&void 0!==arguments[0]?arguments[0]:9,mDirection=arguments[1],mWidth=arguments[2],mHeight=arguments[3],mParams=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};_classCallCheck(this,PassBlurBase);var fs=void 0;switch(mQuality){case 5:default:fs=fsBlur5;break;case 9:fs=fsBlur9;break;case 13:fs=fsBlur13}var _this=_possibleConstructorReturn(this,(PassBlurBase.__proto__||Object.getPrototypeOf(PassBlurBase)).call(this,fs,mWidth,mHeight,mParams));return _this.uniform("uDirection",mDirection),_this.uniform("uResolution",[_GLTool2.default.width,_GLTool2.default.height]),_this}return _inherits(PassBlurBase,_Pass),PassBlurBase}(_Pass3.default);exports.default=PassBlurBase},function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _PassBlurBase2=__webpack_require__(38),_PassBlurBase3=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(_PassBlurBase2),PassHBlur=function(_PassBlurBase){function PassHBlur(){var mQuality=arguments.length>0&&void 0!==arguments[0]?arguments[0]:9,mWidth=arguments[1],mHeight=arguments[2],mParams=arguments[3];return _classCallCheck(this,PassHBlur),_possibleConstructorReturn(this,(PassHBlur.__proto__||Object.getPrototypeOf(PassHBlur)).call(this,mQuality,[1,0],mWidth,mHeight,mParams))}return _inherits(PassHBlur,_PassBlurBase),PassHBlur}(_PassBlurBase3.default);exports.default=PassHBlur},function(module,exports){module.exports="// fxaa.frag\n\n#define SHADER_NAME FXAA\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uResolution;\n\n\nfloat FXAA_SUBPIX_SHIFT = 1.0/4.0;\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#define FXAA_SPAN_MAX     8.0\n\n\nvec4 applyFXAA(sampler2D tex) {\n    vec4 color;\n    vec2 fragCoord = gl_FragCoord.xy;\n    vec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * uResolution).xyz;\n    vec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * uResolution).xyz;\n    vec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * uResolution).xyz;\n    vec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * uResolution).xyz;\n    vec3 rgbM  = texture2D(tex, fragCoord  * uResolution).xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * uResolution;\n\n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * uResolution + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * uResolution + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * uResolution + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * uResolution + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, 1.0);\n    else\n        color = vec4(rgbB, 1.0);\n    return color;\n}\n\nvoid main(void) {\n \tvec4 color = applyFXAA(texture);\n    gl_FragColor = color;\n}"},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0}),exports.ShaderLibs=exports.View3D=exports.View=exports.Scene=exports.BatchFXAA=exports.BatchSky=exports.BatchSkybox=exports.BatchLine=exports.BatchDotsPlane=exports.BatchBall=exports.BatchAxis=exports.BatchCopy=exports.PassFxaa=exports.PassHBlur=exports.PassVBlur=exports.PassBlur=exports.PassMacro=exports.Pass=exports.EffectComposer=exports.ColladaParser=exports.HDRLoader=exports.ObjLoader=exports.BinaryLoader=exports.Object3D=exports.Ray=exports.CameraCube=exports.CameraPerspective=exports.CameraOrtho=exports.Camera=exports.TouchDetector=exports.QuatRotation=exports.WebglNumber=exports.OrbitalControl=exports.TweenNumber=exports.EaseNumber=exports.EventDispatcher=exports.Scheduler=exports.TransformFeedbackObject=exports.MultisampleFrameBuffer=exports.CubeFrameBuffer=exports.FrameBuffer=exports.Batch=exports.Geom=exports.Mesh=exports.GLCubeTexture=exports.GLTextureOld=exports.GLTexture=exports.GLShader=exports.GL=void 0;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_glMatrix=__webpack_require__(1),GLM=function(obj){if(obj&&obj.__esModule)return obj;var newObj={};if(null!=obj)for(var key in obj)Object.prototype.hasOwnProperty.call(obj,key)&&(newObj[key]=obj[key]);return newObj.default=obj,newObj}(_glMatrix),_GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_GLShader=__webpack_require__(2),_GLShader2=_interopRequireDefault(_GLShader),_GLTexture=__webpack_require__(25),_GLTexture2=_interopRequireDefault(_GLTexture),_GLTexture3=__webpack_require__(26),_GLTexture4=_interopRequireDefault(_GLTexture3),_GLCubeTexture=__webpack_require__(27),_GLCubeTexture2=_interopRequireDefault(_GLCubeTexture),_Mesh=__webpack_require__(5),_Mesh2=_interopRequireDefault(_Mesh),_Geom=__webpack_require__(7),_Geom2=_interopRequireDefault(_Geom),_Batch=__webpack_require__(4),_Batch2=_interopRequireDefault(_Batch),_FrameBuffer=__webpack_require__(12),_FrameBuffer2=_interopRequireDefault(_FrameBuffer),_CubeFrameBuffer=__webpack_require__(56),_CubeFrameBuffer2=_interopRequireDefault(_CubeFrameBuffer),_MultisampleFrameBuffer=__webpack_require__(57),_MultisampleFrameBuffer2=_interopRequireDefault(_MultisampleFrameBuffer),_TransformFeedbackObject=__webpack_require__(58),_TransformFeedbackObject2=_interopRequireDefault(_TransformFeedbackObject),_scheduling=__webpack_require__(6),_scheduling2=_interopRequireDefault(_scheduling),_EventDispatcher=__webpack_require__(28),_EventDispatcher2=_interopRequireDefault(_EventDispatcher),_EaseNumber=__webpack_require__(13),_EaseNumber2=_interopRequireDefault(_EaseNumber),_TweenNumber=__webpack_require__(59),_TweenNumber2=_interopRequireDefault(_TweenNumber),_OrbitalControl=__webpack_require__(29),_OrbitalControl2=_interopRequireDefault(_OrbitalControl),_QuatRotation=__webpack_require__(60),_QuatRotation2=_interopRequireDefault(_QuatRotation),_TouchDetector=__webpack_require__(61),_TouchDetector2=_interopRequireDefault(_TouchDetector),_WebglNumber=__webpack_require__(8),_WebglNumber2=_interopRequireDefault(_WebglNumber),_WebglConst=__webpack_require__(23),_Camera=(_interopRequireDefault(_WebglConst),__webpack_require__(15)),_Camera2=_interopRequireDefault(_Camera),_CameraOrtho=__webpack_require__(30),_CameraOrtho2=_interopRequireDefault(_CameraOrtho),_CameraPerspective=__webpack_require__(16),_CameraPerspective2=_interopRequireDefault(_CameraPerspective),_CameraCube=__webpack_require__(63),_CameraCube2=_interopRequireDefault(_CameraCube),_Ray=__webpack_require__(14),_Ray2=_interopRequireDefault(_Ray),_Object3D=__webpack_require__(31),_Object3D2=_interopRequireDefault(_Object3D),_BinaryLoader=__webpack_require__(17),_BinaryLoader2=_interopRequireDefault(_BinaryLoader),_ObjLoader=__webpack_require__(64),_ObjLoader2=_interopRequireDefault(_ObjLoader),_HDRLoader=__webpack_require__(65),_HDRLoader2=_interopRequireDefault(_HDRLoader),_ColladaParser=__webpack_require__(67),_ColladaParser2=_interopRequireDefault(_ColladaParser),_EffectComposer=__webpack_require__(71),_EffectComposer2=_interopRequireDefault(_EffectComposer),_Pass=__webpack_require__(9),_Pass2=_interopRequireDefault(_Pass),_PassMacro=__webpack_require__(36),_PassMacro2=_interopRequireDefault(_PassMacro),_PassBlur=__webpack_require__(72),_PassBlur2=_interopRequireDefault(_PassBlur),_PassVBlur=__webpack_require__(37),_PassVBlur2=_interopRequireDefault(_PassVBlur),_PassHBlur=__webpack_require__(39),_PassHBlur2=_interopRequireDefault(_PassHBlur),_PassFxaa=__webpack_require__(76),_PassFxaa2=_interopRequireDefault(_PassFxaa),_BatchCopy=__webpack_require__(77),_BatchCopy2=_interopRequireDefault(_BatchCopy),_BatchAxis=__webpack_require__(78),_BatchAxis2=_interopRequireDefault(_BatchAxis),_BatchBall=__webpack_require__(81),_BatchBall2=_interopRequireDefault(_BatchBall),_BatchDotsPlane=__webpack_require__(82),_BatchDotsPlane2=_interopRequireDefault(_BatchDotsPlane),_BatchLine=__webpack_require__(84),_BatchLine2=_interopRequireDefault(_BatchLine),_BatchSkybox=__webpack_require__(85),_BatchSkybox2=_interopRequireDefault(_BatchSkybox),_BatchSky=__webpack_require__(86),_BatchSky2=_interopRequireDefault(_BatchSky),_BatchFXAA=__webpack_require__(88),_BatchFXAA2=_interopRequireDefault(_BatchFXAA),_Scene=__webpack_require__(89),_Scene2=_interopRequireDefault(_Scene),_View=__webpack_require__(90),_View2=_interopRequireDefault(_View),_View3D=__webpack_require__(91),_View3D2=_interopRequireDefault(_View3D),_ShaderLibs=__webpack_require__(32),_ShaderLibs2=_interopRequireDefault(_ShaderLibs),Alfrid=function(){function Alfrid(){_classCallCheck(this,Alfrid),this.glm=GLM,this.GL=_GLTool2.default,this.GLTool=_GLTool2.default,this.GLShader=_GLShader2.default,this.GLTexture=_GLTexture4.default,this.GLTextureOld=_GLTexture2.default,this.GLCubeTexture=_GLCubeTexture2.default,this.Mesh=_Mesh2.default,this.Geom=_Geom2.default,this.Batch=_Batch2.default,this.FrameBuffer=_FrameBuffer2.default,this.CubeFrameBuffer=_CubeFrameBuffer2.default,this.Scheduler=_scheduling2.default,this.EventDispatcher=_EventDispatcher2.default,this.EaseNumber=_EaseNumber2.default,this.TweenNumber=_TweenNumber2.default,this.Camera=_Camera2.default,this.CameraOrtho=_CameraOrtho2.default,this.CameraPerspective=_CameraPerspective2.default,this.Ray=_Ray2.default,this.CameraCube=_CameraCube2.default,this.OrbitalControl=_OrbitalControl2.default,this.QuatRotation=_QuatRotation2.default,this.BinaryLoader=_BinaryLoader2.default,this.ObjLoader=_ObjLoader2.default,this.ColladaParser=_ColladaParser2.default,this.HDRLoader=_HDRLoader2.default,this.BatchCopy=_BatchCopy2.default,this.BatchAxis=_BatchAxis2.default,this.BatchBall=_BatchBall2.default,this.BatchBall=_BatchBall2.default,this.BatchLine=_BatchLine2.default,this.BatchSkybox=_BatchSkybox2.default,this.BatchSky=_BatchSky2.default,this.BatchFXAA=_BatchFXAA2.default,this.BatchDotsPlane=_BatchDotsPlane2.default,this.Scene=_Scene2.default,this.View=_View2.default,this.View3D=_View3D2.default,this.Object3D=_Object3D2.default,this.ShaderLibs=_ShaderLibs2.default,this.WebglNumber=_WebglNumber2.default,this.EffectComposer=_EffectComposer2.default,this.Pass=_Pass2.default,this.PassMacro=_PassMacro2.default,this.PassBlur=_PassBlur2.default,this.PassVBlur=_PassVBlur2.default,this.PassHBlur=_PassHBlur2.default,this.PassFxaa=_PassFxaa2.default,this.MultisampleFrameBuffer=_MultisampleFrameBuffer2.default,this.TransformFeedbackObject=_TransformFeedbackObject2.default;for(var s in GLM)GLM[s]&&(window[s]=GLM[s])}return _createClass(Alfrid,[{key:"log",value:function(){navigator.userAgent.indexOf("Chrome")>-1?console.log("%clib alfrid : VERSION 0.2.0","background: #193441; color: #FCFFF5"):console.log("lib alfrid : VERSION ","0.2.0"),console.log("%cClasses : ","color: #193441");for(var s in this)this[s]&&console.log("%c - "+s,"color: #3E606F")}}]),Alfrid}(),al=new Alfrid;exports.default=al,exports.GL=_GLTool2.default,exports.GLShader=_GLShader2.default,exports.GLTexture=_GLTexture4.default,exports.GLTextureOld=_GLTexture2.default,exports.GLCubeTexture=_GLCubeTexture2.default,exports.Mesh=_Mesh2.default,exports.Geom=_Geom2.default,exports.Batch=_Batch2.default,exports.FrameBuffer=_FrameBuffer2.default,exports.CubeFrameBuffer=_CubeFrameBuffer2.default,exports.MultisampleFrameBuffer=_MultisampleFrameBuffer2.default,exports.TransformFeedbackObject=_TransformFeedbackObject2.default,exports.Scheduler=_scheduling2.default,exports.EventDispatcher=_EventDispatcher2.default,exports.EaseNumber=_EaseNumber2.default,exports.TweenNumber=_TweenNumber2.default,exports.OrbitalControl=_OrbitalControl2.default,exports.WebglNumber=_WebglNumber2.default,exports.QuatRotation=_QuatRotation2.default,exports.TouchDetector=_TouchDetector2.default,exports.Camera=_Camera2.default,exports.CameraOrtho=_CameraOrtho2.default,exports.CameraPerspective=_CameraPerspective2.default,exports.CameraCube=_CameraCube2.default,exports.Ray=_Ray2.default,exports.Object3D=_Object3D2.default,exports.BinaryLoader=_BinaryLoader2.default,exports.ObjLoader=_ObjLoader2.default,exports.HDRLoader=_HDRLoader2.default,exports.ColladaParser=_ColladaParser2.default,exports.EffectComposer=_EffectComposer2.default,exports.Pass=_Pass2.default,exports.PassMacro=_PassMacro2.default,exports.PassBlur=_PassBlur2.default,exports.PassVBlur=_PassVBlur2.default,exports.PassHBlur=_PassHBlur2.default,exports.PassFxaa=_PassFxaa2.default,exports.BatchCopy=_BatchCopy2.default,exports.BatchAxis=_BatchAxis2.default,exports.BatchBall=_BatchBall2.default,exports.BatchDotsPlane=_BatchDotsPlane2.default,exports.BatchLine=_BatchLine2.default,exports.BatchSkybox=_BatchSkybox2.default,exports.BatchSky=_BatchSky2.default,exports.BatchFXAA=_BatchFXAA2.default,exports.Scene=_Scene2.default,exports.View=_View2.default,exports.View3D=_View3D2.default,exports.ShaderLibs=_ShaderLibs2.default},function(module,exports,__webpack_require__){"use strict";function create(){var out=new glMatrix.ARRAY_TYPE(4);return out[0]=1,out[1]=0,out[2]=0,out[3]=1,out}function clone(a){var out=new glMatrix.ARRAY_TYPE(4);return out[0]=a[0],out[1]=a[1],out[2]=a[2],out[3]=a[3],out}function copy(out,a){return out[0]=a[0],out[1]=a[1],out[2]=a[2],out[3]=a[3],out}function identity(out){return out[0]=1,out[1]=0,out[2]=0,out[3]=1,out}function fromValues(m00,m01,m10,m11){var out=new glMatrix.ARRAY_TYPE(4);return out[0]=m00,out[1]=m01,out[2]=m10,out[3]=m11,out}function set(out,m00,m01,m10,m11){return out[0]=m00,out[1]=m01,out[2]=m10,out[3]=m11,out}function transpose(out,a){if(out===a){var a1=a[1];out[1]=a[2],out[2]=a1}else out[0]=a[0],out[1]=a[2],out[2]=a[1],out[3]=a[3];return out}function invert(out,a){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],det=a0*a3-a2*a1;return det?(det=1/det,out[0]=a3*det,out[1]=-a1*det,out[2]=-a2*det,out[3]=a0*det,out):null}function adjoint(out,a){var a0=a[0];return out[0]=a[3],out[1]=-a[1],out[2]=-a[2],out[3]=a0,out}function determinant(a){return a[0]*a[3]-a[2]*a[1]}function multiply(out,a,b){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],b0=b[0],b1=b[1],b2=b[2],b3=b[3];return out[0]=a0*b0+a2*b1,out[1]=a1*b0+a3*b1,out[2]=a0*b2+a2*b3,out[3]=a1*b2+a3*b3,out}function rotate(out,a,rad){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],s=Math.sin(rad),c=Math.cos(rad);return out[0]=a0*c+a2*s,out[1]=a1*c+a3*s,out[2]=a0*-s+a2*c,out[3]=a1*-s+a3*c,out}function scale(out,a,v){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],v0=v[0],v1=v[1];return out[0]=a0*v0,out[1]=a1*v0,out[2]=a2*v1,out[3]=a3*v1,out}function fromRotation(out,rad){var s=Math.sin(rad),c=Math.cos(rad);return out[0]=c,out[1]=s,out[2]=-s,out[3]=c,out}function fromScaling(out,v){return out[0]=v[0],out[1]=0,out[2]=0,out[3]=v[1],out}function str(a){return"mat2("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+")"}function frob(a){return Math.sqrt(Math.pow(a[0],2)+Math.pow(a[1],2)+Math.pow(a[2],2)+Math.pow(a[3],2))}function LDU(L,D,U,a){return L[2]=a[2]/a[0],U[0]=a[0],U[1]=a[1],U[3]=a[3]-L[2]*U[1],[L,D,U]}function add(out,a,b){return out[0]=a[0]+b[0],out[1]=a[1]+b[1],out[2]=a[2]+b[2],out[3]=a[3]+b[3],out}function subtract(out,a,b){return out[0]=a[0]-b[0],out[1]=a[1]-b[1],out[2]=a[2]-b[2],out[3]=a[3]-b[3],out}function exactEquals(a,b){return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2]&&a[3]===b[3]}function equals(a,b){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],b0=b[0],b1=b[1],b2=b[2],b3=b[3];return Math.abs(a0-b0)<=glMatrix.EPSILON*Math.max(1,Math.abs(a0),Math.abs(b0))&&Math.abs(a1-b1)<=glMatrix.EPSILON*Math.max(1,Math.abs(a1),Math.abs(b1))&&Math.abs(a2-b2)<=glMatrix.EPSILON*Math.max(1,Math.abs(a2),Math.abs(b2))&&Math.abs(a3-b3)<=glMatrix.EPSILON*Math.max(1,Math.abs(a3),Math.abs(b3))}function multiplyScalar(out,a,b){return out[0]=a[0]*b,out[1]=a[1]*b,out[2]=a[2]*b,out[3]=a[3]*b,out}function multiplyScalarAndAdd(out,a,b,scale){return out[0]=a[0]+b[0]*scale,out[1]=a[1]+b[1]*scale,out[2]=a[2]+b[2]*scale,out[3]=a[3]+b[3]*scale,out}Object.defineProperty(exports,"__esModule",{value:!0}),exports.sub=exports.mul=void 0,exports.create=create,exports.clone=clone,exports.copy=copy,exports.identity=identity,exports.fromValues=fromValues,exports.set=set,exports.transpose=transpose,exports.invert=invert,exports.adjoint=adjoint,exports.determinant=determinant,exports.multiply=multiply,exports.rotate=rotate,exports.scale=scale,exports.fromRotation=fromRotation,exports.fromScaling=fromScaling,exports.str=str,exports.frob=frob,exports.LDU=LDU,exports.add=add,exports.subtract=subtract,exports.exactEquals=exactEquals,exports.equals=equals,exports.multiplyScalar=multiplyScalar,exports.multiplyScalarAndAdd=multiplyScalarAndAdd;var _common=__webpack_require__(3),glMatrix=function(obj){if(obj&&obj.__esModule)return obj;var newObj={};if(null!=obj)for(var key in obj)Object.prototype.hasOwnProperty.call(obj,key)&&(newObj[key]=obj[key]);return newObj.default=obj,newObj}(_common);exports.mul=multiply,exports.sub=subtract},function(module,exports,__webpack_require__){"use strict";function create(){var out=new glMatrix.ARRAY_TYPE(6);return out[0]=1,out[1]=0,out[2]=0,out[3]=1,out[4]=0,out[5]=0,out}function clone(a){var out=new glMatrix.ARRAY_TYPE(6);return out[0]=a[0],out[1]=a[1],out[2]=a[2],out[3]=a[3],out[4]=a[4],out[5]=a[5],out}function copy(out,a){return out[0]=a[0],out[1]=a[1],out[2]=a[2],out[3]=a[3],out[4]=a[4],out[5]=a[5],out}function identity(out){return out[0]=1,out[1]=0,out[2]=0,out[3]=1,out[4]=0,out[5]=0,out}function fromValues(a,b,c,d,tx,ty){var out=new glMatrix.ARRAY_TYPE(6);return out[0]=a,out[1]=b,out[2]=c,out[3]=d,out[4]=tx,out[5]=ty,out}function set(out,a,b,c,d,tx,ty){return out[0]=a,out[1]=b,out[2]=c,out[3]=d,out[4]=tx,out[5]=ty,out}function invert(out,a){var aa=a[0],ab=a[1],ac=a[2],ad=a[3],atx=a[4],aty=a[5],det=aa*ad-ab*ac;return det?(det=1/det,out[0]=ad*det,out[1]=-ab*det,out[2]=-ac*det,out[3]=aa*det,out[4]=(ac*aty-ad*atx)*det,out[5]=(ab*atx-aa*aty)*det,out):null}function determinant(a){return a[0]*a[3]-a[1]*a[2]}function multiply(out,a,b){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],a4=a[4],a5=a[5],b0=b[0],b1=b[1],b2=b[2],b3=b[3],b4=b[4],b5=b[5];return out[0]=a0*b0+a2*b1,out[1]=a1*b0+a3*b1,out[2]=a0*b2+a2*b3,out[3]=a1*b2+a3*b3,out[4]=a0*b4+a2*b5+a4,out[5]=a1*b4+a3*b5+a5,out}function rotate(out,a,rad){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],a4=a[4],a5=a[5],s=Math.sin(rad),c=Math.cos(rad);return out[0]=a0*c+a2*s,out[1]=a1*c+a3*s,out[2]=a0*-s+a2*c,out[3]=a1*-s+a3*c,out[4]=a4,out[5]=a5,out}function scale(out,a,v){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],a4=a[4],a5=a[5],v0=v[0],v1=v[1];return out[0]=a0*v0,out[1]=a1*v0,out[2]=a2*v1,out[3]=a3*v1,out[4]=a4,out[5]=a5,out}function translate(out,a,v){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],a4=a[4],a5=a[5],v0=v[0],v1=v[1];return out[0]=a0,out[1]=a1,out[2]=a2,out[3]=a3,out[4]=a0*v0+a2*v1+a4,out[5]=a1*v0+a3*v1+a5,out}function fromRotation(out,rad){var s=Math.sin(rad),c=Math.cos(rad);return out[0]=c,out[1]=s,out[2]=-s,out[3]=c,out[4]=0,out[5]=0,out}function fromScaling(out,v){return out[0]=v[0],out[1]=0,out[2]=0,out[3]=v[1],out[4]=0,out[5]=0,out}function fromTranslation(out,v){return out[0]=1,out[1]=0,out[2]=0,out[3]=1,out[4]=v[0],out[5]=v[1],out}function str(a){return"mat2d("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+")"}function frob(a){return Math.sqrt(Math.pow(a[0],2)+Math.pow(a[1],2)+Math.pow(a[2],2)+Math.pow(a[3],2)+Math.pow(a[4],2)+Math.pow(a[5],2)+1)}function add(out,a,b){return out[0]=a[0]+b[0],out[1]=a[1]+b[1],out[2]=a[2]+b[2],out[3]=a[3]+b[3],out[4]=a[4]+b[4],out[5]=a[5]+b[5],out}function subtract(out,a,b){return out[0]=a[0]-b[0],out[1]=a[1]-b[1],out[2]=a[2]-b[2],out[3]=a[3]-b[3],out[4]=a[4]-b[4],out[5]=a[5]-b[5],out}function multiplyScalar(out,a,b){return out[0]=a[0]*b,out[1]=a[1]*b,out[2]=a[2]*b,out[3]=a[3]*b,out[4]=a[4]*b,out[5]=a[5]*b,out}function multiplyScalarAndAdd(out,a,b,scale){return out[0]=a[0]+b[0]*scale,out[1]=a[1]+b[1]*scale,out[2]=a[2]+b[2]*scale,out[3]=a[3]+b[3]*scale,out[4]=a[4]+b[4]*scale,out[5]=a[5]+b[5]*scale,out}function exactEquals(a,b){return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2]&&a[3]===b[3]&&a[4]===b[4]&&a[5]===b[5]}function equals(a,b){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],a4=a[4],a5=a[5],b0=b[0],b1=b[1],b2=b[2],b3=b[3],b4=b[4],b5=b[5];return Math.abs(a0-b0)<=glMatrix.EPSILON*Math.max(1,Math.abs(a0),Math.abs(b0))&&Math.abs(a1-b1)<=glMatrix.EPSILON*Math.max(1,Math.abs(a1),Math.abs(b1))&&Math.abs(a2-b2)<=glMatrix.EPSILON*Math.max(1,Math.abs(a2),Math.abs(b2))&&Math.abs(a3-b3)<=glMatrix.EPSILON*Math.max(1,Math.abs(a3),Math.abs(b3))&&Math.abs(a4-b4)<=glMatrix.EPSILON*Math.max(1,Math.abs(a4),Math.abs(b4))&&Math.abs(a5-b5)<=glMatrix.EPSILON*Math.max(1,Math.abs(a5),Math.abs(b5))}Object.defineProperty(exports,"__esModule",{value:!0}),exports.sub=exports.mul=void 0,exports.create=create,exports.clone=clone,exports.copy=copy,exports.identity=identity,exports.fromValues=fromValues,exports.set=set,exports.invert=invert,exports.determinant=determinant,exports.multiply=multiply,exports.rotate=rotate,exports.scale=scale,exports.translate=translate,exports.fromRotation=fromRotation,exports.fromScaling=fromScaling,exports.fromTranslation=fromTranslation,exports.str=str,exports.frob=frob,exports.add=add,exports.subtract=subtract,exports.multiplyScalar=multiplyScalar,exports.multiplyScalarAndAdd=multiplyScalarAndAdd,exports.exactEquals=exactEquals,exports.equals=equals;var _common=__webpack_require__(3),glMatrix=function(obj){if(obj&&obj.__esModule)return obj;var newObj={};if(null!=obj)for(var key in obj)Object.prototype.hasOwnProperty.call(obj,key)&&(newObj[key]=obj[key]);return newObj.default=obj,newObj}(_common);exports.mul=multiply,exports.sub=subtract},function(module,exports,__webpack_require__){"use strict";function create(){var out=new glMatrix.ARRAY_TYPE(16);return out[0]=1,out[1]=0,out[2]=0,out[3]=0,out[4]=0,out[5]=1,out[6]=0,out[7]=0,out[8]=0,out[9]=0,out[10]=1,out[11]=0,out[12]=0,out[13]=0,out[14]=0,out[15]=1,out}function clone(a){var out=new glMatrix.ARRAY_TYPE(16);return out[0]=a[0],out[1]=a[1],out[2]=a[2],out[3]=a[3],out[4]=a[4],out[5]=a[5],out[6]=a[6],out[7]=a[7],out[8]=a[8],out[9]=a[9],out[10]=a[10],out[11]=a[11],out[12]=a[12],out[13]=a[13],out[14]=a[14],out[15]=a[15],out}function copy(out,a){return out[0]=a[0],out[1]=a[1],out[2]=a[2],out[3]=a[3],out[4]=a[4],out[5]=a[5],out[6]=a[6],out[7]=a[7],out[8]=a[8],out[9]=a[9],out[10]=a[10],out[11]=a[11],out[12]=a[12],out[13]=a[13],out[14]=a[14],out[15]=a[15],out}function fromValues(m00,m01,m02,m03,m10,m11,m12,m13,m20,m21,m22,m23,m30,m31,m32,m33){var out=new glMatrix.ARRAY_TYPE(16);return out[0]=m00,out[1]=m01,out[2]=m02,out[3]=m03,out[4]=m10,out[5]=m11,out[6]=m12,out[7]=m13,out[8]=m20,out[9]=m21,out[10]=m22,out[11]=m23,out[12]=m30,out[13]=m31,out[14]=m32,out[15]=m33,out}function set(out,m00,m01,m02,m03,m10,m11,m12,m13,m20,m21,m22,m23,m30,m31,m32,m33){return out[0]=m00,out[1]=m01,out[2]=m02,out[3]=m03,out[4]=m10,out[5]=m11,out[6]=m12,out[7]=m13,out[8]=m20,out[9]=m21,out[10]=m22,out[11]=m23,out[12]=m30,out[13]=m31,out[14]=m32,out[15]=m33,out}function identity(out){return out[0]=1,out[1]=0,out[2]=0,out[3]=0,out[4]=0,out[5]=1,out[6]=0,out[7]=0,out[8]=0,out[9]=0,out[10]=1,out[11]=0,out[12]=0,out[13]=0,out[14]=0,out[15]=1,out}function transpose(out,a){if(out===a){var a01=a[1],a02=a[2],a03=a[3],a12=a[6],a13=a[7],a23=a[11];out[1]=a[4],out[2]=a[8],out[3]=a[12],out[4]=a01,out[6]=a[9],out[7]=a[13],out[8]=a02,out[9]=a12,out[11]=a[14],out[12]=a03,out[13]=a13,out[14]=a23}else out[0]=a[0],out[1]=a[4],out[2]=a[8],out[3]=a[12],out[4]=a[1],out[5]=a[5],out[6]=a[9],out[7]=a[13],out[8]=a[2],out[9]=a[6],out[10]=a[10],out[11]=a[14],out[12]=a[3],out[13]=a[7],out[14]=a[11],out[15]=a[15];return out}function invert(out,a){var a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11],a30=a[12],a31=a[13],a32=a[14],a33=a[15],b00=a00*a11-a01*a10,b01=a00*a12-a02*a10,b02=a00*a13-a03*a10,b03=a01*a12-a02*a11,b04=a01*a13-a03*a11,b05=a02*a13-a03*a12,b06=a20*a31-a21*a30,b07=a20*a32-a22*a30,b08=a20*a33-a23*a30,b09=a21*a32-a22*a31,b10=a21*a33-a23*a31,b11=a22*a33-a23*a32,det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;return det?(det=1/det,out[0]=(a11*b11-a12*b10+a13*b09)*det,out[1]=(a02*b10-a01*b11-a03*b09)*det,out[2]=(a31*b05-a32*b04+a33*b03)*det,out[3]=(a22*b04-a21*b05-a23*b03)*det,out[4]=(a12*b08-a10*b11-a13*b07)*det,out[5]=(a00*b11-a02*b08+a03*b07)*det,out[6]=(a32*b02-a30*b05-a33*b01)*det,out[7]=(a20*b05-a22*b02+a23*b01)*det,out[8]=(a10*b10-a11*b08+a13*b06)*det,out[9]=(a01*b08-a00*b10-a03*b06)*det,out[10]=(a30*b04-a31*b02+a33*b00)*det,out[11]=(a21*b02-a20*b04-a23*b00)*det,out[12]=(a11*b07-a10*b09-a12*b06)*det,out[13]=(a00*b09-a01*b07+a02*b06)*det,out[14]=(a31*b01-a30*b03-a32*b00)*det,out[15]=(a20*b03-a21*b01+a22*b00)*det,out):null}function adjoint(out,a){var a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11],a30=a[12],a31=a[13],a32=a[14],a33=a[15];return out[0]=a11*(a22*a33-a23*a32)-a21*(a12*a33-a13*a32)+a31*(a12*a23-a13*a22),out[1]=-(a01*(a22*a33-a23*a32)-a21*(a02*a33-a03*a32)+a31*(a02*a23-a03*a22)),out[2]=a01*(a12*a33-a13*a32)-a11*(a02*a33-a03*a32)+a31*(a02*a13-a03*a12),out[3]=-(a01*(a12*a23-a13*a22)-a11*(a02*a23-a03*a22)+a21*(a02*a13-a03*a12)),out[4]=-(a10*(a22*a33-a23*a32)-a20*(a12*a33-a13*a32)+a30*(a12*a23-a13*a22)),out[5]=a00*(a22*a33-a23*a32)-a20*(a02*a33-a03*a32)+a30*(a02*a23-a03*a22),out[6]=-(a00*(a12*a33-a13*a32)-a10*(a02*a33-a03*a32)+a30*(a02*a13-a03*a12)),out[7]=a00*(a12*a23-a13*a22)-a10*(a02*a23-a03*a22)+a20*(a02*a13-a03*a12),out[8]=a10*(a21*a33-a23*a31)-a20*(a11*a33-a13*a31)+a30*(a11*a23-a13*a21),out[9]=-(a00*(a21*a33-a23*a31)-a20*(a01*a33-a03*a31)+a30*(a01*a23-a03*a21)),out[10]=a00*(a11*a33-a13*a31)-a10*(a01*a33-a03*a31)+a30*(a01*a13-a03*a11),out[11]=-(a00*(a11*a23-a13*a21)-a10*(a01*a23-a03*a21)+a20*(a01*a13-a03*a11)),out[12]=-(a10*(a21*a32-a22*a31)-a20*(a11*a32-a12*a31)+a30*(a11*a22-a12*a21)),out[13]=a00*(a21*a32-a22*a31)-a20*(a01*a32-a02*a31)+a30*(a01*a22-a02*a21),out[14]=-(a00*(a11*a32-a12*a31)-a10*(a01*a32-a02*a31)+a30*(a01*a12-a02*a11)),out[15]=a00*(a11*a22-a12*a21)-a10*(a01*a22-a02*a21)+a20*(a01*a12-a02*a11),out}function determinant(a){var a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11],a30=a[12],a31=a[13],a32=a[14],a33=a[15];return(a00*a11-a01*a10)*(a22*a33-a23*a32)-(a00*a12-a02*a10)*(a21*a33-a23*a31)+(a00*a13-a03*a10)*(a21*a32-a22*a31)+(a01*a12-a02*a11)*(a20*a33-a23*a30)-(a01*a13-a03*a11)*(a20*a32-a22*a30)+(a02*a13-a03*a12)*(a20*a31-a21*a30)}function multiply(out,a,b){var a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11],a30=a[12],a31=a[13],a32=a[14],a33=a[15],b0=b[0],b1=b[1],b2=b[2],b3=b[3];return out[0]=b0*a00+b1*a10+b2*a20+b3*a30,out[1]=b0*a01+b1*a11+b2*a21+b3*a31,out[2]=b0*a02+b1*a12+b2*a22+b3*a32,out[3]=b0*a03+b1*a13+b2*a23+b3*a33,b0=b[4],b1=b[5],b2=b[6],b3=b[7],out[4]=b0*a00+b1*a10+b2*a20+b3*a30,out[5]=b0*a01+b1*a11+b2*a21+b3*a31,out[6]=b0*a02+b1*a12+b2*a22+b3*a32,out[7]=b0*a03+b1*a13+b2*a23+b3*a33,b0=b[8],b1=b[9],b2=b[10],b3=b[11],out[8]=b0*a00+b1*a10+b2*a20+b3*a30,out[9]=b0*a01+b1*a11+b2*a21+b3*a31,out[10]=b0*a02+b1*a12+b2*a22+b3*a32,out[11]=b0*a03+b1*a13+b2*a23+b3*a33,b0=b[12],b1=b[13],b2=b[14],b3=b[15],out[12]=b0*a00+b1*a10+b2*a20+b3*a30,out[13]=b0*a01+b1*a11+b2*a21+b3*a31,out[14]=b0*a02+b1*a12+b2*a22+b3*a32,out[15]=b0*a03+b1*a13+b2*a23+b3*a33,out}function translate(out,a,v){var x=v[0],y=v[1],z=v[2],a00=void 0,a01=void 0,a02=void 0,a03=void 0,a10=void 0,a11=void 0,a12=void 0,a13=void 0,a20=void 0,a21=void 0,a22=void 0,a23=void 0;return a===out?(out[12]=a[0]*x+a[4]*y+a[8]*z+a[12],out[13]=a[1]*x+a[5]*y+a[9]*z+a[13],out[14]=a[2]*x+a[6]*y+a[10]*z+a[14],out[15]=a[3]*x+a[7]*y+a[11]*z+a[15]):(a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11],out[0]=a00,out[1]=a01,out[2]=a02,out[3]=a03,out[4]=a10,out[5]=a11,out[6]=a12,out[7]=a13,out[8]=a20,out[9]=a21,out[10]=a22,out[11]=a23,out[12]=a00*x+a10*y+a20*z+a[12],out[13]=a01*x+a11*y+a21*z+a[13],out[14]=a02*x+a12*y+a22*z+a[14],out[15]=a03*x+a13*y+a23*z+a[15]),out}function scale(out,a,v){var x=v[0],y=v[1],z=v[2];return out[0]=a[0]*x,out[1]=a[1]*x,out[2]=a[2]*x,out[3]=a[3]*x,out[4]=a[4]*y,out[5]=a[5]*y,out[6]=a[6]*y,out[7]=a[7]*y,out[8]=a[8]*z,out[9]=a[9]*z,out[10]=a[10]*z,out[11]=a[11]*z,out[12]=a[12],out[13]=a[13],out[14]=a[14],out[15]=a[15],out}function rotate(out,a,rad,axis){var x=axis[0],y=axis[1],z=axis[2],len=Math.sqrt(x*x+y*y+z*z),s=void 0,c=void 0,t=void 0,a00=void 0,a01=void 0,a02=void 0,a03=void 0,a10=void 0,a11=void 0,a12=void 0,a13=void 0,a20=void 0,a21=void 0,a22=void 0,a23=void 0,b00=void 0,b01=void 0,b02=void 0,b10=void 0,b11=void 0,b12=void 0,b20=void 0,b21=void 0,b22=void 0;return Math.abs(len)<glMatrix.EPSILON?null:(len=1/len,x*=len,y*=len,z*=len,s=Math.sin(rad),c=Math.cos(rad),t=1-c,a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11],b00=x*x*t+c,b01=y*x*t+z*s,b02=z*x*t-y*s,b10=x*y*t-z*s,b11=y*y*t+c,b12=z*y*t+x*s,b20=x*z*t+y*s,b21=y*z*t-x*s,b22=z*z*t+c,out[0]=a00*b00+a10*b01+a20*b02,out[1]=a01*b00+a11*b01+a21*b02,out[2]=a02*b00+a12*b01+a22*b02,out[3]=a03*b00+a13*b01+a23*b02,out[4]=a00*b10+a10*b11+a20*b12,out[5]=a01*b10+a11*b11+a21*b12,out[6]=a02*b10+a12*b11+a22*b12,out[7]=a03*b10+a13*b11+a23*b12,out[8]=a00*b20+a10*b21+a20*b22,out[9]=a01*b20+a11*b21+a21*b22,out[10]=a02*b20+a12*b21+a22*b22,out[11]=a03*b20+a13*b21+a23*b22,a!==out&&(out[12]=a[12],out[13]=a[13],out[14]=a[14],out[15]=a[15]),out)}function rotateX(out,a,rad){var s=Math.sin(rad),c=Math.cos(rad),a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11];return a!==out&&(out[0]=a[0],out[1]=a[1],out[2]=a[2],out[3]=a[3],out[12]=a[12],out[13]=a[13],out[14]=a[14],out[15]=a[15]),out[4]=a10*c+a20*s,out[5]=a11*c+a21*s,out[6]=a12*c+a22*s,out[7]=a13*c+a23*s,out[8]=a20*c-a10*s,out[9]=a21*c-a11*s,out[10]=a22*c-a12*s,out[11]=a23*c-a13*s,out}function rotateY(out,a,rad){var s=Math.sin(rad),c=Math.cos(rad),a00=a[0],a01=a[1],a02=a[2],a03=a[3],a20=a[8],a21=a[9],a22=a[10],a23=a[11];return a!==out&&(out[4]=a[4],out[5]=a[5],out[6]=a[6],out[7]=a[7],out[12]=a[12],out[13]=a[13],out[14]=a[14],out[15]=a[15]),out[0]=a00*c-a20*s,out[1]=a01*c-a21*s,out[2]=a02*c-a22*s,out[3]=a03*c-a23*s,out[8]=a00*s+a20*c,out[9]=a01*s+a21*c,out[10]=a02*s+a22*c,out[11]=a03*s+a23*c,out}function rotateZ(out,a,rad){var s=Math.sin(rad),c=Math.cos(rad),a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7];return a!==out&&(out[8]=a[8],out[9]=a[9],out[10]=a[10],out[11]=a[11],out[12]=a[12],out[13]=a[13],out[14]=a[14],out[15]=a[15]),out[0]=a00*c+a10*s,out[1]=a01*c+a11*s,out[2]=a02*c+a12*s,out[3]=a03*c+a13*s,out[4]=a10*c-a00*s,out[5]=a11*c-a01*s,out[6]=a12*c-a02*s,out[7]=a13*c-a03*s,out}function fromTranslation(out,v){return out[0]=1,out[1]=0,out[2]=0,out[3]=0,out[4]=0,out[5]=1,out[6]=0,out[7]=0,out[8]=0,out[9]=0,out[10]=1,out[11]=0,out[12]=v[0],out[13]=v[1],out[14]=v[2],out[15]=1,out}function fromScaling(out,v){return out[0]=v[0],out[1]=0,out[2]=0,out[3]=0,out[4]=0,out[5]=v[1],out[6]=0,out[7]=0,out[8]=0,out[9]=0,out[10]=v[2],out[11]=0,out[12]=0,out[13]=0,out[14]=0,out[15]=1,out}function fromRotation(out,rad,axis){var x=axis[0],y=axis[1],z=axis[2],len=Math.sqrt(x*x+y*y+z*z),s=void 0,c=void 0,t=void 0;return Math.abs(len)<glMatrix.EPSILON?null:(len=1/len,x*=len,y*=len,z*=len,s=Math.sin(rad),c=Math.cos(rad),t=1-c,out[0]=x*x*t+c,out[1]=y*x*t+z*s,out[2]=z*x*t-y*s,out[3]=0,out[4]=x*y*t-z*s,out[5]=y*y*t+c,out[6]=z*y*t+x*s,out[7]=0,out[8]=x*z*t+y*s,out[9]=y*z*t-x*s,out[10]=z*z*t+c,out[11]=0,out[12]=0,out[13]=0,out[14]=0,out[15]=1,out)}function fromXRotation(out,rad){var s=Math.sin(rad),c=Math.cos(rad);return out[0]=1,out[1]=0,out[2]=0,out[3]=0,out[4]=0,out[5]=c,out[6]=s,out[7]=0,out[8]=0,out[9]=-s,out[10]=c,out[11]=0,out[12]=0,out[13]=0,out[14]=0,out[15]=1,out}function fromYRotation(out,rad){var s=Math.sin(rad),c=Math.cos(rad);return out[0]=c,out[1]=0,out[2]=-s,out[3]=0,out[4]=0,out[5]=1,out[6]=0,out[7]=0,out[8]=s,out[9]=0,out[10]=c,out[11]=0,out[12]=0,out[13]=0,out[14]=0,out[15]=1,out}function fromZRotation(out,rad){var s=Math.sin(rad),c=Math.cos(rad);return out[0]=c,out[1]=s,out[2]=0,out[3]=0,out[4]=-s,out[5]=c,out[6]=0,out[7]=0,out[8]=0,out[9]=0,out[10]=1,out[11]=0,out[12]=0,out[13]=0,out[14]=0,out[15]=1,out}function fromRotationTranslation(out,q,v){var x=q[0],y=q[1],z=q[2],w=q[3],x2=x+x,y2=y+y,z2=z+z,xx=x*x2,xy=x*y2,xz=x*z2,yy=y*y2,yz=y*z2,zz=z*z2,wx=w*x2,wy=w*y2,wz=w*z2;return out[0]=1-(yy+zz),out[1]=xy+wz,out[2]=xz-wy,out[3]=0,out[4]=xy-wz,out[5]=1-(xx+zz),out[6]=yz+wx,out[7]=0,out[8]=xz+wy,out[9]=yz-wx,out[10]=1-(xx+yy),out[11]=0,out[12]=v[0],out[13]=v[1],out[14]=v[2],out[15]=1,out}function getTranslation(out,mat){return out[0]=mat[12],out[1]=mat[13],out[2]=mat[14],out}function getScaling(out,mat){var m11=mat[0],m12=mat[1],m13=mat[2],m21=mat[4],m22=mat[5],m23=mat[6],m31=mat[8],m32=mat[9],m33=mat[10];return out[0]=Math.sqrt(m11*m11+m12*m12+m13*m13),out[1]=Math.sqrt(m21*m21+m22*m22+m23*m23),out[2]=Math.sqrt(m31*m31+m32*m32+m33*m33),out}function getRotation(out,mat){var trace=mat[0]+mat[5]+mat[10],S=0;return trace>0?(S=2*Math.sqrt(trace+1),out[3]=.25*S,out[0]=(mat[6]-mat[9])/S,out[1]=(mat[8]-mat[2])/S,out[2]=(mat[1]-mat[4])/S):mat[0]>mat[5]&mat[0]>mat[10]?(S=2*Math.sqrt(1+mat[0]-mat[5]-mat[10]),out[3]=(mat[6]-mat[9])/S,out[0]=.25*S,out[1]=(mat[1]+mat[4])/S,out[2]=(mat[8]+mat[2])/S):mat[5]>mat[10]?(S=2*Math.sqrt(1+mat[5]-mat[0]-mat[10]),out[3]=(mat[8]-mat[2])/S,out[0]=(mat[1]+mat[4])/S,out[1]=.25*S,out[2]=(mat[6]+mat[9])/S):(S=2*Math.sqrt(1+mat[10]-mat[0]-mat[5]),out[3]=(mat[1]-mat[4])/S,out[0]=(mat[8]+mat[2])/S,out[1]=(mat[6]+mat[9])/S,out[2]=.25*S),out}function fromRotationTranslationScale(out,q,v,s){var x=q[0],y=q[1],z=q[2],w=q[3],x2=x+x,y2=y+y,z2=z+z,xx=x*x2,xy=x*y2,xz=x*z2,yy=y*y2,yz=y*z2,zz=z*z2,wx=w*x2,wy=w*y2,wz=w*z2,sx=s[0],sy=s[1],sz=s[2];return out[0]=(1-(yy+zz))*sx,out[1]=(xy+wz)*sx,out[2]=(xz-wy)*sx,out[3]=0,out[4]=(xy-wz)*sy,out[5]=(1-(xx+zz))*sy,out[6]=(yz+wx)*sy,out[7]=0,out[8]=(xz+wy)*sz,out[9]=(yz-wx)*sz,out[10]=(1-(xx+yy))*sz,out[11]=0,out[12]=v[0],out[13]=v[1],out[14]=v[2],out[15]=1,out}function fromRotationTranslationScaleOrigin(out,q,v,s,o){var x=q[0],y=q[1],z=q[2],w=q[3],x2=x+x,y2=y+y,z2=z+z,xx=x*x2,xy=x*y2,xz=x*z2,yy=y*y2,yz=y*z2,zz=z*z2,wx=w*x2,wy=w*y2,wz=w*z2,sx=s[0],sy=s[1],sz=s[2],ox=o[0],oy=o[1],oz=o[2];return out[0]=(1-(yy+zz))*sx,out[1]=(xy+wz)*sx,out[2]=(xz-wy)*sx,out[3]=0,out[4]=(xy-wz)*sy,out[5]=(1-(xx+zz))*sy,out[6]=(yz+wx)*sy,out[7]=0,out[8]=(xz+wy)*sz,out[9]=(yz-wx)*sz,out[10]=(1-(xx+yy))*sz,out[11]=0,out[12]=v[0]+ox-(out[0]*ox+out[4]*oy+out[8]*oz),out[13]=v[1]+oy-(out[1]*ox+out[5]*oy+out[9]*oz),out[14]=v[2]+oz-(out[2]*ox+out[6]*oy+out[10]*oz),out[15]=1,out}function fromQuat(out,q){var x=q[0],y=q[1],z=q[2],w=q[3],x2=x+x,y2=y+y,z2=z+z,xx=x*x2,yx=y*x2,yy=y*y2,zx=z*x2,zy=z*y2,zz=z*z2,wx=w*x2,wy=w*y2,wz=w*z2;return out[0]=1-yy-zz,out[1]=yx+wz,out[2]=zx-wy,out[3]=0,out[4]=yx-wz,out[5]=1-xx-zz,out[6]=zy+wx,out[7]=0,out[8]=zx+wy,out[9]=zy-wx,out[10]=1-xx-yy,out[11]=0,out[12]=0,out[13]=0,out[14]=0,out[15]=1,out}function frustum(out,left,right,bottom,top,near,far){var rl=1/(right-left),tb=1/(top-bottom),nf=1/(near-far);return out[0]=2*near*rl,out[1]=0,out[2]=0,out[3]=0,out[4]=0,out[5]=2*near*tb,out[6]=0,out[7]=0,out[8]=(right+left)*rl,out[9]=(top+bottom)*tb,out[10]=(far+near)*nf,out[11]=-1,out[12]=0,out[13]=0,out[14]=far*near*2*nf,out[15]=0,out}function perspective(out,fovy,aspect,near,far){var f=1/Math.tan(fovy/2),nf=1/(near-far);return out[0]=f/aspect,out[1]=0,out[2]=0,out[3]=0,out[4]=0,out[5]=f,out[6]=0,out[7]=0,out[8]=0,out[9]=0,out[10]=(far+near)*nf,out[11]=-1,out[12]=0,out[13]=0,out[14]=2*far*near*nf,out[15]=0,out}function perspectiveFromFieldOfView(out,fov,near,far){var upTan=Math.tan(fov.upDegrees*Math.PI/180),downTan=Math.tan(fov.downDegrees*Math.PI/180),leftTan=Math.tan(fov.leftDegrees*Math.PI/180),rightTan=Math.tan(fov.rightDegrees*Math.PI/180),xScale=2/(leftTan+rightTan),yScale=2/(upTan+downTan);return out[0]=xScale,out[1]=0,out[2]=0,out[3]=0,out[4]=0,out[5]=yScale,out[6]=0,out[7]=0,out[8]=-(leftTan-rightTan)*xScale*.5,out[9]=(upTan-downTan)*yScale*.5,out[10]=far/(near-far),out[11]=-1,out[12]=0,out[13]=0,out[14]=far*near/(near-far),out[15]=0,out}function ortho(out,left,right,bottom,top,near,far){var lr=1/(left-right),bt=1/(bottom-top),nf=1/(near-far);return out[0]=-2*lr,out[1]=0,out[2]=0,out[3]=0,out[4]=0,out[5]=-2*bt,out[6]=0,out[7]=0,out[8]=0,out[9]=0,out[10]=2*nf,out[11]=0,out[12]=(left+right)*lr,out[13]=(top+bottom)*bt,out[14]=(far+near)*nf,out[15]=1,out}function lookAt(out,eye,center,up){var x0=void 0,x1=void 0,x2=void 0,y0=void 0,y1=void 0,y2=void 0,z0=void 0,z1=void 0,z2=void 0,len=void 0,eyex=eye[0],eyey=eye[1],eyez=eye[2],upx=up[0],upy=up[1],upz=up[2],centerx=center[0],centery=center[1],centerz=center[2];return Math.abs(eyex-centerx)<glMatrix.EPSILON&&Math.abs(eyey-centery)<glMatrix.EPSILON&&Math.abs(eyez-centerz)<glMatrix.EPSILON?mat4.identity(out):(z0=eyex-centerx,z1=eyey-centery,z2=eyez-centerz,len=1/Math.sqrt(z0*z0+z1*z1+z2*z2),z0*=len,z1*=len,z2*=len,x0=upy*z2-upz*z1,x1=upz*z0-upx*z2,x2=upx*z1-upy*z0,len=Math.sqrt(x0*x0+x1*x1+x2*x2),len?(len=1/len,x0*=len,x1*=len,x2*=len):(x0=0,x1=0,x2=0),y0=z1*x2-z2*x1,y1=z2*x0-z0*x2,y2=z0*x1-z1*x0,len=Math.sqrt(y0*y0+y1*y1+y2*y2),len?(len=1/len,y0*=len,y1*=len,y2*=len):(y0=0,y1=0,y2=0),out[0]=x0,out[1]=y0,out[2]=z0,out[3]=0,out[4]=x1,out[5]=y1,out[6]=z1,out[7]=0,out[8]=x2,out[9]=y2,out[10]=z2,out[11]=0,out[12]=-(x0*eyex+x1*eyey+x2*eyez),out[13]=-(y0*eyex+y1*eyey+y2*eyez),out[14]=-(z0*eyex+z1*eyey+z2*eyez),out[15]=1,out)}function targetTo(out,eye,target,up){var eyex=eye[0],eyey=eye[1],eyez=eye[2],upx=up[0],upy=up[1],upz=up[2],z0=eyex-target[0],z1=eyey-target[1],z2=eyez-target[2],len=z0*z0+z1*z1+z2*z2;len>0&&(len=1/Math.sqrt(len),z0*=len,z1*=len,z2*=len);var x0=upy*z2-upz*z1,x1=upz*z0-upx*z2,x2=upx*z1-upy*z0;return out[0]=x0,out[1]=x1,out[2]=x2,out[3]=0,out[4]=z1*x2-z2*x1,out[5]=z2*x0-z0*x2,out[6]=z0*x1-z1*x0,out[7]=0,out[8]=z0,out[9]=z1,out[10]=z2,out[11]=0,out[12]=eyex,out[13]=eyey,out[14]=eyez,out[15]=1,out}function str(a){return"mat4("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+", "+a[6]+", "+a[7]+", "+a[8]+", "+a[9]+", "+a[10]+", "+a[11]+", "+a[12]+", "+a[13]+", "+a[14]+", "+a[15]+")"}function frob(a){return Math.sqrt(Math.pow(a[0],2)+Math.pow(a[1],2)+Math.pow(a[2],2)+Math.pow(a[3],2)+Math.pow(a[4],2)+Math.pow(a[5],2)+Math.pow(a[6],2)+Math.pow(a[7],2)+Math.pow(a[8],2)+Math.pow(a[9],2)+Math.pow(a[10],2)+Math.pow(a[11],2)+Math.pow(a[12],2)+Math.pow(a[13],2)+Math.pow(a[14],2)+Math.pow(a[15],2))}function add(out,a,b){return out[0]=a[0]+b[0],out[1]=a[1]+b[1],out[2]=a[2]+b[2],out[3]=a[3]+b[3],out[4]=a[4]+b[4],out[5]=a[5]+b[5],out[6]=a[6]+b[6],out[7]=a[7]+b[7],out[8]=a[8]+b[8],out[9]=a[9]+b[9],out[10]=a[10]+b[10],out[11]=a[11]+b[11],out[12]=a[12]+b[12],out[13]=a[13]+b[13],out[14]=a[14]+b[14],out[15]=a[15]+b[15],out}function subtract(out,a,b){return out[0]=a[0]-b[0],out[1]=a[1]-b[1],out[2]=a[2]-b[2],out[3]=a[3]-b[3],out[4]=a[4]-b[4],out[5]=a[5]-b[5],out[6]=a[6]-b[6],out[7]=a[7]-b[7],out[8]=a[8]-b[8],out[9]=a[9]-b[9],out[10]=a[10]-b[10],out[11]=a[11]-b[11],out[12]=a[12]-b[12],out[13]=a[13]-b[13],out[14]=a[14]-b[14],out[15]=a[15]-b[15],out}function multiplyScalar(out,a,b){return out[0]=a[0]*b,out[1]=a[1]*b,out[2]=a[2]*b,out[3]=a[3]*b,out[4]=a[4]*b,out[5]=a[5]*b,out[6]=a[6]*b,out[7]=a[7]*b,out[8]=a[8]*b,out[9]=a[9]*b,out[10]=a[10]*b,out[11]=a[11]*b,out[12]=a[12]*b,out[13]=a[13]*b,out[14]=a[14]*b,out[15]=a[15]*b,out}function multiplyScalarAndAdd(out,a,b,scale){return out[0]=a[0]+b[0]*scale,out[1]=a[1]+b[1]*scale,out[2]=a[2]+b[2]*scale,out[3]=a[3]+b[3]*scale,out[4]=a[4]+b[4]*scale,out[5]=a[5]+b[5]*scale,out[6]=a[6]+b[6]*scale,out[7]=a[7]+b[7]*scale,out[8]=a[8]+b[8]*scale,out[9]=a[9]+b[9]*scale,out[10]=a[10]+b[10]*scale,out[11]=a[11]+b[11]*scale,out[12]=a[12]+b[12]*scale,out[13]=a[13]+b[13]*scale,out[14]=a[14]+b[14]*scale,out[15]=a[15]+b[15]*scale,out}function exactEquals(a,b){return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2]&&a[3]===b[3]&&a[4]===b[4]&&a[5]===b[5]&&a[6]===b[6]&&a[7]===b[7]&&a[8]===b[8]&&a[9]===b[9]&&a[10]===b[10]&&a[11]===b[11]&&a[12]===b[12]&&a[13]===b[13]&&a[14]===b[14]&&a[15]===b[15]}function equals(a,b){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],a4=a[4],a5=a[5],a6=a[6],a7=a[7],a8=a[8],a9=a[9],a10=a[10],a11=a[11],a12=a[12],a13=a[13],a14=a[14],a15=a[15],b0=b[0],b1=b[1],b2=b[2],b3=b[3],b4=b[4],b5=b[5],b6=b[6],b7=b[7],b8=b[8],b9=b[9],b10=b[10],b11=b[11],b12=b[12],b13=b[13],b14=b[14],b15=b[15];return Math.abs(a0-b0)<=glMatrix.EPSILON*Math.max(1,Math.abs(a0),Math.abs(b0))&&Math.abs(a1-b1)<=glMatrix.EPSILON*Math.max(1,Math.abs(a1),Math.abs(b1))&&Math.abs(a2-b2)<=glMatrix.EPSILON*Math.max(1,Math.abs(a2),Math.abs(b2))&&Math.abs(a3-b3)<=glMatrix.EPSILON*Math.max(1,Math.abs(a3),Math.abs(b3))&&Math.abs(a4-b4)<=glMatrix.EPSILON*Math.max(1,Math.abs(a4),Math.abs(b4))&&Math.abs(a5-b5)<=glMatrix.EPSILON*Math.max(1,Math.abs(a5),Math.abs(b5))&&Math.abs(a6-b6)<=glMatrix.EPSILON*Math.max(1,Math.abs(a6),Math.abs(b6))&&Math.abs(a7-b7)<=glMatrix.EPSILON*Math.max(1,Math.abs(a7),Math.abs(b7))&&Math.abs(a8-b8)<=glMatrix.EPSILON*Math.max(1,Math.abs(a8),Math.abs(b8))&&Math.abs(a9-b9)<=glMatrix.EPSILON*Math.max(1,Math.abs(a9),Math.abs(b9))&&Math.abs(a10-b10)<=glMatrix.EPSILON*Math.max(1,Math.abs(a10),Math.abs(b10))&&Math.abs(a11-b11)<=glMatrix.EPSILON*Math.max(1,Math.abs(a11),Math.abs(b11))&&Math.abs(a12-b12)<=glMatrix.EPSILON*Math.max(1,Math.abs(a12),Math.abs(b12))&&Math.abs(a13-b13)<=glMatrix.EPSILON*Math.max(1,Math.abs(a13),Math.abs(b13))&&Math.abs(a14-b14)<=glMatrix.EPSILON*Math.max(1,Math.abs(a14),Math.abs(b14))&&Math.abs(a15-b15)<=glMatrix.EPSILON*Math.max(1,Math.abs(a15),Math.abs(b15))}Object.defineProperty(exports,"__esModule",{value:!0}),exports.sub=exports.mul=void 0,exports.create=create,exports.clone=clone,exports.copy=copy,exports.fromValues=fromValues,exports.set=set,exports.identity=identity,exports.transpose=transpose,exports.invert=invert,exports.adjoint=adjoint,exports.determinant=determinant,exports.multiply=multiply,exports.translate=translate,exports.scale=scale,exports.rotate=rotate,exports.rotateX=rotateX,exports.rotateY=rotateY,exports.rotateZ=rotateZ,exports.fromTranslation=fromTranslation,exports.fromScaling=fromScaling,exports.fromRotation=fromRotation,exports.fromXRotation=fromXRotation,exports.fromYRotation=fromYRotation,exports.fromZRotation=fromZRotation,exports.fromRotationTranslation=fromRotationTranslation,exports.getTranslation=getTranslation,exports.getScaling=getScaling,exports.getRotation=getRotation,exports.fromRotationTranslationScale=fromRotationTranslationScale,exports.fromRotationTranslationScaleOrigin=fromRotationTranslationScaleOrigin,exports.fromQuat=fromQuat,exports.frustum=frustum,exports.perspective=perspective,exports.perspectiveFromFieldOfView=perspectiveFromFieldOfView,exports.ortho=ortho,exports.lookAt=lookAt,exports.targetTo=targetTo,exports.str=str,exports.frob=frob,exports.add=add,exports.subtract=subtract,exports.multiplyScalar=multiplyScalar,exports.multiplyScalarAndAdd=multiplyScalarAndAdd,exports.exactEquals=exactEquals,exports.equals=equals;var _common=__webpack_require__(3),glMatrix=function(obj){if(obj&&obj.__esModule)return obj;var newObj={};if(null!=obj)for(var key in obj)Object.prototype.hasOwnProperty.call(obj,key)&&(newObj[key]=obj[key]);return newObj.default=obj,newObj}(_common);exports.mul=multiply,exports.sub=subtract},function(module,exports,__webpack_require__){"use strict";function _interopRequireWildcard(obj){if(obj&&obj.__esModule)return obj;var newObj={};if(null!=obj)for(var key in obj)Object.prototype.hasOwnProperty.call(obj,key)&&(newObj[key]=obj[key]);return newObj.default=obj,newObj}function create(){var out=new glMatrix.ARRAY_TYPE(4);return out[0]=0,out[1]=0,out[2]=0,out[3]=1,out}function identity(out){return out[0]=0,out[1]=0,out[2]=0,out[3]=1,out}function setAxisAngle(out,axis,rad){rad*=.5;var s=Math.sin(rad);return out[0]=s*axis[0],out[1]=s*axis[1],out[2]=s*axis[2],out[3]=Math.cos(rad),out}function getAxisAngle(out_axis,q){var rad=2*Math.acos(q[3]),s=Math.sin(rad/2);return 0!=s?(out_axis[0]=q[0]/s,out_axis[1]=q[1]/s,out_axis[2]=q[2]/s):(out_axis[0]=1,out_axis[1]=0,out_axis[2]=0),rad}function multiply(out,a,b){var ax=a[0],ay=a[1],az=a[2],aw=a[3],bx=b[0],by=b[1],bz=b[2],bw=b[3];return out[0]=ax*bw+aw*bx+ay*bz-az*by,out[1]=ay*bw+aw*by+az*bx-ax*bz,out[2]=az*bw+aw*bz+ax*by-ay*bx,out[3]=aw*bw-ax*bx-ay*by-az*bz,out}function rotateX(out,a,rad){rad*=.5;var ax=a[0],ay=a[1],az=a[2],aw=a[3],bx=Math.sin(rad),bw=Math.cos(rad);return out[0]=ax*bw+aw*bx,out[1]=ay*bw+az*bx,out[2]=az*bw-ay*bx,out[3]=aw*bw-ax*bx,out}function rotateY(out,a,rad){rad*=.5;var ax=a[0],ay=a[1],az=a[2],aw=a[3],by=Math.sin(rad),bw=Math.cos(rad);return out[0]=ax*bw-az*by,out[1]=ay*bw+aw*by,out[2]=az*bw+ax*by,out[3]=aw*bw-ay*by,out}function rotateZ(out,a,rad){rad*=.5;var ax=a[0],ay=a[1],az=a[2],aw=a[3],bz=Math.sin(rad),bw=Math.cos(rad);return out[0]=ax*bw+ay*bz,out[1]=ay*bw-ax*bz,out[2]=az*bw+aw*bz,out[3]=aw*bw-az*bz,out}function calculateW(out,a){var x=a[0],y=a[1],z=a[2];return out[0]=x,out[1]=y,out[2]=z,out[3]=Math.sqrt(Math.abs(1-x*x-y*y-z*z)),out}function slerp(out,a,b,t){var ax=a[0],ay=a[1],az=a[2],aw=a[3],bx=b[0],by=b[1],bz=b[2],bw=b[3],omega=void 0,cosom=void 0,sinom=void 0,scale0=void 0,scale1=void 0;return cosom=ax*bx+ay*by+az*bz+aw*bw,cosom<0&&(cosom=-cosom,bx=-bx,by=-by,bz=-bz,bw=-bw),1-cosom>1e-6?(omega=Math.acos(cosom),sinom=Math.sin(omega),scale0=Math.sin((1-t)*omega)/sinom,scale1=Math.sin(t*omega)/sinom):(scale0=1-t,scale1=t),out[0]=scale0*ax+scale1*bx,out[1]=scale0*ay+scale1*by,out[2]=scale0*az+scale1*bz,out[3]=scale0*aw+scale1*bw,out}function invert(out,a){var a0=a[0],a1=a[1],a2=a[2],a3=a[3],dot=a0*a0+a1*a1+a2*a2+a3*a3,invDot=dot?1/dot:0;return out[0]=-a0*invDot,out[1]=-a1*invDot,out[2]=-a2*invDot,out[3]=a3*invDot,out}function conjugate(out,a){return out[0]=-a[0],out[1]=-a[1],out[2]=-a[2],out[3]=a[3],out}function fromMat3(out,m){var fTrace=m[0]+m[4]+m[8],fRoot=void 0;if(fTrace>0)fRoot=Math.sqrt(fTrace+1),out[3]=.5*fRoot,fRoot=.5/fRoot,out[0]=(m[5]-m[7])*fRoot,out[1]=(m[6]-m[2])*fRoot,out[2]=(m[1]-m[3])*fRoot;else{var i=0;m[4]>m[0]&&(i=1),m[8]>m[3*i+i]&&(i=2);var j=(i+1)%3,k=(i+2)%3;fRoot=Math.sqrt(m[3*i+i]-m[3*j+j]-m[3*k+k]+1),out[i]=.5*fRoot,fRoot=.5/fRoot,out[3]=(m[3*j+k]-m[3*k+j])*fRoot,out[j]=(m[3*j+i]+m[3*i+j])*fRoot,out[k]=(m[3*k+i]+m[3*i+k])*fRoot}return out}function fromEuler(out,x,y,z){var halfToRad=.5*Math.PI/180;x*=halfToRad,y*=halfToRad,z*=halfToRad;var sx=Math.sin(x),cx=Math.cos(x),sy=Math.sin(y),cy=Math.cos(y),sz=Math.sin(z),cz=Math.cos(z);return out[0]=sx*cy*cz-cx*sy*sz,out[1]=cx*sy*cz+sx*cy*sz,out[2]=cx*cy*sz-sx*sy*cz,out[3]=cx*cy*cz+sx*sy*sz,out}function str(a){return"quat("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+")"}Object.defineProperty(exports,"__esModule",{value:!0}),exports.setAxes=exports.sqlerp=exports.rotationTo=exports.equals=exports.exactEquals=exports.normalize=exports.sqrLen=exports.squaredLength=exports.len=exports.length=exports.lerp=exports.dot=exports.scale=exports.mul=exports.add=exports.set=exports.copy=exports.fromValues=exports.clone=void 0,exports.create=create,exports.identity=identity,exports.setAxisAngle=setAxisAngle,exports.getAxisAngle=getAxisAngle,exports.multiply=multiply,exports.rotateX=rotateX,exports.rotateY=rotateY,exports.rotateZ=rotateZ,exports.calculateW=calculateW,exports.slerp=slerp,exports.invert=invert,exports.conjugate=conjugate,exports.fromMat3=fromMat3,exports.fromEuler=fromEuler,exports.str=str;var _common=__webpack_require__(3),glMatrix=_interopRequireWildcard(_common),_mat=__webpack_require__(20),mat3=_interopRequireWildcard(_mat),_vec=__webpack_require__(21),vec3=_interopRequireWildcard(_vec),_vec2=__webpack_require__(22),vec4=_interopRequireWildcard(_vec2),length=(exports.clone=vec4.clone,exports.fromValues=vec4.fromValues,exports.copy=vec4.copy,exports.set=vec4.set,exports.add=vec4.add,exports.mul=multiply,exports.scale=vec4.scale,exports.dot=vec4.dot,exports.lerp=vec4.lerp,exports.length=vec4.length),squaredLength=(exports.len=length,exports.squaredLength=vec4.squaredLength),normalize=(exports.sqrLen=squaredLength,exports.normalize=vec4.normalize);exports.exactEquals=vec4.exactEquals,exports.equals=vec4.equals,exports.rotationTo=function(){var tmpvec3=vec3.create(),xUnitVec3=vec3.fromValues(1,0,0),yUnitVec3=vec3.fromValues(0,1,0);return function(out,a,b){var dot=vec3.dot(a,b);return dot<-.999999?(vec3.cross(tmpvec3,xUnitVec3,a),vec3.len(tmpvec3)<1e-6&&vec3.cross(tmpvec3,yUnitVec3,a),vec3.normalize(tmpvec3,tmpvec3),setAxisAngle(out,tmpvec3,Math.PI),out):dot>.999999?(out[0]=0,out[1]=0,out[2]=0,out[3]=1,out):(vec3.cross(tmpvec3,a,b),out[0]=tmpvec3[0],out[1]=tmpvec3[1],out[2]=tmpvec3[2],out[3]=1+dot,normalize(out,out))}}(),exports.sqlerp=function(){var temp1=create(),temp2=create();return function(out,a,b,c,d,t){return slerp(temp1,a,d,t),slerp(temp2,b,c,t),slerp(out,temp1,temp2,2*t*(1-t)),out}}(),exports.setAxes=function(){var matr=mat3.create();return function(out,view,right,up){return matr[0]=right[0],matr[3]=right[1],matr[6]=right[2],matr[1]=up[0],matr[4]=up[1],matr[7]=up[2],matr[2]=-view[0],matr[5]=-view[1],matr[8]=-view[2],normalize(out,fromMat3(out,matr))}}()},function(module,exports,__webpack_require__){"use strict";function create(){var out=new glMatrix.ARRAY_TYPE(2);return out[0]=0,out[1]=0,out}function clone(a){var out=new glMatrix.ARRAY_TYPE(2);return out[0]=a[0],out[1]=a[1],out}function fromValues(x,y){var out=new glMatrix.ARRAY_TYPE(2);return out[0]=x,out[1]=y,out}function copy(out,a){return out[0]=a[0],out[1]=a[1],out}function set(out,x,y){return out[0]=x,out[1]=y,out}function add(out,a,b){return out[0]=a[0]+b[0],out[1]=a[1]+b[1],out}function subtract(out,a,b){return out[0]=a[0]-b[0],out[1]=a[1]-b[1],out}function multiply(out,a,b){return out[0]=a[0]*b[0],out[1]=a[1]*b[1],out}function divide(out,a,b){return out[0]=a[0]/b[0],out[1]=a[1]/b[1],out}function ceil(out,a){return out[0]=Math.ceil(a[0]),out[1]=Math.ceil(a[1]),out}function floor(out,a){return out[0]=Math.floor(a[0]),out[1]=Math.floor(a[1]),out}function min(out,a,b){return out[0]=Math.min(a[0],b[0]),out[1]=Math.min(a[1],b[1]),out}function max(out,a,b){return out[0]=Math.max(a[0],b[0]),out[1]=Math.max(a[1],b[1]),out}function round(out,a){return out[0]=Math.round(a[0]),out[1]=Math.round(a[1]),out}function scale(out,a,b){return out[0]=a[0]*b,out[1]=a[1]*b,out}function scaleAndAdd(out,a,b,scale){return out[0]=a[0]+b[0]*scale,out[1]=a[1]+b[1]*scale,out}function distance(a,b){var x=b[0]-a[0],y=b[1]-a[1];return Math.sqrt(x*x+y*y)}function squaredDistance(a,b){var x=b[0]-a[0],y=b[1]-a[1];return x*x+y*y}function length(a){var x=a[0],y=a[1];return Math.sqrt(x*x+y*y)}function squaredLength(a){var x=a[0],y=a[1];return x*x+y*y}function negate(out,a){return out[0]=-a[0],out[1]=-a[1],out}function inverse(out,a){return out[0]=1/a[0],out[1]=1/a[1],out}function normalize(out,a){var x=a[0],y=a[1],len=x*x+y*y;return len>0&&(len=1/Math.sqrt(len),out[0]=a[0]*len,out[1]=a[1]*len),out}function dot(a,b){return a[0]*b[0]+a[1]*b[1]}function cross(out,a,b){var z=a[0]*b[1]-a[1]*b[0];return out[0]=out[1]=0,out[2]=z,out}function lerp(out,a,b,t){var ax=a[0],ay=a[1];return out[0]=ax+t*(b[0]-ax),out[1]=ay+t*(b[1]-ay),out}function random(out,scale){scale=scale||1;var r=2*glMatrix.RANDOM()*Math.PI;return out[0]=Math.cos(r)*scale,out[1]=Math.sin(r)*scale,out}function transformMat2(out,a,m){var x=a[0],y=a[1];return out[0]=m[0]*x+m[2]*y,out[1]=m[1]*x+m[3]*y,out}function transformMat2d(out,a,m){var x=a[0],y=a[1];return out[0]=m[0]*x+m[2]*y+m[4],out[1]=m[1]*x+m[3]*y+m[5],out}function transformMat3(out,a,m){var x=a[0],y=a[1];return out[0]=m[0]*x+m[3]*y+m[6],out[1]=m[1]*x+m[4]*y+m[7],out}function transformMat4(out,a,m){var x=a[0],y=a[1];return out[0]=m[0]*x+m[4]*y+m[12],out[1]=m[1]*x+m[5]*y+m[13],out}function str(a){return"vec2("+a[0]+", "+a[1]+")"}function exactEquals(a,b){return a[0]===b[0]&&a[1]===b[1]}function equals(a,b){var a0=a[0],a1=a[1],b0=b[0],b1=b[1];return Math.abs(a0-b0)<=glMatrix.EPSILON*Math.max(1,Math.abs(a0),Math.abs(b0))&&Math.abs(a1-b1)<=glMatrix.EPSILON*Math.max(1,Math.abs(a1),Math.abs(b1))}Object.defineProperty(exports,"__esModule",{value:!0}),exports.forEach=exports.sqrLen=exports.sqrDist=exports.dist=exports.div=exports.mul=exports.sub=exports.len=void 0,exports.create=create,exports.clone=clone,exports.fromValues=fromValues,exports.copy=copy,exports.set=set,exports.add=add,exports.subtract=subtract,exports.multiply=multiply,exports.divide=divide,exports.ceil=ceil,exports.floor=floor,exports.min=min,exports.max=max,exports.round=round,exports.scale=scale,exports.scaleAndAdd=scaleAndAdd,exports.distance=distance,exports.squaredDistance=squaredDistance,exports.length=length,exports.squaredLength=squaredLength,exports.negate=negate,exports.inverse=inverse,exports.normalize=normalize,exports.dot=dot,exports.cross=cross,exports.lerp=lerp,exports.random=random,exports.transformMat2=transformMat2,exports.transformMat2d=transformMat2d,exports.transformMat3=transformMat3,exports.transformMat4=transformMat4,exports.str=str,exports.exactEquals=exactEquals,exports.equals=equals;var _common=__webpack_require__(3),glMatrix=function(obj){if(obj&&obj.__esModule)return obj;var newObj={};if(null!=obj)for(var key in obj)Object.prototype.hasOwnProperty.call(obj,key)&&(newObj[key]=obj[key]);return newObj.default=obj,newObj}(_common);exports.len=length,exports.sub=subtract,exports.mul=multiply,exports.div=divide,exports.dist=distance,exports.sqrDist=squaredDistance,exports.sqrLen=squaredLength,exports.forEach=function(){var vec=create();return function(a,stride,offset,count,fn,arg){var i=void 0,l=void 0;for(stride||(stride=2),offset||(offset=0),l=count?Math.min(count*stride+offset,a.length):a.length,i=offset;i<l;i+=stride)vec[0]=a[i],vec[1]=a[i+1],fn(vec,vec,arg),a[i]=vec[0],a[i+1]=vec[1];return a}}()},function(module,exports,__webpack_require__){"use strict";function getAndApplyExtension(gl,name){var ext=gl.getExtension(name);if(!ext)return!1;var suffix=name.split("_")[0],suffixRE=new RegExp(suffix+"$");for(var key in ext){if("function"==typeof ext[key]){var unsuffixedKey=key.replace(suffixRE,"");key.substring&&(gl[unsuffixedKey]=ext[key].bind(ext))}}return!0}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=getAndApplyExtension},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}Object.defineProperty(exports,"__esModule",{value:!0});var _GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_WebglConst=__webpack_require__(23),_WebglConst2=_interopRequireDefault(_WebglConst),exposeAttributes=function(){for(var s in _WebglConst2.default)_GLTool2.default[s]?console.log("already exist : ",s):_GLTool2.default[s]=_WebglConst2.default[s]};exports.default=exposeAttributes},function(module,exports,__webpack_require__){"use strict";function checkFloat(){return _GLTool2.default.webgl2?_GLTool2.default.gl.FLOAT:_GLTool2.default.getExtension("OES_texture_float")?_GLTool2.default.gl.FLOAT:(console.warn("USING FLOAT BUT OES_texture_float NOT SUPPORTED"),_GLTool2.default.gl.UNSIGNED_BYTE)}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(){return hasChecked||(_float=checkFloat()),_float};var _GLTool=__webpack_require__(0),_GLTool2=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(_GLTool),hasChecked=!1,_float=void 0},function(module,exports,__webpack_require__){"use strict";function checkHalfFloat(){if(_GLTool2.default.webgl2)return _GLTool2.default.gl.HALF_FLOAT;var extHalfFloat=_GLTool2.default.getExtension("OES_texture_half_float");return extHalfFloat?extHalfFloat.HALF_FLOAT_OES:(console.warn("USING HALF FLOAT BUT OES_texture_half_float NOT SUPPORTED"),_GLTool2.default.gl.UNSIGNED_BYTE)}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(){return hasChecked||(halfFloat=checkHalfFloat()),halfFloat};var _GLTool=__webpack_require__(0),_GLTool2=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(_GLTool),hasChecked=!1,halfFloat=void 0},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=["EXT_shader_texture_lod","EXT_sRGB","EXT_frag_depth","OES_texture_float","OES_texture_half_float","OES_texture_float_linear","OES_texture_half_float_linear","OES_standard_derivatives","WEBGL_depth_texture","EXT_texture_filter_anisotropic","OES_vertex_array_object","ANGLE_instanced_arrays","WEBGL_draw_buffers"]},function(module,exports,__webpack_require__){"use strict";module.exports=function(strings){"string"==typeof strings&&(strings=[strings]);for(var exprs=[].slice.call(arguments,1),parts=[],i=0;i<strings.length-1;i++)parts.push(strings[i],exprs[i]||"");return parts.push(strings[i]),parts.join("")}},function(module,exports){module.exports="// basic.frag\n\n#define SHADER_NAME BASIC_FRAGMENT\n\nprecision lowp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform float time;\n// uniform sampler2D texture;\n\nvoid main(void) {\n    gl_FragColor = vec4(vTextureCoord, sin(time) * .5 + .5, 1.0);\n}"},function(module,exports,__webpack_require__){"use strict";function isPowerOfTwo(x){return 0!==x&&!(x&x-1)}Object.defineProperty(exports,"__esModule",{value:!0});var _GLTool=__webpack_require__(0),_GLTool2=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(_GLTool),getTextureParameters=function(mParams,mSource,mWidth,mHeight){if(!mParams.minFilter){var minFilter=_GLTool2.default.LINEAR;mWidth&&mWidth&&isPowerOfTwo(mWidth)&&isPowerOfTwo(mHeight)&&(minFilter=_GLTool2.default.NEAREST_MIPMAP_LINEAR),mParams.minFilter=minFilter}return mParams.mipmap=mParams.mipmap||!0,mParams.magFilter=mParams.magFilter||_GLTool2.default.LINEAR,mParams.wrapS=mParams.wrapS||_GLTool2.default.CLAMP_TO_EDGE,mParams.wrapT=mParams.wrapT||_GLTool2.default.CLAMP_TO_EDGE,mParams.internalFormat=mParams.internalFormat||_GLTool2.default.RGBA,mParams.format=mParams.format||_GLTool2.default.RGBA,mParams.premultiplyAlpha=mParams.premultiplyAlpha||!1,mParams.level=mParams.level||0,mParams.anisotropy=mParams.anisotropy||0,mParams};exports.default=getTextureParameters},function(module,exports,__webpack_require__){"use strict";function parseHeaders(arrayBuffer){var header=new Int32Array(arrayBuffer,0,headerLengthInt);if(header[off_magic]!==DDS_MAGIC)throw new Error("Invalid magic number in DDS header");if(!header[off_pfFlags]&DDPF_FOURCC)throw new Error("Unsupported format, must contain a FourCC code");var blockBytes,format,fourCC=header[off_pfFourCC];switch(fourCC){case FOURCC_DXT1:blockBytes=8,format="dxt1";break;case FOURCC_DXT3:blockBytes=16,format="dxt3";break;case FOURCC_DXT5:blockBytes=16,format="dxt5";break;case FOURCC_FP32F:format="rgba32f";break;case FOURCC_DX10:var dx10Header=new Uint32Array(arrayBuffer.slice(128,148));format=dx10Header[0];var resourceDimension=dx10Header[1];dx10Header[2],dx10Header[3],dx10Header[4];if(resourceDimension!==D3D10_RESOURCE_DIMENSION_TEXTURE2D||format!==DXGI_FORMAT_R32G32B32A32_FLOAT)throw new Error("Unsupported DX10 texture format "+format);format="rgba32f";break;default:throw new Error("Unsupported FourCC code: "+int32ToFourCC(fourCC))}var flags=header[off_flags],mipmapCount=1;flags&DDSD_MIPMAPCOUNT&&(mipmapCount=Math.max(1,header[off_mipmapCount]));var cubemap=!1;header[off_caps2]&DDSCAPS2_CUBEMAP&&(cubemap=!0);var dataLength,width=header[off_width],height=header[off_height],dataOffset=header[off_size]+4,texWidth=width,texHeight=height,images=[];if(fourCC===FOURCC_DX10&&(dataOffset+=20),cubemap)for(var f=0;f<6;f++){if("rgba32f"!==format)throw new Error("Only RGBA32f cubemaps are supported");width=texWidth,height=texHeight;for(var requiredMipLevels=Math.log(width)/Math.log(2)+1,i=0;i<requiredMipLevels;i++)dataLength=width*height*16,images.push({offset:dataOffset,length:dataLength,shape:[width,height]}),i<mipmapCount&&(dataOffset+=dataLength),width=Math.floor(width/2),height=Math.floor(height/2)}else for(var i=0;i<mipmapCount;i++)dataLength=Math.max(4,width)/4*Math.max(4,height)/4*blockBytes,images.push({offset:dataOffset,length:dataLength,shape:[width,height]}),dataOffset+=dataLength,width=Math.floor(width/2),height=Math.floor(height/2);return{shape:[texWidth,texHeight],images:images,format:format,flags:flags,cubemap:cubemap}}function fourCCToInt32(value){return value.charCodeAt(0)+(value.charCodeAt(1)<<8)+(value.charCodeAt(2)<<16)+(value.charCodeAt(3)<<24)}function int32ToFourCC(value){return String.fromCharCode(255&value,value>>8&255,value>>16&255,value>>24&255)}var DDS_MAGIC=542327876,DDSD_MIPMAPCOUNT=131072,DDPF_FOURCC=4,FOURCC_DXT1=fourCCToInt32("DXT1"),FOURCC_DXT3=fourCCToInt32("DXT3"),FOURCC_DXT5=fourCCToInt32("DXT5"),FOURCC_DX10=fourCCToInt32("DX10"),FOURCC_FP32F=116,DDSCAPS2_CUBEMAP=512,D3D10_RESOURCE_DIMENSION_TEXTURE2D=3,DXGI_FORMAT_R32G32B32A32_FLOAT=2,headerLengthInt=31,off_magic=0,off_size=1,off_flags=2,off_height=3,off_width=4,off_mipmapCount=7,off_pfFlags=20,off_pfFourCC=21,off_caps2=28;module.exports=parseHeaders},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_GLCubeTexture=__webpack_require__(27),_GLCubeTexture2=_interopRequireDefault(_GLCubeTexture),gl=void 0,CubeFrameBuffer=function(){function CubeFrameBuffer(size){var mParameters=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};_classCallCheck(this,CubeFrameBuffer),gl=_GLTool2.default.gl,this._size=size,this.magFilter=mParameters.magFilter||gl.LINEAR,this.minFilter=mParameters.minFilter||gl.LINEAR,this.wrapS=mParameters.wrapS||gl.CLAMP_TO_EDGE,this.wrapT=mParameters.wrapT||gl.CLAMP_TO_EDGE,this._init()}return _createClass(CubeFrameBuffer,[{key:"_init",value:function(){this.texture=gl.createTexture(),this.glTexture=new _GLCubeTexture2.default(this.texture,{},!0),gl.bindTexture(gl.TEXTURE_CUBE_MAP,this.texture),gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_MAG_FILTER,this.magFilter),gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_MIN_FILTER,this.minFilter),gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_WRAP_S,this.wrapS),gl.texParameteri(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_WRAP_T,this.wrapT);for(var targets=[gl.TEXTURE_CUBE_MAP_POSITIVE_X,gl.TEXTURE_CUBE_MAP_NEGATIVE_X,gl.TEXTURE_CUBE_MAP_POSITIVE_Y,gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,gl.TEXTURE_CUBE_MAP_POSITIVE_Z,gl.TEXTURE_CUBE_MAP_NEGATIVE_Z],i=0;i<targets.length;i++)gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,!1),gl.texImage2D(targets[i],0,gl.RGBA,this.width,this.height,0,gl.RGBA,gl.FLOAT,null);this._frameBuffers=[];for(var _i=0;_i<targets.length;_i++){var frameBuffer=gl.createFramebuffer();gl.bindFramebuffer(gl.FRAMEBUFFER,frameBuffer),gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,targets[_i],this.texture,0);var status=gl.checkFramebufferStatus(gl.FRAMEBUFFER);status!==gl.FRAMEBUFFER_COMPLETE&&console.log("'gl.checkFramebufferStatus() returned '"+status),this._frameBuffers.push(frameBuffer)}gl.bindFramebuffer(gl.FRAMEBUFFER,null),gl.bindRenderbuffer(gl.RENDERBUFFER,null),gl.bindTexture(gl.TEXTURE_CUBE_MAP,null)}},{key:"bind",value:function(mTargetIndex){_GLTool2.default.viewport(0,0,this.width,this.height),gl.bindFramebuffer(gl.FRAMEBUFFER,this._frameBuffers[mTargetIndex])}},{key:"unbind",value:function(){gl.bindFramebuffer(gl.FRAMEBUFFER,null),_GLTool2.default.viewport(0,0,_GLTool2.default.width,_GLTool2.default.height)}},{key:"getTexture",value:function(){return this.glTexture}},{key:"width",get:function(){return this._size}},{key:"height",get:function(){return this._size}}]),CubeFrameBuffer}();exports.default=CubeFrameBuffer},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function isPowerOfTwo(x){return 0!==x&&!(x&x-1)}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_GLTexture=__webpack_require__(25),_GLTexture2=_interopRequireDefault(_GLTexture),gl=void 0,MultisampleFrameBuffer=function(){function MultisampleFrameBuffer(mWidth,mHeight){var mParameters=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};_classCallCheck(this,MultisampleFrameBuffer),gl=_GLTool2.default.gl,this.width=mWidth,this.height=mHeight,this.magFilter=mParameters.magFilter||gl.LINEAR,this.minFilter=mParameters.minFilter||gl.LINEAR,this.wrapS=mParameters.wrapS||gl.CLAMP_TO_EDGE,this.wrapT=mParameters.wrapT||gl.CLAMP_TO_EDGE,this.useDepth=mParameters.useDepth||!0,this.useStencil=mParameters.useStencil||!1,this.texelType=mParameters.type,this._numSample=mParameters.numSample||8,isPowerOfTwo(this.width)&&isPowerOfTwo(this.height)||(this.wrapS=this.wrapT=gl.CLAMP_TO_EDGE,this.minFilter===gl.LINEAR_MIPMAP_NEAREST&&(this.minFilter=gl.LINEAR)),this._init()}return _createClass(MultisampleFrameBuffer,[{key:"_init",value:function(){var texelType=gl.UNSIGNED_BYTE;this.texelType&&(texelType=this.texelType),this.texelType=texelType,this.frameBuffer=gl.createFramebuffer(),this.frameBufferColor=gl.createFramebuffer(),this.renderBufferColor=gl.createRenderbuffer(),this.renderBufferDepth=gl.createRenderbuffer(),this.glTexture=this._createTexture(),this.glDepthTexture=this._createTexture(gl.DEPTH_COMPONENT16,gl.UNSIGNED_SHORT,gl.DEPTH_COMPONENT,!0),gl.bindRenderbuffer(gl.RENDERBUFFER,this.renderBufferColor),gl.renderbufferStorageMultisample(gl.RENDERBUFFER,this._numSample,gl.RGBA8,this.width,this.height),gl.bindRenderbuffer(gl.RENDERBUFFER,this.renderBufferDepth),gl.renderbufferStorageMultisample(gl.RENDERBUFFER,this._numSample,gl.DEPTH_COMPONENT16,this.width,this.height),gl.bindFramebuffer(gl.FRAMEBUFFER,this.frameBuffer),gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.RENDERBUFFER,this.renderBufferColor),gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_ATTACHMENT,gl.RENDERBUFFER,this.renderBufferDepth),gl.bindFramebuffer(gl.FRAMEBUFFER,null),gl.bindFramebuffer(gl.FRAMEBUFFER,this.frameBufferColor),gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,this.glTexture.texture,0),gl.bindFramebuffer(gl.FRAMEBUFFER,null)}},{key:"_createTexture",value:function(mInternalformat,mTexelType,mFormat){var forceNearest=arguments.length>3&&void 0!==arguments[3]&&arguments[3];void 0===mInternalformat&&(mInternalformat=gl.RGBA),void 0===mTexelType&&(mTexelType=this.texelType),mFormat||(mFormat=mInternalformat);var t=gl.createTexture(),glt=new _GLTexture2.default(t,!0),magFilter=forceNearest?_GLTool2.default.NEAREST:this.magFilter,minFilter=forceNearest?_GLTool2.default.NEAREST:this.minFilter;return gl.bindTexture(gl.TEXTURE_2D,t),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,magFilter),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,minFilter),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,this.wrapS),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,this.wrapT),gl.texImage2D(gl.TEXTURE_2D,0,mInternalformat,this.width,this.height,0,mFormat,mTexelType,null),gl.bindTexture(gl.TEXTURE_2D,null),glt}},{key:"bind",value:function(){(!(arguments.length>0&&void 0!==arguments[0])||arguments[0])&&_GLTool2.default.viewport(0,0,this.width,this.height),gl.bindFramebuffer(gl.FRAMEBUFFER,this.frameBuffer)}},{key:"unbind",value:function(){(!(arguments.length>0&&void 0!==arguments[0])||arguments[0])&&_GLTool2.default.viewport(0,0,_GLTool2.default.width,_GLTool2.default.height);var width=this.width,height=this.height;gl.bindFramebuffer(gl.FRAMEBUFFER,null),gl.bindFramebuffer(gl.READ_FRAMEBUFFER,this.frameBuffer),gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER,this.frameBufferColor),gl.clearBufferfv(gl.COLOR,0,[0,0,0,0]),gl.blitFramebuffer(0,0,width,height,0,0,width,height,gl.COLOR_BUFFER_BIT,_GLTool2.default.NEAREST),gl.bindFramebuffer(gl.FRAMEBUFFER,null)}},{key:"getTexture",value:function(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this.glTexture}},{key:"getDepthTexture",value:function(){return this.glDepthTexture}}]),MultisampleFrameBuffer}();exports.default=MultisampleFrameBuffer},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_GLShader=__webpack_require__(2),_GLShader2=_interopRequireDefault(_GLShader),_Mesh=__webpack_require__(5),_Mesh2=_interopRequireDefault(_Mesh),gl=void 0,TransformFeedbackObject=function(){function TransformFeedbackObject(strVertexShader,strFragmentShader){_classCallCheck(this,TransformFeedbackObject),gl=_GLTool2.default.gl,this._vs=strVertexShader,this._fs=strFragmentShader,this._init()}return _createClass(TransformFeedbackObject,[{key:"_init",value:function(){this._meshCurrent=new _Mesh2.default,this._meshTarget=new _Mesh2.default,this._numPoints=-1,this._varyings=[],this.transformFeedback=gl.createTransformFeedback()}},{key:"bufferData",value:function(mData,mName,mVaryingName){var isTransformFeedback=!!mVaryingName;console.log("is Transform feedback ?",mName,isTransformFeedback),this._meshCurrent.bufferData(mData,mName,null,gl.STREAM_COPY,!1),this._meshTarget.bufferData(mData,mName,null,gl.STREAM_COPY,!1),isTransformFeedback&&(this._varyings.push(mVaryingName),this._numPoints<0&&(this._numPoints=mData.length))}},{key:"bufferIndex",value:function(mArrayIndices){this._meshCurrent.bufferIndex(mArrayIndices),this._meshTarget.bufferIndex(mArrayIndices)}},{key:"uniform",value:function(mName,mType,mValue){this.shader&&this.shader.uniform(mName,mType,mValue)}},{key:"generate",value:function(){this.shader=new _GLShader2.default(this._vs,this._fs,this._varyings)}},{key:"render",value:function(){this.shader||this.generate(),this.shader.bind(),_GLTool2.default.drawTransformFeedback(this),this._swap()}},{key:"_swap",value:function(){var tmp=this._meshCurrent;this._meshCurrent=this._meshTarget,this._meshTarget=tmp}},{key:"numPoints",get:function(){return this._numPoints}},{key:"meshCurrent",get:function(){return this._meshCurrent}},{key:"meshTarget",get:function(){return this._meshTarget}},{key:"meshSource",get:function(){return this._meshCurrent}},{key:"meshDestination",get:function(){return this._meshTarget}}]),TransformFeedbackObject}();exports.default=TransformFeedbackObject},function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function getFunc(mEasing){switch(mEasing){default:case"linear":return Easing.Linear.None;case"expIn":return Easing.Exponential.In;case"expOut":return Easing.Exponential.Out;case"expInOut":return Easing.Exponential.InOut;case"cubicIn":return Easing.Cubic.In;case"cubicOut":return Easing.Cubic.Out;case"cubicInOut":return Easing.Cubic.InOut;case"quarticIn":return Easing.Quartic.In;case"quarticOut":return Easing.Quartic.Out;case"quarticInOut":return Easing.Quartic.InOut;case"quinticIn":return Easing.Quintic.In;case"quinticOut":return Easing.Quintic.Out;case"quinticInOut":return Easing.Quintic.InOut;case"sinusoidalIn":return Easing.Sinusoidal.In;case"sinusoidalOut":return Easing.Sinusoidal.Out;case"sinusoidalInOut":return Easing.Sinusoidal.InOut;case"circularIn":return Easing.Circular.In;case"circularOut":return Easing.Circular.Out;case"circularInOut":return Easing.Circular.InOut;case"elasticIn":return Easing.Elastic.In;case"elasticOut":return Easing.Elastic.Out;case"elasticInOut":return Easing.Elastic.InOut;case"backIn":return Easing.Back.In;case"backOut":return Easing.Back.Out;case"backInOut":return Easing.Back.InOut;case"bounceIn":return Easing.Bounce.in;case"bounceOut":return Easing.Bounce.out;case"bounceInOut":return Easing.Bounce.inOut}}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_scheduling=__webpack_require__(6),_scheduling2=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(_scheduling),Easing={Linear:{None:function(k){return k}},Quadratic:{In:function(k){return k*k},Out:function(k){return k*(2-k)},InOut:function(k){return(k*=2)<1?.5*k*k:-.5*(--k*(k-2)-1)}},Cubic:{In:function(k){return k*k*k},Out:function(k){return--k*k*k+1},InOut:function(k){return(k*=2)<1?.5*k*k*k:.5*((k-=2)*k*k+2)}},Quartic:{In:function(k){return k*k*k*k},Out:function(k){return 1- --k*k*k*k},InOut:function(k){return(k*=2)<1?.5*k*k*k*k:-.5*((k-=2)*k*k*k-2)}},Quintic:{In:function(k){return k*k*k*k*k},Out:function(k){return--k*k*k*k*k+1},InOut:function(k){return(k*=2)<1?.5*k*k*k*k*k:.5*((k-=2)*k*k*k*k+2)}},Sinusoidal:{In:function(k){return 1-Math.cos(k*Math.PI/2)},Out:function(k){return Math.sin(k*Math.PI/2)},InOut:function(k){return.5*(1-Math.cos(Math.PI*k))}},Exponential:{In:function(k){return 0===k?0:Math.pow(1024,k-1)},Out:function(k){return 1===k?1:1-Math.pow(2,-10*k)},InOut:function(k){return 0===k?0:1===k?1:(k*=2)<1?.5*Math.pow(1024,k-1):.5*(2-Math.pow(2,-10*(k-1)))}},Circular:{In:function(k){return 1-Math.sqrt(1-k*k)},Out:function(k){return Math.sqrt(1- --k*k)},InOut:function(k){return(k*=2)<1?-.5*(Math.sqrt(1-k*k)-1):.5*(Math.sqrt(1-(k-=2)*k)+1)}},Elastic:{In:function(k){var s=void 0,a=.1;return 0===k?0:1===k?1:(!a||a<1?(a=1,s=.1):s=.4*Math.asin(1/a)/(2*Math.PI),-a*Math.pow(2,10*(k-=1))*Math.sin((k-s)*(2*Math.PI)/.4))},Out:function(k){var s=void 0,a=.1;return 0===k?0:1===k?1:(!a||a<1?(a=1,s=.1):s=.4*Math.asin(1/a)/(2*Math.PI),a*Math.pow(2,-10*k)*Math.sin((k-s)*(2*Math.PI)/.4)+1)},InOut:function(k){var s=void 0,a=.1;return 0===k?0:1===k?1:(!a||a<1?(a=1,s=.1):s=.4*Math.asin(1/a)/(2*Math.PI),(k*=2)<1?a*Math.pow(2,10*(k-=1))*Math.sin((k-s)*(2*Math.PI)/.4)*-.5:a*Math.pow(2,-10*(k-=1))*Math.sin((k-s)*(2*Math.PI)/.4)*.5+1)}},Back:{In:function(k){var s=1.70158;return k*k*((s+1)*k-s)},Out:function(k){var s=1.70158;return--k*k*((s+1)*k+s)+1},InOut:function(k){var s=2.5949095;return(k*=2)<1?k*k*((s+1)*k-s)*.5:.5*((k-=2)*k*((s+1)*k+s)+2)}},Bounce:{in:function(k){return 1-Easing.Bounce.out(1-k)},out:function(k){return k<1/2.75?7.5625*k*k:k<2/2.75?7.5625*(k-=1.5/2.75)*k+.75:k<2.5/2.75?7.5625*(k-=2.25/2.75)*k+.9375:7.5625*(k-=2.625/2.75)*k+.984375},inOut:function(k){return k<.5?.5*Easing.Bounce.in(2*k):.5*Easing.Bounce.out(2*k-1)+.5}}},TweenNumber=function(){function TweenNumber(mValue){var _this=this,mEasing=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"expOut",mSpeed=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.01;_classCallCheck(this,TweenNumber),this._value=mValue,this._startValue=mValue,this._targetValue=mValue,this._counter=1,this.speed=mSpeed,this.easing=mEasing,this._needUpdate=!0,this._efIndex=_scheduling2.default.addEF(function(){return _this._update()})}return _createClass(TweenNumber,[{key:"_update",value:function(){var newCounter=this._counter+this.speed;if(newCounter>1&&(newCounter=1),this._counter===newCounter)return void(this._needUpdate=!1);this._counter=newCounter,this._needUpdate=!0}},{key:"limit",value:function(mMin,mMax){if(mMin>mMax)return void this.limit(mMax,mMin);this._min=mMin,this._max=mMax,this._checkLimit()}},{key:"setTo",value:function(mValue){this._value=mValue,this._targetValue=mValue,this._counter=1}},{key:"_checkLimit",value:function(){void 0!==this._min&&this._targetValue<this._min&&(this._targetValue=this._min),void 0!==this._max&&this._targetValue>this._max&&(this._targetValue=this._max)}},{key:"destroy",value:function(){_scheduling2.default.removeEF(this._efIndex)}},{key:"value",set:function(mValue){this._startValue=this._value,this._targetValue=mValue,this._checkLimit(),this._counter=0},get:function(){if(this._needUpdate){var f=getFunc(this.easing),p=f(this._counter);this._value=this._startValue+p*(this._targetValue-this._startValue),this._needUpdate=!1}return this._value}},{key:"targetValue",get:function(){return this._targetValue}}]),TweenNumber}();exports.default=TweenNumber},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_glMatrix=__webpack_require__(1),_glMatrix2=_interopRequireDefault(_glMatrix),_EaseNumber=__webpack_require__(13),_EaseNumber2=_interopRequireDefault(_EaseNumber),_scheduling=__webpack_require__(6),_scheduling2=_interopRequireDefault(_scheduling),getMouse=function(mEvent,mTarget){var o=mTarget||{};return mEvent.touches?(o.x=mEvent.touches[0].pageX,o.y=mEvent.touches[0].pageY):(o.x=mEvent.clientX,o.y=mEvent.clientY),o},QuatRotation=function(){function QuatRotation(mTarget){var _this=this,mListenerTarget=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window,mEasing=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;_classCallCheck(this,QuatRotation),this._target=mTarget,this._listenerTarget=mListenerTarget,this.matrix=_glMatrix2.default.mat4.create(),this.m=_glMatrix2.default.mat4.create(),this._vZaxis=_glMatrix2.default.vec3.clone([0,0,0]),this._zAxis=_glMatrix2.default.vec3.clone([0,0,1]),this.preMouse={x:0,y:0},this.mouse={x:0,y:0},this._isMouseDown=!1,this._rotation=_glMatrix2.default.quat.create(),this.tempRotation=_glMatrix2.default.quat.create(),this._rotateZMargin=0,this._offset=.004,this._slerp=-1,this._isLocked=!1,this._diffX=new _EaseNumber2.default(0,mEasing),this._diffY=new _EaseNumber2.default(0,mEasing),this._listenerTarget.addEventListener("mousedown",function(e){return _this._onDown(e)}),this._listenerTarget.addEventListener("touchstart",function(e){return _this._onDown(e)}),this._listenerTarget.addEventListener("mousemove",function(e){return _this._onMove(e)}),this._listenerTarget.addEventListener("touchmove",function(e){return _this._onMove(e)}),window.addEventListener("touchend",function(){return _this._onUp()}),window.addEventListener("mouseup",function(){return _this._onUp()}),_scheduling2.default.addEF(function(){return _this._loop()})}return _createClass(QuatRotation,[{key:"inverseControl",value:function(){var isInvert=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this._isInvert=isInvert}},{key:"lock",value:function(){var mValue=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this._isLocked=mValue}},{key:"setCameraPos",value:function(mQuat){var speed=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;if(this.easing=speed,!(this._slerp>0)){var tempRotation=_glMatrix2.default.quat.clone(this._rotation);this._updateRotation(tempRotation),this._rotation=_glMatrix2.default.quat.clone(tempRotation),this._currDiffX=this.diffX=0,this._currDiffY=this.diffY=0,this._isMouseDown=!1,this._isRotateZ=0,this._targetQuat=_glMatrix2.default.quat.clone(mQuat),this._slerp=1}}},{key:"resetQuat",value:function(){this._rotation=_glMatrix2.default.quat.clone([0,0,1,0]),this.tempRotation=_glMatrix2.default.quat.clone([0,0,0,0]),this._targetQuat=void 0,this._slerp=-1}},{key:"_onDown",value:function(mEvent){if(!this._isLocked){var mouse=getMouse(mEvent),tempRotation=_glMatrix2.default.quat.clone(this._rotation);this._updateRotation(tempRotation),this._rotation=tempRotation,this._isMouseDown=!0,this._isRotateZ=0,this.preMouse={x:mouse.x,y:mouse.y},mouse.y<this._rotateZMargin||mouse.y>window.innerHeight-this._rotateZMargin?this._isRotateZ=1:(mouse.x<this._rotateZMargin||mouse.x>window.innerWidth-this._rotateZMargin)&&(this._isRotateZ=2),this._diffX.setTo(0),this._diffY.setTo(0)}}},{key:"_onMove",value:function(mEvent){this._isLocked||getMouse(mEvent,this.mouse)}},{key:"_onUp",value:function(){this._isLocked||(this._isMouseDown=!1)}},{key:"_updateRotation",value:function(mTempRotation){this._isMouseDown&&!this._isLocked&&(this._diffX.value=-(this.mouse.x-this.preMouse.x),this._diffY.value=this.mouse.y-this.preMouse.y,this._isInvert&&(this._diffX.value=-this._diffX.targetValue,this._diffY.value=-this._diffY.targetValue));var angle=void 0,_quat=void 0;if(this._isRotateZ>0)1===this._isRotateZ?(angle=-this._diffX.value*this._offset,angle*=this.preMouse.y<this._rotateZMargin?-1:1,_quat=_glMatrix2.default.quat.clone([0,0,Math.sin(angle),Math.cos(angle)]),_glMatrix2.default.quat.multiply(_quat,mTempRotation,_quat)):(angle=-this._diffY.value*this._offset,angle*=this.preMouse.x<this._rotateZMargin?1:-1,_quat=_glMatrix2.default.quat.clone([0,0,Math.sin(angle),Math.cos(angle)]),_glMatrix2.default.quat.multiply(_quat,mTempRotation,_quat));else{var v=_glMatrix2.default.vec3.clone([this._diffX.value,this._diffY.value,0]),axis=_glMatrix2.default.vec3.create();_glMatrix2.default.vec3.cross(axis,v,this._zAxis),_glMatrix2.default.vec3.normalize(axis,axis),angle=_glMatrix2.default.vec3.length(v)*this._offset,_quat=_glMatrix2.default.quat.clone([Math.sin(angle)*axis[0],Math.sin(angle)*axis[1],Math.sin(angle)*axis[2],Math.cos(angle)]),_glMatrix2.default.quat.multiply(mTempRotation,_quat,mTempRotation)}}},{key:"_loop",value:function(){_glMatrix2.default.mat4.identity(this.m),void 0===this._targetQuat?(_glMatrix2.default.quat.set(this.tempRotation,this._rotation[0],this._rotation[1],this._rotation[2],this._rotation[3]),this._updateRotation(this.tempRotation)):(this._slerp+=.1*(0-this._slerp),this._slerp<5e-4?(_glMatrix2.default.quat.copy(this._rotation,this._targetQuat),_glMatrix2.default.quat.copy(this.tempRotation,this._targetQuat),this._targetQuat=void 0,this._diffX.setTo(0),this._diffY.setTo(0),this._slerp=-1):(_glMatrix2.default.quat.set(this.tempRotation,0,0,0,0),_glMatrix2.default.quat.slerp(this.tempRotation,this._targetQuat,this._rotation,this._slerp))),_glMatrix2.default.vec3.transformQuat(this._vZaxis,this._vZaxis,this.tempRotation),_glMatrix2.default.mat4.fromQuat(this.matrix,this.tempRotation)}},{key:"easing",set:function(mValue){this._diffX.easing=mValue,this._diffY.easing=mValue},get:function(){return this._diffX.easing}}]),QuatRotation}();exports.default=QuatRotation},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}function distance(a,b){var dx=a.x-b.x,dy=a.y-b.y;return Math.sqrt(dx*dx+dy*dy)}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_EventDispatcher2=__webpack_require__(28),_EventDispatcher3=_interopRequireDefault(_EventDispatcher2),_Ray=__webpack_require__(14),_Ray2=_interopRequireDefault(_Ray),_getMouse=__webpack_require__(62),_getMouse2=_interopRequireDefault(_getMouse),TouchDetector=function(_EventDispatcher){function TouchDetector(mMesh,mCamera){var mSkipMoveCheck=arguments.length>2&&void 0!==arguments[2]&&arguments[2],mListenerTarget=arguments.length>3&&void 0!==arguments[3]?arguments[3]:window;_classCallCheck(this,TouchDetector);var _this=_possibleConstructorReturn(this,(TouchDetector.__proto__||Object.getPrototypeOf(TouchDetector)).call(this));return _this._mesh=mMesh,_this._mesh.generateFaces(),_this._camera=mCamera,_this.faceVertices=mMesh.faces.map(function(face){return face.vertices}),_this.clickTolerance=8,_this._ray=new _Ray2.default([0,0,0],[0,0,-1]),_this._hit=vec3.fromValues(-999,-999,-999),_this._lastPos,_this._firstPos,_this.mtxModel=mat4.create(),_this._listenerTarget=mListenerTarget,_this._skippingMove=mSkipMoveCheck,_this._onMoveBind=function(e){return _this._onMove(e)},_this._onDownBind=function(e){return _this._onDown(e)},_this._onUpBind=function(){return _this._onUp()},_this.connect(),_this}return _inherits(TouchDetector,_EventDispatcher),_createClass(TouchDetector,[{key:"connect",value:function(){this._listenerTarget.addEventListener("mousedown",this._onDownBind),this._listenerTarget.addEventListener("mousemove",this._onMoveBind),this._listenerTarget.addEventListener("mouseup",this._onUpBind)}},{key:"disconnect",value:function(){this._listenerTarget.removeEventListener("mousedown",this._onDownBind),this._listenerTarget.removeEventListener("mousemove",this._onMoveBind),this._listenerTarget.removeEventListener("mouseup",this._onUpBind)}},{key:"_checkHit",value:function(){var _this2=this,mType=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"onHit",camera=this._camera;if(camera){var mx=this._lastPos.x/_GLTool2.default.width*2-1,my=-this._lastPos.y/_GLTool2.default.height*2+1;camera.generateRay([mx,my,0],this._ray);for(var hit=void 0,v0=vec3.create(),v1=vec3.create(),v2=vec3.create(),dist=0,getVector=function(v,target){vec3.transformMat4(target,v,_this2.mtxModel)},i=0;i<this.faceVertices.length;i++){var vertices=this.faceVertices[i];getVector(vertices[0],v0),getVector(vertices[1],v1),getVector(vertices[2],v2);var t=this._ray.intersectTriangle(v0,v1,v2);if(t)if(hit){var distToCam=vec3.dist(t,camera.position);distToCam<dist&&(hit=vec3.clone(t),dist=distToCam)}else hit=vec3.clone(t),dist=vec3.dist(hit,camera.position)}hit?(this._hit=vec3.clone(hit),this.dispatchCustomEvent(mType,{hit:hit})):this.dispatchCustomEvent("onUp")}}},{key:"_onDown",value:function(e){this._firstPos=(0,_getMouse2.default)(e),this._lastPos=(0,_getMouse2.default)(e),this._checkHit("onDown")}},{key:"_onMove",value:function(e){this._lastPos=(0,_getMouse2.default)(e),this._skippingMove||this._checkHit()}},{key:"_onUp",value:function(){distance(this._firstPos,this._lastPos)<this.clickTolerance&&this._checkHit()}}]),TouchDetector}(_EventDispatcher3.default);exports.default=TouchDetector},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e){var x=void 0,y=void 0;return e.touches?(x=e.touches[0].pageX,y=e.touches[0].pageY):(x=e.clientX,y=e.clientY),{x:x,y:y}}},function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_CameraPerspective2=__webpack_require__(16),_CameraPerspective3=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(_CameraPerspective2),_glMatrix=__webpack_require__(1),CAMERA_SETTINGS=[[_glMatrix.vec3.fromValues(0,0,0),_glMatrix.vec3.fromValues(1,0,0),_glMatrix.vec3.fromValues(0,-1,0)],[_glMatrix.vec3.fromValues(0,0,0),_glMatrix.vec3.fromValues(-1,0,0),_glMatrix.vec3.fromValues(0,-1,0)],[_glMatrix.vec3.fromValues(0,0,0),_glMatrix.vec3.fromValues(0,1,0),_glMatrix.vec3.fromValues(0,0,1)],[_glMatrix.vec3.fromValues(0,0,0),_glMatrix.vec3.fromValues(0,-1,0),_glMatrix.vec3.fromValues(0,0,-1)],[_glMatrix.vec3.fromValues(0,0,0),_glMatrix.vec3.fromValues(0,0,1),_glMatrix.vec3.fromValues(0,-1,0)],[_glMatrix.vec3.fromValues(0,0,0),_glMatrix.vec3.fromValues(0,0,-1),_glMatrix.vec3.fromValues(0,-1,0)]],CameraCube=function(_CameraPerspective){function CameraCube(){_classCallCheck(this,CameraCube);var _this=_possibleConstructorReturn(this,(CameraCube.__proto__||Object.getPrototypeOf(CameraCube)).call(this));return _this.setPerspective(Math.PI/2,1,.1,1e3),_this}return _inherits(CameraCube,_CameraPerspective),_createClass(CameraCube,[{key:"face",value:function(mIndex){var o=CAMERA_SETTINGS[mIndex];this.lookAt(o[0],o[1],o[2])}}]),CameraCube}(_CameraPerspective3.default);exports.default=CameraCube},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;if(void 0!==getter)return getter.call(receiver)},_BinaryLoader2=__webpack_require__(17),_BinaryLoader3=_interopRequireDefault(_BinaryLoader2),_Mesh=__webpack_require__(5),_Mesh2=_interopRequireDefault(_Mesh),ObjLoader=function(_BinaryLoader){function ObjLoader(){return _classCallCheck(this,ObjLoader),_possibleConstructorReturn(this,(ObjLoader.__proto__||Object.getPrototypeOf(ObjLoader)).apply(this,arguments))}return _inherits(ObjLoader,_BinaryLoader),_createClass(ObjLoader,[{key:"load",value:function(url,callback){var drawType=arguments.length>2&&void 0!==arguments[2]?arguments[2]:4;this._drawType=drawType,_get(ObjLoader.prototype.__proto__||Object.getPrototypeOf(ObjLoader.prototype),"load",this).call(this,url,callback)}},{key:"_onLoaded",value:function(){this.parseObj(this._req.response)}},{key:"parseObj",value:function(objStr){function parseVertexIndex(value){var index=parseInt(value);return 3*(index>=0?index-1:index+vertices.length/3)}function parseNormalIndex(value){var index=parseInt(value);return 3*(index>=0?index-1:index+normals.length/3)}function parseUVIndex(value){var index=parseInt(value);return 2*(index>=0?index-1:index+uvs.length/2)}function addVertex(a,b,c){positions.push([vertices[a],vertices[a+1],vertices[a+2]]),positions.push([vertices[b],vertices[b+1],vertices[b+2]]),positions.push([vertices[c],vertices[c+1],vertices[c+2]]),indices.push(3*count+0),indices.push(3*count+1),indices.push(3*count+2),count++}function addUV(a,b,c){coords.push([uvs[a],uvs[a+1]]),coords.push([uvs[b],uvs[b+1]]),coords.push([uvs[c],uvs[c+1]])}function addNormal(a,b,c){finalNormals.push([normals[a],normals[a+1],normals[a+2]]),finalNormals.push([normals[b],normals[b+1],normals[b+2]]),finalNormals.push([normals[c],normals[c+1],normals[c+2]])}function addFace(a,b,c,d,ua,ub,uc,ud,na,nb,nc,nd){var ia=parseVertexIndex(a),ib=parseVertexIndex(b),ic=parseVertexIndex(c),id=void 0;void 0===d?addVertex(ia,ib,ic):(id=parseVertexIndex(d),addVertex(ia,ib,id),addVertex(ib,ic,id)),void 0!==ua&&(ia=parseUVIndex(ua),ib=parseUVIndex(ub),ic=parseUVIndex(uc),void 0===d?addUV(ia,ib,ic):(id=parseUVIndex(ud),addUV(ia,ib,id),addUV(ib,ic,id))),void 0!==na&&(ia=parseNormalIndex(na),ib=parseNormalIndex(nb),ic=parseNormalIndex(nc),void 0===d?addNormal(ia,ib,ic):(id=parseNormalIndex(nd),addNormal(ia,ib,id),addNormal(ib,ic,id)))}for(var lines=objStr.split("\n"),positions=[],coords=[],finalNormals=[],vertices=[],normals=[],uvs=[],indices=[],count=0,result=void 0,vertexPattern=/v( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/,normalPattern=/vn( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/,uvPattern=/vt( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/,facePattern1=/f( +-?\d+)( +-?\d+)( +-?\d+)( +-?\d+)?/,facePattern2=/f( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))?/,facePattern3=/f( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))?/,facePattern4=/f( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))?/,i=0;i<lines.length;i++){var line=lines[i];line=line.trim(),0!==line.length&&"#"!==line.charAt(0)&&(null!==(result=vertexPattern.exec(line))?vertices.push(parseFloat(result[1]),parseFloat(result[2]),parseFloat(result[3])):null!==(result=normalPattern.exec(line))?normals.push(parseFloat(result[1]),parseFloat(result[2]),parseFloat(result[3])):null!==(result=uvPattern.exec(line))?uvs.push(parseFloat(result[1]),parseFloat(result[2])):null!==(result=facePattern1.exec(line))?addFace(result[1],result[2],result[3],result[4]):null!==(result=facePattern2.exec(line))?addFace(result[2],result[5],result[8],result[11],result[3],result[6],result[9],result[12]):null!==(result=facePattern3.exec(line))?addFace(result[2],result[6],result[10],result[14],result[3],result[7],result[11],result[15],result[4],result[8],result[12],result[16]):null!==(result=facePattern4.exec(line))&&addFace(result[2],result[5],result[8],result[11],void 0,void 0,void 0,void 0,result[3],result[6],result[9],result[12]))}return this._generateMeshes({positions:positions,coords:coords,normals:finalNormals,indices:indices})}},{key:"_generateMeshes",value:function(o){var hasNormals=o.normals.length>0,hasUVs=o.coords.length>0,mesh=void 0;if(o.positions.length>65535){var meshes=[],lastIndex=0,oCopy={};for(oCopy.positions=o.positions.concat(),oCopy.coords=o.coords.concat(),oCopy.indices=o.indices.concat(),oCopy.normals=o.normals.concat();o.indices.length>0;){for(var sliceNum=Math.min(65535,o.positions.length),indices=o.indices.splice(0,sliceNum),positions=[],coords=[],normals=[],index=void 0,tmpIndex=0,i=0;i<indices.length;i++)indices[i]>tmpIndex&&(tmpIndex=indices[i]),index=indices[i],positions.push(oCopy.positions[index]),hasUVs&&coords.push(oCopy.coords[index]),hasNormals&&normals.push(oCopy.normals[index]),indices[i]-=lastIndex;lastIndex=tmpIndex+1,mesh=new _Mesh2.default(this._drawType),mesh.bufferVertex(positions),hasUVs&&mesh.bufferTexCoord(coords),mesh.bufferIndex(indices),hasNormals&&mesh.bufferNormal(normals),meshes.push(mesh)}return this._callback&&this._callback(meshes,oCopy),meshes}return mesh=new _Mesh2.default(this._drawType),mesh.bufferVertex(o.positions),hasUVs&&mesh.bufferTexCoord(o.coords),mesh.bufferIndex(o.indices),hasNormals&&mesh.bufferNormal(o.normals),this._callback&&this._callback(mesh,o),mesh}}]),ObjLoader}(_BinaryLoader3.default);ObjLoader.parse=function(objStr){return(new ObjLoader).parseObj(objStr)},exports.default=ObjLoader},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_BinaryLoader2=__webpack_require__(17),_BinaryLoader3=_interopRequireDefault(_BinaryLoader2),_HDRParser=__webpack_require__(66),_HDRParser2=_interopRequireDefault(_HDRParser),HDRLoader=function(_BinaryLoader){function HDRLoader(){return _classCallCheck(this,HDRLoader),_possibleConstructorReturn(this,(HDRLoader.__proto__||Object.getPrototypeOf(HDRLoader)).call(this,!0))}return _inherits(HDRLoader,_BinaryLoader),_createClass(HDRLoader,[{key:"parse",value:function(mArrayBuffer){return(0,_HDRParser2.default)(mArrayBuffer)}},{key:"_onLoaded",value:function(){var o=this.parse(this._req.response);this._callback&&this._callback(o)}}]),HDRLoader}(_BinaryLoader3.default);HDRLoader.parse=function(mArrayBuffer){return(0,_HDRParser2.default)(mArrayBuffer)},exports.default=HDRLoader},function(module,exports,__webpack_require__){"use strict";function readPixelsRawRLE(buffer,data,offset,fileOffset,scanlineWidth,numScanlines){function readBuf(buf){var bytesRead=0;do{buf[bytesRead++]=buffer[fileOffset]}while(++fileOffset<bufferLength&&bytesRead<buf.length);return bytesRead}function readBufOffset(buf,offset,length){var bytesRead=0;do{buf[offset+bytesRead++]=buffer[fileOffset]}while(++fileOffset<bufferLength&&bytesRead<length);return bytesRead}for(var rgbe=new Array(4),scanlineBuffer=null,ptr=void 0,ptrEnd=void 0,count=void 0,buf=new Array(2),bufferLength=buffer.length;numScanlines>0;){if(readBuf(rgbe)<rgbe.length)throw new Error("Error reading bytes: expected "+rgbe.length);if(2!==rgbe[0]||2!==rgbe[1]||0!=(128&rgbe[2]))return data[offset++]=rgbe[0],data[offset++]=rgbe[1],data[offset++]=rgbe[2],data[offset++]=rgbe[3],void function(buffer,data,offset,numpixels){var numExpected=4*numpixels,numRead=readBufOffset(data,offset,numExpected);if(numRead<numExpected)throw new Error("Error reading raw pixels: got "+numRead+" bytes, expected "+numExpected)}(0,data,offset,scanlineWidth*numScanlines-1);if(((255&rgbe[2])<<8|255&rgbe[3])!==scanlineWidth)throw new Error("Wrong scanline width "+((255&rgbe[2])<<8|255&rgbe[3])+", expected "+scanlineWidth);null===scanlineBuffer&&(scanlineBuffer=new Array(4*scanlineWidth)),ptr=0;for(var i=0;i<4;i++)for(ptrEnd=(i+1)*scanlineWidth;ptr<ptrEnd;){if(readBuf(buf)<buf.length)throw new Error("Error reading 2-byte buffer");if((255&buf[0])>128){if(0===(count=(255&buf[0])-128)||count>ptrEnd-ptr)throw new Error("Bad scanline data");for(;count-- >0;)scanlineBuffer[ptr++]=buf[1]}else{if(0===(count=255&buf[0])||count>ptrEnd-ptr)throw new Error("Bad scanline data");if(scanlineBuffer[ptr++]=buf[1],--count>0){if(readBufOffset(scanlineBuffer,ptr,count)<count)throw new Error("Error reading non-run data");ptr+=count}}}for(var _i=0;_i<scanlineWidth;_i++)data[offset+0]=scanlineBuffer[_i],data[offset+1]=scanlineBuffer[_i+scanlineWidth],data[offset+2]=scanlineBuffer[_i+2*scanlineWidth],data[offset+3]=scanlineBuffer[_i+3*scanlineWidth],offset+=4;numScanlines--}}function parseHdr(buffer){buffer instanceof ArrayBuffer&&(buffer=new Uint8Array(buffer));for(var fileOffset=0,bufferLength=buffer.length,NEW_LINE=10,width=0,height=0,exposure=1,rle=!1,i=0;i<20;i++){var line=function(){var buf="";do{var b=buffer[fileOffset];if(b===NEW_LINE){++fileOffset;break}buf+=String.fromCharCode(b)}while(++fileOffset<bufferLength);return buf}(),match=void 0;if(match=line.match(radiancePattern));else if(match=line.match(formatPattern))rle=!0;else if(match=line.match(exposurePattern))exposure=Number(match[1]);else if(match=line.match(commentPattern));else if(match=line.match(widthHeightPattern)){height=Number(match[1]),width=Number(match[2]);break}}if(!rle)throw new Error("File is not run length encoded!");var data=new Uint8Array(width*height*4);readPixelsRawRLE(buffer,data,0,fileOffset,width,height);for(var floatData=new Float32Array(width*height*4),offset=0;offset<data.length;offset+=4){var r=data[offset+0]/255,g=data[offset+1]/255,b=data[offset+2]/255,e=data[offset+3],f=Math.pow(2,e-128);r*=f,g*=f,b*=f;var floatOffset=offset;floatData[floatOffset+0]=r,floatData[floatOffset+1]=g,floatData[floatOffset+2]=b,floatData[floatOffset+3]=1}return{shape:[width,height],exposure:exposure,gamma:1,data:floatData}}Object.defineProperty(exports,"__esModule",{value:!0});var radiancePattern="#\\?RADIANCE",commentPattern="#.*",exposurePattern="EXPOSURE=\\s*([0-9]*[.][0-9]*)",formatPattern="FORMAT=32-bit_rle_rgbe",widthHeightPattern="-Y ([0-9]+) \\+X ([0-9]+)";exports.default=parseHdr},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}Object.defineProperty(exports,"__esModule",{value:!0});var _colladaParser=__webpack_require__(68),_colladaParser2=_interopRequireDefault(_colladaParser),_Mesh=__webpack_require__(5),_Mesh2=_interopRequireDefault(_Mesh),generateMesh=function(meshes){var caches={};meshes.forEach(function(mesh){var _mesh$mesh=mesh.mesh,vertices=_mesh$mesh.vertices,normals=_mesh$mesh.normals,coords=_mesh$mesh.coords,triangles=_mesh$mesh.triangles,name=_mesh$mesh.name;if(!caches[name]){var glMesh=(new _Mesh2.default).bufferFlattenData(vertices,"aVertexPosition",3).bufferFlattenData(coords,"aTextureCoord",2).bufferFlattenData(normals,"aNormal",3).bufferIndex(triangles);caches[name]=glMesh}mesh.glMesh=caches[name]})},parse=function(mData){var meshes=_colladaParser2.default.parse(mData);return generateMesh(meshes),meshes},load=function(mPath,mCallback){_colladaParser2.default.load(mPath,function(meshes){generateMesh(meshes),mCallback(meshes)})},ColladaParser={parse:parse,load:load};exports.default=ColladaParser},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _Collada=__webpack_require__(69),_Collada2=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(_Collada),_glMatrix=__webpack_require__(1),parseData=function(mData){function getMaterial(id){var mat=void 0;for(var _s in materials)_s===id&&(mat=materials[_s]);var oMaterial={};return mat.diffuse&&(oMaterial.diffuseColor=mat.diffuse),oMaterial.diffuseColor=mat.diffuse||[0,0,0],oMaterial.shininess=mat.shininess||0,mat.textures&&(mat.textures.diffuse&&(oMaterial.diffuseMapID=mat.textures.diffuse.map_id),mat.textures.normal&&(oMaterial.normalMapID=mat.textures.normal.map_id)),oMaterial}function walk(node,mtxParent){var m=_glMatrix.mat4.create();if(node.model?_glMatrix.mat4.multiply(m,mtxParent,node.model):_glMatrix.mat4.copy(m,mtxParent),node.children.length>0&&node.children.forEach(function(child){walk(child,m)}),node.mesh){var _oMesh={};_oMesh.modelMatrix=m,_oMesh.mesh=meshes[node.mesh],_oMesh.id=node.id,_oMesh.name=node.name,_oMesh.material=getMaterial(node.material),meshObjs.push(_oMesh)}}var materials=mData.materials,meshes=mData.meshes,meshObjs=[],allMeshes=[];for(var s in meshes){var oMesh=meshes[s],vertices=oMesh.vertices,normals=oMesh.normals,coords=oMesh.coords,triangles=oMesh.triangles,buffers={vertices:vertices,normals:normals,coords:coords,triangles:triangles};allMeshes.push({id:s,buffers:buffers})}var mtx=_glMatrix.mat4.create();return walk(mData.root,mtx),meshObjs},parse=function(mFile){var o=_Collada2.default.parse(mFile);return parseData(o)},load=function(mPath,mCallBack){_Collada2.default.load(mPath,function(mData){mCallBack(parseData(mData))})},ColladaParser={load:load,parse:parse};exports.default=ColladaParser,module.exports=exports.default},function(module,exports,__webpack_require__){"use strict";(function(global){function request(url,callback){var req=new XMLHttpRequest;req.onload=function(){this.response;200==this.status&&callback&&callback(this.response)},req.open("get",url,!0),req.send()}Object.defineProperty(exports,"__esModule",{value:!0});var _glMatrix=__webpack_require__(1),isWorker=void 0===global.document,DEG2RAD=2*Math.PI/360,temp_mat4=null,temp_vec2=null,temp_vec3=null,temp_vec4=null,temp_quat=null,Collada={libsPath:"./",workerPath:"./",no_flip:!0,use_transferables:!0,onerror:null,verbose:!1,config:{forceParser:!1},init:function(config){config=config||{};for(var i in config)this[i]=config[i];if(this.config=config,isWorker)try{importScripts(this.libsPath+"gl-matrix-min.js",this.libsPath+"tinyxml.js")}catch(err){Collada.throwException(Collada.LIBMISSING_ERROR)}temp_mat4=_glMatrix.mat4.create(),temp_vec2=vec3.create(),temp_vec3=vec3.create(),temp_vec4=vec3.create(),temp_quat=_glMatrix.quat.create(),isWorker&&console.log("Collada worker ready")},load:function(url,callback){request(url,function(data){callback(data?Collada.parse(data):null)})},_xmlroot:null,_nodes_by_id:null,_transferables:null,_controllers_found:null,_geometries_found:null,safeString:function(str){return str?this.convertID?this.convertID(str):str.replace(/ /g,"_"):""},LIBMISSING_ERROR:"Libraries loading error, when using workers remember to pass the URL to the tinyxml.js in the options.libsPath",NOXMLPARSER_ERROR:"TinyXML not found, when using workers remember to pass the URL to the tinyxml.js in the options.libsPath (Workers do not allow to access the native XML DOMParser)",throwException:function(msg){throw isWorker?self.postMessage({action:"exception",msg:msg}):Collada.onerror&&Collada.onerror(msg),msg},getFilename:function(filename){var pos=filename.lastIndexOf("\\");return-1!=pos&&(filename=filename.substr(pos+1)),pos=filename.lastIndexOf("/"),-1!=pos&&(filename=filename.substr(pos+1)),filename},last_name:0,generateName:function(v){v=v||"name_";var name=v+this.last_name;return this.last_name++,name},parse:function(data,options,filename){options=options||{},filename=filename||"_dae_"+Date.now()+".dae";var xmlparser=null,root=null;if(this._transferables=[],this.verbose&&console.log(" - XML parsing..."),global.DOMParser&&!this.config.forceParser)xmlparser=new DOMParser,root=xmlparser.parseFromString(data,"text/xml"),this.verbose&&console.log(" - XML parsed");else{if(!global.DOMImplementation)return Collada.throwException(Collada.NOXMLPARSER_ERROR);try{xmlparser=new DOMImplementation}catch(err){return Collada.throwException(Collada.NOXMLPARSER_ERROR)}root=xmlparser.loadXML(data),this.verbose&&console.log(" - XML parsed");for(var by_ids=root._nodes_by_id={},i=0,l=root.all.length;i<l;++i){var node=root.all[i];by_ids[node.id]=node,node.getAttribute("sid")&&(by_ids[node.getAttribute("sid")]=node)}this.extra_functions||(this.extra_functions=!0,DOMDocument.prototype.querySelector=DOMElement.prototype.querySelector=function(selector){for(var tags=selector.split(" "),current_element=this;tags.length;){var current=tags.shift(),tokens=current.split("#"),tagname=tokens[0],id=tokens[1],elements=tagname?current_element.getElementsByTagName(tagname):current_element.childNodes;if(id){for(var i=0;i<elements.length;i++)if(elements.item(i).getAttribute("id")==id){if(0==tags.length)return elements.item(i);current_element=elements.item(i);break}}else{if(0==tags.length)return elements.item(0);current_element=elements.item(0)}}return null},DOMDocument.prototype.querySelectorAll=DOMElement.prototype.querySelectorAll=function(selector){function inner(root,tags){if(tags){var current=tags.shift(),elements=root.getElementsByTagName(current);if(0!=tags.length)for(var i=0;i<elements.length;i++)inner(elements.item(i),tags.concat());else for(var i=0;i<elements.length;i++)result.push(elements.item(i))}}var tags=selector.split(" ");if(1==tags.length)return this.getElementsByTagName(selector);var result=[];inner(this,tags);var list=new DOMNodeList(this.documentElement);return list._nodes=result,list.length=result.length,list},Object.defineProperty(DOMElement.prototype,"textContent",{get:function(){return this.getChildNodes().item(0).toString()},set:function(){}}))}this._xmlroot=root;var xmlcollada=root.querySelector("COLLADA");xmlcollada&&(this._current_DAE_version=xmlcollada.getAttribute("version"),console.log("DAE Version:"+this._current_DAE_version));var xmlvisual_scene=root.getElementsByTagName("visual_scene").item(0);if(!xmlvisual_scene)throw"visual_scene XML node not found in DAE";this._nodes_by_id={},this._controllers_found={},this._geometries_found={};var scene={object_type:"SceneTree",light:null,materials:{},meshes:{},resources:{},root:{children:[]},external_files:{}},xmlasset=root.getElementsByTagName("asset")[0];xmlasset&&(scene.metadata=this.readAsset(xmlasset));for(var xmlnodes=xmlvisual_scene.childNodes,i=0;i<xmlnodes.length;i++)if("node"==xmlnodes.item(i).localName){var node=this.readNodeTree(xmlnodes.item(i),scene,0,!1);node&&scene.root.children.push(node)}for(var i=0;i<xmlnodes.length;i++)"node"==xmlnodes.item(i).localName&&this.readNodeInfo(xmlnodes.item(i),scene,0,!1);this.readLibraryControllers(scene);var animations=this.readAnimations(root,scene);if(animations){var animations_name="#animations_"+filename.substr(0,filename.indexOf("."));scene.resources[animations_name]=animations,scene.root.animations=animations_name}return scene.images=this.readImages(root),this._nodes_by_id={},this._controllers_found={},this._geometries_found={},this._xmlroot=null,scene},readAsset:function(xmlasset){for(var metadata={},i=0;i<xmlasset.childNodes.length;i++){var xmlchild=xmlasset.childNodes.item(i);if(1==xmlchild.nodeType)switch(xmlchild.localName){case"contributor":var tool=xmlchild.querySelector("authoring_tool");tool&&(metadata.authoring_tool=tool.textContext);break;case"unit":metadata.unit=xmlchild.getAttribute("name");break;default:metadata[xmlchild.localName]=xmlchild.textContent}}return metadata},readNodeTree:function(xmlnode,scene,level,flip){var node_id=this.safeString(xmlnode.getAttribute("id")),node_sid=this.safeString(xmlnode.getAttribute("sid"));if(!node_id&&!node_sid)return null;var node={id:node_sid||node_id,children:[],_depth:level},node_type=xmlnode.getAttribute("type");node_type&&(node.type=node_type);var node_name=xmlnode.getAttribute("name");node_name&&(node.name=node_name),this._nodes_by_id[node.id]=node,node_id&&(this._nodes_by_id[node_id]=node),node_sid&&(this._nodes_by_id[node_sid]=node),node.model=this.readTransform(xmlnode,level,flip);for(var i=0;i<xmlnode.childNodes.length;i++){var xmlchild=xmlnode.childNodes.item(i);if(1==xmlchild.nodeType)if("node"!=xmlchild.localName);else{var child_node=this.readNodeTree(xmlchild,scene,level+1,flip);child_node&&node.children.push(child_node)}}return node},readNodeInfo:function(xmlnode,scene,level,flip,parent){var node,node_id=this.safeString(xmlnode.getAttribute("id")),node_sid=this.safeString(xmlnode.getAttribute("sid"));if(node_id||node_sid)node=this._nodes_by_id[node_id||node_sid];else{if(!parent)return null;node=this._nodes_by_id[parent.id||parent.sid]}if(!node)return console.warn("Collada: Node not found by id: "+(node_id||node_sid)),null;for(var i=0;i<xmlnode.childNodes.length;i++){var xmlchild=xmlnode.childNodes.item(i);if(1==xmlchild.nodeType)if("node"!=xmlchild.localName){if("instance_geometry"==xmlchild.localName){var url=xmlchild.getAttribute("url"),mesh_id=url.toString().substr(1);if(node.mesh=mesh_id,!scene.meshes[url]){var mesh_data=this.readGeometry(url,flip);mesh_data&&(mesh_data.name=mesh_id,scene.meshes[mesh_id]=mesh_data)}var xmlmaterials=xmlchild.querySelectorAll("instance_material");if(xmlmaterials)for(var iMat=0;iMat<xmlmaterials.length;++iMat){var xmlmaterial=xmlmaterials.item(iMat);if(xmlmaterial){var matname=xmlmaterial.getAttribute("target").toString().substr(1);if(!scene.materials[matname]){var material=this.readMaterial(matname);material&&(material.id=matname,scene.materials[material.id]=material)}0==iMat?node.material=matname:(node.materials||(node.materials=[]),node.materials.push(matname))}else console.warn("instance_material not found: "+i)}}if("instance_controller"==xmlchild.localName){var url=xmlchild.getAttribute("url"),xmlcontroller=this._xmlroot.querySelector("controller"+url);if(xmlcontroller){var mesh_data=this.readController(xmlcontroller,flip,scene),xmlbind_material=xmlchild.querySelector("bind_material");if(xmlbind_material)for(var xmltechniques=xmlbind_material.querySelectorAll("technique_common"),iTec=0;iTec<xmltechniques.length;iTec++)for(var xmltechnique=xmltechniques.item(iTec),xmlinstance_materials=xmltechnique.querySelectorAll("instance_material"),iMat=0;iMat<xmlinstance_materials.length;iMat++){var xmlinstance_material=xmlinstance_materials.item(iMat);if(xmlinstance_material){var matname=xmlinstance_material.getAttribute("target").toString().substr(1);if(!scene.materials[matname]){var material=this.readMaterial(matname);material&&(material.id=matname,scene.materials[material.id]=material)}0==iMat?node.material=matname:(node.materials||(node.materials=[]),node.materials.push(matname))}else console.warn("instance_material for controller not found: "+xmlinstance_material)}if(mesh_data){var mesh=mesh_data;"morph"==mesh_data.type&&(mesh=mesh_data.mesh,node.morph_targets=mesh_data.morph_targets),mesh.name=url.toString(),node.mesh=url.toString(),scene.meshes[url]=mesh}}}if("instance_light"==xmlchild.localName){var url=xmlchild.getAttribute("url");this.readLight(node,url)}if("instance_camera"==xmlchild.localName){var url=xmlchild.getAttribute("url");this.readCamera(node,url)}}else this.readNodeInfo(xmlchild,scene,level+1,flip,xmlnode)}},material_translate_table:{},light_translate_table:{point:"omni",directional:"directional",spot:"spot"},camera_translate_table:{xfov:"fov",aspect_ratio:"aspect",znear:"near",zfar:"far"},querySelectorAndId:function(root,selector,id){for(var nodes=root.querySelectorAll(selector),i=0;i<nodes.length;i++){var attr_id=nodes.item(i).getAttribute("id");if(attr_id&&(attr_id=attr_id.toString())==id)return nodes.item(i)}return null},getFirstChildElement:function(root,localName){for(var c=root.childNodes,i=0;i<c.length;++i){var item=c.item(i);if(item.localName&&!localName||localName&&localName==item.localName)return item}return null},readMaterial:function(url){var xmlmaterial=this.querySelectorAndId(this._xmlroot,"library_materials material",url);if(!xmlmaterial)return null;var xmleffect=xmlmaterial.querySelector("instance_effect");if(!xmleffect)return null;var effect_url=xmleffect.getAttribute("url").substr(1),xmleffects=this.querySelectorAndId(this._xmlroot,"library_effects effect",effect_url);if(!xmleffects)return null;var xmltechnique=xmleffects.querySelector("technique");if(!xmltechnique)return null;for(var xmlnewparams=xmleffects.querySelectorAll("newparam"),newparams={},i=0;i<xmlnewparams.length;i++){var parent,init_from=xmlnewparams[i].querySelector("init_from");if(init_from)parent=init_from.innerHTML;else{parent=xmlnewparams[i].querySelector("source").innerHTML}newparams[xmlnewparams[i].getAttribute("sid")]={parent:parent}}var material={},images=this.readImages(this._xmlroot),xmlphong=xmltechnique.querySelector("phong");if(xmlphong||(xmlphong=xmltechnique.querySelector("blinn")),xmlphong||(xmlphong=xmltechnique.querySelector("lambert")),!xmlphong)return null;for(var i=0;i<xmlphong.childNodes.length;++i){var xmlparam=xmlphong.childNodes.item(i);if(xmlparam.localName){var param_name=xmlparam.localName.toString();this.material_translate_table[param_name]&&(param_name=this.material_translate_table[param_name]);var xmlparam_value=this.getFirstChildElement(xmlparam);if(xmlparam_value)if("color"!=xmlparam_value.localName.toString())if("float"!=xmlparam_value.localName.toString()){if("texture"==xmlparam_value.localName.toString()){material.textures||(material.textures={});var map_id=xmlparam_value.getAttribute("texture");if(!map_id)continue;-1===map_id.indexOf(".")&&(map_id=this.getParentParam(newparams,map_id),images[map_id]&&(map_id=images[map_id].path));var map_info={map_id:map_id},uvs=xmlparam_value.getAttribute("texcoord");map_info.uvs=uvs,material.textures[param_name]=map_info}}else material[param_name]=this.readContentAsFloats(xmlparam_value)[0];else{var value=this.readContentAsFloats(xmlparam_value);"RGB_ZERO"==xmlparam.getAttribute("opaque")?material[param_name]=value.subarray(0,4):material[param_name]=value.subarray(0,3)}}}return material.object_type="Material",material},getParentParam:function(newparams,param){return newparams[param]&&newparams[param].parent?this.getParentParam(newparams,newparams[param].parent):param},readLight:function(node,url){function parse_params(light,xml){for(var i=0;i<xml.childNodes.length;i++){var child=xml.childNodes.item(i);if(child&&1==child.nodeType)switch(child.localName){case"color":light.color=Collada.readContentAsFloats(child);break;case"falloff_angle":light.angle_end=Collada.readContentAsFloats(child)[0],light.angle=light.angle_end-10}}}var light={},xmlnode=null;if(url.length>1)xmlnode=this._xmlroot.querySelector("library_lights "+url);else{var xmlliblights=this._xmlroot.querySelector("library_lights");xmlnode=this.getFirstChildElement(xmlliblights,"light")}if(!xmlnode)return null;var children=[],xml=xmlnode.querySelector("technique_common");if(xml)for(var i=0;i<xml.childNodes.length;i++)1==xml.childNodes.item(i).nodeType&&children.push(xml.childNodes.item(i));for(var xmls=xmlnode.querySelectorAll("technique"),i=0;i<xmls.length;i++)for(var xml2=xmls.item(i),j=0;j<xml2.childNodes.length;j++)1==xml2.childNodes.item(j).nodeType&&children.push(xml2.childNodes.item(j));for(var i=0;i<children.length;i++){var xml=children[i];switch(xml.localName){case"point":case"directional":case"spot":light.type=this.light_translate_table[xml.localName],parse_params(light,xml);break;case"intensity":light.intensity=this.readContentAsFloats(xml)[0]}}if(node.model){light.position=[node.model[12],node.model[13],node.model[14]];var forward=[-node.model[8],-node.model[9],-node.model[10]];light.target=[light.position[0]+forward[0],light.position[1]+forward[1],light.position[2]+forward[2]]}else console.warn("Could not read light position for light: "+node.name+". Setting defaults."),light.position=[0,0,0],light.target=[0,-1,0];node.light=light},readCamera:function(node,url){var camera={},xmlnode=this._xmlroot.querySelector("library_cameras "+url);if(!xmlnode)return null;var children=[],xml=xmlnode.querySelector("technique_common");if(xml)for(var i=0;i<xml.childNodes.length;i++)1==xml.childNodes.item(i).nodeType&&children.push(xml.childNodes.item(i));for(var i=0;i<children.length;i++){var tag=children[i];!function(camera,xml){for(var i=0;i<xml.childNodes.length;i++){var child=xml.childNodes.item(i);child&&1==child.nodeType&&(camera[Collada.camera_translate_table[child.localName]||child.localName]=parseFloat(child.textContent))}}(camera,tag)}camera.yfov&&!camera.fov&&(camera.aspect?camera.fov=camera.yfov*camera.aspect:console.warn("Could not convert camera yfov to xfov because aspect ratio not set")),node.camera=camera},readTransform:function(xmlnode,level,flip){for(var matrix=_glMatrix.mat4.create(),temp=_glMatrix.mat4.create(),tmpq=_glMatrix.quat.create(),i=0;i<xmlnode.childNodes.length;i++){var xml=xmlnode.childNodes.item(i);if(xml&&1==xml.nodeType){if("matrix"==xml.localName){var matrix=this.readContentAsFloats(xml);return this.transformMatrix(matrix,0==level),matrix}if("translate"!=xml.localName)if("rotate"!=xml.localName){if("scale"==xml.localName){var values=this.readContentAsFloats(xml);if(flip){var tmp=values[1];values[1]=values[2],values[2]=-tmp}_glMatrix.mat4.scale(matrix,matrix,values)}}else{var values=this.readContentAsFloats(xml);if(4==values.length){var id=xml.getAttribute("sid");if("jointOrientX"==id&&(values[3]+=90,!0),flip){var tmp=values[1];values[1]=values[2],values[2]=-tmp}0!=values[3]&&(_glMatrix.quat.setAxisAngle(tmpq,values.subarray(0,3),values[3]*DEG2RAD),_glMatrix.mat4.fromQuat(temp,tmpq),_glMatrix.mat4.multiply(matrix,matrix,temp))}}else{var values=this.readContentAsFloats(xml);if(flip&&level>0){var tmp=values[1];values[1]=values[2],values[2]=-tmp}_glMatrix.mat4.translate(matrix,matrix,values)}}}return matrix},readTransform2:function(xmlnode,level,flip){for(var matrix=_glMatrix.mat4.create(),rotation=_glMatrix.quat.create(),tmpmatrix=_glMatrix.mat4.create(),tmpq=_glMatrix.quat.create(),translate=vec3.create(),scale=vec3.fromValues(1,1,1),i=0;i<xmlnode.childNodes.length;i++){var xml=xmlnode.childNodes.item(i);if("matrix"==xml.localName){var matrix=this.readContentAsFloats(xml);return this.transformMatrix(matrix,0==level),matrix}if("translate"!=xml.localName)if("rotate"!=xml.localName){if("scale"==xml.localName){var values=this.readContentAsFloats(xml);if(flip){var tmp=values[1];values[1]=values[2],values[2]=-tmp}scale.set(values)}}else{var values=this.readContentAsFloats(xml);if(4==values.length){var id=xml.getAttribute("sid");if("jointOrientX"==id&&(values[3]+=90,!0),flip){var tmp=values[1];values[1]=values[2],values[2]=-tmp}0!=values[3]&&(_glMatrix.quat.setAxisAngle(tmpq,values.subarray(0,3),values[3]*DEG2RAD),_glMatrix.quat.multiply(rotation,rotation,tmpq))}}else{var values=this.readContentAsFloats(xml);translate.set(values)}}if(flip&&level>0){var tmp=translate[1];translate[1]=translate[2],translate[2]=-tmp}return _glMatrix.mat4.translate(matrix,matrix,translate),_glMatrix.mat4.fromQuat(tmpmatrix,rotation),_glMatrix.mat4.multiply(matrix,matrix,tmpmatrix),_glMatrix.mat4.scale(matrix,matrix,scale),matrix},readGeometry:function(id,flip,scene){if(void 0!==this._geometries_found[id])return this._geometries_found[id];var xmlgeometry=this._xmlroot.getElementById(id.substr(1));if(!xmlgeometry)return console.warn("readGeometry: geometry not found: "+id),this._geometries_found[id]=null,null;if("controller"==xmlgeometry.localName){var geometry=this.readController(xmlgeometry,flip,scene);return this._geometries_found[id]=geometry,geometry}if("geometry"!=xmlgeometry.localName)return console.warn("readGeometry: tag should be geometry, instead it was found: "+xmlgeometry.localName),this._geometries_found[id]=null,null;var xmlmesh=xmlgeometry.querySelector("mesh");if(!xmlmesh)return console.warn("readGeometry: mesh not found in geometry: "+id),this._geometries_found[id]=null,null;for(var sources={},xmlsources=xmlmesh.querySelectorAll("source"),i=0;i<xmlsources.length;i++){var xmlsource=xmlsources.item(i);if(xmlsource.querySelector){var float_array=xmlsource.querySelector("float_array");if(float_array){var floats=this.readContentAsFloats(float_array),xmlaccessor=xmlsource.querySelector("accessor"),stride=parseInt(xmlaccessor.getAttribute("stride"));sources[xmlsource.getAttribute("id")]={stride:stride,data:floats}}}}var xmlvertices=xmlmesh.querySelector("vertices input"),vertices_source=sources[xmlvertices.getAttribute("source").substr(1)];sources[xmlmesh.querySelector("vertices").getAttribute("id")]=vertices_source;var mesh=null,xmlpolygons=xmlmesh.querySelector("polygons");if(xmlpolygons&&(mesh=this.readTriangles(xmlpolygons,sources)),!mesh){var xmltriangles=xmlmesh.querySelectorAll("triangles");xmltriangles&&xmltriangles.length&&(mesh=this.readTriangles(xmltriangles,sources))}if(!mesh){var xmlpolylist=xmlmesh.querySelector("polylist");xmlpolylist&&(mesh=this.readPolylist(xmlpolylist,sources))}if(!mesh){var xmllinestrip=xmlmesh.querySelector("linestrips");xmllinestrip&&(mesh=this.readLineStrip(sources,xmllinestrip))}if(!mesh)return console.log("no polygons or triangles in mesh: "+id),this._geometries_found[id]=null,null;if(flip&&!this.no_flip){for(var tmp=0,array=mesh.vertices,i=0,l=array.length;i<l;i+=3)tmp=array[i+1],array[i+1]=array[i+2],array[i+2]=-tmp;array=mesh.normals;for(var i=0,l=array.length;i<l;i+=3)tmp=array[i+1],array[i+1]=array[i+2],array[i+2]=-tmp}if(isWorker&&this.use_transferables)for(var i in mesh){var data=mesh[i];data&&data.buffer&&data.length>100&&this._transferables.push(data.buffer)}return mesh.filename=id,mesh.object_type="Mesh",this._geometries_found[id]=mesh,mesh},readTriangles:function(xmltriangles,sources){for(var groups=[],buffers=[],last_index=0,facemap={},vertex_remap=[],indicesArray=[],last_start=0,material_name="",tris=0;tris<xmltriangles.length;tris++){var xml_shape_root=xmltriangles.item(tris),triangles="triangles"==xml_shape_root.localName;material_name=xml_shape_root.getAttribute("material"),0==tris&&(buffers=this.readShapeInputs(xml_shape_root,sources));for(var xmlps=xml_shape_root.querySelectorAll("p"),i=(buffers.length,0);i<xmlps.length;i++){var xmlp=xmlps.item(i);if(!xmlp||!xmlp.textContent)break;var data=xmlp.textContent.trim().split(" "),first_index=-1,current_index=-1,prev_index=-1,num_values_per_vertex=1;for(var b in buffers)num_values_per_vertex=Math.max(num_values_per_vertex,buffers[b][4]+1);for(var k=0,l=data.length;k<l;k+=num_values_per_vertex){var vertex_id=data.slice(k,k+num_values_per_vertex).join(" ");if(prev_index=current_index,facemap.hasOwnProperty(vertex_id))current_index=facemap[vertex_id];else{for(var j=0;j<buffers.length;++j){var buffer=buffers[j],array=buffer[1],source=buffer[3],index=parseInt(data[k+buffer[4]]);0==j&&(vertex_remap[array.length/buffer[2]]=index),index*=buffer[2];for(var x=0;x<buffer[2];++x){if(void 0===source[index+x])throw"UNDEFINED!";array.push(source[index+x])}}current_index=last_index,last_index+=1,facemap[vertex_id]=current_index}triangles||(0==k&&(first_index=current_index),k>2&&(indicesArray.push(first_index),indicesArray.push(prev_index))),indicesArray.push(current_index)}}var group={name:"group"+tris,start:last_start,length:indicesArray.length-last_start,material:material_name||""};last_start=indicesArray.length,groups.push(group)}var mesh={vertices:new Float32Array(buffers[0][1]),info:{groups:groups},_remap:new Uint32Array(vertex_remap)};return this.transformMeshInfo(mesh,buffers,indicesArray),mesh},readPolylist:function(xml_shape_root,sources){var buffers=[],last_index=0,facemap={},vertex_remap=[],indicesArray=[];xml_shape_root.getAttribute("material"),buffers=this.readShapeInputs(xml_shape_root,sources);for(var xmlvcount=xml_shape_root.querySelector("vcount"),vcount=this.readContentAsUInt32(xmlvcount),xmlp=xml_shape_root.querySelector("p"),data=this.readContentAsUInt32(xmlp),num_data_vertex=buffers.length,pos=0,i=0,l=vcount.length;i<l;++i)for(var num_vertices=vcount[i],first_index=-1,current_index=-1,prev_index=-1,k=0;k<num_vertices;++k){var vertex_id=data.subarray(pos,pos+num_data_vertex).join(" ");if(prev_index=current_index,facemap.hasOwnProperty(vertex_id))current_index=facemap[vertex_id];else{for(var j=0;j<buffers.length;++j){var buffer=buffers[j],index=parseInt(data[pos+j]),array=buffer[1],source=buffer[3];0==j&&(vertex_remap[array.length/num_data_vertex]=index),index*=buffer[2];for(var x=0;x<buffer[2];++x)array.push(source[index+x])}current_index=last_index,last_index+=1,facemap[vertex_id]=current_index}num_vertices>3&&(0==k&&(first_index=current_index),k>2&&(indicesArray.push(first_index),indicesArray.push(prev_index))),indicesArray.push(current_index),pos+=num_data_vertex}var mesh={vertices:new Float32Array(buffers[0][1]),info:{},_remap:new Uint32Array(vertex_remap)};return this.transformMeshInfo(mesh,buffers,indicesArray),mesh},readShapeInputs:function(xml_shape_root,sources){for(var buffers=[],xmlinputs=xml_shape_root.querySelectorAll("input"),i=0;i<xmlinputs.length;i++){var xmlinput=xmlinputs.item(i);if(xmlinput.getAttribute){var semantic=xmlinput.getAttribute("semantic").toUpperCase(),stream_source=sources[xmlinput.getAttribute("source").substr(1)],offset=parseInt(xmlinput.getAttribute("offset")),data_set=0;xmlinput.getAttribute("set")&&(data_set=parseInt(xmlinput.getAttribute("set"))),buffers.push([semantic,[],stream_source.stride,stream_source.data,offset,data_set])}}return buffers},transformMeshInfo:function(mesh,buffers,indicesArray){for(var translator={normal:"normals",texcoord:"coords"},i=1;i<buffers.length;++i){var name=buffers[i][0].toLowerCase(),data=buffers[i][1];data.length&&(translator[name]&&(name=translator[name]),mesh[name]&&(name+=buffers[i][5]),mesh[name]=new Float32Array(data))}return indicesArray&&indicesArray.length&&(mesh.vertices.length>65536?mesh.triangles=new Uint32Array(indicesArray):mesh.triangles=new Uint16Array(indicesArray)),mesh},readLineStrip:function(sources,xmllinestrip){for(var buffers=[],last_index=0,facemap={},vertex_remap=[],indicesArray=[],xmlinputs=xmllinestrip.querySelectorAll("input"),i=0;i<xmlinputs.length;i++){var xmlinput=xmlinputs.item(i);if(xmlinput.getAttribute){var semantic=xmlinput.getAttribute("semantic").toUpperCase(),stream_source=sources[xmlinput.getAttribute("source").substr(1)],offset=parseInt(xmlinput.getAttribute("offset")),data_set=0;xmlinput.getAttribute("set")&&(data_set=parseInt(xmlinput.getAttribute("set"))),buffers.push([semantic,[],stream_source.stride,stream_source.data,offset,data_set])}}for(var xmlps=xmllinestrip.querySelectorAll("p"),num_data_vertex=buffers.length,i=0;i<xmlps.length;i++){var xmlp=xmlps.item(i);if(!xmlp||!xmlp.textContent)break;for(var data=xmlp.textContent.trim().split(" "),current_index=-1,k=0,l=data.length;k<l;k+=num_data_vertex){var vertex_id=data.slice(k,k+num_data_vertex).join(" ");if(current_index,facemap.hasOwnProperty(vertex_id))current_index=facemap[vertex_id];else{for(var j=0;j<buffers.length;++j){var buffer=buffers[j],index=parseInt(data[k+j]),array=buffer[1],source=buffer[3];0==j&&(vertex_remap[array.length/num_data_vertex]=index),index*=buffer[2];for(var x=0;x<buffer[2];++x)array.push(source[index+x])}current_index=last_index,last_index+=1,facemap[vertex_id]=current_index}indicesArray.push(current_index)}}var mesh={primitive:"line_strip",vertices:new Float32Array(buffers[0][1]),info:{}};return this.transformMeshInfo(mesh,buffers,indicesArray)},findXMLNodeById:function(root,nodename,id){if(this._xmlroot._nodes_by_id){var n=this._xmlroot._nodes_by_id[id];if(n&&n.localName==nodename)return n}else{var n=this._xmlroot.getElementById(id);if(n)return n}for(var childs=root.childNodes,i=0;i<childs.length;++i){var xmlnode=childs.item(i);if(1==xmlnode.nodeType&&xmlnode.localName==nodename){if(xmlnode.getAttribute("id")==id)return xmlnode}}return null},readImages:function(root){var xmlimages=root.querySelector("library_images");if(!xmlimages)return null;for(var images={},xmlimages_childs=xmlimages.childNodes,i=0;i<xmlimages_childs.length;++i){var xmlimage=xmlimages_childs.item(i);if(1==xmlimage.nodeType){var xmlinitfrom=xmlimage.querySelector("init_from");if(xmlinitfrom&&xmlinitfrom.textContent){var filename=this.getFilename(xmlinitfrom.textContent),id=xmlimage.getAttribute("id");images[id]={filename:filename,map:id,name:xmlimage.getAttribute("name"),path:xmlinitfrom.textContent}}}}return images},readAnimations:function(root,scene){var xmlanimations=root.querySelector("library_animations");if(!xmlanimations)return null;for(var xmlanimation_childs=xmlanimations.childNodes,animations={object_type:"Animation",takes:{}},default_take={tracks:[]},tracks=default_take.tracks,i=0;i<xmlanimation_childs.length;++i){var xmlanimation=xmlanimation_childs.item(i);if(1==xmlanimation.nodeType&&"animation"==xmlanimation.localName){if(xmlanimation.getAttribute("id"))this.readAnimation(xmlanimation,tracks);else{var xmlanimation2_childs=xmlanimation.querySelectorAll("animation");if(xmlanimation2_childs.length)for(var j=0;j<xmlanimation2_childs.length;++j){var xmlanimation2=xmlanimation2_childs.item(j);this.readAnimation(xmlanimation2,tracks)}else this.readAnimation(xmlanimation,tracks)}}}if(!tracks.length)return null;for(var max_time=0,i=0;i<tracks.length;++i)max_time<tracks[i].duration&&(max_time=tracks[i].duration);return default_take.name="default",default_take.duration=max_time,animations.takes[default_take.name]=default_take,animations},readAnimation:function(xmlanimation,result){if("animation"!=xmlanimation.localName)return null;var xmlchannel_list=(xmlanimation.getAttribute("id"),xmlanimation.querySelectorAll("channel"));if(!xmlchannel_list.length)return null;for(var tracks=result||[],i=0;i<xmlchannel_list.length;++i){var anim=this.readChannel(xmlchannel_list.item(i),xmlanimation);anim&&tracks.push(anim)}return tracks},readChannel:function(xmlchannel,xmlanimation){if("channel"!=xmlchannel.localName||"animation"!=xmlanimation.localName)return null;var source=xmlchannel.getAttribute("source"),target=xmlchannel.getAttribute("target"),xmlsampler=this.findXMLNodeById(xmlanimation,"sampler",source.substr(1));if(!xmlsampler)return console.error("Error DAE: Sampler not found in "+source),null;for(var inputs={},params={},sources={},xmlinputs=xmlsampler.querySelectorAll("input"),time_data=null,j=0;j<xmlinputs.length;j++){var xmlinput=xmlinputs.item(j),source_name=xmlinput.getAttribute("source"),semantic=xmlinput.getAttribute("semantic"),xmlsource=this.findXMLNodeById(xmlanimation,"source",source_name.substr(1));if(xmlsource){var xmlparam=xmlsource.querySelector("param");if(xmlparam){var type=xmlparam.getAttribute("type");inputs[semantic]={source:source_name,type:type};var data_array=null;if("float"==type||"float4x4"==type){var xmlfloatarray=xmlsource.querySelector("float_array"),floats=this.readContentAsFloats(xmlfloatarray);sources[source_name]=floats,data_array=floats;var param_name=xmlparam.getAttribute("name");"TIME"==param_name&&(time_data=data_array),"OUTPUT"==semantic&&(param_name=semantic),param_name?params[param_name]=type:console.warn("Collada: <param> without name attribute in <animation>")}}}}if(!time_data)return console.error("Error DAE: no TIME info found in <channel>: "+xmlchannel.getAttribute("source")),null;var path=target.split("/"),anim={},nodename=path[0],node=this._nodes_by_id[nodename],locator=node.id+"/"+path[1];anim.name=path[1],anim.property=locator;var type="number",element_size=1,param_type=params.OUTPUT;switch(param_type){case"float":element_size=1;break;case"float3x3":element_size=9,type="mat3";break;case"float4x4":element_size=16,type="mat4"}anim.type=type,anim.value_size=element_size,anim.duration=time_data[time_data.length-1];var value_data=sources[inputs.OUTPUT.source];if(!value_data)return null;for(var num_samples=time_data.length,sample_size=element_size+1,anim_data=new Float32Array(num_samples*sample_size),j=0;j<time_data.length;++j){anim_data[j*sample_size]=time_data[j];var value=value_data.subarray(j*element_size,(j+1)*element_size);"float4x4"==param_type&&this.transformMatrix(value,node?0==node._depth:0),anim_data.set(value,j*sample_size+1)}if(isWorker&&this.use_transferables){var data=anim_data;data&&data.buffer&&data.length>100&&this._transferables.push(data.buffer)}return anim.data=anim_data,anim},findNode:function(root,id){if(root.id==id)return root;if(root.children)for(var i in root.children){var ret=this.findNode(root.children[i],id);if(ret)return ret}return null},readLibraryControllers:function(scene){var xmllibrarycontrollers=this._xmlroot.querySelector("library_controllers");if(!xmllibrarycontrollers)return null;for(var xmllibrarycontrollers_childs=xmllibrarycontrollers.childNodes,i=0;i<xmllibrarycontrollers_childs.length;++i){var xmlcontroller=xmllibrarycontrollers_childs.item(i);if(1==xmlcontroller.nodeType&&"controller"==xmlcontroller.localName){var id=xmlcontroller.getAttribute("id");this._controllers_found[id]||this.readController(xmlcontroller,null,scene)}}},readController:function(xmlcontroller,flip,scene){if("controller"==!xmlcontroller.localName)return console.warn("readController: not a controller: "+xmlcontroller.localName),null;var id=xmlcontroller.getAttribute("id");if(this._controllers_found[id])return this._controllers_found[id];var mesh=null,xmlskin=xmlcontroller.querySelector("skin");xmlskin&&(mesh=this.readSkinController(xmlskin,flip,scene));var xmlmorph=xmlcontroller.querySelector("morph");return xmlmorph&&(mesh=this.readMorphController(xmlmorph,flip,scene,mesh)),this._controllers_found[id]?id+="_1blah":this._controllers_found[id]=mesh,mesh},readSkinController:function(xmlskin,flip,scene){var id_geometry=xmlskin.getAttribute("source"),mesh=this.readGeometry(id_geometry,flip,scene);if(!mesh)return null;var sources=this.readSources(xmlskin,flip);if(!sources)return null;var bind_matrix=null,xmlbindmatrix=xmlskin.querySelector("bind_shape_matrix");xmlbindmatrix?(bind_matrix=this.readContentAsFloats(xmlbindmatrix),this.transformMatrix(bind_matrix,!0,!0)):bind_matrix=_glMatrix.mat4.create();var joints=[],xmljoints=xmlskin.querySelector("joints");if(xmljoints){for(var joints_source=null,inv_bind_source=null,xmlinputs=xmljoints.querySelectorAll("input"),i=0;i<xmlinputs.length;i++){var xmlinput=xmlinputs[i],sem=xmlinput.getAttribute("semantic").toUpperCase(),src=xmlinput.getAttribute("source"),source=sources[src.substr(1)];"JOINT"==sem?joints_source=source:"INV_BIND_MATRIX"==sem&&(inv_bind_source=source)}if(!inv_bind_source||!joints_source)return console.error("Error DAE: no joints or inv_bind sources found"),null;for(var i in joints_source){var inv_mat=inv_bind_source.subarray(16*i,16*i+16),nodename=joints_source[i],node=this._nodes_by_id[nodename];node?(this.transformMatrix(inv_mat,0==node._depth,!0),joints.push([nodename,inv_mat])):console.warn("Node "+nodename+" not found")}}var xmlvertexweights=xmlskin.querySelector("vertex_weights");if(xmlvertexweights){for(var weights_indexed_array=null,xmlinputs=xmlvertexweights.querySelectorAll("input"),i=0;i<xmlinputs.length;i++)"WEIGHT"==xmlinputs[i].getAttribute("semantic").toUpperCase()&&(weights_indexed_array=sources[xmlinputs.item(i).getAttribute("source").substr(1)]);if(!weights_indexed_array)throw"no weights found";for(var xmlvcount=xmlvertexweights.querySelector("vcount"),vcount=this.readContentAsUInt32(xmlvcount),xmlv=xmlvertexweights.querySelector("v"),v=this.readContentAsUInt32(xmlv),num_vertices=mesh.vertices.length/3,weights_array=new Float32Array(4*num_vertices),bone_index_array=new Uint8Array(4*num_vertices),pos=0,remap=mesh._remap,max_bone=0,i=0,l=vcount.length;i<l;++i){for(var num_bones=vcount[i],offset=pos,b=bone_index_array.subarray(4*i,4*i+4),w=weights_array.subarray(4*i,4*i+4),sum=0,j=0;j<num_bones&&j<4;++j)b[j]=v[offset+2*j],b[j]>max_bone&&(max_bone=b[j]),w[j]=weights_indexed_array[v[offset+2*j+1]],sum+=w[j];if(num_bones>4&&sum<1)for(var inv_sum=1/sum,j=0;j<4;++j)w[j]*=inv_sum;pos+=2*num_bones}for(var final_weights=new Float32Array(4*num_vertices),final_bone_indices=new Uint8Array(4*num_vertices),used_joints=[],i=0;i<num_vertices;++i){for(var p=4*remap[i],w=weights_array.subarray(p,p+4),b=bone_index_array.subarray(p,p+4),k=0;k<3;++k){for(var max_pos=k,max_value=w[k],j=k+1;j<4;++j)w[j]<=max_value||(max_pos=j,max_value=w[j]);if(max_pos!=k){var tmp=w[k];w[k]=w[max_pos],w[max_pos]=tmp,tmp=b[k],b[k]=b[max_pos],b[max_pos]=tmp}}final_weights.set(w,4*i),final_bone_indices.set(b,4*i),w[0]&&(used_joints[b[0]]=!0),w[1]&&(used_joints[b[1]]=!0),w[2]&&(used_joints[b[2]]=!0),w[3]&&(used_joints[b[3]]=!0)}max_bone>=joints.length&&console.warn("Mesh uses higher bone index than bones found");for(var new_bones=[],bones_translation={},i=0;i<used_joints.length;++i)used_joints[i]&&(bones_translation[i]=new_bones.length,new_bones.push(joints[i]));if(new_bones.length<joints.length){for(var i=0;i<final_bone_indices.length;i++)final_bone_indices[i]=bones_translation[final_bone_indices[i]];joints=new_bones}mesh.weights=final_weights,mesh.bone_indices=final_bone_indices,mesh.bones=joints,mesh.bind_matrix=bind_matrix}return mesh},readMorphController:function(xmlmorph,flip,scene,mesh){var id_geometry=xmlmorph.getAttribute("source"),base_mesh=this.readGeometry(id_geometry,flip,scene);if(!base_mesh)return null;var sources=this.readSources(xmlmorph,flip),morphs=[],xmltargets=xmlmorph.querySelector("targets");if(!xmltargets)return null;for(var xmlinputs=xmltargets.querySelectorAll("input"),targets=null,weights=null,i=0;i<xmlinputs.length;i++){var xmlinput=xmlinputs.item(i),semantic=xmlinput.getAttribute("semantic").toUpperCase(),data=sources[xmlinput.getAttribute("source").substr(1)];"MORPH_TARGET"==semantic?targets=data:"MORPH_WEIGHT"==semantic&&(weights=data)}if(!targets||!weights)return console.warn("Morph controller without targets or weights. Skipping it."),null;for(var i in targets){var id="#"+targets[i],geometry=this.readGeometry(id,flip,scene);scene.meshes[id]=geometry,morphs.push({mesh:id,weight:weights[i]})}return base_mesh.morph_targets=morphs,base_mesh},readBindMaterials:function(xmlbind_material,mesh){for(var materials=[],xmltechniques=xmlbind_material.querySelectorAll("technique_common"),i=0;i<xmltechniques.length;i++)for(var xmltechnique=xmltechniques.item(i),xmlinstance_materials=xmltechnique.querySelectorAll("instance_material"),j=0;j<xmlinstance_materials.length;j++){var xmlinstance_material=xmlinstance_materials.item(j);xmlinstance_material&&materials.push(xmlinstance_material.getAttribute("symbol"))}return materials},readSources:function(xmlnode,flip){for(var sources={},xmlsources=xmlnode.querySelectorAll("source"),i=0;i<xmlsources.length;i++){var xmlsource=xmlsources.item(i);if(xmlsource.querySelector){if(xmlsource.querySelector("float_array")){var floats=this.readContentAsFloats(xmlsource);sources[xmlsource.getAttribute("id")]=floats}else{var name_array=xmlsource.querySelector("Name_array");if(name_array){var names=this.readContentAsStringsArray(name_array);if(!names)continue;sources[xmlsource.getAttribute("id")]=names}else{var ref_array=xmlsource.querySelector("IDREF_array");if(ref_array){var names=this.readContentAsStringsArray(ref_array);if(!names)continue;sources[xmlsource.getAttribute("id")]=names}else;}}}}return sources},readContentAsUInt32:function(xmlnode){if(!xmlnode)return null;var text=xmlnode.textContent;if(text=text.replace(/\n/gi," "),text=text.trim(),0==text.length)return null;for(var numbers=text.split(" "),floats=new Uint32Array(numbers.length),k=0;k<numbers.length;k++)floats[k]=parseInt(numbers[k]);return floats},readContentAsFloats:function(xmlnode){if(!xmlnode)return null;var text=xmlnode.textContent;text=text.replace(/\n/gi," "),text=text.replace(/\s\s+/gi," "),text=text.replace(/\t/gi,""),text=text.trim();for(var numbers=text.split(" "),count=xmlnode.getAttribute("count"),length=count?parseInt(count):numbers.length,floats=new Float32Array(length),k=0;k<numbers.length;k++)floats[k]=parseFloat(numbers[k]);return floats},readContentAsStringsArray:function(xmlnode){if(!xmlnode)return null;var text=xmlnode.textContent;text=text.replace(/\n/gi," "),text=text.replace(/\s\s/gi," "),text=text.trim();for(var words=text.split(" "),k=0;k<words.length;k++)words[k]=words[k].trim();if(xmlnode.getAttribute("count")&&parseInt(xmlnode.getAttribute("count"))!=words.length){var merged_words=[],name="";for(var i in words)name?name+=" "+words[i]:name=words[i],this._nodes_by_id[this.safeString(name)]&&(merged_words.push(this.safeString(name)),name="");var count=parseInt(xmlnode.getAttribute("count"));return merged_words.length==count?merged_words:(console.error("Error: bone names have spaces, avoid using spaces in names"),null)}return words},max3d_matrix_0:new Float32Array([0,-1,0,0,0,0,-1,0,1,0,0,-0,0,0,0,1]),transformMatrix:function(matrix,first_level,inverted){if(_glMatrix.mat4.transpose(matrix,matrix),this.no_flip)return matrix;if(first_level){var temp=new Float32Array(matrix.subarray(4,8));matrix.set(matrix.subarray(8,12),4),matrix.set(temp,8),temp=matrix.subarray(8,12),vec4.scale(temp,temp,-1)}else{var M=_glMatrix.mat4.create(),m=matrix;M.set([m[0],m[2],-m[1]],0),M.set([m[8],m[10],-m[9]],4),M.set([-m[4],-m[6],m[5]],8),M.set([m[12],m[14],-m[13]],12),m.set(M)}return matrix}};exports.default=Collada,module.exports=exports.default}).call(exports,__webpack_require__(70))},function(module,exports,__webpack_require__){"use strict";var g,_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj};g=function(){return this}();try{g=g||Function("return this")()||(0,eval)("this")}catch(e){"object"===("undefined"==typeof window?"undefined":_typeof(window))&&(g=window)}module.exports=g},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_Pass=__webpack_require__(9),_GLTool=(_interopRequireDefault(_Pass),__webpack_require__(0)),_GLTool2=_interopRequireDefault(_GLTool),_Geom=__webpack_require__(7),_Geom2=_interopRequireDefault(_Geom),_FrameBuffer=__webpack_require__(12),_FrameBuffer2=_interopRequireDefault(_FrameBuffer),EffectComposer=function(){function EffectComposer(mWidth,mHeight){arguments.length>2&&void 0!==arguments[2]&&arguments[2];_classCallCheck(this,EffectComposer),this._width=mWidth||_GLTool2.default.width,this._height=mHeight||_GLTool2.default.height,this._params={},this.setSize(mWidth,mHeight),this._mesh=_Geom2.default.bigTriangle(),this._passes=[],this._returnTexture}return _createClass(EffectComposer,[{key:"addPass",value:function(pass){if(pass.passes)return void this.addPass(pass.passes);if(pass.length)for(var i=0;i<pass.length;i++)this._passes.push(pass[i]);else this._passes.push(pass)}},{key:"render",value:function(mSource){var _this=this,source=mSource,fboTarget=void 0;return this._passes.forEach(function(pass){fboTarget=pass.hasFbo?pass.fbo:_this._fboTarget,fboTarget.bind(),_GLTool2.default.clear(0,0,0,0),pass.render(source),_GLTool2.default.draw(_this._mesh),fboTarget.unbind(),pass.hasFbo?source=pass.fbo.getTexture():(_this._swap(),source=_this._fboCurrent.getTexture())}),this._returnTexture=source,source}},{key:"_swap",value:function(){var tmp=this._fboCurrent;this._fboCurrent=this._fboTarget,this._fboTarget=tmp,this._current=this._fboCurrent,this._target=this._fboTarget}},{key:"setSize",value:function(mWidth,mHeight){this._width=mWidth,this._height=mHeight,this._fboCurrent=new _FrameBuffer2.default(this._width,this._height,this._params),this._fboTarget=new _FrameBuffer2.default(this._width,this._height,this._params)}},{key:"getTexture",value:function(){return this._returnTexture}},{key:"passes",get:function(){return this._passes}}]),EffectComposer}();exports.default=EffectComposer},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _PassVBlur=__webpack_require__(37),_PassVBlur2=_interopRequireDefault(_PassVBlur),_PassHBlur=__webpack_require__(39),_PassHBlur2=_interopRequireDefault(_PassHBlur),_PassMacro2=__webpack_require__(36),_PassMacro3=_interopRequireDefault(_PassMacro2),PassBlur=function(_PassMacro){function PassBlur(){var mQuality=arguments.length>0&&void 0!==arguments[0]?arguments[0]:9,mWidth=arguments[1],mHeight=arguments[2],mParams=arguments[3];_classCallCheck(this,PassBlur);var _this=_possibleConstructorReturn(this,(PassBlur.__proto__||Object.getPrototypeOf(PassBlur)).call(this)),vBlur=new _PassVBlur2.default(mQuality,mWidth,mHeight,mParams),hBlur=new _PassHBlur2.default(mQuality,mWidth,mHeight,mParams);return _this.addPass(vBlur),_this.addPass(hBlur),_this}return _inherits(PassBlur,_PassMacro),PassBlur}(_PassMacro3.default);exports.default=PassBlur},function(module,exports){module.exports="// blur5.frag\n// source  : https://github.com/Jam3/glsl-fast-gaussian-blur\n\n#define SHADER_NAME BLUR_5\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uDirection;\nuniform vec2 uResolution;\n\nvec4 blur5(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n\tvec4 color = vec4(0.0);\n\tvec2 off1 = vec2(1.3333333333333333) * direction;\n\tcolor += texture2D(image, uv) * 0.29411764705882354;\n\tcolor += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;\n\tcolor += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;\n\treturn color; \n}\n\n\nvoid main(void) {\n    gl_FragColor = blur5(texture, vTextureCoord, uResolution, uDirection);\n}"},function(module,exports){module.exports="// blur9.frag\n// source  : https://github.com/Jam3/glsl-fast-gaussian-blur\n\n#define SHADER_NAME BLUR_9\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uDirection;\nuniform vec2 uResolution;\n\nvec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n\tvec4 color = vec4(0.0);\n\tvec2 off1 = vec2(1.3846153846) * direction;\n\tvec2 off2 = vec2(3.2307692308) * direction;\n\tcolor += texture2D(image, uv) * 0.2270270270;\n\tcolor += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;\n\tcolor += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;\n\tcolor += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;\n\tcolor += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;\n\treturn color;\n}\n\n\nvoid main(void) {\n    gl_FragColor = blur9(texture, vTextureCoord, uResolution, uDirection);\n}"},function(module,exports){module.exports="// blur13.frag\n// source  : https://github.com/Jam3/glsl-fast-gaussian-blur\n\n#define SHADER_NAME BLUR_13\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uDirection;\nuniform vec2 uResolution;\n\nvec4 blur13(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n\tvec4 color = vec4(0.0);\n\tvec2 off1 = vec2(1.411764705882353) * direction;\n\tvec2 off2 = vec2(3.2941176470588234) * direction;\n\tvec2 off3 = vec2(5.176470588235294) * direction;\n\tcolor += texture2D(image, uv) * 0.1964825501511404;\n\tcolor += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;\n\tcolor += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;\n\tcolor += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;\n\tcolor += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;\n\tcolor += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;\n\tcolor += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;\n\treturn color;\n}\n\n\nvoid main(void) {\n    gl_FragColor = blur13(texture, vTextureCoord, uResolution, uDirection);\n}"},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_Pass2=__webpack_require__(9),_Pass3=_interopRequireDefault(_Pass2),_fxaa=__webpack_require__(40),_fxaa2=_interopRequireDefault(_fxaa),PassFxaa=function(_Pass){function PassFxaa(){_classCallCheck(this,PassFxaa);var _this=_possibleConstructorReturn(this,(PassFxaa.__proto__||Object.getPrototypeOf(PassFxaa)).call(this,_fxaa2.default));return _this.uniform("uResolution",[1/_GLTool2.default.width,1/_GLTool2.default.height]),_this}return _inherits(PassFxaa,_Pass),PassFxaa}(_Pass3.default);exports.default=PassFxaa},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;if(void 0!==getter)return getter.call(receiver)},_Geom=__webpack_require__(7),_Geom2=_interopRequireDefault(_Geom),_GLShader=__webpack_require__(2),_GLShader2=_interopRequireDefault(_GLShader),_Batch2=__webpack_require__(4),_Batch3=_interopRequireDefault(_Batch2),vs=__webpack_require__(18),fs=__webpack_require__(19),BatchCopy=function(_Batch){function BatchCopy(){_classCallCheck(this,BatchCopy);var mesh=_Geom2.default.bigTriangle(),shader=new _GLShader2.default(vs,fs),_this=_possibleConstructorReturn(this,(BatchCopy.__proto__||Object.getPrototypeOf(BatchCopy)).call(this,mesh,shader));return shader.bind(),shader.uniform("texture","uniform1i",0),_this}return _inherits(BatchCopy,_Batch),_createClass(BatchCopy,[{key:"draw",value:function(texture){this.shader.bind(),texture.bind(0),_get(BatchCopy.prototype.__proto__||Object.getPrototypeOf(BatchCopy.prototype),"draw",this).call(this)}}]),BatchCopy}(_Batch3.default);exports.default=BatchCopy},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_Mesh=__webpack_require__(5),_Mesh2=_interopRequireDefault(_Mesh),_GLShader=__webpack_require__(2),_GLShader2=_interopRequireDefault(_GLShader),_Batch2=__webpack_require__(4),_Batch3=_interopRequireDefault(_Batch2),vs=__webpack_require__(79),fs=__webpack_require__(80),BatchAxis=function(_Batch){function BatchAxis(){_classCallCheck(this,BatchAxis);var positions=[],colors=[],indices=[0,1,2,3,4,5],r=9999;positions.push([-r,0,0]),positions.push([r,0,0]),positions.push([0,-r,0]),positions.push([0,r,0]),positions.push([0,0,-r]),positions.push([0,0,r]),colors.push([1,0,0]),colors.push([1,0,0]),colors.push([0,1,0]),colors.push([0,1,0]),colors.push([0,0,1]),colors.push([0,0,1]);var mesh=new _Mesh2.default(_GLTool2.default.LINES);mesh.bufferVertex(positions),mesh.bufferIndex(indices),mesh.bufferData(colors,"aColor",3);var shader=new _GLShader2.default(vs,fs);return _possibleConstructorReturn(this,(BatchAxis.__proto__||Object.getPrototypeOf(BatchAxis)).call(this,mesh,shader))}return _inherits(BatchAxis,_Batch),BatchAxis}(_Batch3.default);exports.default=BatchAxis},function(module,exports){module.exports="// axis.vert\n\n#define SHADER_NAME BASIC_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec3 aColor;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vColor = aColor;\n    vNormal = aNormal;\n}"},function(module,exports){module.exports="// axis.frag\n\n#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision lowp float;\n#define GLSLIFY 1\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\t// vec3 color = vNormal;\n\tvec3 color = vColor + vNormal * 0.0001;\n    gl_FragColor = vec4(color, 1.0);\n}"},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;if(void 0!==getter)return getter.call(receiver)},_Geom=__webpack_require__(7),_Geom2=_interopRequireDefault(_Geom),_GLShader=__webpack_require__(2),_GLShader2=_interopRequireDefault(_GLShader),_Batch2=__webpack_require__(4),_Batch3=_interopRequireDefault(_Batch2),vs=__webpack_require__(33),fs=__webpack_require__(10),BatchBall=function(_Batch){function BatchBall(){_classCallCheck(this,BatchBall);var mesh=_Geom2.default.sphere(1,24),shader=new _GLShader2.default(vs,fs);return _possibleConstructorReturn(this,(BatchBall.__proto__||Object.getPrototypeOf(BatchBall)).call(this,mesh,shader))}return _inherits(BatchBall,_Batch),_createClass(BatchBall,[{key:"draw",value:function(){var position=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[0,0,0],scale=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],color=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1,1],opacity=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.shader.bind(),this.shader.uniform("position","uniform3fv",position),this.shader.uniform("scale","uniform3fv",scale),this.shader.uniform("color","uniform3fv",color),this.shader.uniform("opacity","uniform1f",opacity),_get(BatchBall.prototype.__proto__||Object.getPrototypeOf(BatchBall.prototype),"draw",this).call(this)}}]),BatchBall}(_Batch3.default);exports.default=BatchBall},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;if(void 0!==getter)return getter.call(receiver)},_GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_Mesh=__webpack_require__(5),_Mesh2=_interopRequireDefault(_Mesh),_GLShader=__webpack_require__(2),_GLShader2=_interopRequireDefault(_GLShader),_Batch2=__webpack_require__(4),_Batch3=_interopRequireDefault(_Batch2),vs=__webpack_require__(83),fs=__webpack_require__(10),BatchDotsPlane=function(_Batch){function BatchDotsPlane(){_classCallCheck(this,BatchDotsPlane);var positions=[],indices=[],index=0,i=void 0,j=void 0;for(i=-100;i<100;i+=1)for(j=-100;j<100;j+=1)positions.push([i,j,0]),indices.push(index),index++,positions.push([i,0,j]),indices.push(index),index++;var mesh=new _Mesh2.default(_GLTool2.default.POINTS);mesh.bufferVertex(positions),mesh.bufferIndex(indices);var shader=new _GLShader2.default(vs,fs),_this=_possibleConstructorReturn(this,(BatchDotsPlane.__proto__||Object.getPrototypeOf(BatchDotsPlane)).call(this,mesh,shader));return _this.color=[1,1,1],_this.opacity=.5,_this}return _inherits(BatchDotsPlane,_Batch),_createClass(BatchDotsPlane,[{key:"draw",value:function(){this.shader.bind(),this.shader.uniform("color","uniform3fv",this.color),this.shader.uniform("opacity","uniform1f",this.opacity),_get(BatchDotsPlane.prototype.__proto__||Object.getPrototypeOf(BatchDotsPlane.prototype),"draw",this).call(this)}}]),BatchDotsPlane}(_Batch3.default);exports.default=BatchDotsPlane},function(module,exports){module.exports="// basic.vert\n\n#define SHADER_NAME DOTS_PLANE_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition + aNormal * 0.000001, 1.0);\n    gl_PointSize = 1.0;\n    vNormal = aNormal;\n}"},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;if(void 0!==getter)return getter.call(receiver)},_GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_Mesh=__webpack_require__(5),_Mesh2=_interopRequireDefault(_Mesh),_GLShader=__webpack_require__(2),_GLShader2=_interopRequireDefault(_GLShader),_Batch2=__webpack_require__(4),_Batch3=_interopRequireDefault(_Batch2),vs=__webpack_require__(11),fs=__webpack_require__(10),BatchAxis=function(_Batch){function BatchAxis(){_classCallCheck(this,BatchAxis);var positions=[],indices=[0,1],coords=[[0,0],[1,1]];positions.push([0,0,0]),positions.push([0,0,0]);var mesh=new _Mesh2.default(_GLTool2.default.LINES);mesh.bufferVertex(positions),mesh.bufferTexCoord(coords),mesh.bufferIndex(indices);var shader=new _GLShader2.default(vs,fs);return _possibleConstructorReturn(this,(BatchAxis.__proto__||Object.getPrototypeOf(BatchAxis)).call(this,mesh,shader))}return _inherits(BatchAxis,_Batch),_createClass(BatchAxis,[{key:"draw",value:function(mPositionA,mPositionB){var color=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1,1],opacity=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._mesh.bufferVertex([mPositionA,mPositionB]),this._shader.bind(),this._shader.uniform("color","vec3",color),this._shader.uniform("opacity","float",opacity),_get(BatchAxis.prototype.__proto__||Object.getPrototypeOf(BatchAxis.prototype),"draw",this).call(this)}}]),BatchAxis}(_Batch3.default);exports.default=BatchAxis},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;if(void 0!==getter)return getter.call(receiver)},_Geom=__webpack_require__(7),_Geom2=_interopRequireDefault(_Geom),_GLShader=__webpack_require__(2),_GLShader2=_interopRequireDefault(_GLShader),_Batch2=__webpack_require__(4),_Batch3=_interopRequireDefault(_Batch2),vs=__webpack_require__(34),fs=__webpack_require__(35),BatchSkybox=function(_Batch){function BatchSkybox(){var size=arguments.length>0&&void 0!==arguments[0]?arguments[0]:20;_classCallCheck(this,BatchSkybox);var mesh=_Geom2.default.skybox(size),shader=new _GLShader2.default(vs,fs);return _possibleConstructorReturn(this,(BatchSkybox.__proto__||Object.getPrototypeOf(BatchSkybox)).call(this,mesh,shader))}return _inherits(BatchSkybox,_Batch),_createClass(BatchSkybox,[{key:"draw",value:function(texture){this.shader.bind(),texture.bind(0),_get(BatchSkybox.prototype.__proto__||Object.getPrototypeOf(BatchSkybox.prototype),"draw",this).call(this)}}]),BatchSkybox}(_Batch3.default);exports.default=BatchSkybox},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;if(void 0!==getter)return getter.call(receiver)},_Geom=__webpack_require__(7),_Geom2=_interopRequireDefault(_Geom),_GLShader=__webpack_require__(2),_GLShader2=_interopRequireDefault(_GLShader),_Batch2=__webpack_require__(4),_Batch3=_interopRequireDefault(_Batch2),vs=__webpack_require__(87),fs=__webpack_require__(19),BatchSky=function(_Batch){function BatchSky(){var size=arguments.length>0&&void 0!==arguments[0]?arguments[0]:50,seg=arguments.length>1&&void 0!==arguments[1]?arguments[1]:24;_classCallCheck(this,BatchSky);var mesh=_Geom2.default.sphere(size,seg,!0),shader=new _GLShader2.default(vs,fs);return _possibleConstructorReturn(this,(BatchSky.__proto__||Object.getPrototypeOf(BatchSky)).call(this,mesh,shader))}return _inherits(BatchSky,_Batch),_createClass(BatchSky,[{key:"draw",value:function(texture){this.shader.bind(),texture.bind(0),_get(BatchSky.prototype.__proto__||Object.getPrototypeOf(BatchSky.prototype),"draw",this).call(this)}}]),BatchSky}(_Batch3.default);exports.default=BatchSky},function(module,exports){module.exports="// sky.vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tmat4 matView = uViewMatrix;\n\tmatView[3][0] = 0.0;\n\tmatView[3][1] = 0.0;\n\tmatView[3][2] = 0.0;\n\t\n    gl_Position = uProjectionMatrix * matView * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vTextureCoord = aTextureCoord;\n    vNormal = aNormal;\n}"},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_get=function get(object,property,receiver){null===object&&(object=Function.prototype);var desc=Object.getOwnPropertyDescriptor(object,property);if(void 0===desc){var parent=Object.getPrototypeOf(object);return null===parent?void 0:get(parent,property,receiver)}if("value"in desc)return desc.value;var getter=desc.get;if(void 0!==getter)return getter.call(receiver)},_GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_Geom=__webpack_require__(7),_Geom2=_interopRequireDefault(_Geom),_GLShader=__webpack_require__(2),_GLShader2=_interopRequireDefault(_GLShader),_Batch2=__webpack_require__(4),_Batch3=_interopRequireDefault(_Batch2),vs=__webpack_require__(18),fs=__webpack_require__(40),BatchFXAA=function(_Batch){function BatchFXAA(){_classCallCheck(this,BatchFXAA);var mesh=_Geom2.default.bigTriangle(),shader=new _GLShader2.default(vs,fs),_this=_possibleConstructorReturn(this,(BatchFXAA.__proto__||Object.getPrototypeOf(BatchFXAA)).call(this,mesh,shader));return shader.bind(),shader.uniform("texture","uniform1i",0),_this}return _inherits(BatchFXAA,_Batch),_createClass(BatchFXAA,[{key:"draw",value:function(texture){this.shader.bind(),texture.bind(0),this.shader.uniform("uResolution","vec2",[1/_GLTool2.default.width,1/_GLTool2.default.height]),_get(BatchFXAA.prototype.__proto__||Object.getPrototypeOf(BatchFXAA.prototype),"draw",this).call(this)}}]),BatchFXAA}(_Batch3.default);exports.default=BatchFXAA},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_scheduling=__webpack_require__(6),_scheduling2=_interopRequireDefault(_scheduling),_GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),_CameraPerspective=__webpack_require__(16),_CameraPerspective2=_interopRequireDefault(_CameraPerspective),_CameraOrtho=__webpack_require__(30),_CameraOrtho2=_interopRequireDefault(_CameraOrtho),_OrbitalControl=__webpack_require__(29),_OrbitalControl2=_interopRequireDefault(_OrbitalControl),Scene=function(){function Scene(){var _this=this;_classCallCheck(this,Scene),this._children=[],this._matrixIdentity=mat4.create(),_GLTool2.default.enableAlphaBlending(),this._init(),this._initTextures(),this._initViews(),this._efIndex=_scheduling2.default.addEF(function(){return _this._loop()}),window.addEventListener("resize",function(){return _this.resize()})}return _createClass(Scene,[{key:"update",value:function(){}},{key:"render",value:function(){}},{key:"stop",value:function(){-1!==this._efIndex&&(this._efIndex=_scheduling2.default.removeEF(this._efIndex))}},{key:"start",value:function(){var _this2=this;-1===this._efIndex&&(this._efIndex=_scheduling2.default.addEF(function(){return _this2._loop()}))}},{key:"resize",value:function(){_GLTool2.default.setSize(window.innerWidth,window.innerHeight),this.camera.setAspectRatio(_GLTool2.default.aspectRatio)}},{key:"addChild",value:function(mChild){this._children.push(mChild)}},{key:"removeChild",value:function(mChild){var index=this._children.indexOf(mChild);if(-1==index)return void console.warn("Child no exist");this._children.splice(index,1)}},{key:"_initTextures",value:function(){}},{key:"_initViews",value:function(){}},{key:"_renderChildren",value:function(){for(var child=void 0,i=0;i<this._children.length;i++)child=this._children[i],child.toRender();_GLTool2.default.rotate(this._matrixIdentity)}},{key:"_init",value:function(){this.camera=new _CameraPerspective2.default,this.camera.setPerspective(45*Math.PI/180,_GLTool2.default.aspectRatio,.1,100),this.orbitalControl=new _OrbitalControl2.default(this.camera,window,15),this.orbitalControl.radius.value=10,this.cameraOrtho=new _CameraOrtho2.default}},{key:"_loop",value:function(){_GLTool2.default.viewport(0,0,_GLTool2.default.width,_GLTool2.default.height),_GLTool2.default.setMatrices(this.camera),this.update(),this._renderChildren(),this.render()}}]),Scene}();exports.default=Scene},function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_GLShader=__webpack_require__(2),_GLShader2=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(_GLShader),View=function(){function View(mStrVertex,mStrFrag){_classCallCheck(this,View),this.shader=new _GLShader2.default(mStrVertex,mStrFrag),this._init()}return _createClass(View,[{key:"_init",value:function(){}},{key:"render",value:function(){}}]),View}();exports.default=View},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_Object3D2=__webpack_require__(31),_Object3D3=_interopRequireDefault(_Object3D2),_GLShader=__webpack_require__(2),_GLShader2=_interopRequireDefault(_GLShader),_GLTool=__webpack_require__(0),_GLTool2=_interopRequireDefault(_GLTool),View3D=function(_Object3D){function View3D(mStrVertex,mStrFrag){_classCallCheck(this,View3D);var _this=_possibleConstructorReturn(this,(View3D.__proto__||Object.getPrototypeOf(View3D)).call(this));return _this._children=[],_this.shader=new _GLShader2.default(mStrVertex,mStrFrag),_this._init(),_this._matrixTemp=mat4.create(),_this}return _inherits(View3D,_Object3D),_createClass(View3D,[{key:"_init",value:function(){}},{key:"addChild",value:function(mChild){this._children.push(mChild)}},{key:"removeChild",value:function(mChild){var index=this._children.indexOf(mChild);if(-1==index)return void console.warn("Child no exist");this._children.splice(index,1)}},{key:"toRender",value:function(matrix){void 0===matrix&&(matrix=mat4.create()),mat4.mul(this._matrixTemp,matrix,this.matrix),_GLTool2.default.rotate(this._matrixTemp),this.render();for(var i=0;i<this._children.length;i++){this._children[i].toRender(this.matrix)}}},{key:"render",value:function(){}}]),View3D}(_Object3D3.default);exports.default=View3D}])});

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
// Config.js

exports.default = {
	numTrees: 60,
	treeScale: 2.1,
	floorRadius: 3.5,
	maxFloorHeight: 0.6,
	treeBumpHeight: 0.25,
	numSlides: 500,
	noiseNum: 8,
	noiseScale: 3,
	animated: false,
	fxaa: true,
	overlayOpacity: .25,
	bloomStrength: .25,
	pixelateMixing: 0.05,
	animal: 'deer',
	fogMovingSpeed: .5,
	gradientMap: 0.5,
	showSnow: true,
	snowSpeed: .5
};

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return _gsScope; });
/* unused harmony export TweenLite */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return globals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return TweenLite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return SimpleTimeline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Animation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Ease; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return Linear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return Power0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return Power1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return Power2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return Power3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return Power4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return TweenPlugin; });
/* unused harmony export EventDispatcher */
/*!
 * VERSION: 2.0.2
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */

/* ES6 changes:
	- declare and export _gsScope at top.
	- set var TweenLite = the result of the main function
	- export default TweenLite at the bottom
	- return TweenLite at the bottom of the main function
	- pass in _gsScope as the first parameter of the main function (which is actually at the bottom)
	- remove the "export to multiple environments" in Definition().
 */
var _gsScope = (typeof(window) !== "undefined") ? window : (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || {};

var TweenLite = (function(window, moduleName) {

		"use strict";
		var _exports = {},
			_doc = window.document,
			_globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
		if (_globals.TweenLite) {
			return _globals.TweenLite; //in case the core set of classes is already loaded, don't instantiate twice.
		}
		var _namespace = function(ns) {
				var a = ns.split("."),
					p = _globals, i;
				for (i = 0; i < a.length; i++) {
					p[a[i]] = p = p[a[i]] || {};
				}
				return p;
			},
			gs = _namespace("com.greensock"),
			_tinyNum = 0.0000000001,
			_slice = function(a) { //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++])) {}
				return b;
			},
			_emptyFunc = function() {},
			_isArray = (function() { //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
				var toString = Object.prototype.toString,
					array = toString.call([]);
				return function(obj) {
					return obj != null && (obj instanceof Array || (typeof(obj) === "object" && !!obj.push && toString.call(obj) === array));
				};
			}()),
			a, i, p, _ticker, _tickerActive,
			_defLookup = {},

			/**
			 * @constructor
			 * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
			 * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
			 * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
			 * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
			 *
			 * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
			 * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
			 * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
			 * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
			 * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
			 * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
			 * sandbox the banner one like:
			 *
			 * <script>
			 *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
			 * </script>
			 * <script src="js/greensock/v1.7/TweenMax.js"></script>
			 * <script>
			 *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
			 * </script>
			 * <script src="js/greensock/v1.6/TweenMax.js"></script>
			 * <script>
			 *     gs.TweenLite.to(...); //would use v1.7
			 *     TweenLite.to(...); //would use v1.6
			 * </script>
			 *
			 * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
			 * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
			 * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
			 * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
			 */
			Definition = function(ns, dependencies, func, global) {
				this.sc = (_defLookup[ns]) ? _defLookup[ns].sc : []; //subclasses
				_defLookup[ns] = this;
				this.gsClass = null;
				this.func = func;
				var _classes = [];
				this.check = function(init) {
					var i = dependencies.length,
						missing = i,
						cur, a, n, cl;
					while (--i > -1) {
						if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
							_classes[i] = cur.gsClass;
							missing--;
						} else if (init) {
							cur.sc.push(this);
						}
					}
					if (missing === 0 && func) {
						a = ("com.greensock." + ns).split(".");
						n = a.pop();
						cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);

						//exports to multiple environments
						if (global) {
							_globals[n] = _exports[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
							/*
							if (typeof(module) !== "undefined" && module.exports) { //node
								if (ns === moduleName) {
									module.exports = _exports[moduleName] = cl;
									for (i in _exports) {
										cl[i] = _exports[i];
									}
								} else if (_exports[moduleName]) {
									_exports[moduleName][n] = cl;
								}
							} else if (typeof(define) === "function" && define.amd){ //AMD
								define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() { return cl; });
							}
							*/
						}
						for (i = 0; i < this.sc.length; i++) {
							this.sc[i].check();
						}
					}
				};
				this.check(true);
			},

			//used to create Definition instances (which basically registers a class that has dependencies).
			_gsDefine = window._gsDefine = function(ns, dependencies, func, global) {
				return new Definition(ns, dependencies, func, global);
			},

			//a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
			_class = gs._class = function(ns, func, global) {
				func = func || function() {};
				_gsDefine(ns, [], function(){ return func; }, global);
				return func;
			};

		_gsDefine.globals = _globals;



/*
 * ----------------------------------------------------------------
 * Ease
 * ----------------------------------------------------------------
 */
		var _baseParams = [0, 0, 1, 1],
			Ease = _class("easing.Ease", function(func, extraParams, type, power) {
				this._func = func;
				this._type = type || 0;
				this._power = power || 0;
				this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
			}, true),
			_easeMap = Ease.map = {},
			_easeReg = Ease.register = function(ease, names, types, create) {
				var na = names.split(","),
					i = na.length,
					ta = (types || "easeIn,easeOut,easeInOut").split(","),
					e, name, j, type;
				while (--i > -1) {
					name = na[i];
					e = create ? _class("easing."+name, null, true) : gs.easing[name] || {};
					j = ta.length;
					while (--j > -1) {
						type = ta[j];
						_easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
					}
				}
			};

		p = Ease.prototype;
		p._calcEnd = false;
		p.getRatio = function(p) {
			if (this._func) {
				this._params[0] = p;
				return this._func.apply(null, this._params);
			}
			var t = this._type,
				pw = this._power,
				r = (t === 1) ? 1 - p : (t === 2) ? p : (p < 0.5) ? p * 2 : (1 - p) * 2;
			if (pw === 1) {
				r *= r;
			} else if (pw === 2) {
				r *= r * r;
			} else if (pw === 3) {
				r *= r * r * r;
			} else if (pw === 4) {
				r *= r * r * r * r;
			}
			return (t === 1) ? 1 - r : (t === 2) ? r : (p < 0.5) ? r / 2 : 1 - (r / 2);
		};

		//create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
		a = ["Linear","Quad","Cubic","Quart","Quint,Strong"];
		i = a.length;
		while (--i > -1) {
			p = a[i]+",Power"+i;
			_easeReg(new Ease(null,null,1,i), p, "easeOut", true);
			_easeReg(new Ease(null,null,2,i), p, "easeIn" + ((i === 0) ? ",easeNone" : ""));
			_easeReg(new Ease(null,null,3,i), p, "easeInOut");
		}
		_easeMap.linear = gs.easing.Linear.easeIn;
		_easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks


/*
 * ----------------------------------------------------------------
 * EventDispatcher
 * ----------------------------------------------------------------
 */
		var EventDispatcher = _class("events.EventDispatcher", function(target) {
			this._listeners = {};
			this._eventTarget = target || this;
		});
		p = EventDispatcher.prototype;

		p.addEventListener = function(type, callback, scope, useParam, priority) {
			priority = priority || 0;
			var list = this._listeners[type],
				index = 0,
				listener, i;
			if (this === _ticker && !_tickerActive) {
				_ticker.wake();
			}
			if (list == null) {
				this._listeners[type] = list = [];
			}
			i = list.length;
			while (--i > -1) {
				listener = list[i];
				if (listener.c === callback && listener.s === scope) {
					list.splice(i, 1);
				} else if (index === 0 && listener.pr < priority) {
					index = i + 1;
				}
			}
			list.splice(index, 0, {c:callback, s:scope, up:useParam, pr:priority});
		};

		p.removeEventListener = function(type, callback) {
			var list = this._listeners[type], i;
			if (list) {
				i = list.length;
				while (--i > -1) {
					if (list[i].c === callback) {
						list.splice(i, 1);
						return;
					}
				}
			}
		};

		p.dispatchEvent = function(type) {
			var list = this._listeners[type],
				i, t, listener;
			if (list) {
				i = list.length;
				if (i > 1) {
					list = list.slice(0); //in case addEventListener() is called from within a listener/callback (otherwise the index could change, resulting in a skip)
				}
				t = this._eventTarget;
				while (--i > -1) {
					listener = list[i];
					if (listener) {
						if (listener.up) {
							listener.c.call(listener.s || t, {type:type, target:t});
						} else {
							listener.c.call(listener.s || t);
						}
					}
				}
			}
		};


/*
 * ----------------------------------------------------------------
 * Ticker
 * ----------------------------------------------------------------
 */
 		var _reqAnimFrame = window.requestAnimationFrame,
			_cancelAnimFrame = window.cancelAnimationFrame,
			_getTime = Date.now || function() {return new Date().getTime();},
			_lastUpdate = _getTime();

		//now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
		a = ["ms","moz","webkit","o"];
		i = a.length;
		while (--i > -1 && !_reqAnimFrame) {
			_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
			_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
		}

		_class("Ticker", function(fps, useRAF) {
			var _self = this,
				_startTime = _getTime(),
				_useRAF = (useRAF !== false && _reqAnimFrame) ? "auto" : false,
				_lagThreshold = 500,
				_adjustedLag = 33,
				_tickWord = "tick", //helps reduce gc burden
				_fps, _req, _id, _gap, _nextTime,
				_tick = function(manual) {
					var elapsed = _getTime() - _lastUpdate,
						overlap, dispatch;
					if (elapsed > _lagThreshold) {
						_startTime += elapsed - _adjustedLag;
					}
					_lastUpdate += elapsed;
					_self.time = (_lastUpdate - _startTime) / 1000;
					overlap = _self.time - _nextTime;
					if (!_fps || overlap > 0 || manual === true) {
						_self.frame++;
						_nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
						dispatch = true;
					}
					if (manual !== true) { //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
						_id = _req(_tick);
					}
					if (dispatch) {
						_self.dispatchEvent(_tickWord);
					}
				};

			EventDispatcher.call(_self);
			_self.time = _self.frame = 0;
			_self.tick = function() {
				_tick(true);
			};

			_self.lagSmoothing = function(threshold, adjustedLag) {
				if (!arguments.length) { //if lagSmoothing() is called with no arguments, treat it like a getter that returns a boolean indicating if it's enabled or not. This is purposely undocumented and is for internal use.
					return (_lagThreshold < 1 / _tinyNum);
				}
				_lagThreshold = threshold || (1 / _tinyNum); //zero should be interpreted as basically unlimited
				_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
			};

			_self.sleep = function() {
				if (_id == null) {
					return;
				}
				if (!_useRAF || !_cancelAnimFrame) {
					clearTimeout(_id);
				} else {
					_cancelAnimFrame(_id);
				}
				_req = _emptyFunc;
				_id = null;
				if (_self === _ticker) {
					_tickerActive = false;
				}
			};

			_self.wake = function(seamless) {
				if (_id !== null) {
					_self.sleep();
				} else if (seamless) {
					_startTime += -_lastUpdate + (_lastUpdate = _getTime());
				} else if (_self.frame > 10) { //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
					_lastUpdate = _getTime() - _lagThreshold + 5;
				}
				_req = (_fps === 0) ? _emptyFunc : (!_useRAF || !_reqAnimFrame) ? function(f) { return setTimeout(f, ((_nextTime - _self.time) * 1000 + 1) | 0); } : _reqAnimFrame;
				if (_self === _ticker) {
					_tickerActive = true;
				}
				_tick(2);
			};

			_self.fps = function(value) {
				if (!arguments.length) {
					return _fps;
				}
				_fps = value;
				_gap = 1 / (_fps || 60);
				_nextTime = this.time + _gap;
				_self.wake();
			};

			_self.useRAF = function(value) {
				if (!arguments.length) {
					return _useRAF;
				}
				_self.sleep();
				_useRAF = value;
				_self.fps(_fps);
			};
			_self.fps(fps);

			//a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
			setTimeout(function() {
				if (_useRAF === "auto" && _self.frame < 5 && (_doc || {}).visibilityState !== "hidden") {
					_self.useRAF(false);
				}
			}, 1500);
		});

		p = gs.Ticker.prototype = new gs.events.EventDispatcher();
		p.constructor = gs.Ticker;


/*
 * ----------------------------------------------------------------
 * Animation
 * ----------------------------------------------------------------
 */
		var Animation = _class("core.Animation", function(duration, vars) {
				this.vars = vars = vars || {};
				this._duration = this._totalDuration = duration || 0;
				this._delay = Number(vars.delay) || 0;
				this._timeScale = 1;
				this._active = (vars.immediateRender === true);
				this.data = vars.data;
				this._reversed = (vars.reversed === true);

				if (!_rootTimeline) {
					return;
				}
				if (!_tickerActive) { //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
					_ticker.wake();
				}

				var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
				tl.add(this, tl._time);

				if (this.vars.paused) {
					this.paused(true);
				}
			});

		_ticker = Animation.ticker = new gs.Ticker();
		p = Animation.prototype;
		p._dirty = p._gc = p._initted = p._paused = false;
		p._totalTime = p._time = 0;
		p._rawPrevTime = -1;
		p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
		p._paused = false;


		//some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
		var _checkTimeout = function() {
				if (_tickerActive && _getTime() - _lastUpdate > 2000 && ((_doc || {}).visibilityState !== "hidden" || !_ticker.lagSmoothing())) { //note: if the tab is hidden, we should still wake if lagSmoothing has been disabled.
					_ticker.wake();
				}
				var t = setTimeout(_checkTimeout, 2000);
				if (t.unref) {
					// allows a node process to exit even if the timeout’s callback hasn't been invoked. Without it, the node process could hang as this function is called every two seconds.
					t.unref();
				}
			};
		_checkTimeout();


		p.play = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.reversed(false).paused(false);
		};

		p.pause = function(atTime, suppressEvents) {
			if (atTime != null) {
				this.seek(atTime, suppressEvents);
			}
			return this.paused(true);
		};

		p.resume = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.paused(false);
		};

		p.seek = function(time, suppressEvents) {
			return this.totalTime(Number(time), suppressEvents !== false);
		};

		p.restart = function(includeDelay, suppressEvents) {
			return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, (suppressEvents !== false), true);
		};

		p.reverse = function(from, suppressEvents) {
			if (from != null) {
				this.seek((from || this.totalDuration()), suppressEvents);
			}
			return this.reversed(true).paused(false);
		};

		p.render = function(time, suppressEvents, force) {
			//stub - we override this method in subclasses.
		};

		p.invalidate = function() {
			this._time = this._totalTime = 0;
			this._initted = this._gc = false;
			this._rawPrevTime = -1;
			if (this._gc || !this.timeline) {
				this._enabled(true);
			}
			return this;
		};

		p.isActive = function() {
			var tl = this._timeline, //the 2 root timelines won't have a _timeline; they're always active.
				startTime = this._startTime,
				rawTime;
			return (!tl || (!this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime(true)) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale - 0.0000001));
		};

		p._enabled = function (enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			this._gc = !enabled;
			this._active = this.isActive();
			if (ignoreTimeline !== true) {
				if (enabled && !this.timeline) {
					this._timeline.add(this, this._startTime - this._delay);
				} else if (!enabled && this.timeline) {
					this._timeline._remove(this, true);
				}
			}
			return false;
		};


		p._kill = function(vars, target) {
			return this._enabled(false, false);
		};

		p.kill = function(vars, target) {
			this._kill(vars, target);
			return this;
		};

		p._uncache = function(includeSelf) {
			var tween = includeSelf ? this : this.timeline;
			while (tween) {
				tween._dirty = true;
				tween = tween.timeline;
			}
			return this;
		};

		p._swapSelfInParams = function(params) {
			var i = params.length,
				copy = params.concat();
			while (--i > -1) {
				if (params[i] === "{self}") {
					copy[i] = this;
				}
			}
			return copy;
		};

		p._callback = function(type) {
			var v = this.vars,
				callback = v[type],
				params = v[type + "Params"],
				scope = v[type + "Scope"] || v.callbackScope || this,
				l = params ? params.length : 0;
			switch (l) { //speed optimization; call() is faster than apply() so use it when there are only a few parameters (which is by far most common). Previously we simply did var v = this.vars; v[type].apply(v[type + "Scope"] || v.callbackScope || this, v[type + "Params"] || _blankArray);
				case 0: callback.call(scope); break;
				case 1: callback.call(scope, params[0]); break;
				case 2: callback.call(scope, params[0], params[1]); break;
				default: callback.apply(scope, params);
			}
		};

//----Animation getters/setters --------------------------------------------------------

		p.eventCallback = function(type, callback, params, scope) {
			if ((type || "").substr(0,2) === "on") {
				var v = this.vars;
				if (arguments.length === 1) {
					return v[type];
				}
				if (callback == null) {
					delete v[type];
				} else {
					v[type] = callback;
					v[type + "Params"] = (_isArray(params) && params.join("").indexOf("{self}") !== -1) ? this._swapSelfInParams(params) : params;
					v[type + "Scope"] = scope;
				}
				if (type === "onUpdate") {
					this._onUpdate = callback;
				}
			}
			return this;
		};

		p.delay = function(value) {
			if (!arguments.length) {
				return this._delay;
			}
			if (this._timeline.smoothChildTiming) {
				this.startTime( this._startTime + value - this._delay );
			}
			this._delay = value;
			return this;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				this._dirty = false;
				return this._duration;
			}
			this._duration = this._totalDuration = value;
			this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
			if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
				this.totalTime(this._totalTime * (value / this._duration), true);
			}
			return this;
		};

		p.totalDuration = function(value) {
			this._dirty = false;
			return (!arguments.length) ? this._totalDuration : this.duration(value);
		};

		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			return this.totalTime((value > this._duration) ? this._duration : value, suppressEvents);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (!arguments.length) {
				return this._totalTime;
			}
			if (this._timeline) {
				if (time < 0 && !uncapped) {
					time += this.totalDuration();
				}
				if (this._timeline.smoothChildTiming) {
					if (this._dirty) {
						this.totalDuration();
					}
					var totalDuration = this._totalDuration,
						tl = this._timeline;
					if (time > totalDuration && !uncapped) {
						time = totalDuration;
					}
					this._startTime = (this._paused ? this._pauseTime : tl._time) - ((!this._reversed ? time : totalDuration - time) / this._timeScale);
					if (!tl._dirty) { //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
						this._uncache(false);
					}
					//in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
					if (tl._timeline) {
						while (tl._timeline) {
							if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
								tl.totalTime(tl._totalTime, true);
							}
							tl = tl._timeline;
						}
					}
				}
				if (this._gc) {
					this._enabled(true, false);
				}
				if (this._totalTime !== time || this._duration === 0) {
					if (_lazyTweens.length) {
						_lazyRender();
					}
					this.render(time, suppressEvents, false);
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
						_lazyRender();
					}
				}
			}
			return this;
		};

		p.progress = p.totalProgress = function(value, suppressEvents) {
			var duration = this.duration();
			return (!arguments.length) ? (duration ? this._time / duration : this.ratio) : this.totalTime(duration * value, suppressEvents);
		};

		p.startTime = function(value) {
			if (!arguments.length) {
				return this._startTime;
			}
			if (value !== this._startTime) {
				this._startTime = value;
				if (this.timeline) if (this.timeline._sortChildren) {
					this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			return this;
		};

		p.endTime = function(includeRepeats) {
			return this._startTime + ((includeRepeats != false) ? this.totalDuration() : this.duration()) / this._timeScale;
		};

		p.timeScale = function(value) {
			if (!arguments.length) {
				return this._timeScale;
			}
			var pauseTime, t;
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			if (this._timeline && this._timeline.smoothChildTiming) {
				pauseTime = this._pauseTime;
				t = (pauseTime || pauseTime === 0) ? pauseTime : this._timeline.totalTime();
				this._startTime = t - ((t - this._startTime) * this._timeScale / value);
			}
			this._timeScale = value;
			t = this.timeline;
			while (t && t.timeline) { //must update the duration/totalDuration of all ancestor timelines immediately in case in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
				t._dirty = true;
				t.totalDuration();
				t = t.timeline;
			}
			return this;
		};

		p.reversed = function(value) {
			if (!arguments.length) {
				return this._reversed;
			}
			if (value != this._reversed) {
				this._reversed = value;
				this.totalTime(((this._timeline && !this._timeline.smoothChildTiming) ? this.totalDuration() - this._totalTime : this._totalTime), true);
			}
			return this;
		};

		p.paused = function(value) {
			if (!arguments.length) {
				return this._paused;
			}
			var tl = this._timeline,
				raw, elapsed;
			if (value != this._paused) if (tl) {
				if (!_tickerActive && !value) {
					_ticker.wake();
				}
				raw = tl.rawTime();
				elapsed = raw - this._pauseTime;
				if (!value && tl.smoothChildTiming) {
					this._startTime += elapsed;
					this._uncache(false);
				}
				this._pauseTime = value ? raw : null;
				this._paused = value;
				this._active = this.isActive();
				if (!value && elapsed !== 0 && this._initted && this.duration()) {
					raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
					this.render(raw, (raw === this._totalTime), true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
				}
			}
			if (this._gc && !value) {
				this._enabled(true, false);
			}
			return this;
		};


/*
 * ----------------------------------------------------------------
 * SimpleTimeline
 * ----------------------------------------------------------------
 */
		var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {
			Animation.call(this, 0, vars);
			this.autoRemoveChildren = this.smoothChildTiming = true;
		});

		p = SimpleTimeline.prototype = new Animation();
		p.constructor = SimpleTimeline;
		p.kill()._gc = false;
		p._first = p._last = p._recent = null;
		p._sortChildren = false;

		p.add = p.insert = function(child, position, align, stagger) {
			var prevTween, st;
			child._startTime = Number(position || 0) + child._delay;
			if (child._paused) if (this !== child._timeline) { //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
				child._pauseTime = this.rawTime() - (child._timeline.rawTime() - child._pauseTime);
			}
			if (child.timeline) {
				child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
			}
			child.timeline = child._timeline = this;
			if (child._gc) {
				child._enabled(true, true);
			}
			prevTween = this._last;
			if (this._sortChildren) {
				st = child._startTime;
				while (prevTween && prevTween._startTime > st) {
					prevTween = prevTween._prev;
				}
			}
			if (prevTween) {
				child._next = prevTween._next;
				prevTween._next = child;
			} else {
				child._next = this._first;
				this._first = child;
			}
			if (child._next) {
				child._next._prev = child;
			} else {
				this._last = child;
			}
			child._prev = prevTween;
			this._recent = child;
			if (this._timeline) {
				this._uncache(true);
			}
			return this;
		};

		p._remove = function(tween, skipDisable) {
			if (tween.timeline === this) {
				if (!skipDisable) {
					tween._enabled(false, true);
				}

				if (tween._prev) {
					tween._prev._next = tween._next;
				} else if (this._first === tween) {
					this._first = tween._next;
				}
				if (tween._next) {
					tween._next._prev = tween._prev;
				} else if (this._last === tween) {
					this._last = tween._prev;
				}
				tween._next = tween._prev = tween.timeline = null;
				if (tween === this._recent) {
					this._recent = this._last;
				}

				if (this._timeline) {
					this._uncache(true);
				}
			}
			return this;
		};

		p.render = function(time, suppressEvents, force) {
			var tween = this._first,
				next;
			this._totalTime = this._time = this._rawPrevTime = time;
			while (tween) {
				next = tween._next; //record it here because the value could change after rendering...
				if (tween._active || (time >= tween._startTime && !tween._paused && !tween._gc)) {
					if (!tween._reversed) {
						tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
					} else {
						tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
					}
				}
				tween = next;
			}
		};

		p.rawTime = function() {
			if (!_tickerActive) {
				_ticker.wake();
			}
			return this._totalTime;
		};

/*
 * ----------------------------------------------------------------
 * TweenLite
 * ----------------------------------------------------------------
 */
		var TweenLite = _class("TweenLite", function(target, duration, vars) {
				Animation.call(this, duration, vars);
				this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

				if (target == null) {
					throw "Cannot tween a null target.";
				}

				this.target = target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;

				var isSelector = (target.jquery || (target.length && target !== window && target[0] && (target[0] === window || (target[0].nodeType && target[0].style && !target.nodeType)))),
					overwrite = this.vars.overwrite,
					i, targ, targets;

				this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === "number") ? overwrite >> 0 : _overwriteLookup[overwrite];

				if ((isSelector || target instanceof Array || (target.push && _isArray(target))) && typeof(target[0]) !== "number") {
					this._targets = targets = _slice(target);  //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
					this._propLookup = [];
					this._siblings = [];
					for (i = 0; i < targets.length; i++) {
						targ = targets[i];
						if (!targ) {
							targets.splice(i--, 1);
							continue;
						} else if (typeof(targ) === "string") {
							targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings
							if (typeof(targ) === "string") {
								targets.splice(i+1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
							}
							continue;
						} else if (targ.length && targ !== window && targ[0] && (targ[0] === window || (targ[0].nodeType && targ[0].style && !targ.nodeType))) { //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
							targets.splice(i--, 1);
							this._targets = targets = targets.concat(_slice(targ));
							continue;
						}
						this._siblings[i] = _register(targ, this, false);
						if (overwrite === 1) if (this._siblings[i].length > 1) {
							_applyOverwrite(targ, this, null, 1, this._siblings[i]);
						}
					}

				} else {
					this._propLookup = {};
					this._siblings = _register(target, this, false);
					if (overwrite === 1) if (this._siblings.length > 1) {
						_applyOverwrite(target, this, null, 1, this._siblings);
					}
				}
				if (this.vars.immediateRender || (duration === 0 && this._delay === 0 && this.vars.immediateRender !== false)) {
					this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
					this.render(Math.min(0, -this._delay)); //in case delay is negative
				}
			}, true),
			_isSelector = function(v) {
				return (v && v.length && v !== window && v[0] && (v[0] === window || (v[0].nodeType && v[0].style && !v.nodeType))); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
			},
			_autoCSS = function(vars, target) {
				var css = {},
					p;
				for (p in vars) {
					if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || (_plugins[p] && _plugins[p]._autoCSS))) { //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
						css[p] = vars[p];
						delete vars[p];
					}
				}
				vars.css = css;
			};

		p = TweenLite.prototype = new Animation();
		p.constructor = TweenLite;
		p.kill()._gc = false;

//----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

		p.ratio = 0;
		p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
		p._notifyPluginsOfEnabled = p._lazy = false;

		TweenLite.version = "2.0.2";
		TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
		TweenLite.defaultOverwrite = "auto";
		TweenLite.ticker = _ticker;
		TweenLite.autoSleep = 120;
		TweenLite.lagSmoothing = function(threshold, adjustedLag) {
			_ticker.lagSmoothing(threshold, adjustedLag);
		};

		TweenLite.selector = window.$ || window.jQuery || function(e) {
			var selector = window.$ || window.jQuery;
			if (selector) {
				TweenLite.selector = selector;
				return selector(e);
			}
			if (!_doc) { //in some dev environments (like Angular 6), GSAP gets loaded before the document is defined! So re-query it here if/when necessary.
				_doc = window.document;
			}
			return (!_doc) ? e : (_doc.querySelectorAll ? _doc.querySelectorAll(e) : _doc.getElementById((e.charAt(0) === "#") ? e.substr(1) : e));
		};

		var _lazyTweens = [],
			_lazyLookup = {},
			_numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
			_relExp = /[\+-]=-?[\.\d]/,
			//_nonNumbersExp = /(?:([\-+](?!(\d|=)))|[^\d\-+=e]|(e(?![\-+][\d])))+/ig,
			_setRatio = function(v) {
				var pt = this._firstPT,
					min = 0.000001,
					val;
				while (pt) {
					val = !pt.blob ? pt.c * v + pt.s : (v === 1 && this.end != null) ? this.end : v ? this.join("") : this.start;
					if (pt.m) {
						val = pt.m.call(this._tween, val, this._target || pt.t, this._tween);
					} else if (val < min) if (val > -min && !pt.blob) { //prevents issues with converting very small numbers to strings in the browser
						val = 0;
					}
					if (!pt.f) {
						pt.t[pt.p] = val;
					} else if (pt.fp) {
						pt.t[pt.p](pt.fp, val);
					} else {
						pt.t[pt.p](val);
					}
					pt = pt._next;
				}
			},
			//compares two strings (start/end), finds the numbers that are different and spits back an array representing the whole value but with the changing values isolated as elements. For example, "rgb(0,0,0)" and "rgb(100,50,0)" would become ["rgb(", 0, ",", 50, ",0)"]. Notice it merges the parts that are identical (performance optimization). The array also has a linked list of PropTweens attached starting with _firstPT that contain the tweening data (t, p, s, c, f, etc.). It also stores the starting value as a "start" property so that we can revert to it if/when necessary, like when a tween rewinds fully. If the quantity of numbers differs between the start and end, it will always prioritize the end value(s). The pt parameter is optional - it's for a PropTween that will be appended to the end of the linked list and is typically for actually setting the value after all of the elements have been updated (with array.join("")).
			_blobDif = function(start, end, filter, pt) {
				var a = [],
					charIndex = 0,
					s = "",
					color = 0,
					startNums, endNums, num, i, l, nonNumbers, currentNum;
				a.start = start;
				a.end = end;
				start = a[0] = start + ""; //ensure values are strings
				end = a[1] = end + "";
				if (filter) {
					filter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.
					start = a[0];
					end = a[1];
				}
				a.length = 0;
				startNums = start.match(_numbersExp) || [];
				endNums = end.match(_numbersExp) || [];
				if (pt) {
					pt._next = null;
					pt.blob = 1;
					a._firstPT = a._applyPT = pt; //apply last in the linked list (which means inserting it first)
				}
				l = endNums.length;
				for (i = 0; i < l; i++) {
					currentNum = endNums[i];
					nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex)-charIndex);
					s += (nonNumbers || !i) ? nonNumbers : ","; //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
					charIndex += nonNumbers.length;
					if (color) { //sense rgba() values and round them.
						color = (color + 1) % 5;
					} else if (nonNumbers.substr(-5) === "rgba(") {
						color = 1;
					}
					if (currentNum === startNums[i] || startNums.length <= i) {
						s += currentNum;
					} else {
						if (s) {
							a.push(s);
							s = "";
						}
						num = parseFloat(startNums[i]);
						a.push(num);
						a._firstPT = {_next: a._firstPT, t:a, p: a.length-1, s:num, c:((currentNum.charAt(1) === "=") ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : (parseFloat(currentNum) - num)) || 0, f:0, m:(color && color < 4) ? Math.round : 0};
						//note: we don't set _prev because we'll never need to remove individual PropTweens from this list.
					}
					charIndex += currentNum.length;
				}
				s += end.substr(charIndex);
				if (s) {
					a.push(s);
				}
				a.setRatio = _setRatio;
				if (_relExp.test(end)) { //if the end string contains relative values, delete it so that on the final render (in _setRatio()), we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
					a.end = null;
				}
				return a;
			},
			//note: "funcParam" is only necessary for function-based getters/setters that require an extra parameter like getAttribute("width") and setAttribute("width", value). In this example, funcParam would be "width". Used by AttrPlugin for example.
			_addPropTween = function(target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index) {
				if (typeof(end) === "function") {
					end = end(index || 0, target);
				}
				var type = typeof(target[prop]),
					getterName = (type !== "function") ? "" : ((prop.indexOf("set") || typeof(target["get" + prop.substr(3)]) !== "function") ? prop : "get" + prop.substr(3)),
					s = (start !== "get") ? start : !getterName ? target[prop] : funcParam ? target[getterName](funcParam) : target[getterName](),
					isRelative = (typeof(end) === "string" && end.charAt(1) === "="),
					pt = {t:target, p:prop, s:s, f:(type === "function"), pg:0, n:overwriteProp || prop, m:(!mod ? 0 : (typeof(mod) === "function") ? mod : Math.round), pr:0, c:isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : (parseFloat(end) - s) || 0},
					blob;

				if (typeof(s) !== "number" || (typeof(end) !== "number" && !isRelative)) {
					if (funcParam || isNaN(s) || (!isRelative && isNaN(end)) || typeof(s) === "boolean" || typeof(end) === "boolean") {
						//a blob (string that has multiple numbers in it)
						pt.fp = funcParam;
						blob = _blobDif(s, (isRelative ? (parseFloat(pt.s) + pt.c) + (pt.s + "").replace(/[0-9\-\.]/g, "") : end), stringFilter || TweenLite.defaultStringFilter, pt);
						pt = {t: blob, p: "setRatio", s: 0, c: 1, f: 2, pg: 0, n: overwriteProp || prop, pr: 0, m: 0}; //"2" indicates it's a Blob property tween. Needed for RoundPropsPlugin for example.
					} else {
						pt.s = parseFloat(s);
						if (!isRelative) {
							pt.c = (parseFloat(end) - pt.s) || 0;
						}
					}
				}
				if (pt.c) { //only add it to the linked list if there's a change.
					if ((pt._next = this._firstPT)) {
						pt._next._prev = pt;
					}
					this._firstPT = pt;
					return pt;
				}
			},
			_internals = TweenLite._internals = {isArray:_isArray, isSelector:_isSelector, lazyTweens:_lazyTweens, blobDif:_blobDif}, //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
			_plugins = TweenLite._plugins = {},
			_tweenLookup = _internals.tweenLookup = {},
			_tweenLookupNum = 0,
			_reservedProps = _internals.reservedProps = {ease:1, delay:1, overwrite:1, onComplete:1, onCompleteParams:1, onCompleteScope:1, useFrames:1, runBackwards:1, startAt:1, onUpdate:1, onUpdateParams:1, onUpdateScope:1, onStart:1, onStartParams:1, onStartScope:1, onReverseComplete:1, onReverseCompleteParams:1, onReverseCompleteScope:1, onRepeat:1, onRepeatParams:1, onRepeatScope:1, easeParams:1, yoyo:1, immediateRender:1, repeat:1, repeatDelay:1, data:1, paused:1, reversed:1, autoCSS:1, lazy:1, onOverwrite:1, callbackScope:1, stringFilter:1, id:1, yoyoEase:1},
			_overwriteLookup = {none:0, all:1, auto:2, concurrent:3, allOnStart:4, preexisting:5, "true":1, "false":0},
			_rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
			_rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
			_nextGCFrame = 30,
			_lazyRender = _internals.lazyRender = function() {
				var i = _lazyTweens.length,
					tween;
				_lazyLookup = {};
				while (--i > -1) {
					tween = _lazyTweens[i];
					if (tween && tween._lazy !== false) {
						tween.render(tween._lazy[0], tween._lazy[1], true);
						tween._lazy = false;
					}
				}
				_lazyTweens.length = 0;
			};

		_rootTimeline._startTime = _ticker.time;
		_rootFramesTimeline._startTime = _ticker.frame;
		_rootTimeline._active = _rootFramesTimeline._active = true;
		setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

		Animation._updateRoot = TweenLite.render = function() {
				var i, a, p;
				if (_lazyTweens.length) { //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
					_lazyRender();
				}
				_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
				_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
				if (_lazyTweens.length) {
					_lazyRender();
				}
				if (_ticker.frame >= _nextGCFrame) { //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
					_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
					for (p in _tweenLookup) {
						a = _tweenLookup[p].tweens;
						i = a.length;
						while (--i > -1) {
							if (a[i]._gc) {
								a.splice(i, 1);
							}
						}
						if (a.length === 0) {
							delete _tweenLookup[p];
						}
					}
					//if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
					p = _rootTimeline._first;
					if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
						while (p && p._paused) {
							p = p._next;
						}
						if (!p) {
							_ticker.sleep();
						}
					}
				}
			};

		_ticker.addEventListener("tick", Animation._updateRoot);

		var _register = function(target, tween, scrub) {
				var id = target._gsTweenID, a, i;
				if (!_tweenLookup[id || (target._gsTweenID = id = "t" + (_tweenLookupNum++))]) {
					_tweenLookup[id] = {target:target, tweens:[]};
				}
				if (tween) {
					a = _tweenLookup[id].tweens;
					a[(i = a.length)] = tween;
					if (scrub) {
						while (--i > -1) {
							if (a[i] === tween) {
								a.splice(i, 1);
							}
						}
					}
				}
				return _tweenLookup[id].tweens;
			},
			_onOverwrite = function(overwrittenTween, overwritingTween, target, killedProps) {
				var func = overwrittenTween.vars.onOverwrite, r1, r2;
				if (func) {
					r1 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				func = TweenLite.onOverwrite;
				if (func) {
					r2 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				return (r1 !== false && r2 !== false);
			},
			_applyOverwrite = function(target, tween, props, mode, siblings) {
				var i, changed, curTween, l;
				if (mode === 1 || mode >= 4) {
					l = siblings.length;
					for (i = 0; i < l; i++) {
						if ((curTween = siblings[i]) !== tween) {
							if (!curTween._gc) {
								if (curTween._kill(null, target, tween)) {
									changed = true;
								}
							}
						} else if (mode === 5) {
							break;
						}
					}
					return changed;
				}
				//NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
				var startTime = tween._startTime + _tinyNum,
					overlaps = [],
					oCount = 0,
					zeroDur = (tween._duration === 0),
					globalStart;
				i = siblings.length;
				while (--i > -1) {
					if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
						//ignore
					} else if (curTween._timeline !== tween._timeline) {
						globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
						if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
							overlaps[oCount++] = curTween;
						}
					} else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
						overlaps[oCount++] = curTween;
					}
				}

				i = oCount;
				while (--i > -1) {
					curTween = overlaps[i];
					l = curTween._firstPT; //we need to discern if there were property tweens originally; if they all get removed in the next line's _kill() call, the tween should be killed. See https://github.com/greensock/GreenSock-JS/issues/278
					if (mode === 2) if (curTween._kill(props, target, tween)) {
						changed = true;
					}
					if (mode !== 2 || (!curTween._firstPT && curTween._initted && l)) {
						if (mode !== 2 && !_onOverwrite(curTween, tween)) {
							continue;
						}
						if (curTween._enabled(false, false)) { //if all property tweens have been overwritten, kill the tween.
							changed = true;
						}
					}
				}
				return changed;
			},
			_checkOverlap = function(tween, reference, zeroDur) {
				var tl = tween._timeline,
					ts = tl._timeScale,
					t = tween._startTime;
				while (tl._timeline) {
					t += tl._startTime;
					ts *= tl._timeScale;
					if (tl._paused) {
						return -100;
					}
					tl = tl._timeline;
				}
				t /= ts;
				return (t > reference) ? t - reference : ((zeroDur && t === reference) || (!tween._initted && t - reference < 2 * _tinyNum)) ? _tinyNum : ((t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum) ? 0 : t - reference - _tinyNum;
			};


//---- TweenLite instance methods -----------------------------------------------------------------------------

		p._init = function() {
			var v = this.vars,
				op = this._overwrittenProps,
				dur = this._duration,
				immediate = !!v.immediateRender,
				ease = v.ease,
				i, initPlugins, pt, p, startVars, l;
			if (v.startAt) {
				if (this._startAt) {
					this._startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
					this._startAt.kill();
				}
				startVars = {};
				for (p in v.startAt) { //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
					startVars[p] = v.startAt[p];
				}
				startVars.data = "isStart";
				startVars.overwrite = false;
				startVars.immediateRender = true;
				startVars.lazy = (immediate && v.lazy !== false);
				startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
				startVars.onUpdate = v.onUpdate;
				startVars.onUpdateParams = v.onUpdateParams;
				startVars.onUpdateScope = v.onUpdateScope || v.callbackScope || this;
				this._startAt = TweenLite.to(this.target || {}, 0, startVars);
				if (immediate) {
					if (this._time > 0) {
						this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
					} else if (dur !== 0) {
						return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
					}
				}
			} else if (v.runBackwards && dur !== 0) {
				//from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
				if (this._startAt) {
					this._startAt.render(-1, true);
					this._startAt.kill();
					this._startAt = null;
				} else {
					if (this._time !== 0) { //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
						immediate = false;
					}
					pt = {};
					for (p in v) { //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
						if (!_reservedProps[p] || p === "autoCSS") {
							pt[p] = v[p];
						}
					}
					pt.overwrite = 0;
					pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
					pt.lazy = (immediate && v.lazy !== false);
					pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
					this._startAt = TweenLite.to(this.target, 0, pt);
					if (!immediate) {
						this._startAt._init(); //ensures that the initial values are recorded
						this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
						if (this.vars.immediateRender) {
							this._startAt = null;
						}
					} else if (this._time === 0) {
						return;
					}
				}
			}
			this._ease = ease = (!ease) ? TweenLite.defaultEase : (ease instanceof Ease) ? ease : (typeof(ease) === "function") ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
			if (v.easeParams instanceof Array && ease.config) {
				this._ease = ease.config.apply(ease, v.easeParams);
			}
			this._easeType = this._ease._type;
			this._easePower = this._ease._power;
			this._firstPT = null;

			if (this._targets) {
				l = this._targets.length;
				for (i = 0; i < l; i++) {
					if ( this._initProps( this._targets[i], (this._propLookup[i] = {}), this._siblings[i], (op ? op[i] : null), i) ) {
						initPlugins = true;
					}
				}
			} else {
				initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0);
			}

			if (initPlugins) {
				TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
			}
			if (op) if (!this._firstPT) if (typeof(this.target) !== "function") { //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
				this._enabled(false, false);
			}
			if (v.runBackwards) {
				pt = this._firstPT;
				while (pt) {
					pt.s += pt.c;
					pt.c = -pt.c;
					pt = pt._next;
				}
			}
			this._onUpdate = v.onUpdate;
			this._initted = true;
		};

		p._initProps = function(target, propLookup, siblings, overwrittenProps, index) {
			var p, i, initPlugins, plugin, pt, v;
			if (target == null) {
				return false;
			}

			if (_lazyLookup[target._gsTweenID]) {
				_lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
			}

			if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) { //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
				_autoCSS(this.vars, target);
			}
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push && _isArray(v))) if (v.join("").indexOf("{self}") !== -1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this, index)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
					//pg - isPlugin 	[boolean]
					//pr - priority		[number]
					//m - mod           [function | 0]
					this._firstPT = pt = {_next:this._firstPT, t:plugin, p:"setRatio", s:0, c:1, f:1, n:p, pg:1, pr:plugin._priority, m:0};
					i = plugin._overwriteProps.length;
					while (--i > -1) {
						propLookup[plugin._overwriteProps[i]] = this._firstPT;
					}
					if (plugin._priority || plugin._onInitAllProps) {
						initPlugins = true;
					}
					if (plugin._onDisable || plugin._onEnable) {
						this._notifyPluginsOfEnabled = true;
					}
					if (pt._next) {
						pt._next._prev = pt;
					}

				} else {
					propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter, index);
				}
			}

			if (overwrittenProps) if (this._kill(overwrittenProps, target)) { //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
				return this._initProps(target, propLookup, siblings, overwrittenProps, index);
			}
			if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
				this._kill(propLookup, target);
				return this._initProps(target, propLookup, siblings, overwrittenProps, index);
			}
			if (this._firstPT) if ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration)) { //zero duration tweens don't lazy render by default; everything else does.
				_lazyLookup[target._gsTweenID] = true;
			}
			return initPlugins;
		};

		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time >= duration - 0.0000001 && time >= 0) { //to work around occasional floating point math artifacts.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = "onComplete";
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (prevRawPrevTime < 0 || (time <= 0 && time >= -0.0000001) || (prevRawPrevTime === _tinyNum && this.data !== "isPause")) if (prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted || (this._startAt && this._startAt.progress())) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately. Also, we check progress() because if startAt has already rendered at its end, we should force a render at its beginning. Otherwise, if you put the playhead directly on top of where a fromTo({immediateRender:false}) starts, and then move it backwards, the from() won't revert its values.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;

				if (this._easeType) {
					var r = time / duration, type = this._easeType, pow = this._easePower;
					if (type === 1 || (type === 3 && r >= 0.5)) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - (r / 2);
					}

				} else {
					this.ratio = this._ease.getRatio(time / duration);
				}
			}

			if (this._time === prevTime && !force) {
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) {
					this._time = this._totalTime = prevTime;
					this._rawPrevTime = prevRawPrevTime;
					_lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
				}
			}
			if (this._lazy !== false) { //in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
				this._lazy = false;
			}
			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true;  //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTime === 0) {
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, true, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._time !== 0 || duration === 0) if (!suppressEvents) {
					this._callback("onStart");
				}
			}
			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}

			if (this._onUpdate) {
				if (time < 0) if (this._startAt && time !== -0.0001) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._time !== prevTime || isComplete || force) {
					this._callback("onUpdate");
				}
			}
			if (callback) if (!this._gc || force) { //check _gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) { //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
					this._startAt.render(time, true, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};

		p._kill = function(vars, target, overwritingTween) {
			if (vars === "all") {
				vars = null;
			}
			if (vars == null) if (target == null || target === this.target) {
				this._lazy = false;
				return this._enabled(false, false);
			}
			target = (typeof(target) !== "string") ? (target || this._targets || this.target) : TweenLite.selector(target) || target;
			var simultaneousOverwrite = (overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline),
				firstPT = this._firstPT,
				i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				while (--i > -1) {
					if (this._kill(vars, target[i], overwritingTween)) {
						changed = true;
					}
				}
			} else {
				if (this._targets) {
					i = this._targets.length;
					while (--i > -1) {
						if (target === this._targets[i]) {
							propLookup = this._propLookup[i] || {};
							this._overwrittenProps = this._overwrittenProps || [];
							overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
							break;
						}
					}
				} else if (target !== this.target) {
					return false;
				} else {
					propLookup = this._propLookup;
					overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
				}

				if (propLookup) {
					killProps = vars || propLookup;
					record = (vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof(vars) !== "object" || !vars._tempKill)); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
					if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
						for (p in killProps) {
							if (propLookup[p]) {
								if (!killed) {
									killed = [];
								}
								killed.push(p);
							}
						}
						if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) { //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
							return false;
						}
					}

					for (p in killProps) {
						if ((pt = propLookup[p])) {
							if (simultaneousOverwrite) { //if another tween overwrites this one and they both start at exactly the same time, yet this tween has already rendered once (for example, at 0.001) because it's first in the queue, we should revert the values to where they were at 0 so that the starting values aren't contaminated on the overwriting tween.
								if (pt.f) {
									pt.t[pt.p](pt.s);
								} else {
									pt.t[pt.p] = pt.s;
								}
								changed = true;
							}
							if (pt.pg && pt.t._kill(killProps)) {
								changed = true; //some plugins need to be notified so they can perform cleanup tasks first
							}
							if (!pt.pg || pt.t._overwriteProps.length === 0) {
								if (pt._prev) {
									pt._prev._next = pt._next;
								} else if (pt === this._firstPT) {
									this._firstPT = pt._next;
								}
								if (pt._next) {
									pt._next._prev = pt._prev;
								}
								pt._next = pt._prev = null;
							}
							delete propLookup[p];
						}
						if (record) {
							overwrittenProps[p] = 1;
						}
					}
					if (!this._firstPT && this._initted && firstPT) { //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
						this._enabled(false, false);
					}
				}
			}
			return changed;
		};

		p.invalidate = function() {
			if (this._notifyPluginsOfEnabled) {
				TweenLite._onPluginEvent("_onDisable", this);
			}
			this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
			this._notifyPluginsOfEnabled = this._active = this._lazy = false;
			this._propLookup = (this._targets) ? {} : [];
			Animation.prototype.invalidate.call(this);
			if (this.vars.immediateRender) {
				this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
				this.render(Math.min(0, -this._delay)); //in case delay is negative.
			}
			return this;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (enabled && this._gc) {
				var targets = this._targets,
					i;
				if (targets) {
					i = targets.length;
					while (--i > -1) {
						this._siblings[i] = _register(targets[i], this, true);
					}
				} else {
					this._siblings = _register(this.target, this, true);
				}
			}
			Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
			if (this._notifyPluginsOfEnabled) if (this._firstPT) {
				return TweenLite._onPluginEvent((enabled ? "_onEnable" : "_onDisable"), this);
			}
			return false;
		};


//----TweenLite static methods -----------------------------------------------------

		TweenLite.to = function(target, duration, vars) {
			return new TweenLite(target, duration, vars);
		};

		TweenLite.from = function(target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenLite(target, duration, vars);
		};

		TweenLite.fromTo = function(target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return new TweenLite(target, duration, toVars);
		};

		TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {
			return new TweenLite(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, callbackScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, immediateRender:false, lazy:false, useFrames:useFrames, overwrite:0});
		};

		TweenLite.set = function(target, vars) {
			return new TweenLite(target, 0, vars);
		};

		TweenLite.getTweensOf = function(target, onlyActive) {
			if (target == null) { return []; }
			target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;
			var i, a, j, t;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				a = [];
				while (--i > -1) {
					a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
				}
				i = a.length;
				//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
				while (--i > -1) {
					t = a[i];
					j = i;
					while (--j > -1) {
						if (t === a[j]) {
							a.splice(i, 1);
						}
					}
				}
			} else if (target._gsTweenID) {
				a = _register(target).concat();
				i = a.length;
				while (--i > -1) {
					if (a[i]._gc || (onlyActive && !a[i].isActive())) {
						a.splice(i, 1);
					}
				}
			}
			return a || [];
		};

		TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, onlyActive, vars) {
			if (typeof(onlyActive) === "object") {
				vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)
				onlyActive = false;
			}
			var a = TweenLite.getTweensOf(target, onlyActive),
				i = a.length;
			while (--i > -1) {
				a[i]._kill(vars, target);
			}
		};



/*
 * ----------------------------------------------------------------
 * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
 * ----------------------------------------------------------------
 */
		var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {
					this._overwriteProps = (props || "").split(",");
					this._propName = this._overwriteProps[0];
					this._priority = priority || 0;
					this._super = TweenPlugin.prototype;
				}, true);

		p = TweenPlugin.prototype;
		TweenPlugin.version = "1.19.0";
		TweenPlugin.API = 2;
		p._firstPT = null;
		p._addTween = _addPropTween;
		p.setRatio = _setRatio;

		p._kill = function(lookup) {
			var a = this._overwriteProps,
				pt = this._firstPT,
				i;
			if (lookup[this._propName] != null) {
				this._overwriteProps = [];
			} else {
				i = a.length;
				while (--i > -1) {
					if (lookup[a[i]] != null) {
						a.splice(i, 1);
					}
				}
			}
			while (pt) {
				if (lookup[pt.n] != null) {
					if (pt._next) {
						pt._next._prev = pt._prev;
					}
					if (pt._prev) {
						pt._prev._next = pt._next;
						pt._prev = null;
					} else if (this._firstPT === pt) {
						this._firstPT = pt._next;
					}
				}
				pt = pt._next;
			}
			return false;
		};

		p._mod = p._roundProps = function(lookup) {
			var pt = this._firstPT,
				val;
			while (pt) {
				val = lookup[this._propName] || (pt.n != null && lookup[ pt.n.split(this._propName + "_").join("") ]);
				if (val && typeof(val) === "function") { //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
					if (pt.f === 2) {
						pt.t._applyPT.m = val;
					} else {
						pt.m = val;
					}
				}
				pt = pt._next;
			}
		};

		TweenLite._onPluginEvent = function(type, tween) {
			var pt = tween._firstPT,
				changed, pt2, first, last, next;
			if (type === "_onInitAllProps") {
				//sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if ((pt._prev = pt2 ? pt2._prev : last)) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if ((pt._next = pt2)) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				pt = tween._firstPT = first;
			}
			while (pt) {
				if (pt.pg) if (typeof(pt.t[type]) === "function") if (pt.t[type]()) {
					changed = true;
				}
				pt = pt._next;
			}
			return changed;
		};

		TweenPlugin.activate = function(plugins) {
			var i = plugins.length;
			while (--i > -1) {
				if (plugins[i].API === TweenPlugin.API) {
					_plugins[(new plugins[i]())._propName] = plugins[i];
				}
			}
			return true;
		};

		//provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
		_gsDefine.plugin = function(config) {
			if (!config || !config.propName || !config.init || !config.API) { throw "illegal plugin definition."; }
			var propName = config.propName,
				priority = config.priority || 0,
				overwriteProps = config.overwriteProps,
				map = {init:"_onInitTween", set:"setRatio", kill:"_kill", round:"_mod", mod:"_mod", initAll:"_onInitAllProps"},
				Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin",
					function() {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}, (config.global === true)),
				p = Plugin.prototype = new TweenPlugin(propName),
				prop;
			p.constructor = Plugin;
			Plugin.API = config.API;
			for (prop in map) {
				if (typeof(config[prop]) === "function") {
					p[map[prop]] = config[prop];
				}
			}
			Plugin.version = config.version;
			TweenPlugin.activate([Plugin]);
			return Plugin;
		};


		//now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
		a = window._gsQueue;
		if (a) {
			for (i = 0; i < a.length; i++) {
				a[i]();
			}
			for (p in _defLookup) {
				if (!_defLookup[p].func) {
					window.console.log("GSAP encountered missing dependency: " + p);
				}
			}
		}

		_tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated

		return TweenLite;

})(_gsScope, "TweenLite");

var globals = _gsScope.GreenSockGlobals;
var nonGlobals = globals.com.greensock;

var SimpleTimeline = nonGlobals.core.SimpleTimeline;
var Animation = nonGlobals.core.Animation;
var Ease = globals.Ease;
var Linear = globals.Linear;
var Power0 = Linear;
var Power1 = globals.Power1;
var Power2 = globals.Power2;
var Power3 = globals.Power3;
var Power4 = globals.Power4;
var TweenPlugin = globals.TweenPlugin;
var EventDispatcher = nonGlobals.events.EventDispatcher;

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(71)(module), __webpack_require__(8)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _assetList = __webpack_require__(6);

var _assetList2 = _interopRequireDefault(_assetList);

var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Assets.js

var Assets = {};
var _assets = [];

var getAsset = function getAsset(id) {
	return assets.find(function (a) {
		return a.id === id;
	}).file;
};

var getExtension = function getExtension(mFile) {
	var ary = mFile.split('.');
	return ary[ary.length - 1];
};

Assets.init = function () {
	var hdrCubemaps = {};
	_assets = _assetList2.default.map(function (o) {
		var ext = getExtension(o.url);
		var file = getAsset(o.id);
		var texture = void 0;

		switch (ext) {
			case 'jpg':
			case 'png':
				texture = new _alfrid.GLTexture(file);
				return {
					id: o.id,
					file: texture
				};
				break;

			case 'hdr':
				var cubemapName = o.id.split('_')[0];
				texture = _alfrid2.default.HDRLoader.parse(file);

				var oAsset = {
					id: o.id,
					file: texture
				};

				if (!hdrCubemaps[cubemapName]) {
					hdrCubemaps[cubemapName] = [];
				}

				hdrCubemaps[cubemapName].push(oAsset);
				return oAsset;

				break;
			case 'dds':
				texture = _alfrid.GLCubeTexture.parseDDS(file);
				return {
					id: o.id,
					file: texture
				};
				break;

			case 'obj':
				var mesh = _alfrid.ObjLoader.parse(file);
				return {
					id: o.id,
					file: mesh
				};
				break;
		}
	});

	for (var s in hdrCubemaps) {
		if (hdrCubemaps[s].length == 6) {
			console.log('Generate Cubemap :', s);

			var ary = [Assets.get(s + '_posx'), Assets.get(s + '_negx'), Assets.get(s + '_posy'), Assets.get(s + '_negy'), Assets.get(s + '_posz'), Assets.get(s + '_negz')];

			var texture = new _alfrid2.default.GLCubeTexture(ary);
			_assets.push({
				id: s,
				file: texture
			});
		}
	}

	if (_assets.length > 0) {
		console.debug('ASSETS:');
		console.table(_assets);
	}
};

Assets.get = function (mId) {
	return _assets.find(function (a) {
		return a.id === mId;
	}).file;
};

exports.default = Assets;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(16)(undefined);
// imports


// module
exports.push([module.i, "html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  overflow: hidden;\n  position: static;\n  background: black; }\n\nhtml {\n  -webkit-text-size-adjust: none;\n  -moz-text-size-adjust: none;\n  text-size-adjust: none; }\n\nh1, h2, h3, h4, text, p {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-webkit-font-smoothing: antialiased;\n  font-family: 'Open Sans', sans-serif;\n  user-select: none;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale; }\n\n.loading-anim {\n  width: 100px;\n  height: 100px;\n  position: fixed;\n  left: 50%;\n  top: 50%;\n  margin-left: -50px;\n  margin-top: -100px;\n  z-index: 9998;\n  transition: opacity 1s ease-out; }\n  .loading-anim.close {\n    opacity: 0; }\n\n.container {\n  position: fixed;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0; }\n\n.audio-toggle {\n  width: 18px;\n  height: 18px;\n  position: fixed;\n  z-index: 9999;\n  bottom: 5%;\n  left: 5%;\n  background: none;\n  border: none;\n  padding: 0;\n  font: inherit;\n  cursor: pointer;\n  outline: inherit;\n  background-color: rgba(255, 0, 0, 0.1);\n  opacity: .5; }\n\n.sound-on {\n  background-image: url(\"../../assets/css-img/soundOn.png\"); }\n  .isSoundOn .sound-on {\n    opacity: 0; }\n\n.sound-off {\n  background-image: url(\"../../assets/css-img/soundOff.png\");\n  opacity: 0; }\n  .isSoundOn .sound-off {\n    opacity: 1; }\n\n.sound-icon {\n  position: absolute;\n  background-size: 100%;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  transition: opacity .5s ease-out; }\n\n.desc {\n  position: fixed;\n  opacity: 1;\n  color: white;\n  bottom: 10%;\n  width: 100%;\n  text-align: center;\n  font-size: 12px;\n  letter-spacing: 5px;\n  transition: opacity .5s ease-out; }\n  .isLoading .desc {\n    opacity: 0; }\n  .isMobile .desc {\n    display: none;\n    opacity: 0; }\n  .hasInteract .desc {\n    opacity: 0; }\n\n.fullscreen {\n  position: absolute;\n  z-index: 9999;\n  color: white;\n  bottom: 10%;\n  width: 100%;\n  text-align: center;\n  background: none;\n  border: none;\n  padding: 0;\n  font: inherit;\n  cursor: pointer;\n  outline: inherit;\n  display: none;\n  opacity: 0;\n  font-size: 12px;\n  letter-spacing: 5px;\n  transition: opacity .5s ease-out;\n  margin-left: -9999px; }\n  .isMobileChrome .fullscreen {\n    display: block;\n    margin-left: 0;\n    opacity: 1; }\n\n.Main-Canvas {\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n  position: absolute;\n  /*user-select:none;*/\n  opacity: 1;\n  transition: opacity .5s ease-out .25s; }\n  .isLoading .Main-Canvas {\n    opacity: 0; }\n\ndiv:-webkit-full-screen {\n  width: 100% !important; }\n\ndiv:-moz-full-screen {\n  width: 100% !important; }\n\ndiv:-ms-fullscreen {\n  width: 100% !important; }\n\ndiv:fullscreen {\n  width: 100% !important; }\n\n/* While in fullscreen, hide any children with class 'tohide' */\n:-webkit-full-screen .tohide {\n  display: none; }\n\n:-moz-full-screen .tohide {\n  display: none; }\n\n:-ms-fullscreen .tohide {\n  display: none; }\n\n:fullscreen .tohide {\n  display: none; }\n\n.container-ui {\n  position: fixed;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  opacity: 0;\n  transition: opacity .5s ease-out; }\n  .isOpened .container-ui {\n    opacity: 1; }\n\n.Message {\n  position: absolute;\n  z-index: 999;\n  width: 100%;\n  top: calc(50% - 50px);\n  text-align: center;\n  letter-spacing: 11px;\n  color: white;\n  opacity: 0;\n  transition: opacity .5s ease-out, letter-spacing .5s ease-out; }\n  .isLoading .Message {\n    letter-spacing: 10px;\n    opacity: 1; }\n\n.Loading-Bar {\n  position: absolute;\n  z-index: 998;\n  width: 0%;\n  height: 1px;\n  top: 55%;\n  background: rgba(255, 255, 255, 0.5);\n  opacity: 0;\n  transition: width .5s ease-out, opacity .5s ease-out; }\n  .isLoading .Loading-Bar {\n    opacity: 1; }\n", ""]);

// exports


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _generateTrees = __webpack_require__(32);

Object.defineProperty(exports, 'generateTrees', {
  enumerable: true,
  get: function get() {
    return _generateTrees.generateTrees;
  }
});

var _generateHeightMap = __webpack_require__(33);

Object.defineProperty(exports, 'generateHeightMap', {
  enumerable: true,
  get: function get() {
    return _generateHeightMap.generateHeightMap;
  }
});

var _getBoundingBox = __webpack_require__(37);

Object.defineProperty(exports, 'getBoundingBox', {
  enumerable: true,
  get: function get() {
    return _getBoundingBox.getBoundingBox;
  }
});

var _saveJson = __webpack_require__(38);

Object.defineProperty(exports, 'saveJson', {
  enumerable: true,
  get: function get() {
    return _saveJson.saveJson;
  }
});

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var assetsToLoad = [{ "id": "gradientMap", "url": "assets/img/gradientMap.png", "type": "png" }, { "id": "noise", "url": "assets/img/noise.jpg", "type": "jpg" }, { "id": "bear", "url": "assets/obj/bear.obj", "type": "text" }, { "id": "deer", "url": "assets/obj/deer.obj", "type": "text" }, { "id": "laputa", "url": "assets/obj/laputa.obj", "type": "text" }, { "id": "rock", "url": "assets/obj/rock.obj", "type": "text" }, { "id": "tree1", "url": "assets/obj/tree1.obj", "type": "text" }, { "id": "tree2", "url": "assets/obj/tree2.obj", "type": "text" }, { "id": "whale", "url": "assets/obj/whale.obj", "type": "text" }];

exports.default = assetsToLoad;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Config = __webpack_require__(1);

var _Config2 = _interopRequireDefault(_Config);

var _fastUrlParser = __webpack_require__(21);

var _fastUrlParser2 = _interopRequireDefault(_fastUrlParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Settings.js

_fastUrlParser2.default.queryString = __webpack_require__(27);

var enabled = true;

var reload = function reload() {
	if (!enabled) {
		return;
	}
	window.location.href = window.location.origin + window.location.pathname + '?config=' + JSON.stringify(_Config2.default);
};

var refresh = function refresh() {
	if (!enabled) {
		return;
	}
	window.history.pushState('experiment', 'Title', window.location.origin + window.location.pathname + '?config=' + JSON.stringify(_Config2.default));
};

var delayIndex = -1;

var delayReload = function delayReload() {
	if (!enabled) {
		return;
	}
	window.clearTimeout(delayIndex);

	delayIndex = window.setTimeout(function () {
		window.location.href = window.location.origin + window.location.pathname + '?config=' + JSON.stringify(_Config2.default);
	}, 500);
};

var init = function init() {
	var mEnabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

	enabled = mEnabled;
	var parsed = _fastUrlParser2.default.parse(window.location.search, true);

	if (parsed.query.config) {
		var oConfig = JSON.parse(parsed.query.config);

		for (var key in oConfig) {
			_Config2.default[key] = oConfig[key];
		}
	}

	console.log('Config :', _Config2.default);
	refresh();
};

exports.default = {
	enabled: enabled,
	reload: reload,
	refresh: refresh,
	delayReload: delayReload,
	init: init
};

/***/ }),
/* 8 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\nvarying vec4 vScreenPosition;\nvarying float vOpacity;\n\nvoid main(void) {\n\tfloat z = vScreenPosition.z / vScreenPosition.w;\n\t// z = smoothstep(0.9, 1.0, z);\n    gl_FragColor = vec4(vec3(z * 0.25), 1.0);\n}"

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _Config = __webpack_require__(1);

var _Config2 = _interopRequireDefault(_Config);

var _fog = __webpack_require__(49);

var _fog2 = _interopRequireDefault(_fog);

var _fog3 = __webpack_require__(50);

var _fog4 = _interopRequireDefault(_fog3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // ViewFog.js

var ViewFog = function (_alfrid$View) {
	_inherits(ViewFog, _alfrid$View);

	function ViewFog() {
		_classCallCheck(this, ViewFog);

		return _possibleConstructorReturn(this, (ViewFog.__proto__ || Object.getPrototypeOf(ViewFog)).call(this, _fog2.default, _fog4.default));
	}

	_createClass(ViewFog, [{
		key: '_init',
		value: function _init() {
			this.reset(_Config2.default.numSlides);
		}
	}, {
		key: 'reset',
		value: function reset(mNumSlides) {
			this._numSlides = mNumSlides;

			console.log('Setting number of slides : ', mNumSlides);

			var s = _Config2.default.floorRadius * 2;
			this.mesh = _alfrid2.default.Geom.plane(s, s, 1);

			// const { numSlides } = Config;
			var numSlides = this._numSlides;
			var posOffset = [];

			for (var i = 0; i < numSlides; i++) {
				var z = (i / numSlides - 0.5) * s;
				posOffset.push([0, s / 2, z]);
			}

			this.offset = 0.23;
			this.mesh.bufferInstance(posOffset, 'aPosOffset');
			console.log(posOffset.length);
		}
	}, {
		key: 'render',
		value: function render(texture0, texture1, percent) {
			_alfrid.GL.enableAdditiveBlending();
			this.shader.bind();
			this.shader.uniform("uOffset", "float", this.offset);
			this.shader.uniform("uNum", "float", _Config2.default.noiseNum);
			this.shader.uniform("uNumSlices", "float", this._numSlides);
			this.shader.uniform("texture0", "uniform1i", 0);
			texture0.bind(0);
			this.shader.uniform("texture1", "uniform1i", 1);
			texture1.bind(1);
			this.shader.uniform("uPercent", "float", percent);
			this.shader.uniform("uSize", "float", _Config2.default.floorRadius);

			_alfrid.GL.draw(this.mesh);
			_alfrid.GL.enableAlphaBlending();
		}
	}]);

	return ViewFog;
}(_alfrid2.default.View);

exports.default = ViewFog;

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export TimelineLite */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TimelineLite; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(2);
/*!
 * VERSION: 2.0.2
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */


__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */]._gsDefine("TimelineLite", ["core.Animation","core.SimpleTimeline","TweenLite"], function() {

		var TimelineLite = function(vars) {
				__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["i" /* SimpleTimeline */].call(this, vars);
				this._labels = {};
				this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);
				this.smoothChildTiming = (this.vars.smoothChildTiming === true);
				this._sortChildren = true;
				this._onUpdate = this.vars.onUpdate;
				var v = this.vars,
					val, p;
				for (p in v) {
					val = v[p];
					if (_isArray(val)) if (val.join("").indexOf("{self}") !== -1) {
						v[p] = this._swapSelfInParams(val);
					}
				}
				if (_isArray(v.tweens)) {
					this.add(v.tweens, 0, v.align, v.stagger);
				}
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */]._internals,
			_internals = TimelineLite._internals = {},
			_isSelector = TweenLiteInternals.isSelector,
			_isArray = TweenLiteInternals.isArray,
			_lazyTweens = TweenLiteInternals.lazyTweens,
			_lazyRender = TweenLiteInternals.lazyRender,
			_globals = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */]._gsDefine.globals,
			_copy = function(vars) {
				var copy = {}, p;
				for (p in vars) {
					copy[p] = vars[p];
				}
				return copy;
			},
			_applyCycle = function(vars, targets, i) {
				var alt = vars.cycle,
					p, val;
				for (p in alt) {
					val = alt[p];
					vars[p] = (typeof(val) === "function") ? val(i, targets[i]) : val[i % val.length];
				}
				delete vars.cycle;
			},
			_pauseCallback = _internals.pauseCallback = function() {},
			_slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			p = TimelineLite.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["i" /* SimpleTimeline */]();

		TimelineLite.version = "2.0.2";
		p.constructor = TimelineLite;
		p.kill()._gc = p._forcingPlayhead = p._hasPause = false;

		/* might use later...
		//translates a local time inside an animation to the corresponding time on the root/global timeline, factoring in all nesting and timeScales.
		function localToGlobal(time, animation) {
			while (animation) {
				time = (time / animation._timeScale) + animation._startTime;
				animation = animation.timeline;
			}
			return time;
		}

		//translates the supplied time on the root/global timeline into the corresponding local time inside a particular animation, factoring in all nesting and timeScales
		function globalToLocal(time, animation) {
			var scale = 1;
			time -= localToGlobal(0, animation);
			while (animation) {
				scale *= animation._timeScale;
				animation = animation.timeline;
			}
			return time * scale;
		}
		*/

		p.to = function(target, duration, vars, position) {
			var Engine = (vars.repeat && _globals.TweenMax) || __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */];
			return duration ? this.add( new Engine(target, duration, vars), position) : this.set(target, vars, position);
		};

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat && _globals.TweenMax) || __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */]).from(target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat && _globals.TweenMax) || __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */];
			return duration ? this.add( Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};

		p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, callbackScope:onCompleteAllScope, smoothChildTiming:this.smoothChildTiming}),
				cycle = vars.cycle,
				copy, i;
			if (typeof(targets) === "string") {
				targets = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].selector(targets) || targets;
			}
			targets = targets || [];
			if (_isSelector(targets)) { //senses if the targets object is a selector. If it is, we should translate it into an array.
				targets = _slice(targets);
			}
			stagger = stagger || 0;
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			for (i = 0; i < targets.length; i++) {
				copy = _copy(vars);
				if (copy.startAt) {
					copy.startAt = _copy(copy.startAt);
					if (copy.startAt.cycle) {
						_applyCycle(copy.startAt, targets, i);
					}
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				tl.to(targets[i], duration, copy, i * stagger);
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);
			vars.runBackwards = true;
			return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.call = function(callback, params, scope, position) {
			return this.add( __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].delayedCall(0, callback, params, scope), position);
		};

		p.set = function(target, vars, position) {
			position = this._parseTimeOrLabel(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = (position === this._time && !this._paused);
			}
			return this.add( new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */](target, 0, vars), position);
		};

		TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {
			vars = vars || {};
			if (vars.smoothChildTiming == null) {
				vars.smoothChildTiming = true;
			}
			var tl = new TimelineLite(vars),
				root = tl._timeline,
				hasNegativeStart, time,	tween, next;
			if (ignoreDelayedCalls == null) {
				ignoreDelayedCalls = true;
			}
			root._remove(tl, true);
			tl._startTime = 0;
			tl._rawPrevTime = tl._time = tl._totalTime = root._time;
			tween = root._first;
			while (tween) {
				next = tween._next;
				if (!ignoreDelayedCalls || !(tween instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */] && tween.target === tween.vars.onComplete)) {
					time = tween._startTime - tween._delay;
					if (time < 0) {
						hasNegativeStart = 1;
					}
					tl.add(tween, time);
				}
				tween = next;
			}
			root.add(tl, 0);
			if (hasNegativeStart) { //calling totalDuration() will force the adjustment necessary to shift the children forward so none of them start before zero, and moves the timeline backwards the same amount, so the playhead is still aligned where it should be globally, but the timeline doesn't have illegal children that start before zero.
				tl.totalDuration();
			}
			return tl;
		};

		p.add = function(value, position, align, stagger) {
			var curTime, l, i, child, tl, beforeRawTime;
			if (typeof(position) !== "number") {
				position = this._parseTimeOrLabel(position, 0, true, value);
			}
			if (!(value instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["a" /* Animation */])) {
				if ((value instanceof Array) || (value && value.push && _isArray(value))) {
					align = align || "normal";
					stagger = stagger || 0;
					curTime = position;
					l = value.length;
					for (i = 0; i < l; i++) {
						if (_isArray(child = value[i])) {
							child = new TimelineLite({tweens:child});
						}
						this.add(child, curTime);
						if (typeof(child) !== "string" && typeof(child) !== "function") {
							if (align === "sequence") {
								curTime = child._startTime + (child.totalDuration() / child._timeScale);
							} else if (align === "start") {
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
				} else if (typeof(value) === "string") {
					return this.addLabel(value, position);
				} else if (typeof(value) === "function") {
					value = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].delayedCall(0, value);
				} else {
					throw("Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.");
				}
			}

			__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["i" /* SimpleTimeline */].prototype.add.call(this, value, position);

			if (value._time) { //in case, for example, the _startTime is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
				curTime = Math.max(0, Math.min(value.totalDuration(), (this.rawTime() - value._startTime) * value._timeScale));
				if (Math.abs(curTime - value._totalTime) > 0.00001) { //if an onComplete restarts the tween in a nested timeline, for example, there could be an endless loop without this logic (v2.0.2), like var masterTL = new TimelineMax({autoRemoveChildren: true}), tl = new TimelineMax(); tl.eventCallback("onComplete", function() { tl.restart() } );tl.fromTo('div', 1.1, { rotation: 0 }, { rotation: 360 }, 0);masterTL.add(tl);
					value.render(curTime, false, false);
				}
			}

			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration < this.duration()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = (tl.rawTime() > value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime && tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
						tl._enabled(true, false);
					}
					tl = tl._timeline;
				}
			}

			return this;
		};

		p.remove = function(value) {
			if (value instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["a" /* Animation */]) {
				this._remove(value, false);
				var tl = value._timeline = value.vars.useFrames ? __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["a" /* Animation */]._rootFramesTimeline : __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["a" /* Animation */]._rootTimeline; //now that it's removed, default it to the root timeline so that if it gets played again, it doesn't jump back into this timeline.
				value._startTime = (value._paused ? value._pauseTime : tl._time) - ((!value._reversed ? value._totalTime : value.totalDuration() - value._totalTime) / value._timeScale); //ensure that if it gets played again, the timing is correct.
				return this;
			} else if (value instanceof Array || (value && value.push && _isArray(value))) {
				var i = value.length;
				while (--i > -1) {
					this.remove(value[i]);
				}
				return this;
			} else if (typeof(value) === "string") {
				return this.removeLabel(value);
			}
			return this.kill(null, value);
		};

		p._remove = function(tween, skipDisable) {
			__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["i" /* SimpleTimeline */].prototype._remove.call(this, tween, skipDisable);
			var last = this._last;
			if (!last) {
				this._time = this._totalTime = this._duration = this._totalDuration = 0;
			} else if (this._time > this.duration()) {
				this._time = this._duration;
				this._totalTime = this._totalDuration;
			}
			return this;
		};

		p.append = function(value, offsetOrLabel) {
			return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
		};

		p.insert = p.insertMultiple = function(value, position, align, stagger) {
			return this.add(value, position || 0, align, stagger);
		};

		p.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {
			return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
		};

		p.addLabel = function(label, position) {
			this._labels[label] = this._parseTimeOrLabel(position);
			return this;
		};

		p.addPause = function(position, callback, params, scope) {
			var t = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].delayedCall(0, _pauseCallback, params, scope || this);
			t.vars.onComplete = t.vars.onReverseComplete = callback;
			t.data = "isPause";
			this._hasPause = true;
			return this.add(t, position);
		};

		p.removeLabel = function(label) {
			delete this._labels[label];
			return this;
		};

		p.getLabelTime = function(label) {
			return (this._labels[label] != null) ? this._labels[label] : -1;
		};

		p._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
			var clippedDuration, i;
			//if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().
			if (ignore instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["a" /* Animation */] && ignore.timeline === this) {
				this.remove(ignore);
			} else if (ignore && ((ignore instanceof Array) || (ignore.push && _isArray(ignore)))) {
				i = ignore.length;
				while (--i > -1) {
					if (ignore[i] instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["a" /* Animation */] && ignore[i].timeline === this) {
						this.remove(ignore[i]);
					}
				}
			}
			clippedDuration = (typeof(timeOrLabel) === "number" && !offsetOrLabel) ? 0 : (this.duration() > 99999999999) ? this.recent().endTime(false) : this._duration; //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
			if (typeof(offsetOrLabel) === "string") {
				return this._parseTimeOrLabel(offsetOrLabel, (appendIfAbsent && typeof(timeOrLabel) === "number" && this._labels[offsetOrLabel] == null) ? timeOrLabel - clippedDuration : 0, appendIfAbsent);
			}
			offsetOrLabel = offsetOrLabel || 0;
			if (typeof(timeOrLabel) === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) { //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
				i = timeOrLabel.indexOf("=");
				if (i === -1) {
					if (this._labels[timeOrLabel] == null) {
						return appendIfAbsent ? (this._labels[timeOrLabel] = clippedDuration + offsetOrLabel) : offsetOrLabel;
					}
					return this._labels[timeOrLabel] + offsetOrLabel;
				}
				offsetOrLabel = parseInt(timeOrLabel.charAt(i-1) + "1", 10) * Number(timeOrLabel.substr(i+1));
				timeOrLabel = (i > 1) ? this._parseTimeOrLabel(timeOrLabel.substr(0, i-1), 0, appendIfAbsent) : clippedDuration;
			} else if (timeOrLabel == null) {
				timeOrLabel = clippedDuration;
			}
			return Number(timeOrLabel) + offsetOrLabel;
		};

		p.seek = function(position, suppressEvents) {
			return this.totalTime((typeof(position) === "number") ? position : this._parseTimeOrLabel(position), (suppressEvents !== false));
		};

		p.stop = function() {
			return this.paused(true);
		};

		p.gotoAndPlay = function(position, suppressEvents) {
			return this.play(position, suppressEvents);
		};

		p.gotoAndStop = function(position, suppressEvents) {
			return this.pause(position, suppressEvents);
		};

		p.render = function(time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var prevTime = this._time,
				totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevPaused = this._paused,
				tween, isComplete, next, callback, internalForce, pauseTween, curTime;
			if (prevTime !== this._time) { //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
				time += this._time - prevTime;
			}
			if (time >= totalDur - 0.0000001 && time >= 0) { //to work around occasional floating point math artifacts.
				this._totalTime = this._time = totalDur;
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if ((time <= 0 && time >= -0.0000001) || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) if (this._rawPrevTime !== time && this._first) {
						internalForce = true;
						if (this._rawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7.

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				if (prevTime !== 0 || (this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || (time < 0 && this._rawPrevTime >= 0)))) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) { //ensures proper GC if a timeline is resumed after it's finished reversing.
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (this._rawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}

			} else {

				if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
					if (time >= prevTime) {
						tween = this._first;
						while (tween && tween._startTime <= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
								pauseTween = tween;
							}
							tween = tween._next;
						}
					} else {
						tween = this._last;
						while (tween && tween._startTime >= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
								pauseTween = tween;
							}
							tween = tween._prev;
						}
					}
					if (pauseTween) {
						this._time = time = pauseTween._startTime;
						this._totalTime = time + (this._cycle * (this._totalDuration + this._repeatDelay));
					}
				}

				this._totalTime = this._time = this._rawPrevTime = time;
			}
			if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time > 0) {
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTime === 0) if (this.vars.onStart) if (this._time !== 0 || !this._duration) if (!suppressEvents) {
				this._callback("onStart");
			}

			curTime = this._time;
			if (curTime >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime <= curTime && !tween._paused && !tween._gc)) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
						if (pauseTween === tween) {
							pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
							while (pauseTween && pauseTween.endTime() > this._time) {
								pauseTween.render( (pauseTween._reversed ? pauseTween.totalDuration() - ((time - pauseTween._startTime) * pauseTween._timeScale) : (time - pauseTween._startTime) * pauseTween._timeScale), suppressEvents, force);
								pauseTween = pauseTween._prev;
							}
							pauseTween = null;
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._callback("onUpdate");
			}

			if (callback) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
			}
		};

		p._hasPausedChild = function() {
			var tween = this._first;
			while (tween) {
				if (tween._paused || ((tween instanceof TimelineLite) && tween._hasPausedChild())) {
					return true;
				}
				tween = tween._next;
			}
			return false;
		};

		p.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || -9999999999;
			var a = [],
				tween = this._first,
				cnt = 0;
			while (tween) {
				if (tween._startTime < ignoreBeforeTime) {
					//do nothing
				} else if (tween instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */]) {
					if (tweens !== false) {
						a[cnt++] = tween;
					}
				} else {
					if (timelines !== false) {
						a[cnt++] = tween;
					}
					if (nested !== false) {
						a = a.concat(tween.getChildren(true, tweens, timelines));
						cnt = a.length;
					}
				}
				tween = tween._next;
			}
			return a;
		};

		p.getTweensOf = function(target, nested) {
			var disabled = this._gc,
				a = [],
				cnt = 0,
				tweens, i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].getTweensOf(target);
			i = tweens.length;
			while (--i > -1) {
				if (tweens[i].timeline === this || (nested && this._contains(tweens[i]))) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
				this._enabled(false, true);
			}
			return a;
		};

		p.recent = function() {
			return this._recent;
		};

		p._contains = function(tween) {
			var tl = tween.timeline;
			while (tl) {
				if (tl === this) {
					return true;
				}
				tl = tl.timeline;
			}
			return false;
		};

		p.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || 0;
			var tween = this._first,
				labels = this._labels,
				p;
			while (tween) {
				if (tween._startTime >= ignoreBeforeTime) {
					tween._startTime += amount;
				}
				tween = tween._next;
			}
			if (adjustLabels) {
				for (p in labels) {
					if (labels[p] >= ignoreBeforeTime) {
						labels[p] += amount;
					}
				}
			}
			return this._uncache(true);
		};

		p._kill = function(vars, target) {
			if (!vars && !target) {
				return this._enabled(false, false);
			}
			var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
				i = tweens.length,
				changed = false;
			while (--i > -1) {
				if (tweens[i]._kill(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function(labels) {
			var tweens = this.getChildren(false, true, true),
				i = tweens.length;
			this._time = this._totalTime = 0;
			while (--i > -1) {
				tweens[i]._enabled(false, false);
			}
			if (labels !== false) {
				this._labels = {};
			}
			return this._uncache(true);
		};

		p.invalidate = function() {
			var tween = this._first;
			while (tween) {
				tween.invalidate();
				tween = tween._next;
			}
			return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["a" /* Animation */].prototype.invalidate.call(this);;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (enabled === this._gc) {
				var tween = this._first;
				while (tween) {
					tween._enabled(enabled, true);
					tween = tween._next;
				}
			}
			return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["i" /* SimpleTimeline */].prototype._enabled.call(this, enabled, ignoreTimeline);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			this._forcingPlayhead = true;
			var val = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["a" /* Animation */].prototype.totalTime.apply(this, arguments);
			this._forcingPlayhead = false;
			return val;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					this.totalDuration(); //just triggers recalculation
				}
				return this._duration;
			}
			if (this.duration() !== 0 && value !== 0) {
				this.timeScale(this._duration / value);
			}
			return this;
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					var max = 0,
						tween = this._last,
						prevStart = 999999999999,
						prev, end;
					while (tween) {
						prev = tween._prev; //record it here in case the tween changes position in the sequence...
						if (tween._dirty) {
							tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
						}
						if (tween._startTime > prevStart && this._sortChildren && !tween._paused && !this._calculatingDuration) { //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
							this._calculatingDuration = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add(), like _parseTimeOrLabel().
							this.add(tween, tween._startTime - tween._delay);
							this._calculatingDuration = 0;
						} else {
							prevStart = tween._startTime;
						}
						if (tween._startTime < 0 && !tween._paused) { //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
							max -= tween._startTime;
							if (this._timeline.smoothChildTiming) {
								this._startTime += tween._startTime / this._timeScale;
								this._time -= tween._startTime;
								this._totalTime -= tween._startTime;
								this._rawPrevTime -= tween._startTime;
							}
							this.shiftChildren(-tween._startTime, false, -9999999999);
							prevStart = 0;
						}
						end = tween._startTime + (tween._totalDuration / tween._timeScale);
						if (end > max) {
							max = end;
						}
						tween = prev;
					}
					this._duration = this._totalDuration = max;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return (value && this.totalDuration()) ? this.timeScale(this._totalDuration / value) : this;
		};

		p.paused = function(value) {
			if (!value) { //if there's a pause directly at the spot from where we're unpausing, skip it.
				var tween = this._first,
					time = this._time;
				while (tween) {
					if (tween._startTime === time && tween.data === "isPause") {
						tween._rawPrevTime = 0; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won't fire.
					}
					tween = tween._next;
				}
			}
			return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["a" /* Animation */].prototype.paused.apply(this, arguments);
		};

		p.usesFrames = function() {
			var tl = this._timeline;
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return (tl === __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["a" /* Animation */]._rootFramesTimeline);
		};

		p.rawTime = function(wrapRepeats) {
			return (wrapRepeats && (this._paused || (this._repeat && this.time() > 0 && this.totalProgress() < 1))) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(wrapRepeats) - this._startTime) * this._timeScale;
		};

		return TimelineLite;

	}, true);

var TimelineLite = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["m" /* globals */].TimelineLite;



/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var EventEmitter = __webpack_require__(82).EventEmitter;

function Emitter() {
    EventEmitter.call(this);
    this.setMaxListeners(20);
}

Emitter.prototype = Object.create(EventEmitter.prototype);
Emitter.prototype.constructor = Emitter;

Emitter.prototype.off = function(type, listener) {
    if (listener) {
        return this.removeListener(type, listener);
    }
    if (type) {
        return this.removeAllListeners(type);
    }
    return this.removeAllListeners();
};

module.exports = Emitter;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
    mbs: 0,
    secs: 0,
    update: function(request, startTime, url, log) {
        var length;
        var headers = request.getAllResponseHeaders();
        if (headers) {
            var match = headers.match(/content-length: (\d+)/i);
            if (match && match.length) {
                length = match[1];
            }
        }
        // var length = request.getResponseHeader('Content-Length');
        if (length) {
            length = parseInt(length, 10);
            var mbs = length / 1024 / 1024;
            var secs = (Date.now() - startTime) / 1000;
            this.secs += secs;
            this.mbs += mbs;
            if (log) {
                this.log(url, mbs, secs);
            }
        } else if(log) {
            console.warn.call(console, 'Can\'t get Content-Length:', url);
        }
    },
    log: function(url, mbs, secs) {
        if (url) {
            var file = 'File loaded: ' +
                url.substr(url.lastIndexOf('/') + 1) +
                ' size:' + mbs.toFixed(2) + 'mb' +
                ' time:' + secs.toFixed(2) + 's' +
                ' speed:' + (mbs / secs).toFixed(2) + 'mbps';

            console.log.call(console, file);
        }
        var total = 'Total loaded: ' + this.mbs.toFixed(2) + 'mb' +
            ' time:' + this.secs.toFixed(2) + 's' +
            ' speed:' + this.getMbps().toFixed(2) + 'mbps';
        console.log.call(console, total);
    },
    getMbps: function() {
        return this.mbs / this.secs;
    }
};


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(15);

var _debugPolyfill = __webpack_require__(19);

var _debugPolyfill2 = _interopRequireDefault(_debugPolyfill);

var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _SceneApp = __webpack_require__(20);

var _SceneApp2 = _interopRequireDefault(_SceneApp);

var _assetsLoader = __webpack_require__(80);

var _assetsLoader2 = _interopRequireDefault(_assetsLoader);

var _LoadingAnim = __webpack_require__(85);

var _LoadingAnim2 = _interopRequireDefault(_LoadingAnim);

var _assetList = __webpack_require__(6);

var _assetList2 = _interopRequireDefault(_assetList);

var _Assets = __webpack_require__(3);

var _Assets2 = _interopRequireDefault(_Assets);

var _Config = __webpack_require__(1);

var _Config2 = _interopRequireDefault(_Config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var loadingAnim = void 0;

if (document.body) {
	_init();
} else {
	window.addEventListener('DOMContentLoaded', _init);
}

function _init() {

	loadingAnim = new _LoadingAnim2.default();

	//	LOADING ASSETS
	if (_assetList2.default.length > 0) {
		document.body.classList.add('isLoading');

		var loader = new _assetsLoader2.default({
			assets: _assetList2.default
		}).on('error', function (error) {
			console.log('Error :', error);
		}).on('progress', function (p) {
			// console.log('Progress : ', p);
			var loader = document.body.querySelector('.Loading-Bar');
			if (loader) loader.style.width = p * 100 + '%';
		}).on('complete', _onImageLoaded).start();
	} else {
		_init3D();
	}
}

function _onImageLoaded(o) {
	//	ASSETS
	console.log('Image Loaded : ', o);
	window.assets = o;
	var loader = document.body.querySelector('.Loading-Bar');
	console.log('Loader :', loader);
	loader.style.width = '100%';

	_init3D();

	setTimeout(function () {
		document.body.classList.remove('isLoading');
	}, 250);
}

function _init3D() {
	var container = document.body.querySelector('.container');
	//	CREATE CANVAS
	var canvas = document.createElement('canvas');
	canvas.className = 'Main-Canvas';
	container.appendChild(canvas);

	//	INIT 3D TOOL
	_alfrid.GL.init(canvas, { ignoreWebgl2: true });
	console.log('isMobiel :', _alfrid.GL.isMobile);
	if (_alfrid.GL.isMobile) {

		var ua = navigator.userAgent;
		if (/Chrome/i.test(ua)) {
			setTimeout(function () {
				document.body.classList.add('isMobileChrome');
			}, 1000);
		}

		setTimeout(function () {
			document.body.classList.add('isMobile');
		}, 1000);
	}

	//	INIT ASSETS
	_Assets2.default.init();

	//	CREATE SCENE
	var scene = new _SceneApp2.default();

	//	Fullscreen
	var btnFS = document.body.querySelector('.fullscreen');
	var btnFSText = btnFS.querySelector('p');
	var isInFullScreen = false;

	btnFS.addEventListener('touchend', function (e) {
		console.log('fullscreen');
		isInFullScreen = !isInFullScreen;

		if (isInFullScreen) {
			document.body.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
			btnFSText.innerHTML = 'Exit Fullscreen';
		} else {
			document.webkitExitFullscreen();
			btnFSText.innerHTML = 'Go Fullscreen';
		}
	});

	loadingAnim.on('onAnimClosed', function () {
		scene.open();

		setTimeout(function () {
			document.body.classList.add('isOpened');
		}, 1000);
	});
	loadingAnim.close();
}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(4);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(17)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(true) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept(4, function() {
			var newContent = __webpack_require__(4);
			if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 16 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			memo[selector] = fn.call(this, selector);
		}

		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(18);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 18 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// debugPolyfill.js

window.gui = {
	add: function add() {}
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _Assets = __webpack_require__(3);

var _Assets2 = _interopRequireDefault(_Assets);

var _Settings = __webpack_require__(7);

var _Settings2 = _interopRequireDefault(_Settings);

var _Config = __webpack_require__(1);

var _Config2 = _interopRequireDefault(_Config);

var _Noise3D = __webpack_require__(29);

var _Noise3D2 = _interopRequireDefault(_Noise3D);

var _utils = __webpack_require__(5);

var _ViewFloor = __webpack_require__(39);

var _ViewFloor2 = _interopRequireDefault(_ViewFloor);

var _ViewTrees = __webpack_require__(41);

var _ViewTrees2 = _interopRequireDefault(_ViewTrees);

var _ViewBg = __webpack_require__(43);

var _ViewBg2 = _interopRequireDefault(_ViewBg);

var _ViewGround = __webpack_require__(46);

var _ViewGround2 = _interopRequireDefault(_ViewGround);

var _ViewFog = __webpack_require__(10);

var _ViewFog2 = _interopRequireDefault(_ViewFog);

var _ViewFogs = __webpack_require__(51);

var _ViewFogs2 = _interopRequireDefault(_ViewFogs);

var _ViewFXAA = __webpack_require__(52);

var _ViewFXAA2 = _interopRequireDefault(_ViewFXAA);

var _ViewAnimal = __webpack_require__(54);

var _ViewAnimal2 = _interopRequireDefault(_ViewAnimal);

var _ViewSquares = __webpack_require__(57);

var _ViewSquares2 = _interopRequireDefault(_ViewSquares);

var _ViewCover = __webpack_require__(60);

var _ViewCover2 = _interopRequireDefault(_ViewCover);

var _ViewSnow = __webpack_require__(61);

var _ViewSnow2 = _interopRequireDefault(_ViewSnow);

var _PassBloom = __webpack_require__(63);

var _PassBloom2 = _interopRequireDefault(_PassBloom);

var _SoundManager = __webpack_require__(67);

var _SoundManager2 = _interopRequireDefault(_SoundManager);

var _addControls = __webpack_require__(69);

var _addControls2 = _interopRequireDefault(_addControls);

var _TweenMax = __webpack_require__(70);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // SceneApp.js

var fboScale = 1;
var interval = 25;

var random = function random(min, max) {
	return min + Math.random() * (max - min);
};

var SceneApp = function (_Scene) {
	_inherits(SceneApp, _Scene);

	function SceneApp() {
		_classCallCheck(this, SceneApp);

		if (_alfrid.GL.isMobile) {
			fboScale = 0.8;
		}
		_Settings2.default.init();

		_Config2.default.showSnow = false;
		_Settings2.default.refresh();

		var _this = _possibleConstructorReturn(this, (SceneApp.__proto__ || Object.getPrototypeOf(SceneApp)).call(this));

		_this.resize();
		_alfrid.GL.enableAlphaBlending();
		_this.orbitalControl.radius.value = 5;
		_this.orbitalControl.radius.limit(5, 5);
		_this.orbitalControl.rx.limit(-.15, .0);
		var easing = 0.05;
		_this.orbitalControl.rx.easing = easing;
		_this.orbitalControl.ry.easing = easing;

		_this.mtx = mat4.create();
		mat4.translate(_this.mtx, _this.mtx, vec3.fromValues(0, -1.1, 0));

		//	setup front camera for projection
		_this.cameraFront = new _alfrid2.default.CameraPerspective();
		var fov = 50 * Math.PI / 180;
		var far = 15;
		var near = 1;
		_this.camera.setPerspective(fov, _alfrid.GL.aspectRatio, near, far);
		_this.cameraFront.setPerspective(fov, _alfrid.GL.aspectRatio, near, far);
		_this.cameraFront.lookAt([0, 0, 5], [0, 0, 0]);

		_this._biasMatrix = mat4.fromValues(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);

		_this._mtxFront = mat4.create();
		mat4.mul(_this._mtxFront, _this.cameraFront.projection, _this.cameraFront.matrix);
		mat4.mul(_this._mtxFront, _this._biasMatrix, _this._mtxFront);
		_this._vSquares.setMatrices(_this.cameraFront);

		_this._isInTransition = false;
		_this._hasOpened = false;
		_this._hasProfiledFog = false;
		_this._resizeTimeout = 0;
		_this._goodFogRenderCount = 0;
		_this._count = 0;

		window.addEventListener('keydown', function (e) {
			if (e.keyCode === 32) {
				_this.next();
			}
		});

		_this._haslocked = false;
		_this._angles = {
			x: 0,
			y: 0
		};

		window.addEventListener('touchend', function () {
			if (Math.random() > .8 && !_this._haslocked) {

				_this.next();
				_this._haslocked = true;

				setTimeout(function () {
					_this._haslocked = false;
				}, 15000);
			}
		});

		(0, _addControls2.default)(_this);
		return _this;
	}

	_createClass(SceneApp, [{
		key: 'open',
		value: function open() {
			this._vOpeningCover.close();
		}
	}, {
		key: '_initTextures',
		value: function _initTextures() {
			this._fboCapture = new _alfrid2.default.FrameBuffer(_alfrid.GL.width, _alfrid.GL.height, {
				minFilter: _alfrid.GL.LINEAR,
				magFilter: _alfrid.GL.LINEAR
			});

			this._fboRender = new _alfrid2.default.FrameBuffer(_alfrid.GL.width * fboScale, _alfrid.GL.height * fboScale);
			this._fboTemp = new _alfrid2.default.FrameBuffer(_alfrid.GL.width * fboScale, _alfrid.GL.height * fboScale);

			this._noises = new _Noise3D2.default(_Config2.default.noiseNum, _Config2.default.noiseScale);
		}
	}, {
		key: '_initViews',
		value: function _initViews() {
			console.log('init views');

			this._bCopy = new _alfrid2.default.BatchCopy();
			this._bBall = new _alfrid2.default.BatchBall();

			this._vFloor = new _ViewFloor2.default();
			this._vTrees = new _ViewTrees2.default();
			this._vBg = new _ViewBg2.default();
			this._vAnimal = new _ViewAnimal2.default();
			this._vSnow = new _ViewSnow2.default();
			this._vGround = new _ViewGround2.default();
			// this._vFog      = new ViewFog();
			this._vFogs = new _ViewFogs2.default();
			this._vFxaa = new _ViewFXAA2.default();
			this._vSquares = new _ViewSquares2.default();
			this._vCover = new _ViewCover2.default();
			this._vOpeningCover = new _ViewCover2.default();
			this._vOpeningCover.opacity.setTo(1);
			this._passBloom = new _PassBloom2.default(3);

			this._resetTreePosition();
		}
	}, {
		key: 'next',
		value: function next() {
			var _this2 = this;

			if (!document.body.classList.contains('hasInteract')) {
				document.body.classList.add('hasInteract');
			}
			// this.orbitalControl.lock(true);
			this._angles.x *= 0.1;
			this._angles.y *= 0.1;

			this._angles.x *= 0;
			this._angles.y *= 0;

			var animals = ['deer', 'laputa', 'whale', 'bear'];
			var index = animals.indexOf(_Config2.default.animal);
			index++;
			if (index >= animals.length) {
				index = 0;
			}

			// let g = 0.5;
			//	take screen shot of current frame
			this._fboCapture.bind();
			_alfrid.GL.clear(0, 0, 0, 0);
			_alfrid.GL.setMatrices(this.camera);
			this.renderScene();
			this._fboCapture.unbind();

			//	set flag to start rendering the planes
			this._hasOpened = false;
			this._isInTransition = true;

			//	set camera position to front
			this.orbitalControl.rx.setTo(0);
			this.orbitalControl.ry.setTo(0);
			this.orbitalControl.radius.setTo(5);
			this.orbitalControl._loop();
			this.orbitalControl.lock(true);
			//	move camera to side to hide the planes

			//	reset planes position
			this._vSquares.reset();
			this._vSquares.open();

			_Config2.default.animal = animals[index];
			// Settings.refresh();
			this._vAnimal.setAnimal(animals[index]);

			this._resetTreePosition();
			this._capture();

			setTimeout(function () {
				_this2._vCover.open();
			}, 1000);

			setTimeout(function () {
				_TweenMax.TweenLite.killTweensOf(_this2._angles);
				_TweenMax.TweenLite.to(_this2._angles, 3, { "x": -0.1, "y": random(-0.3, 0.3), ease: Circ.easeInOut });

				_this2._vSquares.close();
				_this2._vCover.close();
				_this2._hasOpened = true;
			}, 3000);

			setTimeout(function () {
				_this2._isInTransition = false;
				_this2._angles.x = _this2._angles.y = 0;
				_this2.orbitalControl.lock(false);
			}, 6000);

			//	when camera in position ( planes not visible )
			//	disable rendering the planes
		}
	}, {
		key: '_capture',
		value: function _capture() {
			this._fboTemp.bind();
			_alfrid.GL.clear(0, 0, 0, 1);
			_alfrid.GL.setMatrices(this.camera);
			this.renderScene();
			this._fboTemp.unbind();
		}
	}, {
		key: '_resetTreePosition',
		value: function _resetTreePosition() {
			this._trees = (0, _utils.generateTrees)();
			this._vTrees.reset(this._trees);
			this._textureFloor = (0, _utils.generateHeightMap)(this._trees);
		}
	}, {
		key: 'resetCamera',
		value: function resetCamera() {
			//	set camera position to front
			this.orbitalControl.rx.setTo(0);
			this.orbitalControl.ry.setTo(0);
		}
	}, {
		key: 'updateFog',
		value: function updateFog() {
			this._count = 0;
			this._noises.update();
		}
	}, {
		key: 'render',
		value: function render() {
			this._hasProfiledFog = false;
			this._count++;
			if (this._count >= interval) {
				this.updateFog();
			}

			if (this._isInTransition) {
				this.orbitalControl.rx.setTo(this._angles.x);
				this.orbitalControl.ry.setTo(this._angles.y);
			}
			_alfrid.GL.clear(0, 0, 0, 1);

			if (this._isInTransition && this._hasOpened) {
				this._capture();
			}

			this._fboRender.bind();
			_alfrid.GL.clear(0, 0, 0, 1);

			if (this._isInTransition) {
				_alfrid.GL.disable(_alfrid.GL.DEPTH_TEST);
				if (this._hasOpened) {
					this._bCopy.draw(this._fboTemp.getTexture());
				} else {
					this._bCopy.draw(this._fboCapture.getTexture());
				}

				this._vCover.render();

				_alfrid.GL.enable(_alfrid.GL.DEPTH_TEST);
				_alfrid.GL.rotate(this.mtx);
				this._vSquares.render(this._mtxFront, this._fboCapture.getTexture());
			} else {
				this.renderScene();
			}

			this._fboRender.unbind();

			this._passBloom.render(this._fboRender.getTexture());

			if (_Config2.default.fxaa) {
				this._vFxaa.render(this._fboRender.getTexture(), this._passBloom.getTexture());
			} else {
				this._bCopy.draw(this._fboRender.getTexture());
			}

			_alfrid.GL.disable(_alfrid.GL.DEPTH_TEST);
			this._vOpeningCover.render();
			_alfrid.GL.enable(_alfrid.GL.DEPTH_TEST);
		}
	}, {
		key: 'renderScene',
		value: function renderScene() {
			var mRenderFog = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			_alfrid.GL.rotate(this.mtx);

			this._vBg.render();
			this._vGround.render();
			this._vFloor.render(this._textureFloor);
			if (_Config2.default.showSnow) {
				this._vSnow.render();
			}
			this._vTrees.render(this.camera.position);
			this._vAnimal.render();

			if (!_alfrid.GL.isMobile && mRenderFog) {
				var t0 = performance.now();
				var tt0 = new Date().getTime();
				this._vFogs.render(this._noises.texture0, this._noises.texture1, this._count / interval);
				var t1 = performance.now();
				var tt1 = new Date().getTime();
				var renderTime = t1 - t0;
				var renderTime0 = tt1 - tt0;

				if (Math.random() > 0.5) {
					console.log('Fog render time :', renderTime, renderTime0);
				}
			}

			this._hasProfiledFog = true;
		}
	}, {
		key: 'resize',
		value: function resize() {
			var _this3 = this;

			var _window = window,
			    innerWidth = _window.innerWidth,
			    innerHeight = _window.innerHeight,
			    devicePixelRatio = _window.devicePixelRatio;

			_alfrid.GL.setSize(innerWidth, innerHeight);
			this.camera.setAspectRatio(_alfrid.GL.aspectRatio);

			if (this.cameraFront) {
				this.cameraFront.setAspectRatio(_alfrid.GL.aspectRatio);
				mat4.identity(this._mtxFront, this._mtxFront);
				mat4.mul(this._mtxFront, this.cameraFront.projection, this.cameraFront.matrix);
				mat4.mul(this._mtxFront, this._biasMatrix, this._mtxFront);
				this._vSquares.setMatrices(this.cameraFront);
			}

			if (this._resizeTimeout !== 0) {
				clearTimeout(this._resizeTimeout);
			}

			this._resizeTimeout = setTimeout(function () {
				_this3._fboCapture = new _alfrid2.default.FrameBuffer(_alfrid.GL.width, _alfrid.GL.height, {
					minFilter: _alfrid.GL.LINEAR,
					magFilter: _alfrid.GL.LINEAR
				});

				_this3._fboRender = new _alfrid2.default.FrameBuffer(_alfrid.GL.width * fboScale, _alfrid.GL.height * fboScale);
				_this3._fboTemp = new _alfrid2.default.FrameBuffer(_alfrid.GL.width * fboScale, _alfrid.GL.height * fboScale);
			}, 1000 / 60 * 5);
		}
	}]);

	return SceneApp;
}(_alfrid.Scene);

exports.default = SceneApp;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
Copyright (c) 2014 Petka Antonov

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
function Url() {
    //For more efficient internal representation and laziness.
    //The non-underscore versions of these properties are accessor functions
    //defined on the prototype.
    this._protocol = null;
    this._href = "";
    this._port = -1;
    this._query = null;

    this.auth = null;
    this.slashes = null;
    this.host = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;

    this._prependSlash = false;
}

var querystring = __webpack_require__(22);

Url.queryString = querystring;

Url.prototype.parse =
function Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (typeof str !== "string") {
        throw new TypeError("Parameter 'url' must be a string, not " +
            typeof str);
    }
    var start = 0;
    var end = str.length - 1;

    //Trim leading and trailing ws
    while (str.charCodeAt(start) <= 0x20 /*' '*/) start++;
    while (str.charCodeAt(end) <= 0x20 /*' '*/) end--;

    start = this._parseProtocol(str, start, end);

    //Javascript doesn't have host
    if (this._protocol !== "javascript") {
        start = this._parseHost(str, start, end, hostDenotesSlash);
        var proto = this._protocol;
        if (!this.hostname &&
            (this.slashes || (proto && !slashProtocols[proto]))) {
            this.hostname = this.host = "";
        }
    }

    if (start <= end) {
        var ch = str.charCodeAt(start);

        if (ch === 0x2F /*'/'*/ || ch === 0x5C /*'\'*/) {
            this._parsePath(str, start, end, disableAutoEscapeChars);
        }
        else if (ch === 0x3F /*'?'*/) {
            this._parseQuery(str, start, end, disableAutoEscapeChars);
        }
        else if (ch === 0x23 /*'#'*/) {
          this._parseHash(str, start, end, disableAutoEscapeChars);
        }
        else if (this._protocol !== "javascript") {
            this._parsePath(str, start, end, disableAutoEscapeChars);
        }
        else { //For javascript the pathname is just the rest of it
            this.pathname = str.slice(start, end + 1 );
        }

    }

    if (!this.pathname && this.hostname &&
        this._slashProtocols[this._protocol]) {
        this.pathname = "/";
    }

    if (parseQueryString) {
        var search = this.search;
        if (search == null) {
            search = this.search = "";
        }
        if (search.charCodeAt(0) === 0x3F /*'?'*/) {
            search = search.slice(1);
        }
        //This calls a setter function, there is no .query data property
        this.query = Url.queryString.parse(search);
    }
};

Url.prototype.resolve = function Url$resolve(relative) {
    return this.resolveObject(Url.parse(relative, false, true)).format();
};

Url.prototype.format = function Url$format() {
    var auth = this.auth || "";

    if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
    }

    var protocol = this.protocol || "";
    var pathname = this.pathname || "";
    var hash = this.hash || "";
    var search = this.search || "";
    var query = "";
    var hostname = this.hostname || "";
    var port = this.port || "";
    var host = false;
    var scheme = "";

    //Cache the result of the getter function
    var q = this.query;
    if (q && typeof q === "object") {
        query = Url.queryString.stringify(q);
    }

    if (!search) {
        search = query ? "?" + query : "";
    }

    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 0x3A /*':'*/)
        protocol += ":";

    if (this.host) {
        host = auth + this.host;
    }
    else if (hostname) {
        var ip6 = hostname.indexOf(":") > -1;
        if (ip6) hostname = "[" + hostname + "]";
        host = auth + hostname + (port ? ":" + port : "");
    }

    var slashes = this.slashes ||
        ((!protocol ||
        slashProtocols[protocol]) && host !== false);


    if (protocol) scheme = protocol + (slashes ? "//" : "");
    else if (slashes) scheme = "//";

    if (slashes && pathname && pathname.charCodeAt(0) !== 0x2F /*'/'*/) {
        pathname = "/" + pathname;
    }
    if (search && search.charCodeAt(0) !== 0x3F /*'?'*/)
        search = "?" + search;
    if (hash && hash.charCodeAt(0) !== 0x23 /*'#'*/)
        hash = "#" + hash;

    pathname = escapePathName(pathname);
    search = escapeSearch(search);

    return scheme + (host === false ? "" : host) + pathname + search + hash;
};

Url.prototype.resolveObject = function Url$resolveObject(relative) {
    if (typeof relative === "string")
        relative = Url.parse(relative, false, true);

    var result = this._clone();

    // hash is always overridden, no matter what.
    // even href="" will remove it.
    result.hash = relative.hash;

    // if the relative url is empty, then there"s nothing left to do here.
    if (!relative.href) {
        result._href = "";
        return result;
    }

    // hrefs like //foo/bar always cut to the protocol.
    if (relative.slashes && !relative._protocol) {
        relative._copyPropsTo(result, true);

        if (slashProtocols[result._protocol] &&
            result.hostname && !result.pathname) {
            result.pathname = "/";
        }
        result._href = "";
        return result;
    }

    if (relative._protocol && relative._protocol !== result._protocol) {
        // if it"s a known url protocol, then changing
        // the protocol does weird things
        // first, if it"s not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that"s known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashProtocols[relative._protocol]) {
            relative._copyPropsTo(result, false);
            result._href = "";
            return result;
        }

        result._protocol = relative._protocol;
        if (!relative.host && relative._protocol !== "javascript") {
            var relPath = (relative.pathname || "").split("/");
            while (relPath.length && !(relative.host = relPath.shift()));
            if (!relative.host) relative.host = "";
            if (!relative.hostname) relative.hostname = "";
            if (relPath[0] !== "") relPath.unshift("");
            if (relPath.length < 2) relPath.unshift("");
            result.pathname = relPath.join("/");
        } else {
            result.pathname = relative.pathname;
        }

        result.search = relative.search;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result._port = relative._port;
        result.slashes = result.slashes || relative.slashes;
        result._href = "";
        return result;
    }

    var isSourceAbs =
        (result.pathname && result.pathname.charCodeAt(0) === 0x2F /*'/'*/);
    var isRelAbs = (
            relative.host ||
            (relative.pathname &&
            relative.pathname.charCodeAt(0) === 0x2F /*'/'*/)
        );
    var mustEndAbs = (isRelAbs || isSourceAbs ||
                        (result.host && relative.pathname));

    var removeAllDots = mustEndAbs;

    var srcPath = result.pathname && result.pathname.split("/") || [];
    var relPath = relative.pathname && relative.pathname.split("/") || [];
    var psychotic = result._protocol && !slashProtocols[result._protocol];

    // if the url is a non-slashed url, then relative
    // links like ../.. should be able
    // to crawl up to the hostname, as well.  This is strange.
    // result.protocol has already been set by now.
    // Later on, put the first path part into the host field.
    if (psychotic) {
        result.hostname = "";
        result._port = -1;
        if (result.host) {
            if (srcPath[0] === "") srcPath[0] = result.host;
            else srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative._protocol) {
            relative.hostname = "";
            relative._port = -1;
            if (relative.host) {
                if (relPath[0] === "") relPath[0] = relative.host;
                else relPath.unshift(relative.host);
            }
            relative.host = "";
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }

    if (isRelAbs) {
        // it"s absolute.
        result.host = relative.host ?
            relative.host : result.host;
        result.hostname = relative.hostname ?
            relative.hostname : result.hostname;
        result.search = relative.search;
        srcPath = relPath;
        // fall through to the dot-handling below.
    } else if (relPath.length) {
        // it"s relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
    } else if (relative.search) {
        // just pull out the search.
        // like href="?foo".
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            //occationaly the auth can get stuck only in host
            //this especialy happens in cases like
            //url.resolveObject("mailto:local1@domain1", "local2@domain2")
            var authInHost = result.host && result.host.indexOf("@") > 0 ?
                result.host.split("@") : false;
            if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
            }
        }
        result.search = relative.search;
        result._href = "";
        return result;
    }

    if (!srcPath.length) {
        // no path at all.  easy.
        // we"ve already handled the other stuff above.
        result.pathname = null;
        result._href = "";
        return result;
    }

    // if a url ENDs in . or .., then it must get a trailing slash.
    // however, if it ends in anything else non-slashy,
    // then it must NOT get a trailing slash.
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (
        (result.host || relative.host) && (last === "." || last === "..") ||
        last === "");

    // strip single dots, resolve double dots to parent dir
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === ".") {
            srcPath.splice(i, 1);
        } else if (last === "..") {
            srcPath.splice(i, 1);
            up++;
        } else if (up) {
            srcPath.splice(i, 1);
            up--;
        }
    }

    // if the path is allowed to go above the root, restore leading ..s
    if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
            srcPath.unshift("..");
        }
    }

    if (mustEndAbs && srcPath[0] !== "" &&
        (!srcPath[0] || srcPath[0].charCodeAt(0) !== 0x2F /*'/'*/)) {
        srcPath.unshift("");
    }

    if (hasTrailingSlash && (srcPath.join("/").substr(-1) !== "/")) {
        srcPath.push("");
    }

    var isAbsolute = srcPath[0] === "" ||
        (srcPath[0] && srcPath[0].charCodeAt(0) === 0x2F /*'/'*/);

    // put the host back
    if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" :
            srcPath.length ? srcPath.shift() : "";
        //occationaly the auth can get stuck only in host
        //this especialy happens in cases like
        //url.resolveObject("mailto:local1@domain1", "local2@domain2")
        var authInHost = result.host && result.host.indexOf("@") > 0 ?
            result.host.split("@") : false;
        if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
        }
    }

    mustEndAbs = mustEndAbs || (result.host && srcPath.length);

    if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
    }

    result.pathname = srcPath.length === 0 ? null : srcPath.join("/");
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result._href = "";
    return result;
};

var punycode = __webpack_require__(25);
Url.prototype._hostIdna = function Url$_hostIdna(hostname) {
    // IDNA Support: Returns a punycoded representation of "domain".
    // It only converts parts of the domain name that
    // have non-ASCII characters, i.e. it doesn't matter if
    // you call it with a domain that already is ASCII-only.
    return punycode.toASCII(hostname);
};

var escapePathName = Url.prototype._escapePathName =
function Url$_escapePathName(pathname) {
    if (!containsCharacter2(pathname, 0x23 /*'#'*/, 0x3F /*'?'*/)) {
        return pathname;
    }
    //Avoid closure creation to keep this inlinable
    return _escapePath(pathname);
};

var escapeSearch = Url.prototype._escapeSearch =
function Url$_escapeSearch(search) {
    if (!containsCharacter2(search, 0x23 /*'#'*/, -1)) return search;
    //Avoid closure creation to keep this inlinable
    return _escapeSearch(search);
};

Url.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {
    var doLowerCase = false;
    var protocolCharacters = this._protocolCharacters;

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 0x3A /*':'*/) {
            var protocol = str.slice(start, i);
            if (doLowerCase) protocol = protocol.toLowerCase();
            this._protocol = protocol;
            return i + 1;
        }
        else if (protocolCharacters[ch] === 1) {
            if (ch < 0x61 /*'a'*/)
                doLowerCase = true;
        }
        else {
            return start;
        }

    }
    return start;
};

Url.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode) {
    var auth = str.slice(start, end + 1);
    if (decode) {
        auth = decodeURIComponent(auth);
    }
    this.auth = auth;
};

Url.prototype._parsePort = function Url$_parsePort(str, start, end) {
    //Internal format is integer for more efficient parsing
    //and for efficient trimming of leading zeros
    var port = 0;
    //Distinguish between :0 and : (no port number at all)
    var hadChars = false;
    var validPort = true;

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/) {
            port = (10 * port) + (ch - 0x30 /*'0'*/);
            hadChars = true;
        }
        else {
            validPort = false;
            if (ch === 0x5C/*'\'*/ || ch === 0x2F/*'/'*/) {
                validPort = true;
            }
            break;
        }

    }
    if ((port === 0 && !hadChars) || !validPort) {
        if (!validPort) {
            this._port = -2;
        }
        return 0;
    }

    this._port = port;
    return i - start;
};

Url.prototype._parseHost =
function Url$_parseHost(str, start, end, slashesDenoteHost) {
    var hostEndingCharacters = this._hostEndingCharacters;
    var first = str.charCodeAt(start);
    var second = str.charCodeAt(start + 1);
    if ((first === 0x2F /*'/'*/ || first === 0x5C /*'\'*/) &&
        (second === 0x2F /*'/'*/ || second === 0x5C /*'\'*/)) {
        this.slashes = true;

        //The string starts with //
        if (start === 0) {
            //The string is just "//"
            if (end < 2) return start;
            //If slashes do not denote host and there is no auth,
            //there is no host when the string starts with //
            var hasAuth =
                containsCharacter(str, 0x40 /*'@'*/, 2, hostEndingCharacters);
            if (!hasAuth && !slashesDenoteHost) {
                this.slashes = null;
                return start;
            }
        }
        //There is a host that starts after the //
        start += 2;
    }
    //If there is no slashes, there is no hostname if
    //1. there was no protocol at all
    else if (!this._protocol ||
        //2. there was a protocol that requires slashes
        //e.g. in 'http:asd' 'asd' is not a hostname
        slashProtocols[this._protocol]
    ) {
        return start;
    }

    var doLowerCase = false;
    var idna = false;
    var hostNameStart = start;
    var hostNameEnd = end;
    var lastCh = -1;
    var portLength = 0;
    var charsAfterDot = 0;
    var authNeedsDecoding = false;

    var j = -1;

    //Find the last occurrence of an @-sign until hostending character is met
    //also mark if decoding is needed for the auth portion
    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 0x40 /*'@'*/) {
            j = i;
        }
        //This check is very, very cheap. Unneeded decodeURIComponent is very
        //very expensive
        else if (ch === 0x25 /*'%'*/) {
            authNeedsDecoding = true;
        }
        else if (hostEndingCharacters[ch] === 1) {
            break;
        }
    }

    //@-sign was found at index j, everything to the left from it
    //is auth part
    if (j > -1) {
        this._parseAuth(str, start, j - 1, authNeedsDecoding);
        //hostname starts after the last @-sign
        start = hostNameStart = j + 1;
    }

    //Host name is starting with a [
    if (str.charCodeAt(start) === 0x5B /*'['*/) {
        for (var i = start + 1; i <= end; ++i) {
            var ch = str.charCodeAt(i);

            //Assume valid IP6 is between the brackets
            if (ch === 0x5D /*']'*/) {
                if (str.charCodeAt(i + 1) === 0x3A /*':'*/) {
                    portLength = this._parsePort(str, i + 2, end) + 1;
                }
                var hostname = str.slice(start + 1, i).toLowerCase();
                this.hostname = hostname;
                this.host = this._port > 0 ?
                    "[" + hostname + "]:" + this._port :
                    "[" + hostname + "]";
                this.pathname = "/";
                return i + portLength + 1;
            }
        }
        //Empty hostname, [ starts a path
        return start;
    }

    for (var i = start; i <= end; ++i) {
        if (charsAfterDot > 62) {
            this.hostname = this.host = str.slice(start, i);
            return i;
        }
        var ch = str.charCodeAt(i);

        if (ch === 0x3A /*':'*/) {
            portLength = this._parsePort(str, i + 1, end) + 1;
            hostNameEnd = i - 1;
            break;
        }
        else if (ch < 0x61 /*'a'*/) {
            if (ch === 0x2E /*'.'*/) {
                //Node.js ignores this error
                /*
                if (lastCh === DOT || lastCh === -1) {
                    this.hostname = this.host = "";
                    return start;
                }
                */
                charsAfterDot = -1;
            }
            else if (0x41 /*'A'*/ <= ch && ch <= 0x5A /*'Z'*/) {
                doLowerCase = true;
            }
            //Valid characters other than ASCII letters -, _, +, 0-9
            else if (!(ch === 0x2D /*'-'*/ ||
                       ch === 0x5F /*'_'*/ ||
                       ch === 0x2B /*'+'*/ ||
                       (0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/))
                ) {
                if (hostEndingCharacters[ch] === 0 &&
                    this._noPrependSlashHostEnders[ch] === 0) {
                    this._prependSlash = true;
                }
                hostNameEnd = i - 1;
                break;
            }
        }
        else if (ch >= 0x7B /*'{'*/) {
            if (ch <= 0x7E /*'~'*/) {
                if (this._noPrependSlashHostEnders[ch] === 0) {
                    this._prependSlash = true;
                }
                hostNameEnd = i - 1;
                break;
            }
            idna = true;
        }
        lastCh = ch;
        charsAfterDot++;
    }

    //Node.js ignores this error
    /*
    if (lastCh === DOT) {
        hostNameEnd--;
    }
    */

    if (hostNameEnd + 1 !== start &&
        hostNameEnd - hostNameStart <= 256) {
        var hostname = str.slice(hostNameStart, hostNameEnd + 1);
        if (doLowerCase) hostname = hostname.toLowerCase();
        if (idna) hostname = this._hostIdna(hostname);
        this.hostname = hostname;
        this.host = this._port > 0 ? hostname + ":" + this._port : hostname;
    }

    return hostNameEnd + 1 + portLength;

};

Url.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {
    if (!noProtocol) {
        input._protocol = this._protocol;
    }
    input._href = this._href;
    input._port = this._port;
    input._prependSlash = this._prependSlash;
    input.auth = this.auth;
    input.slashes = this.slashes;
    input.host = this.host;
    input.hostname = this.hostname;
    input.hash = this.hash;
    input.search = this.search;
    input.pathname = this.pathname;
};

Url.prototype._clone = function Url$_clone() {
    var ret = new Url();
    ret._protocol = this._protocol;
    ret._href = this._href;
    ret._port = this._port;
    ret._prependSlash = this._prependSlash;
    ret.auth = this.auth;
    ret.slashes = this.slashes;
    ret.host = this.host;
    ret.hostname = this.hostname;
    ret.hash = this.hash;
    ret.search = this.search;
    ret.pathname = this.pathname;
    return ret;
};

Url.prototype._getComponentEscaped =
function Url$_getComponentEscaped(str, start, end, isAfterQuery) {
    var cur = start;
    var i = start;
    var ret = "";
    var autoEscapeMap = isAfterQuery ?
        this._afterQueryAutoEscapeMap : this._autoEscapeMap;
    for (; i <= end; ++i) {
        var ch = str.charCodeAt(i);
        var escaped = autoEscapeMap[ch];

        if (escaped !== "" && escaped !== undefined) {
            if (cur < i) ret += str.slice(cur, i);
            ret += escaped;
            cur = i + 1;
        }
    }
    if (cur < i + 1) ret += str.slice(cur, i);
    return ret;
};

Url.prototype._parsePath =
function Url$_parsePath(str, start, end, disableAutoEscapeChars) {
    var pathStart = start;
    var pathEnd = end;
    var escape = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    var prePath = this._port === -2 ? "/:" : "";

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);
        if (ch === 0x23 /*'#'*/) {
          this._parseHash(str, i, end, disableAutoEscapeChars);
            pathEnd = i - 1;
            break;
        }
        else if (ch === 0x3F /*'?'*/) {
            this._parseQuery(str, i, end, disableAutoEscapeChars);
            pathEnd = i - 1;
            break;
        }
        else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {
            escape = true;
        }
    }

    if (pathStart > pathEnd) {
        this.pathname = prePath === "" ? "/" : prePath;
        return;
    }

    var path;
    if (escape) {
        path = this._getComponentEscaped(str, pathStart, pathEnd, false);
    }
    else {
        path = str.slice(pathStart, pathEnd + 1);
    }
    this.pathname = prePath === ""
        ? (this._prependSlash ? "/" + path : path)
        : prePath + path;
};

Url.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {
    var queryStart = start;
    var queryEnd = end;
    var escape = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 0x23 /*'#'*/) {
            this._parseHash(str, i, end, disableAutoEscapeChars);
            queryEnd = i - 1;
            break;
        }
        else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {
            escape = true;
        }
    }

    if (queryStart > queryEnd) {
        this.search = "";
        return;
    }

    var query;
    if (escape) {
        query = this._getComponentEscaped(str, queryStart, queryEnd, true);
    }
    else {
        query = str.slice(queryStart, queryEnd + 1);
    }
    this.search = query;
};

Url.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {
    if (start > end) {
        this.hash = "";
        return;
    }

    this.hash = disableAutoEscapeChars ?
        str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);
};

Object.defineProperty(Url.prototype, "port", {
    get: function() {
        if (this._port >= 0) {
            return ("" + this._port);
        }
        return null;
    },
    set: function(v) {
        if (v == null) {
            this._port = -1;
        }
        else {
            this._port = parseInt(v, 10);
        }
    }
});

Object.defineProperty(Url.prototype, "query", {
    get: function() {
        var query = this._query;
        if (query != null) {
            return query;
        }
        var search = this.search;

        if (search) {
            if (search.charCodeAt(0) === 0x3F /*'?'*/) {
                search = search.slice(1);
            }
            if (search !== "") {
                this._query = search;
                return search;
            }
        }
        return search;
    },
    set: function(v) {
        this._query = v;
    }
});

Object.defineProperty(Url.prototype, "path", {
    get: function() {
        var p = this.pathname || "";
        var s = this.search || "";
        if (p || s) {
            return p + s;
        }
        return (p == null && s) ? ("/" + s) : null;
    },
    set: function() {}
});

Object.defineProperty(Url.prototype, "protocol", {
    get: function() {
        var proto = this._protocol;
        return proto ? proto + ":" : proto;
    },
    set: function(v) {
        if (typeof v === "string") {
            var end = v.length - 1;
            if (v.charCodeAt(end) === 0x3A /*':'*/) {
                this._protocol = v.slice(0, end);
            }
            else {
                this._protocol = v;
            }
        }
        else if (v == null) {
            this._protocol = null;
        }
    }
});

Object.defineProperty(Url.prototype, "href", {
    get: function() {
        var href = this._href;
        if (!href) {
            href = this._href = this.format();
        }
        return href;
    },
    set: function(v) {
        this._href = v;
    }
});

Url.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (str instanceof Url) return str;
    var ret = new Url();
    ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);
    return ret;
};

Url.format = function Url$Format(obj) {
    if (typeof obj === "string") {
        obj = Url.parse(obj);
    }
    if (!(obj instanceof Url)) {
        return Url.prototype.format.call(obj);
    }
    return obj.format();
};

Url.resolve = function Url$Resolve(source, relative) {
    return Url.parse(source, false, true).resolve(relative);
};

Url.resolveObject = function Url$ResolveObject(source, relative) {
    if (!source) return relative;
    return Url.parse(source, false, true).resolveObject(relative);
};

function _escapePath(pathname) {
    return pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
    });
}

function _escapeSearch(search) {
    return search.replace(/#/g, function(match) {
        return encodeURIComponent(match);
    });
}

//Search `char1` (integer code for a character) in `string`
//starting from `fromIndex` and ending at `string.length - 1`
//or when a stop character is found
function containsCharacter(string, char1, fromIndex, stopCharacterTable) {
    var len = string.length;
    for (var i = fromIndex; i < len; ++i) {
        var ch = string.charCodeAt(i);

        if (ch === char1) {
            return true;
        }
        else if (stopCharacterTable[ch] === 1) {
            return false;
        }
    }
    return false;
}

//See if `char1` or `char2` (integer codes for characters)
//is contained in `string`
function containsCharacter2(string, char1, char2) {
    for (var i = 0, len = string.length; i < len; ++i) {
        var ch = string.charCodeAt(i);
        if (ch === char1 || ch === char2) return true;
    }
    return false;
}

//Makes an array of 128 uint8's which represent boolean values.
//Spec is an array of ascii code points or ascii code point ranges
//ranges are expressed as [start, end]

//Create a table with the characters 0x30-0x39 (decimals '0' - '9') and
//0x7A (lowercaseletter 'z') as `true`:
//
//var a = makeAsciiTable([[0x30, 0x39], 0x7A]);
//a[0x30]; //1
//a[0x15]; //0
//a[0x35]; //1
function makeAsciiTable(spec) {
    var ret = new Uint8Array(128);
    spec.forEach(function(item){
        if (typeof item === "number") {
            ret[item] = 1;
        }
        else {
            var start = item[0];
            var end = item[1];
            for (var j = start; j <= end; ++j) {
                ret[j] = 1;
            }
        }
    });

    return ret;
}


var autoEscape = ["<", ">", "\"", "`", " ", "\r", "\n",
    "\t", "{", "}", "|", "\\", "^", "`", "'"];

var autoEscapeMap = new Array(128);



for (var i = 0, len = autoEscapeMap.length; i < len; ++i) {
    autoEscapeMap[i] = "";
}

for (var i = 0, len = autoEscape.length; i < len; ++i) {
    var c = autoEscape[i];
    var esc = encodeURIComponent(c);
    if (esc === c) {
        esc = escape(c);
    }
    autoEscapeMap[c.charCodeAt(0)] = esc;
}
var afterQueryAutoEscapeMap = autoEscapeMap.slice();
autoEscapeMap[0x5C /*'\'*/] = "/";

var slashProtocols = Url.prototype._slashProtocols = {
    http: true,
    https: true,
    gopher: true,
    file: true,
    ftp: true,

    "http:": true,
    "https:": true,
    "gopher:": true,
    "file:": true,
    "ftp:": true
};

//Optimize back from normalized object caused by non-identifier keys
function f(){}
f.prototype = slashProtocols;

Url.prototype._protocolCharacters = makeAsciiTable([
    [0x61 /*'a'*/, 0x7A /*'z'*/],
    [0x41 /*'A'*/, 0x5A /*'Z'*/],
    0x2E /*'.'*/, 0x2B /*'+'*/, 0x2D /*'-'*/
]);

Url.prototype._hostEndingCharacters = makeAsciiTable([
    0x23 /*'#'*/, 0x3F /*'?'*/, 0x2F /*'/'*/, 0x5C /*'\'*/
]);

Url.prototype._autoEscapeCharacters = makeAsciiTable(
    autoEscape.map(function(v) {
        return v.charCodeAt(0);
    })
);

//If these characters end a host name, the path will not be prepended a /
Url.prototype._noPrependSlashHostEnders = makeAsciiTable(
    [
        "<", ">", "'", "`", " ", "\r",
        "\n", "\t", "{", "}", "|",
        "^", "`", "\"", "%", ";"
    ].map(function(v) {
        return v.charCodeAt(0);
    })
);

Url.prototype._autoEscapeMap = autoEscapeMap;
Url.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;

module.exports = Url;

Url.replace = function Url$Replace() {
    __webpack_require__.c.url = {
        exports: Url
    };
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(23);
exports.encode = exports.stringify = __webpack_require__(24);


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)(module), __webpack_require__(8)))

/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var QueryStringSerializer = __webpack_require__(28);
module.exports = QueryStringParser;

var rplus = /\+/g;
var rint = /^[0-9]+$/;
var isArray = Array.isArray;
var haveProp = {}.hasOwnProperty;

function QueryStringParser() {
    this.containsSparse = false;
    this.cacheKey = "";
    this.cacheVal = null;
}

QueryStringParser.maxLength = 32768;
QueryStringParser.maxDepth = 4;
QueryStringParser.maxKeys = 256;

QueryStringParser.parse = function QueryStringParser$Parse(str) {
    if (typeof str === "string") {
        var maxLength = QueryStringParser.maxLength;
        if (str.length > maxLength) {
            throw new RangeError(
                "str is too large (" +
                "QueryStringParser.maxLength=" + maxLength + ")"
            );
        }
        var parser = new QueryStringParser();
        return parser.parseString(str, false);
    }
    else if (str !== null && typeof str === "object") {
        var parser = new QueryStringParser();
        return parser.parseObject(str);
    }
    return {};
};

QueryStringParser.stringify =
function QueryStringParser$Stringify(value) {
    var serializer = new QueryStringSerializer();
    return serializer.serialize(value);
};

QueryStringParser.prototype.decode =
function QueryStringParser$decode(str, shouldDecode, containsPlus) {
    if (shouldDecode === false) return str;
    if (containsPlus === true) str = str.replace(rplus, " ");
    try {
        return decodeURIComponent(str);
    }
    catch (e) {
        return str;
    }
};

QueryStringParser.prototype.maybeArrayIndex =
function QueryStringParser$maybeArrayIndex(str, arrayLength) {
    var len = str.length;
    if (len === 0) {
        return arrayLength;
    }
    var ch = str.charCodeAt(0);

    if (ch === 48) {
        return len > 1 ? -1 : 0;
    }
    else if (48 <= ch && ch <= 57) {
        if (len === 1) {
            return ch - 48;
        }
        else if (rint.test(str)) {
            var v = parseInt(str, 10);
            if (0 < v && v <= 1073741822) {
                return v;
            }
        }
    }
    return -1;
};

QueryStringParser.prototype.getSlot =
function QueryStringParser$getSlot(dictionary, prevKey, curKey) {
    var slot;
    if (!(haveProp.call(dictionary, prevKey))) {
        var index = this.maybeArrayIndex(curKey, 0);
        if (index > -1) {
            slot = [];
        }
        else {
            slot = {};
        }
        dictionary[prevKey] = slot;
    }
    else {
        slot = dictionary[prevKey];
    }
    return slot;
};

QueryStringParser.prototype.placeNestedValue =
function QueryStringParser$placeNestedValue
(dictionary, key, value, i, prevKey, curKey) {
    var slot = this.getSlot(dictionary, prevKey, curKey);
    var index = -1;

    if (isArray(slot)) {
        index = this.maybeArrayIndex(curKey, slot.length);
    }

    var len = key.length;
    var depth = 2;
    var maxDepth = QueryStringParser.maxDepth;
    var start = -1;
    for (; i < len; ++i) {
        var ch = key.charCodeAt(i);
        if (ch === 91) {
            start = i + 1;
        }
        else if (ch === 93 &&
                start > -1) {
            prevKey = curKey;
            curKey = start === i ? "" : key.substring(start, i);
            start = -1;
            depth++;
            if (depth > maxDepth) {
                throw new RangeError("Nesting depth of keys is too large " +
                    "(QueryStringParser.maxDepth="+maxDepth+")" );
            }
            slot = this.getSlot(slot, prevKey, curKey);

            index = isArray(slot)
                ? this.maybeArrayIndex(curKey, slot.length)
                : -1;
        }
    }

    if(index > -1) {
        if (value !== "") {
            if (index === slot.length) {
                slot.push(value);
            }
            else {
                this.containsSparse = true;
                slot[index] = value;
            }
        }
    }
    else {
        this.insert(slot, curKey, value);
    }
};

QueryStringParser.prototype.insert =
function QueryStringParser$insert(dictionary, key, value) {
    var ret = null;
    if (haveProp.call(dictionary, key)) {
        var prev = dictionary[key];
        if( isArray(prev) ) {
            prev.push(value);
            ret = prev;
        }
        else {
            ret = [prev, value];
            dictionary[key] = ret;
        }
    }
    else {
        dictionary[key] = value;
    }
    return ret;
};

QueryStringParser.prototype.push =
function QueryStringParser$push(dictionary, key, value) {
    var ret = null;
    if (haveProp.call(dictionary, key)) {
        var prev = dictionary[key];
        prev.push(value);
        ret = prev;
    }
    else {
        ret = [value];
        dictionary[key] = ret;
    }
    return ret;
};

QueryStringParser.prototype.maybePlaceNestedValue =
function QueryStringParser$maybePlaceNestedValue(dictionary, key, value) {
    var len = key.length;
    if (key.charCodeAt(len - 1) !== 93) {
        this.placeValue(dictionary, key, value, false);
        return;
    }
    var start = -1;

    var i = 0;
    var curKey;
    var prevKey;

    for (; i < len; ++i) {
        var ch = key.charCodeAt(i);

        if (ch === 91) {
            start = i + 1;
            prevKey = key.slice(0, i);
        }
        else if (ch === 93) {
            if (start < 0) {
                this.placeValue(dictionary, key, value, false);
                return;
            }
            curKey = start === i ? "" : key.slice(start, i);
            i++;
            break;
        }
    }

    if (curKey === void 0) {
        this.placeValue(dictionary, key, value, false);
        return;
    }

    if (curKey === "" && value !== "" && i === len) {
        if (key === this.cacheKey) {
            this.cacheVal.push(value);
        }
        else {
            this.cacheKey = key;
            this.cacheVal = this.push(dictionary, prevKey, value);
        }
    }
    else {
        this.placeNestedValue(dictionary, key, value, i, prevKey, curKey);
    }
};

QueryStringParser.prototype.placeValue =
function QueryStringParser$placeValue(dictionary, key, value, possiblyNested) {
    if (possiblyNested === true) {
        this.maybePlaceNestedValue(dictionary, key, value);
        return;
    }
    if (key === this.cacheKey) {
        this.cacheVal.push(value);
        return;
    }
    var cache = this.insert(dictionary, key, value);
    if (cache !== null) {
        this.cacheKey = key;
        this.cacheVal = cache;
    }
};

QueryStringParser.prototype.compact =
function QueryStringParser$compact(obj) {
    if (isArray(obj)) {
        var ret = [];
        var keys = Object.keys(obj);
        for( var i = 0, len = keys.length; i < len; ++i ) {
            ret.push(obj[keys[i]]);
        }
        return ret;
    }
    else if (typeof obj === "object") {
        var keys = Object.keys(obj);
        for( var i = 0, len = keys.length; i < len; ++i ) {
            var key = keys[i];
            obj[key] = this.compact(obj[key]);
        }
    }
    else {
        return obj;
    }
};

QueryStringParser.prototype.parseObject =
function QueryStringParser$parseObject(obj) {
    var keys = Object.keys(obj);
    var len = keys.length;
    if (len === 0) {
        return {};
    }
    len--;
    var ret = "";
    var key;
    for( var i = 0; i < len; ++i ) {
        key = keys[i];
        ret += key + "=" + obj[key] + "&";
    }
    key = keys[i];
    ret += key + "=" + obj[key];
    return this.parseString(ret, true);
};

QueryStringParser.prototype.parseString =
function QueryStringParser$parseString(str, noDecode) {
    var maxKeys = QueryStringParser.maxKeys;
    var keys = 0;
    var decodeKey = false;
    var decodeValue = false;
    var possiblyNested = false;
    var len = str.length;
    var i = 0;
    var dictionary = {};
    var keyStart = 0;
    var keyEnd = 0;
    var valueStart = 0;
    var valueEnd = 0;
    var left = 0;
    var lastIndex = len - 1;
    var containsPlus = false;


    for (; i < len; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 91) {
            left++;
        }
        else if (left > 0 && ch === 93) {
            possiblyNested = true;
            left--;
        }
        else if (left === 0 && ch === 61) {
            var j = i + 1;

            keyEnd = i - 1;
            valueEnd = valueStart = j;
            var key = str.slice(keyStart, keyEnd + 1);
            key = this.decode(key, decodeKey, containsPlus);
            decodeKey = false;

            for (; j < len; ++j) {
                ch = str.charCodeAt(j);
                if ((ch === 43 || ch === 37) && !noDecode) {
                    if (ch === 43) containsPlus = true;
                    decodeValue = true;
                }
                if (ch === 38 || j === lastIndex) {
                    valueEnd = j;
                    i = j;

                    if (ch === 38) {
                        valueEnd--;
                    }

                    var value = str.slice(valueStart, valueEnd + 1);
                    value = this.decode(value, decodeValue, containsPlus);

                    this.placeValue(dictionary, key, value, possiblyNested);

                    containsPlus = decodeValue = false;
                    possiblyNested = false;

                    keyStart = j + 1;
                    keys++;
                    if (keys > maxKeys) {
                        throw new RangeError("Amount of keys is too large " +
                            "(QueryStringParser.maxKeys=" + maxKeys + ")");
                    }
                    break;
                }
            }
        }
        else if ((ch === 43 || ch === 37) && !noDecode) {
            if (ch === 43) containsPlus = true;
            decodeKey = true;
        }
    }
    if (keyStart !== len) {
        var value = "";
        var key = str.slice(keyStart, len);
        key = this.decode(key, decodeKey, containsPlus);
        this.placeValue(dictionary, key, value, possiblyNested);
    }


    if (this.containsSparse) {
        this.compact(dictionary);
    }

    return dictionary;
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

module.exports = QueryStringSerializer;
var enc = encodeURIComponent;
var ARRAY = [];
var isArray = Array.isArray;
var getProto = Object.getPrototypeOf;
var oProto = getProto({});

function isObject(obj) {
    if (isArray(obj)) {
        return true;
    }
    if (obj === null || typeof obj !== "object") {
        return false;
    }
    var proto = getProto(obj);

    return proto === oProto || proto === null;
}

function QueryStringSerializer() {

}

QueryStringSerializer.prototype.serialize =
function QueryStringSerializer$serialize(obj) {
    if (obj === null ||
        typeof obj !== "object") {
        throw new TypeError("the obj to stringify must be an object");
    }
    var keys = Object.keys(obj);
    var len = keys.length;
    var array = ARRAY;
    var stack = [];
    var ret = [];
    var cur = obj;
    var keyPrefix = "";

    for (var i = 0; i < len; ++i) {
        var key = keys === array ? i : keys[i];
        var value = cur[key];
        if (isObject(value)) {
            stack.push(keyPrefix, cur, keys, len, i);

            if (keyPrefix === "") {
                keyPrefix = key;
            }
            else {
                keyPrefix = keyPrefix + "[" + enc(key) + "]";
            }

            if (isArray(value)) {
                keys = array;
                len = value.length;
            }
            else {
                keys = Object.keys(value);
                len = keys.length;
            }
            i = -1;
            cur = value;
        }
        else {
            if (typeof value !== "string") {
                value = "" + value;
            }

            var serializedKey = keyPrefix === ""
                                ? enc(key)
                                : keyPrefix + "[" + enc(key) + "]";
            ret.push(serializedKey + "=" + enc(value));
        }

        if(i === len - 1 && stack.length > 0) {
            i = stack.pop();
            len = stack.pop();
            keys = stack.pop();
            cur = stack.pop();
            keyPrefix = stack.pop();
        }
    }

    return ret.join("&");
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Noise3D.js

var _Noise3DTexture = __webpack_require__(30);

var _Noise3DTexture2 = _interopRequireDefault(_Noise3DTexture);

var _Config = __webpack_require__(1);

var _Config2 = _interopRequireDefault(_Config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Noise3D = function () {
	function Noise3D() {
		var mNum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8.0;
		var mNoiseScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;

		_classCallCheck(this, Noise3D);

		this._seed = Math.random() * 0xFF;
		this.speed = 0.03;

		var a = new _Noise3DTexture2.default(mNum, mNoiseScale);
		var b = new _Noise3DTexture2.default(mNum, mNoiseScale);

		a.render(this._seed);
		this._seed += this.speed * _Config2.default.fogMovingSpeed;
		b.render(this._seed);
		this._noises = [a, b];
	}

	_createClass(Noise3D, [{
		key: 'update',
		value: function update() {
			this.swap();
			this._seed += this.speed * _Config2.default.fogMovingSpeed;
			this.noise1.render(this._seed);
		}
	}, {
		key: 'swap',
		value: function swap() {
			this._noises = this._noises.reverse();
		}
	}, {
		key: 'noise0',
		get: function get() {
			return this._noises[0];
		}
	}, {
		key: 'noise1',
		get: function get() {
			return this._noises[1];
		}
	}, {
		key: 'texture0',
		get: function get() {
			return this._noises[0].getTexture();
		}
	}, {
		key: 'texture1',
		get: function get() {
			return this._noises[1].getTexture();
		}
	}]);

	return Noise3D;
}();

exports.default = Noise3D;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Noise3DTexture.js

var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _noise = __webpack_require__(31);

var _noise2 = _interopRequireDefault(_noise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Noise3DTexture = function () {
	function Noise3DTexture() {
		var mNum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8.0;
		var mNoiseScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
		var mSeed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Math.random() * 0xFF;

		_classCallCheck(this, Noise3DTexture);

		this._num = mNum;
		this.noiseScale = mNoiseScale;
		this._seed = mSeed;

		this._init();
	}

	_createClass(Noise3DTexture, [{
		key: '_init',
		value: function _init() {
			this.mesh = _alfrid.Geom.bigTriangle();
			this.shader = new _alfrid.GLShader(_alfrid2.default.ShaderLibs.bigTriangleVert, _noise2.default);

			this._noiseSize = this._num * this._num;
			var fboSize = Math.pow(this._num, 3);

			this._fboNoise = new _alfrid2.default.FrameBuffer(fboSize, fboSize, {
				minFilter: _alfrid.GL.LINEAR,
				magFilter: _alfrid.GL.LINEAR,
				wrapS: _alfrid.GL.MIRRORED_REPEAT,
				wrapT: _alfrid.GL.MIRRORED_REPEAT
			});
		}
	}, {
		key: 'render',
		value: function render(mSeed) {
			this._seed += 0.003;
			this._fboNoise.bind();
			_alfrid.GL.clear(0, 0, 0, 0);
			var size = this._noiseSize;
			var index = void 0;
			for (var i = 0; i < this._num; i++) {
				for (var j = 0; j < this._num; j++) {
					_alfrid.GL.viewport(i * size, j * size, size, size);
					index = (i + j * this._num) / this._noiseSize;

					this.shader.bind();
					this.shader.uniform("uNoiseScale", "float", this.noiseScale);
					this.shader.uniform("uZ", "float", index);
					this.shader.uniform("uSeed", "float", mSeed || this._seed);
					_alfrid.GL.draw(this.mesh);
				}
			}

			this._fboNoise.unbind();
		}
	}, {
		key: 'getTexture',
		value: function getTexture() {
			return this._fboNoise.getTexture();
		}
	}, {
		key: 'num',
		get: function get() {
			return this._num;
		}
	}]);

	return Noise3DTexture;
}();

exports.default = Noise3DTexture;

/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = "// noise.frag\n\n#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform float uZ;\nuniform float uSeed;\nuniform float uNoiseScale;\n\n\nvec3 mod289(vec3 x) {\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\t}\n\nvec4 mod289(vec4 x) {\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\t}\n\nvec4 permute(vec4 x) {\treturn mod289(((x*34.0)+1.0)*x);\t}\n\nvec4 taylorInvSqrt(vec4 r) {\treturn 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v) { \n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\tvec3 i  = floor(v + dot(v, C.yyy) );\n\tvec3 x0 =   v - i + dot(i, C.xxx) ;\n\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min( g.xyz, l.zxy );\n\tvec3 i2 = max( g.xyz, l.zxy );\n\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\ti = mod289(i); \n\tvec4 p = permute( permute( permute( \n\t\t\t\t\t\t i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t\t\t\t\t + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n\t\t\t\t\t + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3  ns = n_ * D.wyz - D.xzx;\n\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\n\tvec4 b0 = vec4( x.xy, y.xy );\n\tvec4 b1 = vec4( x.zw, y.zw );\n\n\tvec4 s0 = floor(b0)*2.0 + 1.0;\n\tvec4 s1 = floor(b1)*2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n\tvec3 p0 = vec3(a0.xy,h.x);\n\tvec3 p1 = vec3(a0.zw,h.y);\n\tvec3 p2 = vec3(a1.xy,h.z);\n\tvec3 p3 = vec3(a1.zw,h.w);\n\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 snoiseVec3( vec3 x ){\n\n\tfloat s  = snoise(vec3( x ));\n\tfloat s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n\tfloat s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n\tvec3 c = vec3( s , s1 , s2 );\n\treturn c;\n}\n\nvec3 curlNoise( vec3 p ){\n\t\n\tconst float e = .1;\n\tvec3 dx = vec3( e   , 0.0 , 0.0 );\n\tvec3 dy = vec3( 0.0 , e   , 0.0 );\n\tvec3 dz = vec3( 0.0 , 0.0 , e   );\n\n\tvec3 p_x0 = snoiseVec3( p - dx );\n\tvec3 p_x1 = snoiseVec3( p + dx );\n\tvec3 p_y0 = snoiseVec3( p - dy );\n\tvec3 p_y1 = snoiseVec3( p + dy );\n\tvec3 p_z0 = snoiseVec3( p - dz );\n\tvec3 p_z1 = snoiseVec3( p + dz );\n\n\tfloat x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n\tfloat y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n\tfloat z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n\tconst float divisor = 1.0 / ( 2.0 * e );\n\treturn normalize( vec3( x , y , z ) * divisor );\n}\n\nvoid main(void) {\n\tvec3 offset = curlNoise(vec3(vTextureCoord, uSeed) ) * .5 + .5;\n\toffset      = mix(offset, vec3(1.0), .5);\n\toffset      += 0.5;\n\tvec3 noise  = curlNoise(vec3(vTextureCoord, uZ ) * uNoiseScale * offset);\n\tnoise       = noise * .5 + .5;\n\n\n\tgl_FragColor = vec4(noise, 1.0);\n}"

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.generateTrees = undefined;

var _Config = __webpack_require__(1);

var _Config2 = _interopRequireDefault(_Config);

var _Assets = __webpack_require__(3);

var _Assets2 = _interopRequireDefault(_Assets);

var _ = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var random = function random(min, max) {
	return min + Math.random() * (max - min);
}; // generateTrees.js

var checkBox = function checkBox(box, a, r) {
	var margin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

	var x = Math.cos(a) * r;
	var z = Math.sin(a) * r;
	var left = box.left,
	    right = box.right,
	    front = box.front,
	    back = box.back;


	var hit = false;

	if (x > left - margin && x < right + margin && z < front + margin && z > back - margin) {
		hit = true;
	}

	return hit;
};

var margins = {
	deer: 0.8,
	laputa: 0.8,
	whale: 0.1,
	bear: 0.8,
	bull: 0.8
};

var generateTrees = function generateTrees() {
	var mesh = _Assets2.default.get(_Config2.default.animal);
	var box = (0, _.getBoundingBox)(mesh, _Config2.default.animal);
	var positions = [];
	var r = _Config2.default.floorRadius * 1.05;
	var i = _Config2.default.numTrees;

	var margin = margins[_Config2.default.animal] || 0.1;

	while (i--) {
		var rr = 0;
		var a = 0;
		var count = 0;
		do {
			rr = Math.sqrt(Math.random()) * r;
			a = Math.random() * Math.PI * 2.0;
		} while (checkBox(box, a, rr, margin) && count++ < 100);

		positions.push([Math.cos(a) * rr, 0, Math.sin(a) * rr]);
	}

	return positions;
};

exports.generateTrees = generateTrees;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.generateHeightMap = undefined;

var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _Config = __webpack_require__(1);

var _Config2 = _interopRequireDefault(_Config);

var _FboPingPong = __webpack_require__(34);

var _FboPingPong2 = _interopRequireDefault(_FboPingPong);

var _Assets = __webpack_require__(3);

var _Assets2 = _interopRequireDefault(_Assets);

var _treeHeight = __webpack_require__(35);

var _treeHeight2 = _interopRequireDefault(_treeHeight);

var _hill = __webpack_require__(36);

var _hill2 = _interopRequireDefault(_hill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// generateHeightMap.js

var random = function random(min, max) {
	return min + Math.random() * (max - min);
};
var fbo = void 0,
    shader = void 0,
    shaderHill = void 0,
    mesh = void 0;

var generateHeightMap = function generateHeightMap(trees) {
	var size = 1024;
	if (!fbo) {
		fbo = new _FboPingPong2.default(size, size, { minFilter: GL.LINEAR_MIPMAP_NEAREST });
		shader = new _alfrid2.default.GLShader(_alfrid2.default.ShaderLibs.bigTriangleVert, _treeHeight2.default);
		shaderHill = new _alfrid2.default.GLShader(_alfrid2.default.ShaderLibs.bigTriangleVert, _hill2.default);
		mesh = _alfrid2.default.Geom.bigTriangle();
	}

	var floorSize = _Config2.default.floorRadius;

	fbo.read.bind();
	GL.clear(0, 0, 0, 1);
	fbo.read.unbind();

	//	generate height
	fbo.write.bind();
	GL.clear(0, 0, 0, 1);
	shaderHill.bind();
	shaderHill.uniform("uSeed", "float", Math.random() * 0xFF);
	shaderHill.uniform("uNoiseScale", "float", random(2, 5));
	GL.draw(mesh);
	fbo.write.unbind();

	fbo.swap();

	var i = trees.length;
	while (i--) {
		var pos = trees[i];
		var u = pos[0] / floorSize * .5 + .5;
		var v = 1.0 - (pos[2] / floorSize * .5 + .5);

		fbo.write.bind();
		GL.clear(0, 0, 0, 0);
		shader.bind();
		shader.uniform("texture", "uniform1i", 0);
		fbo.readTexture.bind(0);
		shader.uniform("uPos", "vec2", [u, v]);
		shader.uniform("uHeight", "float", Math.random());
		shader.uniform("uRange", "float", random(0.05, 0.1));
		shader.uniform("uPower", "float", random(2, 3));
		shader.uniform("uBumpHeight", "float", _Config2.default.treeBumpHeight);
		GL.draw(mesh);
		fbo.write.unbind();

		fbo.swap();
	}

	return fbo.readTexture;
};

exports.generateHeightMap = generateHeightMap;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // FboPingPong.js


var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FboPingPong = function () {
	function FboPingPong(width, height, settings) {
		_classCallCheck(this, FboPingPong);

		var a = new _alfrid2.default.FrameBuffer(width, height, settings);
		var b = new _alfrid2.default.FrameBuffer(width, height, settings);
		this._fbos = [a, b];
	}

	_createClass(FboPingPong, [{
		key: 'swap',
		value: function swap() {
			this._fbos.reverse();
		}
	}, {
		key: 'read',
		get: function get() {
			return this._fbos[0];
		}
	}, {
		key: 'write',
		get: function get() {
			return this._fbos[1];
		}
	}, {
		key: 'readTexture',
		get: function get() {
			return this._fbos[0].getTexture();
		}
	}, {
		key: 'writeTexture',
		get: function get() {
			return this._fbos[1].getTexture();
		}
	}]);

	return FboPingPong;
}();

exports.default = FboPingPong;

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = "// copy.frag\n\n#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform float uHeight;\nuniform float uRange;\nuniform float uPower;\nuniform float uBumpHeight;\nuniform vec2 uPos;\n\nvoid main(void) {\n\tfloat d = distance(uPos, vTextureCoord);\n\td = smoothstep(uRange, 0.0, d);\n\td = pow(d, uPower);\n    gl_FragColor = texture2D(texture, vTextureCoord);\n    gl_FragColor.rgb += vec3(d * mix(uHeight, 1.0, 0.5) * uBumpHeight);\n}"

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = "// copy.frag\n\n#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform float uSeed;\nuniform float uNoiseScale;\n\nvec4 permute(vec4 x) {  return mod(((x*34.0)+1.0)*x, 289.0);    }\nvec4 taylorInvSqrt(vec4 r) {    return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v){\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    \n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 = v - i + dot(i, C.xxx) ;\n    \n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n    \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n    \n    i = mod(i, 289.0 );\n    vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    \n    float n_ = 1.0/7.0;\n    vec3  ns = n_ * D.wyz - D.xzx;\n    \n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);\n    \n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );\n    \n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    \n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n    \n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    \n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    \n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n    \n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    \n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat snoise(float x, float y, float z){\n    return snoise(vec3(x, y, z));\n}\n\n\n#define PI 3.141592653\n\n\nvoid main(void) {\n\tfloat d = distance(vTextureCoord, vec2(.5));\n\td = smoothstep(0.5, 0.0, d);\n\td = sin(d * PI * 0.5);\n\n\tfloat noise = snoise(vec3(vTextureCoord * uNoiseScale, uSeed)) * .5 + .5;\n\n\td = mix(0.0, noise, d);\n\n    gl_FragColor = vec4(vec3(d), 1.0);\n}"

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
// getBoundingBox.js

var caches = {};

var getBoundingBox = function getBoundingBox(mesh, id) {
	if (caches[id]) {
		return caches[id];
	}

	var min = Math.min,
	    max = Math.max;

	var right = -999;
	var left = 999;
	var front = -999;
	var back = 999;

	var vertices = mesh.vertices;


	vertices.forEach(function (v) {
		left = min(v[0], left);
		right = max(v[0], right);

		front = max(v[2], front);
		back = min(v[2], back);
	});

	caches[id] = { left: left, right: right, front: front, back: back };

	return caches[id];
};

exports.getBoundingBox = getBoundingBox;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
// saveJson.js

var saveJson = function saveJson(obj) {
	var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'data';

	var str = JSON.stringify(obj, null, 4);
	var data = encode(str);

	var blob = new Blob([data], {
		type: 'application/octet-stream'
	});

	var url = URL.createObjectURL(blob);
	var link = document.createElement('a');
	link.setAttribute('href', url);
	link.setAttribute('download', name + '.json');
	var event = document.createEvent('MouseEvents');
	event.initMouseEvent('click', true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
	link.dispatchEvent(event);
};

var encode = function encode(s) {
	var out = [];
	for (var i = 0; i < s.length; i++) {
		out[i] = s.charCodeAt(i);
	}
	return new Uint8Array(out);
};

exports.saveJson = saveJson;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _Assets = __webpack_require__(3);

var _Assets2 = _interopRequireDefault(_Assets);

var _Config = __webpack_require__(1);

var _Config2 = _interopRequireDefault(_Config);

var _floor = __webpack_require__(40);

var _floor2 = _interopRequireDefault(_floor);

var _depth = __webpack_require__(9);

var _depth2 = _interopRequireDefault(_depth);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // ViewFloor.js

var ViewFloor = function (_alfrid$View) {
	_inherits(ViewFloor, _alfrid$View);

	function ViewFloor() {
		_classCallCheck(this, ViewFloor);

		return _possibleConstructorReturn(this, (ViewFloor.__proto__ || Object.getPrototypeOf(ViewFloor)).call(this, _floor2.default, _depth2.default));
	}

	_createClass(ViewFloor, [{
		key: '_init',
		value: function _init() {
			var floorRadius = _Config2.default.floorRadius;

			this.mesh = _alfrid2.default.Geom.plane(floorRadius * 2, floorRadius * 2, 100, 'xz');
		}
	}, {
		key: 'render',
		value: function render(texture) {
			this.shader.bind();
			this.shader.uniform("texture", "uniform1i", 0);
			texture.bind(0);
			this.shader.uniform("uFloorHeight", "float", _Config2.default.maxFloorHeight);
			_alfrid.GL.draw(this.mesh);
		}
	}]);

	return ViewFloor;
}(_alfrid2.default.View);

exports.default = ViewFloor;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float uFloorHeight;\n\nuniform sampler2D texture;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\nvarying vec4 vScreenPosition;\n\nvoid main(void) {\n\tvec3 pos        = aVertexPosition;\n\tfloat h         = texture2D(texture, aTextureCoord).r;\n\tpos.y           = h * uFloorHeight;\n\tvScreenPosition = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(pos, 1.0);\n\tgl_Position     = vScreenPosition;\n\tvTextureCoord   = aTextureCoord;\n\tvNormal         = aNormal;\n}"

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _Assets = __webpack_require__(3);

var _Assets2 = _interopRequireDefault(_Assets);

var _Config = __webpack_require__(1);

var _Config2 = _interopRequireDefault(_Config);

var _trees = __webpack_require__(42);

var _trees2 = _interopRequireDefault(_trees);

var _depth = __webpack_require__(9);

var _depth2 = _interopRequireDefault(_depth);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // ViewTrees.js

var ViewTrees = function (_alfrid$View) {
	_inherits(ViewTrees, _alfrid$View);

	function ViewTrees() {
		_classCallCheck(this, ViewTrees);

		return _possibleConstructorReturn(this, (ViewTrees.__proto__ || Object.getPrototypeOf(ViewTrees)).call(this, _trees2.default, _depth2.default));
	}

	_createClass(ViewTrees, [{
		key: '_init',
		value: function _init() {
			// this.mesh = Assets.get('pillar');
			this.mesh1 = _Assets2.default.get('tree1');
			this.mesh2 = _Assets2.default.get('tree2');

			this.mesh = [this.mesh1, this.mesh2];
		}
	}, {
		key: 'reset',
		value: function reset(trees) {

			var i = trees.length;
			var half = i / 2;

			var data1 = [];
			var data2 = [];

			while (i--) {
				var pos = trees[i];
				if (i < half) {
					data1.push([pos[0], pos[2], Math.random(), Math.random() * Math.PI * 2]);
				} else {
					data2.push([pos[0], pos[2], Math.random(), Math.random() * Math.PI * 2]);
				}
			}

			this.mesh1.bufferInstance(data1, 'aPosOffset');
			this.mesh2.bufferInstance(data2, 'aPosOffset');
		}
	}, {
		key: 'render',
		value: function render(mCamPos) {
			this.shader.bind();
			this.shader.uniform("uTreeScale", "float", _Config2.default.treeScale);
			this.shader.uniform("uCamPos", "vec3", mCamPos);
			_alfrid.GL.draw(this.mesh);
		}
	}]);

	return ViewTrees;
}(_alfrid2.default.View);

exports.default = ViewTrees;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\nattribute vec4 aPosOffset;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float uTreeScale;\nuniform vec3 uCamPos;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\nvarying vec4 vScreenPosition;\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid main(void) {\n\tfloat d = distance(uCamPos.xz, aPosOffset.xy);\n\tfloat t = smoothstep(1.0, 2.5, d);\n\tt = mix(1.0, t, .5);\n\n\t\n\tvec3 pos        = aVertexPosition;\n\tfloat scale     = mix(aPosOffset.z, 1.0, .3);\n\tpos.xz          = rotate(pos.xz, aPosOffset.w);\n\tpos.xz \t\t\t*= t;\n\tpos.y           *= 3.0;\n\tpos.y           -= 3.0;\n\tpos             *= scale * uTreeScale;\n\n\tpos.xz          += aPosOffset.xy;\n\n\n\n\t\n\tvScreenPosition = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(pos, 1.0);\n\tgl_Position     = vScreenPosition;\n\tvTextureCoord   = aTextureCoord;\n\tvNormal         = aNormal;\n}"

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _Config = __webpack_require__(1);

var _Config2 = _interopRequireDefault(_Config);

var _bg = __webpack_require__(44);

var _bg2 = _interopRequireDefault(_bg);

var _bg3 = __webpack_require__(45);

var _bg4 = _interopRequireDefault(_bg3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // ViewBg.js

var ViewBg = function (_alfrid$View) {
	_inherits(ViewBg, _alfrid$View);

	function ViewBg() {
		_classCallCheck(this, ViewBg);

		return _possibleConstructorReturn(this, (ViewBg.__proto__ || Object.getPrototypeOf(ViewBg)).call(this, _bg2.default, _bg4.default));
	}

	_createClass(ViewBg, [{
		key: '_init',
		value: function _init() {
			// const radius = Config.floorRadius * Math.sqrt(2);
			var radius = _Config2.default.floorRadius * 2.5;
			this.mesh = _alfrid2.default.Geom.sphere(radius, 12, true);
		}
	}, {
		key: 'render',
		value: function render() {
			this.shader.bind();
			_alfrid.GL.draw(this.mesh);
		}
	}]);

	return ViewBg;
}(_alfrid2.default.View);

exports.default = ViewBg;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tgl_Position   = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);\n\tvTextureCoord = aTextureCoord;\n\tvNormal       = uNormalMatrix * aNormal;\n}"

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = "// copy.frag\n\n#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec3 vNormal;\n// uniform sampler2D texture;\n\nfloat diffuse(vec3 N, vec3 L) {\n\treturn max(dot(N, normalize(L)), 0.0);\n}\n\n\nvec3 diffuse(vec3 N, vec3 L, vec3 C) {\n\treturn diffuse(N, L) * C;\n}\n\n\n#define FRONT vec3(0.0, 0.0, -1.0)\n\nvoid main(void) {\n\tfloat d = diffuse(vNormal, FRONT);\n    gl_FragColor = vec4(vec3(d), 1.0);\n}"

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _Config = __webpack_require__(1);

var _Config2 = _interopRequireDefault(_Config);

var _ground = __webpack_require__(47);

var _ground2 = _interopRequireDefault(_ground);

var _ground3 = __webpack_require__(48);

var _ground4 = _interopRequireDefault(_ground3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // ViewGround.js

var ViewGround = function (_alfrid$View) {
	_inherits(ViewGround, _alfrid$View);

	function ViewGround() {
		_classCallCheck(this, ViewGround);

		return _possibleConstructorReturn(this, (ViewGround.__proto__ || Object.getPrototypeOf(ViewGround)).call(this, _ground2.default, _ground4.default));
	}

	_createClass(ViewGround, [{
		key: '_init',
		value: function _init() {
			var r = _Config2.default.floorRadius * 4;
			this.mesh = _alfrid2.default.Geom.plane(r, r, 1, 'xz');
		}
	}, {
		key: 'render',
		value: function render() {
			this.shader.bind();
			_alfrid.GL.draw(this.mesh);
		}
	}]);

	return ViewGround;
}(_alfrid2.default.View);

exports.default = ViewGround;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\nvarying vec4 vScreenPosition;\n\nvoid main(void) {\n\tvec3 pos        = aVertexPosition;\n\tpos.y           -= 0.01;\n\tvScreenPosition = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(pos, 1.0);\n\tgl_Position     = vScreenPosition;\n\tvTextureCoord   = aTextureCoord;\n\tvNormal         = aNormal;\n}"

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = "// copy.frag\n\n#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\n\nvarying vec4 vScreenPosition;\n\nvoid main(void) {\n\n\tfloat d = distance(vTextureCoord, vec2(.5));\n\td = smoothstep(0.5, 0.35, d);\n\n    float z = vScreenPosition.z / vScreenPosition.w;\n    gl_FragColor = vec4(vec3(z * 0.25), d);\n}"

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\nattribute vec3 aPosOffset;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat4 uLocalMatrix;\nuniform mat3 uModelViewMatrixInverse;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\nvoid main(void) {\n\t// vec3 position = uModelViewMatrixInverse * (uModelMatrix * uLocalMatrix * vec4(aVertexPosition, 1.0)).xyz;\n\tvec3 position = (uModelMatrix * vec4(aVertexPosition + aPosOffset, 1.0)).xyz;\n\tposition \t  = uModelViewMatrixInverse * position;\n\tgl_Position   = uProjectionMatrix * uViewMatrix * vec4(position, 1.0);\n\tvTextureCoord = aTextureCoord;\n\tvNormal       = aNormal;\n\n\tvPosition \t  = position;\n}"

/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nvarying vec3 vPosition;\nuniform sampler2D texture0;\nuniform sampler2D texture1;\nuniform float uPercent;\nuniform float uNum;\nuniform float uNumSlices;\nuniform float uOffset;\nuniform float uSize;\n\n\nvec2 getUVOffset(float index) {\n\tfloat x = mod(index, uNum);\n\tfloat y = floor(index/uNum);\n\treturn vec2(x, y) / uNum;\n}\n\nvec3 texture3D(vec3 pos, sampler2D texture) {\n\tvec3 posAdj = (pos * .25 + .5);\n\t\n\tfloat tz    = posAdj.z;\n\tfloat num   = uNum * uNum;\n\t\n\tfloat i0    = floor(tz * num);\n\tfloat i1    = ceil(tz * num);\n\tvec2 uv0    = posAdj.xy / uNum + getUVOffset(i0);\n\tvec2 uv1    = posAdj.xy / uNum + getUVOffset(i1);\n\tvec3 color0 = texture2D(texture, uv0).xyz;\n\tvec3 color1 = texture2D(texture, uv1).xyz;\n\tfloat p     = mod(tz * num - i0, 1.0);\n\tvec3 color  = mix(color0, color1, p);\n\t\n\tcolor       /= uNumSlices;\n\treturn color;\n}\n\n\nvec3 power(vec3 v, float p) {\n\treturn vec3(\n\t\t\tpow(v.x, p),\n\t\t\tpow(v.y, p),\n\t\t\tpow(v.z, p)\n\t\t);\n}\n\n\nvoid main(void) {\n\tfloat scale = 2.0;\n\tvec3 pos = vPosition / uSize;\n\n\tvec3 color0 = texture3D(pos, texture0);\n\tvec3 color1 = texture3D(pos, texture1);\n\n\tvec3 color = mix(color0, color1, uPercent);\n\n\tfloat a = smoothstep(-0.5, -0.2, vPosition.y);\n    // gl_FragColor = vec4( pow(color.r, 1.0 + uOffset) * 2.0);\n    gl_FragColor = vec4( power(color.rrr, 1.0 + uOffset) * 2.0, 1.0 );\n    // gl_FragColor = vec4( power(color.rrr, 1.0 + uOffset) * 2.0 * a, 1.0 );\n\n    // gl_FragColor = vec4(color.rgb, 1.0);\n}"

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // ViewFogs.js

var _ViewFog = __webpack_require__(10);

var _ViewFog2 = _interopRequireDefault(_ViewFog);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ViewFogs = function () {
	function ViewFogs() {
		_classCallCheck(this, ViewFogs);

		this._views = [new _ViewFog2.default(), new _ViewFog2.default()];
	}

	_createClass(ViewFogs, [{
		key: 'reset',
		value: function reset(mNumSlides) {
			console.log('reset');
			this.nextView.reset(mNumSlides);
		}
	}, {
		key: 'swap',
		value: function swap() {
			this._views = this._views.reverse();
		}
	}, {
		key: 'render',
		value: function render(texture0, texture1, percent) {
			this.currentView.render(texture0, texture1, percent);
		}
	}, {
		key: 'currentView',
		get: function get() {
			return this._views[0];
		}
	}, {
		key: 'nextView',
		get: function get() {
			return this._views[1];
		}
	}]);

	return ViewFogs;
}();

exports.default = ViewFogs;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _Assets = __webpack_require__(3);

var _Assets2 = _interopRequireDefault(_Assets);

var _Config = __webpack_require__(1);

var _Config2 = _interopRequireDefault(_Config);

var _fxaa = __webpack_require__(53);

var _fxaa2 = _interopRequireDefault(_fxaa);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // ViewFXAA.js

var ViewFXAA = function (_alfrid$View) {
	_inherits(ViewFXAA, _alfrid$View);

	function ViewFXAA() {
		_classCallCheck(this, ViewFXAA);

		return _possibleConstructorReturn(this, (ViewFXAA.__proto__ || Object.getPrototypeOf(ViewFXAA)).call(this, _alfrid2.default.ShaderLibs.bigTriangleVert, _fxaa2.default));
	}

	_createClass(ViewFXAA, [{
		key: '_init',
		value: function _init() {
			this.mesh = _alfrid2.default.Geom.bigTriangle();
			this.textureNoise = _Assets2.default.get('noise');
			this.textureNoise.wrapS = this.textureNoise.wrapT = _alfrid.GL.REPEAT;
			this.textureNoise.minFilter = this.textureNoise.magFilter = _alfrid.GL.NEAREST;

			this.textureMap = _Assets2.default.get('gradientMap');
			this.textureMap.minFilter = this.textureMap.magFilter = _alfrid.GL.NEAREST;
		}
	}, {
		key: 'render',
		value: function render(texture, textureBloom) {
			this.shader.bind();
			this.shader.uniform("texture", "uniform1i", 0);
			texture.bind(0);
			this.shader.uniform("textureNoise", "uniform1i", 1);
			this.textureNoise.bind(1);
			this.shader.uniform("textureBloom", "uniform1i", 2);
			textureBloom.bind(2);
			this.shader.uniform("textureMap", "uniform1i", 3);
			this.textureMap.bind(3);
			this.shader.uniform("uResolution", "vec2", [1 / _alfrid.GL.width, 1 / _alfrid.GL.height]);
			this.shader.uniform("uOverlay", "float", _Config2.default.overlayOpacity);
			this.shader.uniform("uBloomStrength", "float", _Config2.default.bloomStrength);
			this.shader.uniform("uGradientMap", "float", _Config2.default.gradientMap);
			_alfrid.GL.draw(this.mesh);
		}
	}]);

	return ViewFXAA;
}(_alfrid2.default.View);

exports.default = ViewFXAA;

/***/ }),
/* 53 */
/***/ (function(module, exports) {

module.exports = "// fxaa.frag\n\n#define SHADER_NAME FXAA\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform sampler2D textureNoise;\nuniform sampler2D textureBloom;\nuniform sampler2D textureMap;\nuniform vec2 uResolution;\nuniform float uBloomStrength;\nuniform float uOverlay;\nuniform float uGradientMap;\n\n\nfloat FXAA_SUBPIX_SHIFT = 1.0/4.0;\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#define FXAA_SPAN_MAX     8.0\n\n\nvec4 applyFXAA(sampler2D tex) {\n    vec4 color;\n    vec2 fragCoord = gl_FragCoord.xy;\n    vec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * uResolution).xyz;\n    vec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * uResolution).xyz;\n    vec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * uResolution).xyz;\n    vec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * uResolution).xyz;\n    vec3 rgbM  = texture2D(tex, fragCoord  * uResolution).xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * uResolution;\n\n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * uResolution + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * uResolution + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * uResolution + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * uResolution + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, 1.0);\n    else\n        color = vec4(rgbB, 1.0);\n    return color;\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n    return mix(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, step(base, vec3(0.5)));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\tvec3 blended = mix(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, step(base, vec3(0.5)));\n\treturn mix(base, blended, opacity);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\n\nvoid main(void) {\n    float t = abs(vTextureCoord.x - .5);\n    t = smoothstep(0.3, 0.0, t);\n\n\tvec4 color = applyFXAA(texture);\n    vec3 bloom = texture2D(textureBloom, vTextureCoord).rgb;\n    color.rgb += bloom.rgb * uBloomStrength * t;\n\n    float l = luma(color.rgb);\n    vec2 uvGradient = vec2(l, .5);\n    vec3 colorGraded = texture2D(textureMap, uvGradient).rgb;    \n    color.rgb = mix(color.rgb, colorGraded, uGradientMap);\n\n\tvec2 uv = vTextureCoord * 5.0;\n\tvec3 noise = texture2D(textureNoise, uv).rgb;\n\tcolor.rgb = blendOverlay(color.rgb, noise, uOverlay);\n\n    \n    \n\n\tgl_FragColor = color;\n}"

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _Config = __webpack_require__(1);

var _Config2 = _interopRequireDefault(_Config);

var _Assets = __webpack_require__(3);

var _Assets2 = _interopRequireDefault(_Assets);

var _animal = __webpack_require__(55);

var _animal2 = _interopRequireDefault(_animal);

var _animal3 = __webpack_require__(56);

var _animal4 = _interopRequireDefault(_animal3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // ViewAnimal.js

var ViewAnimal = function (_alfrid$View) {
	_inherits(ViewAnimal, _alfrid$View);

	function ViewAnimal() {
		_classCallCheck(this, ViewAnimal);

		return _possibleConstructorReturn(this, (ViewAnimal.__proto__ || Object.getPrototypeOf(ViewAnimal)).call(this, _animal2.default, _animal4.default));
	}

	_createClass(ViewAnimal, [{
		key: '_init',
		value: function _init() {
			this.mesh = _Assets2.default.get(_Config2.default.animal);
		}
	}, {
		key: 'setAnimal',
		value: function setAnimal(mId) {
			this.mesh = _Assets2.default.get(mId);
		}
	}, {
		key: 'render',
		value: function render() {
			_alfrid.GL.disable(_alfrid.GL.CULL_FACE);
			this.shader.bind();
			_alfrid.GL.draw(this.mesh);
			_alfrid.GL.enable(_alfrid.GL.CULL_FACE);
		}
	}]);

	return ViewAnimal;
}(_alfrid2.default.View);

exports.default = ViewAnimal;

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\nvarying vec4 vScreenPosition;\n\nvoid main(void) {\n\tvec3 pos        = aVertexPosition;\n\tpos.y           += 0.2;\n\tvScreenPosition = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(pos, 1.0);\n\tgl_Position     = vScreenPosition;\n\tvTextureCoord   = aTextureCoord;\n\tvNormal         = uNormalMatrix * aNormal;\n}"

/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\nvarying vec3 vNormal;\nvarying vec4 vScreenPosition;\nvarying vec2 vTextureCoord;\n\n\n#define LIGHT vec3(0.0, 0.0, 1.0)\n\nfloat diffuse(vec3 N, vec3 L) {\n\treturn max(dot(N, normalize(L)), 0.0);\n}\n\n\nvec3 diffuse(vec3 N, vec3 L, vec3 C) {\n\treturn diffuse(N, L) * C;\n}\n\nvoid main(void) {\n\tfloat z = vScreenPosition.z / vScreenPosition.w;\n    gl_FragColor = vec4(vec3(z * 0.25), 1.0);\n\n\n    float d = diffuse(vNormal, LIGHT);\n    gl_FragColor.rgb += pow(1.0 - d, 2.0) * .1;\n}"

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _Config = __webpack_require__(1);

var _Config2 = _interopRequireDefault(_Config);

var _squares = __webpack_require__(58);

var _squares2 = _interopRequireDefault(_squares);

var _squares3 = __webpack_require__(59);

var _squares4 = _interopRequireDefault(_squares3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // ViewSquares.js

var random = function random(min, max) {
	return min + Math.random() * (max - min);
};

var ViewSquares = function (_alfrid$View) {
	_inherits(ViewSquares, _alfrid$View);

	function ViewSquares() {
		_classCallCheck(this, ViewSquares);

		return _possibleConstructorReturn(this, (ViewSquares.__proto__ || Object.getPrototypeOf(ViewSquares)).call(this, _squares2.default, _squares4.default));
	}

	_createClass(ViewSquares, [{
		key: '_init',
		value: function _init() {
			var size = .15;
			this.mesh = _alfrid2.default.Geom.plane(size, size, 1);
			this.offset = new _alfrid2.default.TweenNumber(0, 'linear', 0.005);

			this.viewInvert = mat4.create();
			this.projInvert = mat4.create();
			this.reset();
		}
	}, {
		key: 'setMatrices',
		value: function setMatrices(camera) {
			mat4.invert(this.projInvert, camera.projection);
			mat4.invert(this.viewInvert, camera.matrix);
		}
	}, {
		key: 'reset',
		value: function reset() {
			var i = 20000;
			var positions = [];
			var extras = [];
			var r = 3.5;

			while (i--) {
				positions.push([random(-r, r), random(-r / 2, r), random(-r, r)]);
				extras.push([Math.random(), Math.random(), Math.random()]);
			}

			this.mesh.bufferInstance(positions, 'aPosOffset');
			this.mesh.bufferInstance(extras, 'aExtra');
		}
	}, {
		key: 'open',
		value: function open() {
			this.offset.speed = 0.01;
			this.offset.value = 1;
		}
	}, {
		key: 'close',
		value: function close() {
			this.offset.speed = 0.005;
			this.offset.value = 0;
		}
	}, {
		key: 'render',
		value: function render(mMatrix, mTexture) {
			this.shader.bind();
			this.shader.uniform("texture", "uniform1i", 0);
			mTexture.bind(0);
			this.shader.uniform("uMatrix", "mat4", mMatrix);
			this.shader.uniform("uOffset", "float", this.offset.value);
			this.shader.uniform("uMixing", "float", _Config2.default.pixelateMixing);
			_alfrid.GL.draw(this.mesh);
		}
	}]);

	return ViewSquares;
}(_alfrid2.default.View);

exports.default = ViewSquares;

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\nattribute vec3 aPosOffset;\nattribute vec3 aExtra;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat4 uMatrix;\nuniform mat4 uViewInvert;\nuniform mat4 uProjInvert;\nuniform float uOffset;\n\nuniform sampler2D textureDepth;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\nvarying vec2 vUV;\nvarying vec2 vUVCenter;\nvarying vec4 vScreenPosition;\nvarying vec3 vExtra;\nvarying vec3 vDebug;\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat circularIn(float t) {\n  return 1.0 - sqrt(1.0 - t * t);\n}\n\n\n\nfloat circularOut(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\nfloat circularInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat cubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\n\nfloat getSurfacePosition(mat4 shadowMatrix, vec3 position, mat4 invertProj, mat4 invertView, sampler2D textureDepth) {\n    \n    //  get the shadow coord\n\tvec4 vShadowCoord = shadowMatrix * uModelMatrix * vec4(position, 1.0);\n\tvec4 shadowCoord  = vShadowCoord / vShadowCoord.w;\n\tvec2 uv           = shadowCoord.xy;\n\n    //  reconstruct world position from depth buffer\n\tfloat depth             = texture2D(textureDepth, uv).r;\n\tfloat z                 = depth * 2.0 - 1.0;\n\tvec4 clipSpacePosition  = vec4(uv * 2.0 - 1.0, z, 1.0);\n\tvec4 viewSpacePosition  = invertProj * clipSpacePosition;\n\tviewSpacePosition       /= viewSpacePosition.w;\n\tvec4 worldSpacePosition = invertView * viewSpacePosition;\n    return worldSpacePosition.z * 0.5;\n}\n\n\nvoid main(void) {\n\tfloat scale     = -aExtra.z + uOffset * 2.0;\n\tscale           = smoothstep(0.0, 1.0, scale);\n\tscale           = circularInOut(scale);\n\t\n\tvec3 pos        = aVertexPosition;\n\tpos             *= mix(aExtra.x, 1.0, .5) * scale; \n\tpos             += aPosOffset;\n\t\n\tvScreenPosition = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(pos, 1.0);\n\tgl_Position     = vScreenPosition;\n\tvTextureCoord   = aTextureCoord;\n\tvNormal         = aNormal;\n\t\n\tvec4 coord      = uMatrix * uModelMatrix * vec4(pos, 1.0);\n\tvUV             = coord.xy / coord.w;\n\tcoord           = uMatrix * uModelMatrix * vec4(aPosOffset, 1.0);\n\tvUVCenter       = coord.xy / coord.w;\n\t\n\tvExtra          = aExtra;\n}"

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = "// copy.frag\n\n#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nvarying vec2 vUV;\nvarying vec2 vUVCenter;\nvarying vec3 vExtra;\nvarying vec3 vDebug;\nvarying vec4 vScreenPosition;\n\nuniform sampler2D texture;\nuniform sampler2D textureDepth;\nuniform float uMixing;\n\nvoid main(void) {\n    vec4 color0 = texture2D(texture, vUV);\n    vec4 color1 = texture2D(texture, vUVCenter);\n\n    gl_FragColor = mix(color0, color1, (0.5 + vExtra.y * .5) * uMixing );\n\n    float z = vScreenPosition.z / vScreenPosition.w;\n    gl_FragColor.rgb *= (1.0 - z * 0.25);\n}"

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // ViewCover.js

var ViewCover = function (_alfrid$View) {
	_inherits(ViewCover, _alfrid$View);

	function ViewCover() {
		_classCallCheck(this, ViewCover);

		return _possibleConstructorReturn(this, (ViewCover.__proto__ || Object.getPrototypeOf(ViewCover)).call(this, _alfrid2.default.ShaderLibs.bigTriangleVert, _alfrid2.default.ShaderLibs.simpleColorFrag));
	}

	_createClass(ViewCover, [{
		key: "_init",
		value: function _init() {
			this.mesh = _alfrid2.default.Geom.bigTriangle();
			this.opacity = new _alfrid2.default.EaseNumber(0, 0.02);
		}
	}, {
		key: "open",
		value: function open() {
			this.opacity.value = 1;
		}
	}, {
		key: "close",
		value: function close() {
			this.opacity.value = 0;
		}
	}, {
		key: "render",
		value: function render() {
			if (this.opacity.value <= 0.001) {
				return;
			}
			this.shader.bind();
			this.shader.uniform("color", "vec3", [0, 0, 0]);
			this.shader.uniform("opacity", "float", this.opacity.value);
			_alfrid.GL.draw(this.mesh);
		}
	}]);

	return ViewCover;
}(_alfrid2.default.View);

exports.default = ViewCover;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _Assets = __webpack_require__(3);

var _Assets2 = _interopRequireDefault(_Assets);

var _Config = __webpack_require__(1);

var _Config2 = _interopRequireDefault(_Config);

var _snow = __webpack_require__(62);

var _snow2 = _interopRequireDefault(_snow);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // ViewSnow.js

var random = function random(min, max) {
	return min + Math.random() * (max - min);
};

var ViewSnow = function (_alfrid$View) {
	_inherits(ViewSnow, _alfrid$View);

	function ViewSnow() {
		_classCallCheck(this, ViewSnow);

		return _possibleConstructorReturn(this, (ViewSnow.__proto__ || Object.getPrototypeOf(ViewSnow)).call(this, _snow2.default, _alfrid2.default.ShaderLibs.simpleColorFrag));
	}

	_createClass(ViewSnow, [{
		key: '_init',
		value: function _init() {
			this.mesh = _Assets2.default.get('rock');

			var num = 500;
			var positions = [];
			var extra = [];
			var r = _Config2.default.floorRadius;

			while (num--) {
				positions.push([random(-r, r), random(0, r), random(-r, r)]);
				extra.push([Math.random(), Math.random(), Math.random()]);
			}

			this.mesh.bufferInstance(positions, 'aPosOffset');
			this.mesh.bufferInstance(extra, 'aExtra');

			this.shader.bind();
			this.shader.uniform("color", "vec3", [1, 1, 1]);
			this.shader.uniform("opacity", "float", 1);
		}
	}, {
		key: 'render',
		value: function render() {
			this.shader.bind();
			this.shader.uniform("uTime", "float", _alfrid2.default.Scheduler.deltaTime);
			this.shader.uniform("uRadius", "float", _Config2.default.floorRadius);
			this.shader.uniform("uSpeed", "float", _Config2.default.snowSpeed);
			_alfrid.GL.draw(this.mesh);
		}
	}]);

	return ViewSnow;
}(_alfrid2.default.View);

exports.default = ViewSnow;

/***/ }),
/* 62 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\nattribute vec3 aExtra;\nattribute vec3 aPosOffset;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float uTime;\nuniform float uRadius;\nuniform float uSpeed;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\nvoid main(void) {\n\tvec3 scale     = mix(aExtra, vec3(1.0), .75);\n\tvec3 axis      = normalize(aExtra);\n\tfloat angle    = aExtra.y + mix(aExtra.z, 1.0, .5) * uTime;\n\tvec3 pos       = rotate(aVertexPosition, axis, angle);\n\tpos            = pos * scale * .0006;\n\t\n\tvec3 dir       = vec3(aExtra.x, aExtra.y * .5 + .5, aExtra.z);\n\tdir.y          *= -1.0;\n\tvec3 posOffset = aPosOffset + dir * uTime * 0.1 * uSpeed;\n\tposOffset.y    = mod(posOffset.y, uRadius);\n\tposOffset.x    = mod(posOffset.x + uRadius, uRadius * 2.0) - uRadius;\n\tposOffset.z    = mod(posOffset.z + uRadius, uRadius * 2.0) - uRadius;\n\tpos            += posOffset;\n\t\n\tgl_Position    = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(pos, 1.0);\n\tvTextureCoord  = aTextureCoord;\n\tvNormal        = aNormal;\n}"

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // PassBloom.js

var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _threshold = __webpack_require__(64);

var _threshold2 = _interopRequireDefault(_threshold);

var _bloom = __webpack_require__(65);

var _bloom2 = _interopRequireDefault(_bloom);

var _bloomCompose = __webpack_require__(66);

var _bloomCompose2 = _interopRequireDefault(_bloomCompose);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PassBloom = function () {
	function PassBloom() {
		var mNumMips = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;
		var mStartingScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;

		_classCallCheck(this, PassBloom);

		this._numMips = Math.min(mNumMips, 5);
		this._startingScale = mStartingScale;
		this._initTextures();
		this._initViews();
	}

	_createClass(PassBloom, [{
		key: '_initTextures',
		value: function _initTextures() {
			var width = Math.round(_alfrid.GL.width * this._startingScale);
			var height = Math.round(_alfrid.GL.height * this._startingScale);

			this._fbos = [];
			for (var i = 0; i < this._numMips; i++) {
				var fboV = new _alfrid2.default.FrameBuffer(width, height);
				var fboH = new _alfrid2.default.FrameBuffer(width, height);
				this._fbos.push({ fboV: fboV, fboH: fboH });

				width = Math.round(width / 2);
				height = Math.round(height / 2);
			}

			// const scale = 0.5;
			// this._fboThreshold = new alfrid.FrameBuffer(GL.width * scale, GL.height * scale);
			// this._fboCompose = new alfrid.FrameBuffer(GL.width * scale, GL.height * scale);

			// const oSettings = {
			// 	minFilter:GL.NEAREST_MIPMAP_LINEAR,
			// 	magFilter:GL.NEAREST_MIPMAP_LINEAR,
			// }

			var oSettings = {
				minFilter: _alfrid.GL.LINEAR,
				magFilter: _alfrid.GL.LINEAR
			};

			window.GL = _alfrid.GL;

			var s = 512;
			this._fboThreshold = new _alfrid2.default.FrameBuffer(s, s, oSettings);
			this._fboCompose = new _alfrid2.default.FrameBuffer(s, s, oSettings);
		}
	}, {
		key: '_initViews',
		value: function _initViews() {
			//	mesh
			this.mesh = _alfrid2.default.Geom.bigTriangle();

			var vsTri = _alfrid2.default.ShaderLibs.bigTriangleVert;

			// 	shaders - threshold
			this.shaderThreshold = new _alfrid2.default.GLShader(vsTri, _threshold2.default);
			this.uniformsThreshold = {
				luminosityThreshold: 0.5,
				smoothWidth: 0.01,
				defaultOpacity: 0,
				defaultColor: [0, 0, 0]
			};

			this.shaderThreshold.bind();
			this.shaderThreshold.uniform("texture", "uniform1i", 0);
			this.shaderThreshold.uniform(this.uniformsThreshold);

			//	shaders - mip bloom
			var kernelSizeArray = [3, 5, 7, 9, 11];
			var width = Math.round(_alfrid.GL.width * this._startingScale);
			var height = Math.round(_alfrid.GL.height * this._startingScale);

			this._shadersBloom = [];
			for (var i = 0; i < this._numMips; i++) {
				var kernelSize = kernelSizeArray[i];
				var _fs = _bloom2.default.replace(/\${kernelRadius}/g, kernelSize);
				var shader = new _alfrid2.default.GLShader(vsTri, _fs);
				shader.bind();
				shader.uniform("texSize", "vec2", [width, height]);
				this._shadersBloom.push(shader);

				width = Math.round(width / 2);
				height = Math.round(height / 2);
			}

			//	shader - compose

			this.uniformsCompose = {
				bloomStrength: 1.,
				bloomRadius: 0.4
			};

			var fs = _bloomCompose2.default.replace(/\${NUM_MIPS}/g, this._numMips);

			var strBloom = '';
			for (var _i = 0; _i < this._numMips; _i++) {
				strBloom += '\tcolor += lerpBloomFactor(bloomTintColors[' + _i + '].a) * vec4(bloomTintColors[' + _i + '].rgb, 1.0) * texture2D(blurTexture' + (_i + 1) + ', vTextureCoord);';
			}

			fs = fs.replace(/\${BLOOMS}/g, strBloom);

			var tintColor = [];
			this.shaderCompose = new _alfrid2.default.GLShader(vsTri, fs);
			this.shaderCompose.bind();
			for (var _i2 = 0; _i2 < this._numMips; _i2++) {
				this.shaderCompose.uniform('blurTexture' + (_i2 + 1), "uniform1i", _i2);
				tintColor = tintColor.concat([1, 1, 1, 1.0 - 0.2 * _i2]);
			}

			this.shaderCompose.uniform('bloomTintColors', 'vec4', tintColor);
			this.shaderCompose.uniform(this.uniformsCompose);
		}
	}, {
		key: 'render',
		value: function render(texture) {
			this._fboThreshold.bind();
			_alfrid.GL.clear(0, 0, 0, 0);
			this.shaderThreshold.bind();

			this.shaderThreshold.uniform(this.uniformsThreshold);
			texture.bind(0);
			_alfrid.GL.draw(this.mesh);
			this._fboThreshold.unbind();

			var inputTexture = this._fboThreshold.getTexture();

			for (var i = 0; i < this._numMips; i++) {
				var _fbos$i = this._fbos[i],
				    fboV = _fbos$i.fboV,
				    fboH = _fbos$i.fboH;

				var shader = this._shadersBloom[i];

				shader.bind();
				shader.uniform("texture", "uniform1i", 0);

				//	bloom V
				fboV.bind();
				_alfrid.GL.clear(0, 0, 0, 0);
				shader.uniform("direction", "vec2", [0, 1]);
				inputTexture.bind(0);
				_alfrid.GL.draw(this.mesh);
				fboV.unbind();

				//	bloom H
				fboH.bind();
				_alfrid.GL.clear(0, 0, 0, 0);
				shader.uniform("direction", "vec2", [1, 0]);
				fboV.getTexture().bind(0);
				_alfrid.GL.draw(this.mesh);
				fboH.unbind();

				inputTexture = fboH.getTexture();
			}

			this._fboCompose.bind();
			_alfrid.GL.clear(0, 0, 0, 0);
			this.shaderCompose.bind();
			for (var _i3 = 0; _i3 < this._numMips; _i3++) {
				var _fboH = this._fbos[_i3].fboH;

				_fboH.getTexture().bind(_i3);
			}
			this.shaderCompose.uniform(this.uniformsCompose);
			_alfrid.GL.draw(this.mesh);
			this._fboCompose.unbind();
		}
	}, {
		key: 'getTexture',
		value: function getTexture() {
			return this._fboCompose.getTexture();
		}
	}, {
		key: 'resize',
		value: function resize() {}
	}, {
		key: 'fbos',
		get: function get() {
			return this._fbos;
		}
	}]);

	return PassBloom;
}();

exports.default = PassBloom;

/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = "// copy.frag\n\n#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec3 defaultColor;\nuniform float defaultOpacity;\nuniform float luminosityThreshold;\nuniform float smoothWidth;\n\n\nvoid main(void) {\n\n\tvec4 texel       = texture2D( texture, vTextureCoord );\n\t\n\tvec3 luma        = vec3( 0.299, 0.587, 0.114 );\n\tfloat v          = dot( texel.xyz, luma );\n\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\tfloat alpha      = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\tgl_FragColor = mix( outputColor, texel, alpha );\n}"

/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = "// bloom.frag\n\n\nprecision highp float;\n#define GLSLIFY 1\n\n#define KERNEL_RADIUS ${kernelRadius}\n#define SIGMA ${kernelRadius}\n\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 texSize;\nuniform vec2 direction;\n\nfloat gaussianPdf(in float x, in float sigma) {\n\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n}\n\nvoid main() {\n\tvec2 invSize = 1.0 / texSize;\n\tfloat fSigma = float(SIGMA);\n\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\tvec3 diffuseSum = texture2D( texture, vTextureCoord).rgb * weightSum;\n\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\tfloat x = float(i);\n\t\tfloat w = gaussianPdf(x, fSigma);\n\t\tvec2 uvOffset = direction * invSize * x;\n\t\tvec3 sample1 = texture2D( texture, vTextureCoord + uvOffset).rgb;\n\t\tvec3 sample2 = texture2D( texture, vTextureCoord - uvOffset).rgb;\n\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\tweightSum += 2.0 * w;\n\t}\n\n\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t// gl_FragColor = texture2D(texture, vTextureCoord);\n}"

/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = "// copy.frag\n\n#define SHADER_NAME SIMPLE_TEXTURE\n\n#define NUM_MIPS ${NUM_MIPS}\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D blurTexture1;\nuniform sampler2D blurTexture2;\nuniform sampler2D blurTexture3;\nuniform sampler2D blurTexture4;\nuniform sampler2D blurTexture5;\n\nuniform float bloomStrength;\nuniform float bloomRadius;\nuniform vec4 bloomTintColors[NUM_MIPS];\n\nfloat lerpBloomFactor(const in float factor) { \n\tfloat mirrorFactor = 1.2 - factor;\n\treturn mix(factor, mirrorFactor, bloomRadius);\n}\n\nvec4 getBloom() {\n\tvec4 color = vec4(0.0);\n\t${BLOOMS}\n\treturn color;\n}\n\nvoid main() {\n\tgl_FragColor = bloomStrength * getBloom();\n}"

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // SoundManager.js


var _sono = __webpack_require__(68);

var _sono2 = _interopRequireDefault(_sono);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SoundManager = function () {
	function SoundManager() {
		var _this = this;

		_classCallCheck(this, SoundManager);

		this._hasStarted = false;
		this._isPlaying = false;

		this._btn = document.body.querySelector('.audio-toggle');
		this._btn.addEventListener('click', function () {
			return _this.toggle();
		});
	}

	_createClass(SoundManager, [{
		key: 'fadeOut',
		value: function fadeOut() {}
	}, {
		key: 'faseIn',
		value: function faseIn() {}
	}, {
		key: 'toggle',
		value: function toggle() {
			console.log('Toggle music');

			if (!this._hasStarted) {
				this._sound = _sono2.default.createSound({
					src: './assets/audio/music.mp3',
					loop: true,
					volume: 0.25
				});
				this._hasStarted = true;
			}

			if (this._isPlaying) {
				this._sound.pause();
			} else {
				this._sound.play();
			}

			if (this._btn.classList.contains('isSoundOn')) {
				this._btn.classList.remove('isSoundOn');
			}
			this._btn.class;

			this._isPlaying = !this._isPlaying;
			if (this._isPlaying) {
				this._btn.classList.add('isSoundOn');
			}
		}
	}]);

	return SoundManager;
}();

exports.default = new SoundManager();

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

!function (e, n) {
  "object" == ( false ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? module.exports = n() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (n),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : e.sono = n();
}(undefined, function () {
  "use strict";
  function e(e) {
    if ("string" != typeof e) return "";if ("data:" === e.slice(0, 5)) {
      var n = e.match(/data:audio\/(ogg|mp3|opus|wav|m4a)/i);if (n && n.length > 1) return n[1].toLowerCase();
    }e = e.split("?")[0], e = e.slice(e.lastIndexOf("/") + 1);var t = e.split(".");return 1 === t.length || "" === t[0] && 2 === t.length ? "" : t.pop().toLowerCase();
  }function n(n) {
    var t = void 0;if (Array.isArray(n)) for (var r = 0; r < n.length; r++) {
      t = n[r];var o = e(t);if (ne.indexOf(o) > -1) break;
    } else "object" === ("undefined" == typeof n ? "undefined" : J(n)) && Object.keys(n).some(function (r) {
      t = n[r];var o = e(t);return ne.indexOf(o) > -1;
    });return t || n;
  }function t(e) {
    return !!(e && window.AudioBuffer && e instanceof window.AudioBuffer);
  }function r(e) {
    return !!(e && window.ArrayBuffer && e instanceof window.ArrayBuffer);
  }function o(e) {
    return !!(e && window.HTMLMediaElement && e instanceof window.HTMLMediaElement);
  }function i(e) {
    return !!(e && "function" == typeof e.getAudioTracks && e.getAudioTracks().length && window.MediaStreamTrack && e.getAudioTracks()[0] instanceof window.MediaStreamTrack);
  }function u(e) {
    return !(!e || "string" != typeof e || "sine" !== e && "square" !== e && "sawtooth" !== e && "triangle" !== e);
  }function a(e) {
    return !!(e && "object" === ("undefined" == typeof e ? "undefined" : J(e)) && e.bufferSize && e.channels && e.callback);
  }function c(e) {
    return !(!e || "string" != typeof e || !(e.indexOf(".") > -1 || "data:" === e.slice(0, 5)));
  }function s(e) {
    if (!e || o(e)) return !1;var n = e.src || e.url || e.data || e;return c(n) || r(n) || Array.isArray(n) && c(n[0]);
  }function f(e, n) {
    function t(e) {
      var n = 12 * (Math.log(e / 440) / Math.log(2));return Math.round(n) + 69;
    }function r(e) {
      return 440 * Math.pow(2, (e - 69) / 12);
    }function o(e, n) {
      return Math.floor(1200 * Math.log(e / r(n)) / Math.log(2));
    }function i(e, n) {
      return !e || a.fftSize !== c || !!(n && e instanceof Uint8Array) || !n && e instanceof Float32Array;
    }function u(e, n) {
      return e ? new Float32Array(n) : new Uint8Array(n);
    }n = n || {};var a = e.createAnalyser(),
        c = n.fftSize || 512,
        s = !!n.float,
        f = !!n.float,
        l = void 0,
        d = void 0;a.fftSize = c, a.smoothingTimeConstant = n.smoothing || n.smoothingTimeConstant || a.smoothingTimeConstant, a.minDecibels = n.minDecibels || a.minDecibels, a.maxDecibels = n.maxDecibels || a.maxDecibels;var v = new Blob(["onmessage=function(e){var data=e.data;var f=new Float32Array(data.b);for(var i=0;i<f.length;i++){data.sum+=f[i]}data.sum/=f.length;postMessage(Math.max(1.0-(data.sum/data.numSamples*-1.0),0))};"]),
        p = new Blob(["onmessage=function(e){var data=e.data;var sampleRate=data.sampleRate;var buf=new Float32Array(data.b);var SIZE=buf.length;var MAX_SAMPLES=Math.floor(SIZE/2);var best_offset=-1;var best_correlation=0;var rms=0;var foundGoodCorrelation=false;var correlations=new Array(MAX_SAMPLES);for(var i=0;i<SIZE;i++){var val=buf[i];rms+=val*val}rms=Math.sqrt(rms/SIZE);if (rms<0.01){postMessage(-1)}else{var lastCorrelation=1;for(var offset=0;offset<MAX_SAMPLES;offset++){var correlation=0;for(var i=0;i<MAX_SAMPLES;i++){correlation+=Math.abs((buf[i])-(buf[i+offset]))}correlation=1-(correlation/MAX_SAMPLES);correlations[offset]=correlation;if ((correlation>0.9)&&(correlation>lastCorrelation)){foundGoodCorrelation=true;if (correlation>best_correlation){best_correlation=correlation;best_offset=offset}}else if (foundGoodCorrelation){var shift=(correlations[best_offset+1]-correlations[best_offset-1])/correlations[best_offset];postMessage(sampleRate/(best_offset+(8*shift)))}lastCorrelation=correlation}if (best_correlation>0.01){postMessage(sampleRate/best_offset)}else{postMessage(-1)}}};"]),
        g = URL.createObjectURL(v),
        h = new Worker(g),
        m = URL.createObjectURL(p),
        y = new Worker(m),
        b = null,
        w = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"],
        T = null,
        M = { hertz: null, note: null, noteIndex: null, detuneCents: null, detune: null };return h.onmessage = function (e) {
      b && b(e.data);
    }, y.onmessage = function (e) {
      if (T) {
        var n = e.data;if (n !== -1) {
          var r = t(n),
              i = o(n, r);M.hertz = n, M.noteIndex = r % 12, M.note = w[r % 12], M.detuneCents = i, 0 === i ? M.detune = "" : i < 0 ? M.detune = "flat" : M.detune = "sharp";
        }T(M);
      }
    }, a.getWaveform = function (e) {
      return arguments.length || (e = f), i(l, e) && (c = a.fftSize, f = e, l = u(e, c)), e && this.getFloatTimeDomainData ? this.getFloatTimeDomainData(l) : this.getByteTimeDomainData(l), l;
    }, a.getPitch = function (n) {
      T = T || n;var t = new Float32Array(a.fftSize);t.set(a.getWaveform(!0)), y.postMessage({ sampleRate: e.sampleRate, b: t.buffer }, [t.buffer]);
    }, a.getFrequencies = function (e) {
      return arguments.length || (e = s), i(d, e) && (c = a.fftSize, s = e, d = u(e, a.frequencyBinCount)), e ? this.getFloatFrequencyData(d) : this.getByteFrequencyData(d), d;
    }, a.getAmplitude = function (e) {
      b = b || e;var n = new Float32Array(a.fftSize);n.set(a.getFrequencies(!0)), h.postMessage({ sum: 0, length: n.byteLength, numSamples: a.fftSize / 2, b: n.buffer }, [n.buffer]);
    }, a.update = function () {
      a.getWaveform(), a.getFrequencies();
    }, Object.defineProperties(a, { smoothing: { get: function get() {
          return a.smoothingTimeConstant;
        }, set: function set(e) {
          a.smoothingTimeConstant = e;
        } } }), a;
  }function l(e, n) {
    return arguments.length < 2 && (n = 0), "number" != typeof e || isNaN(e) ? n : e;
  }function d(e, n) {
    n = l(n, 1);var t = e.createWaveShaper(),
        r = new Float32Array(ue);return t.update = function (e) {
      if (n = e, n <= 0) return n = 0, void (this.curve = null);for (var t = 100 * e, o = Math.PI / 180, i = void 0, u = 0; u < ue; u++) {
        i = 2 * u / ue - 1, r[u] = (3 + t) * i * 20 * o / (Math.PI + t * Math.abs(i));
      }this.curve = r;
    }, Object.defineProperties(t, { amount: { get: function get() {
          return n;
        }, set: function set(e) {
          this.update(e);
        } } }), "undefined" != typeof n && t.update(n), t;
  }function v(e, n) {
    n = n || {};var t = e.createGain(),
        r = e.createDelay(),
        o = e.createGain(),
        i = e.createGain();r.delayTime.value = l(n.delayTime, .5), o.gain.value = l(n.feedback, .5), t.connect(r), t.connect(i), r.connect(o), o.connect(r), o.connect(i);var u = t;return u.name = "Echo", u._output = i, Object.defineProperties(u, { delay: { get: function get() {
          return r.delayTime.value;
        }, set: function set(e) {
          r.delayTime.value = e;
        } }, feedback: { get: function get() {
          return o.gain.value;
        }, set: function set(e) {
          o.gain.value = e;
        } } }), u;
  }function p() {
    function e() {}function n() {
      return { value: 1, defaultValue: 1, linearRampToValueAtTime: e, setValueAtTime: e, exponentialRampToValueAtTime: e, setTargetAtTime: e, setValueCurveAtTime: e, cancelScheduledValues: e };
    }function t() {
      return { connect: e, disconnect: e, frequencyBinCount: 0, smoothingTimeConstant: 0, fftSize: 0, minDecibels: 0, maxDecibels: 0, getByteTimeDomainData: e, getByteFrequencyData: e, getFloatTimeDomainData: e, getFloatFrequencyData: e, gain: n(), panningModel: 0, setPosition: e, setOrientation: e, setVelocity: e, distanceModel: 0, refDistance: 0, maxDistance: 0, rolloffFactor: 0, coneInnerAngle: 360, coneOuterAngle: 360, coneOuterGain: 0, type: 0, frequency: n(), Q: n(), detune: n(), delayTime: n(), buffer: 0, threshold: n(), knee: n(), ratio: n(), attack: n(), release: n(), reduction: n(), oversample: 0, curve: 0, sampleRate: 1, length: 0, duration: 0, numberOfChannels: 0, getChannelData: function getChannelData() {
          return [];
        }, copyFromChannel: e, copyToChannel: e, dopplerFactor: 0, speedOfSound: 0, start: e };
    }var r = Date.now();return window.Uint8Array || (window.Uint8Array = window.Float32Array = Array), { createAnalyser: t, createBuffer: t, createBiquadFilter: t, createChannelMerger: t, createChannelSplitter: t, createDynamicsCompressor: t, createConvolver: t, createDelay: t, createGain: t, createOscillator: t, createPanner: t, createScriptProcessor: t, createWaveShaper: t, listener: t(), get currentTime() {
        return (Date.now() - r) / 1e3;
      } };
  }function g(e) {
    function n(e) {
      var n = Math.log(o / r) / Math.LN2,
          t = Math.pow(2, n * (e - 1));return o * t;
    }var t = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],
        r = 40,
        o = e.sampleRate / 2,
        i = e.createBiquadFilter();return i.type = t.type, i.set = function (e, n, t) {
      return "undefined" != typeof e && "number" == typeof e && (i.frequency.value = e), "undefined" != typeof n && "number" == typeof n && (i.Q.value = n), "undefined" != typeof t && "number" == typeof t && (i.gain.value = t), i;
    }, i.setByPercent = function (e, t, r) {
      return i.set(n(e), t, r);
    }, i.set(t.frequency, t.q, t.gain);
  }function h(e, n) {
    var t = e.createGain(),
        r = e.createDelay(),
        o = e.createGain(),
        i = e.createOscillator(),
        u = e.createGain(),
        a = e.createGain();r.delayTime.value = l(n.delay, .005), o.gain.value = l(n.feedback, .5), i.type = "sine", i.frequency.value = l(n.frequency, .002), u.gain.value = l(n.gain, .25), t.connect(a), t.connect(r), r.connect(a), r.connect(o), o.connect(t), i.connect(u), u.connect(r.delayTime), i.start(0);var c = t;return c.name = "Flanger", c._output = a, Object.defineProperties(c, { delay: { get: function get() {
          return r.delayTime.value;
        }, set: function set(e) {
          r.delayTime.value = e;
        } }, lfoFrequency: { get: function get() {
          return i.frequency.value;
        }, set: function set(e) {
          i.frequency.value = e;
        } }, lfoGain: { get: function get() {
          return u.gain.value;
        }, set: function set(e) {
          u.gain.value = e;
        } }, feedback: { get: function get() {
          return o.gain.value;
        }, set: function set(e) {
          o.gain.value = e;
        } } }), c;
  }function m(e, n) {
    var t = e.createGain(),
        r = e.createChannelSplitter(2),
        o = e.createChannelMerger(2),
        i = e.createGain(),
        u = e.createGain(),
        a = e.createOscillator(),
        c = e.createGain(),
        s = e.createGain(),
        f = e.createDelay(),
        d = e.createDelay(),
        v = e.createGain();i.gain.value = u.gain.value = l(n.feedback, .5), f.delayTime.value = d.delayTime.value = l(n.delay, .003), a.type = "sine", a.frequency.value = l(n.frequency, .5), c.gain.value = l(n.gain, .005), s.gain.value = 0 - c.gain.value, t.connect(r), r.connect(f, 0), r.connect(d, 1), f.connect(i), d.connect(u), i.connect(d), u.connect(f), f.connect(o, 0, 0), d.connect(o, 0, 1), o.connect(v), t.connect(v), a.connect(c), a.connect(s), c.connect(f.delayTime), s.connect(d.delayTime), a.start(0);var p = t;return p.name = "StereoFlanger", p._output = v, Object.defineProperties(p, { delay: { get: function get() {
          return f.delayTime.value;
        }, set: function set(e) {
          f.delayTime.value = d.delayTime.value = e;
        } }, lfoFrequency: { get: function get() {
          return a.frequency.value;
        }, set: function set(e) {
          a.frequency.value = e;
        } }, lfoGain: { get: function get() {
          return c.gain.value;
        }, set: function set(e) {
          c.gain.value = s.gain.value = e;
        } }, feedback: { get: function get() {
          return i.gain.value;
        }, set: function set(e) {
          i.gain.value = u.gain.value = e;
        } } }), p;
  }function y(e, n) {
    return n = n || {}, n.stereo ? new m(e, n) : new h(e, n);
  }function b(e) {
    function n(e, n) {
      var t = e.x,
          r = e.y,
          o = e.z,
          i = n.x,
          u = n.y,
          a = n.z;e.x = r * a - o * u, e.y = o * i - t * a, e.z = t * u - r * i;
    }function t(e) {
      if (0 === e.x && 0 === e.y && 0 === e.z) return e;var n = Math.sqrt(e.x * e.x + e.y * e.y + e.z * e.z),
          t = 1 / n;return e.x *= t, e.y *= t, e.z *= t, e;
    }function r(e, r) {
      var o = u.get(r.x, r.y, r.z);n(o, a), n(o, r), t(o), t(r), e.setOrientation(r.x, r.y, r.z, o.x, o.y, o.z), u.dispose(r), u.dispose(o);
    }function o(e, n) {
      e.setPosition(n.x, n.y, n.z), u.dispose(n);
    }var i = e.createPanner();i.panningModel = b.defaults.panningModel, i.distanceModel = b.defaults.distanceModel, i.refDistance = b.defaults.refDistance, i.maxDistance = b.defaults.maxDistance, i.rolloffFactor = b.defaults.rolloffFactor, i.coneInnerAngle = b.defaults.coneInnerAngle, i.coneOuterAngle = b.defaults.coneOuterAngle, i.coneOuterGain = b.defaults.coneOuterGain, i.setPosition(0, 0, 1), i.setOrientation(0, 0, 0);var u = { pool: [], get: function get(e, n, t) {
        var r = this.pool.length ? this.pool.pop() : { x: 0, y: 0, z: 0 };return "undefined" != typeof e && isNaN(e) && "x" in e && "y" in e && "z" in e ? (r.x = l(e.x), r.y = l(e.y), r.z = l(e.z)) : (r.x = l(e), r.y = l(n), r.z = l(t)), r;
      }, dispose: function dispose(e) {
        this.pool.push(e);
      } },
        a = u.get(0, 1, 0),
        c = Math.PI / 4,
        s = Math.PI / 2;return i.set = function (e, n, t) {
      var r = u.get(e, n, t);1 === arguments.length && r.x && (e = r.x, e > 1 && (e = 1), e < -1 && (e = -1), e *= c, t = e + s, t > s && (t = Math.PI - t), r.x = Math.sin(e), r.z = Math.sin(t)), o(i, r);
    }, i.setSourcePosition = function (e, n, t) {
      o(i, u.get(e, n, t));
    }, i.setSourceOrientation = function (e, n, t) {
      r(i, u.get(e, n, t));
    }, i.setListenerPosition = function (n, t, r) {
      o(e.listener, u.get(n, t, r));
    }, i.setListenerOrientation = function (n, t, o) {
      r(e.listener, u.get(n, t, o));
    }, i.getDefaults = function () {
      return b.defaults;
    }, i.setDefaults = function (e) {
      Object.keys(e).forEach(function (n) {
        b.defaults[n] = e[n];
      });
    }, i;
  }function w(e) {
    var n = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],
        t = l(n.stages, 8),
        r = [],
        o = void 0,
        i = e.createGain(),
        u = e.createGain(),
        a = e.createOscillator(),
        c = e.createGain(),
        s = e.createGain();u.gain.value = l(n.feedback, .5), a.type = "sine", a.frequency.value = l(n.frequency, .5), c.gain.value = l(n.gain, 300);for (var f = 0; f < t; f++) {
      o = e.createBiquadFilter(), o.type = "allpass", o.frequency.value = 1e3 * f, f > 0 && r[f - 1].connect(o), c.connect(o.frequency), r.push(o);
    }var d = r[0],
        v = r[r.length - 1];i.connect(d), i.connect(s), v.connect(s), v.connect(u), u.connect(d), a.connect(c), a.start(0);var p = i;return p.name = "Phaser", p._output = s, Object.defineProperties(p, { lfoFrequency: { get: function get() {
          return a.frequency.value;
        }, set: function set(e) {
          a.frequency.value = e;
        } }, lfoGain: { get: function get() {
          return c.gain.value;
        }, set: function set(e) {
          c.gain.value = e;
        } }, feedback: { get: function get() {
          return u.gain.value;
        }, set: function set(e) {
          u.gain.value = e;
        } } }), p;
  }function T(e, n) {
    function t(e, n) {
      for (var t = new Float32Array(n), r = 0, o = 0; o < e.length; o++) {
        t.set(e[o], r), r += e[o].length;
      }return t;
    }function r() {
      if (!a.length) return e.createBuffer(2, u, e.sampleRate);var n = a.length * u,
          r = e.createBuffer(2, n, e.sampleRate);return r.getChannelData(0).set(t(a, n)), r.getChannelData(1).set(t(c, n)), r;
    }function o() {
      v && (v.onaudioprocess = null, l.disconnect(), v.disconnect());
    }function i() {
      o(), v = e.createScriptProcessor(u, 2, 2), l.connect(v), v.connect(e.destination), v.connect(d), v.onaudioprocess = function (e) {
        var t = e.inputBuffer.getChannelData(0),
            r = e.inputBuffer.getChannelData(1);if (n) {
          var o = e.outputBuffer.getChannelData(0),
              i = e.outputBuffer.getChannelData(1);o.set(t), i.set(r);
        }p.isRecording && (a.push(new Float32Array(t)), c.push(new Float32Array(r)));
      };
    }var u = 4096,
        a = [],
        c = [],
        s = 0,
        f = 0,
        l = e.createGain(),
        d = e.createGain(),
        v = void 0,
        p = l;return p.name = "Recorder", p._output = d, p.isRecording = !1, p.start = function () {
      i(), a.length = 0, c.length = 0, s = e.currentTime, f = 0, this.isRecording = !0;
    }, p.stop = function () {
      return f = e.currentTime, this.isRecording = !1, o(), r();
    }, p.getDuration = function () {
      return this.isRecording ? e.currentTime - s : f - s;
    }, p;
  }function M(e) {
    var n = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],
        t = e.sampleRate,
        r = l(n.time, 1),
        o = l(n.decay, 5),
        i = !!n.reverse,
        u = void 0,
        a = void 0,
        c = e.createGain(),
        s = e.createConvolver(),
        f = e.createGain();c.connect(s), c.connect(f), s.connect(f);var d = c;return d.name = "Reverb", d._output = f, d.update = function (n) {
      if ("undefined" != typeof n.time && (r = n.time, u = Math.floor(t * r), a = u ? e.createBuffer(2, u, t) : null), "undefined" != typeof n.decay && (o = n.decay), "undefined" != typeof n.reverse && (i = n.reverse), !a) return void (s.buffer = null);for (var c = a.getChannelData(0), f = a.getChannelData(1), l = void 0, d = void 0, v = 0; v < u; v++) {
        l = i ? u - v : v, d = Math.pow(1 - l / u, o), c[v] = (2 * Math.random() - 1) * d, f[v] = (2 * Math.random() - 1) * d;
      }s.buffer = a;
    }, d.update({ time: r, decay: o, reverse: i }), Object.defineProperties(d, { time: { get: function get() {
          return r;
        }, set: function set(e) {
          e !== r && this.update({ time: e });
        } }, decay: { get: function get() {
          return o;
        }, set: function set(e) {
          e !== o && this.update({ decay: e });
        } }, reverse: { get: function get() {
          return i;
        }, set: function set(e) {
          e !== i && this.update({ reverse: !!e });
        } } }), d;
  }function A(e) {
    function n(e, n) {
      var t = e._output || e;t.disconnect(), t.connect(n);
    }function t(e) {
      var t = X.length,
          r = t ? X[t - 1] : Z;r && n(r, e), H = e;
    }function r() {
      if (Z) {
        for (var e = void 0, r = void 0, o = 0; o < X.length; o++) {
          e = X[o], r = 0 === o ? Z : X[o - 1], n(r, e);
        }H && t(H);
      }
    }function o(e) {
      return !!e && X.indexOf(e) > -1;
    }function i(e) {
      return e ? o(e) ? e : (X.push(e), r(), e) : null;
    }function u(e) {
      if (!e) return null;if (!o(e)) return e;for (var n = X.length, t = 0; t < n; t++) {
        if (e === X[t]) {
          X.splice(t, 1);break;
        }
      }var i = e._output || e;return i.disconnect(), r(), e;
    }function a(e, n) {
      n = !!n;var t = o(e);return arguments.length > 1 && t === n ? W : (t ? u(e) : i(e), W);
    }function c() {
      for (; X.length;) {
        X.pop().disconnect();
      }return r(), W;
    }function s() {
      c(), e = null, H = null, X = [], Z && Z.disconnect(), Z = null;
    }function l(n) {
      return i(new f(e, n));
    }function h(n) {
      var t = e.createDynamicsCompressor();return t.update = function (e) {
        t.threshold.value = "undefined" != typeof e.threshold ? e.threshold : -24, t.knee.value = "undefined" != typeof e.knee ? e.knee : 30, t.ratio.value = "undefined" != typeof e.ratio ? e.ratio : 12, t.attack.value = "undefined" != typeof e.attack ? e.attack : 3e-4, t.release.value = "undefined" != typeof e.release ? e.release : .25;
      }, t.update(n || {}), i(t);
    }function m(n) {
      var t = e.createConvolver();return t.buffer = n, i(t);
    }function A(n) {
      var t = e.createDelay();return "undefined" != typeof n && (t.delayTime.value = n), i(t);
    }function O(n) {
      return i(new v(e, n));
    }function E(n) {
      return i(new d(e, n));
    }function S(n, t, r, o) {
      return i(new g(e, { type: n, frequency: t, q: r, gain: o }));
    }function x(e, n) {
      return S("lowpass", { frequency: e, q: n });
    }function L(e, n) {
      return S("highpass", { frequency: e, q: n });
    }function _(e, n) {
      return S("bandpass", { frequency: e, q: n });
    }function C(e, n) {
      return S("lowshelf", { frequency: e, q: 0, gain: n });
    }function k(e, n) {
      return S("highshelf", { frequency: e, q: 0, gain: n });
    }function D(e, n, t) {
      return S("peaking", { frequency: e, q: n, gain: t });
    }function P(e, n, t) {
      return S("notch", { frequency: e, q: n, gain: t });
    }function R(e, n) {
      return S("allpass", { frequency: e, q: n });
    }function q(n) {
      return i(new y(e, n));
    }function F(n) {
      var t = e.createGain();return "undefined" != typeof n && (t.gain.value = n), t;
    }function z() {
      return i(new b(e));
    }function j(n) {
      return i(new w(e, n));
    }function G(n) {
      return i(new T(e, n));
    }function B(n, t, r) {
      return i(new M(e, n, t, r));
    }function V() {
      var n = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0],
          t = n.bufferSize || 1024,
          r = "undefined" == typeof n.inputChannels ? 0 : n.inputChannels,
          o = "undefined" == typeof n.outputChannels ? 1 : n.outputChannels,
          u = e.createScriptProcessor(t, r, o),
          a = n.thisArg || n.context || u,
          c = n.callback || function () {};return u.onaudioprocess = c.bind(a), i(u);
    }function N(e) {
      return Z = e, r(), e;
    }function I(e) {
      return t(e), e;
    }e = e || new p();var U = new b(e),
        W = null,
        H = void 0,
        X = [],
        Z = void 0;return W = { context: e, nodeList: X, panning: U, has: o, add: i, remove: u, toggle: a, removeAll: c, destroy: s, setSource: N, setDestination: I, analyser: l, compressor: h, convolver: m, delay: A, echo: O, distortion: E, filter: S, lowpass: x, highpass: L, bandpass: _, lowshelf: C, highshelf: k, peaking: D, notch: P, allpass: R, flanger: q, gain: F, panner: z, phaser: j, recorder: G, reverb: B, script: V }, Object.freeze(W);
  }function O(e, n) {
    function t(e, n) {
      var t = void 0;return e || 0 === e ? (g.some(function (n) {
        return (n === e || n.id === e) && (t = n, !0);
      }), t && n ? n(t) : t) : t;
    }function r(e) {
      return t(e, function (e) {
        return g.splice(g.indexOf(e), 1);
      }), b;
    }function o(e) {
      return e.gain.disconnect(), e.gain.connect(m), g.push(e), e.once("destroy", r), b;
    }function i(e, n) {
      return g.forEach(function (t) {
        return t.play(e, n);
      }), b;
    }function u() {
      return g.forEach(function (e) {
        e.playing && e.pause();
      }), b;
    }function a() {
      return g.forEach(function (e) {
        e.paused && e.play();
      }), b;
    }function c() {
      return g.forEach(function (e) {
        return e.stop();
      }), b;
    }function s(e) {
      return g.forEach(function (n) {
        return n.seek(e);
      }), b;
    }function f() {
      return y = b.volume, b.volume = 0, b;
    }function l() {
      return b.volume = y || 1, b;
    }function d(e) {
      return b.volume = e, b;
    }function v(n, t) {
      if (e) {
        var r = m.gain,
            o = e.currentTime;r.cancelScheduledValues(o), r.setValueAtTime(r.value, o), r.linearRampToValueAtTime(n, o + t);
      } else g.forEach(function (e) {
        e.fade(n, t);
      });return b;
    }function p() {
      for (; g.length;) {
        g.pop().destroy();
      }
    }var g = [],
        h = new A(e),
        m = h.gain(),
        y = 1,
        b = null;return e && (h.setSource(m), h.setDestination(n || e.destination)), b = { add: o, find: t, remove: r, play: i, pause: u, resume: a, stop: c, seek: s, setVolume: d, mute: f, unMute: l, fade: v, destroy: p }, Object.defineProperties(b, { effect: { value: h }, gain: { value: m }, sounds: { value: g }, volume: { get: function get() {
          return m.gain.value;
        }, set: function set(n) {
          isNaN(n) || (e ? (m.gain.cancelScheduledValues(e.currentTime), m.gain.value = n, m.gain.setValueAtTime(n, e.currentTime)) : m.gain.value = n, g.forEach(function (e) {
            e.context || (e.groupVolume = n);
          }));
        } } }), b;
  }function E() {
    this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
  }function S(e) {
    return "function" == typeof e;
  }function x(e) {
    return "number" == typeof e;
  }function L(e) {
    return "object" == (typeof e === "undefined" ? "undefined" : _typeof(e)) && null !== e;
  }function _(e) {
    return void 0 === e;
  }function C(e) {
    function n() {
      g.off("error"), g.off("progress"), g.off("complete"), g.off("loaded"), T && "function" == typeof T.removeEventListener && (T.removeEventListener("canplaythrough", a), T.removeEventListener("error", o)), b && (b.removeEventListener("progress", r), b.removeEventListener("load", u), b.removeEventListener("error", o));
    }function t(e) {
      g.emit("progress", 1), g.emit("loaded", e), g.emit("complete", e), n();
    }function r(e) {
      e.lengthComputable && (h = e.loaded / e.total, g.emit("progress", h));
    }function o(t) {
      window.clearTimeout(w);var r = t;T && T.error && (r = "Media Error: " + p[T.error.code] + " " + e), b && (r = "XHR Error: " + b.status + " " + b.statusText + " " + e), g.emit("error", r), n();
    }function i(e) {
      m.decodeAudioData(e, function (e) {
        T = e, b = null, h = 1, t(e);
      }, o);
    }function u() {
      i(b.response);
    }function a() {
      window.clearTimeout(w), T && (h = 1, t(T));
    }function c() {
      n(), b && 4 !== b.readyState && b.abort(), b = null, window.clearTimeout(w);
    }function s() {
      c(), b = null, T = null, m = null;
    }function f() {
      return e instanceof window.ArrayBuffer ? void i(e) : (b = new XMLHttpRequest(), b.open("GET", e, !0), b.responseType = "arraybuffer", b.addEventListener("progress", r), b.addEventListener("load", u), b.addEventListener("error", o), void b.send());
    }function l() {
      T && T.tagName || (T = document.createElement("audio")), y || (window.clearTimeout(w), w = window.setTimeout(a, 2e3), T.addEventListener("canplaythrough", a, !1)), T.addEventListener("error", o, !1), T.preload = "auto", T.src = e, T.load(), y && t(T);
    }function d() {
      m ? f() : l();
    }function v(n) {
      e = n, d();
    }var p = ["", "ABORTED", "NETWORK", "DECODE", "SRC_NOT_SUPPORTED"],
        g = new se(),
        h = 0,
        m = void 0,
        y = void 0,
        b = void 0,
        w = void 0,
        T = void 0,
        M = { on: g.on.bind(g), once: g.once.bind(g), off: g.off.bind(g), load: v, start: d, cancel: c, destroy: s };return Object.defineProperties(M, { data: { get: function get() {
          return T;
        } }, progress: { get: function get() {
          return h;
        } }, audioContext: { set: function set(e) {
          m = e;
        } }, isTouchLocked: { set: function set(e) {
          y = e;
        } } }), Object.freeze(M);
  }function k(e, n, t) {
    function r() {
      return !m && n && (m = n.createBufferSource(), m.buffer = e), m;
    }function o() {
      if (m) {
        m.onended = null;try {
          m.disconnect(), m.stop(0);
        } catch (e) {}m = null;
      }v = !1, p = 0, h = !1, y = 0;
    }function i() {
      var e = n.currentTime - y;o(), p = e, h = !1, v = !0;
    }function u() {
      o(), f = !0, "function" == typeof l && l(s);
    }function a(e) {
      var t = arguments.length <= 1 || void 0 === arguments[1] ? 0 : arguments[1];if (!h) {
        for (e = e ? n.currentTime + e : 0, t && (p = 0), p && (t = p); t > s.duration;) {
          t %= s.duration;
        }r(), m.onended = u, m.start(e, t), m.loop = d, m.playbackRate.value = g, y = n.currentTime - t, f = !1, v = !1, p = 0, h = !0;
      }
    }function c() {
      o(), e = null, n = null, l = null, m = null;
    }var s = {},
        f = !1,
        l = t,
        d = !1,
        v = !1,
        p = 0,
        g = 1,
        h = !1,
        m = null,
        y = 0;return Object.defineProperties(s, { play: { value: a }, pause: { value: i }, stop: { value: o }, destroy: { value: c }, currentTime: { get: function get() {
          if (p) return p;if (y) {
            var e = n.currentTime - y;return e > s.duration && (e %= s.duration), e;
          }return 0;
        } }, duration: { get: function get() {
          return e ? e.duration : 0;
        } }, ended: { get: function get() {
          return f;
        } }, loop: { get: function get() {
          return d;
        }, set: function set(e) {
          d = !!e, m && (m.loop = d);
        } }, paused: { get: function get() {
          return v;
        } }, playbackRate: { get: function get() {
          return g;
        }, set: function set(e) {
          g = e, m && (m.playbackRate.value = g);
        } }, playing: { get: function get() {
          return h;
        } }, progress: { get: function get() {
          return s.duration ? s.currentTime / s.duration : 0;
        } }, sourceNode: { get: function get() {
          return r();
        } } }), Object.freeze(s);
  }function D(e, n, t) {
    function r() {
      return !T && n && (T = n.createMediaElementSource(e)), T;
    }function o(n) {
      e.src = n, e.load(), v = !1, y = !1, w = !1;
    }function i() {
      e.removeEventListener("canplaythrough", i), w && e.play();
    }function u() {
      return m ? (e.currentTime = 0, e.currentTime > 0 && e.load(), void e.play()) : (v = !0, y = !1, w = !1, void ("function" == typeof p && p(d)));
    }function a(n, t) {
      clearTimeout(g), e.volume = A * M, e.playbackRate = b, t && (e.currentTime = t), n ? g = setTimeout(a, n) : e.play(), v = !1, y = !1, w = !0, e.removeEventListener("ended", u), e.addEventListener("ended", u, !1), e.readyState < 1 && (e.removeEventListener("canplaythrough", i), e.addEventListener("canplaythrough", i, !1), e.load(), e.play());
    }function c() {
      clearTimeout(g), e && (e.pause(), w = !1, y = !0);
    }function s() {
      if (clearTimeout(g), e) {
        e.pause();try {
          e.currentTime = 0, e.currentTime > 0 && e.load();
        } catch (e) {}w = !1, y = !1;
      }
    }function f(e, t) {
      function r(e, n) {
        h = window.setTimeout(function () {
          return d.volume = d.volume + .2 * (e - d.volume), Math.abs(d.volume - e) > .05 ? void r(e, n) : void (d.volume = e);
        }, 1e3 * n);
      }return n ? d : (window.clearTimeout(h), r(e, t / 10), d);
    }function l() {
      e.removeEventListener("ended", u), e.removeEventListener("canplaythrough", i), s(), e = null, n = null, p = null, T = null;
    }var d = {},
        v = !1,
        p = t,
        g = void 0,
        h = void 0,
        m = !1,
        y = !1,
        b = 1,
        w = !1,
        T = null,
        M = 1,
        A = 1;return Object.defineProperties(d, { play: { value: a }, pause: { value: c }, stop: { value: s }, load: { value: o }, fade: { value: f }, destroy: { value: l }, currentTime: { get: function get() {
          return e ? e.currentTime : 0;
        } }, duration: { get: function get() {
          return e ? e.duration : 0;
        } }, ended: { get: function get() {
          return v;
        } }, loop: { get: function get() {
          return m;
        }, set: function set(e) {
          m = !!e;
        } }, paused: { get: function get() {
          return y;
        } }, playbackRate: { get: function get() {
          return b;
        }, set: function set(n) {
          b = n, e && (e.playbackRate = b);
        } }, playing: { get: function get() {
          return w;
        } }, progress: { get: function get() {
          return e && e.duration ? e.currentTime / e.duration : 0;
        } }, sourceNode: { get: function get() {
          return r();
        } }, volume: { get: function get() {
          return A;
        }, set: function set(n) {
          window.clearTimeout(h), A = n, e && (e.volume = A * M);
        } }, groupVolume: { get: function get() {
          return M;
        }, set: function set(n) {
          M = n, e && (e.volume = A * M);
        } } }), Object.freeze(d);
  }function P(e, n) {
    function t() {
      return !l && n && (l = n.createMediaStreamSource(e), navigator.mozGetUserMedia && (window.mozHack = l)), l;
    }function r(e) {
      e = e ? n.currentTime + e : 0, t(), l.start(e), d = n.currentTime - s, a = !1, f = !0, c = !1, s = 0;
    }function o() {
      if (l) {
        try {
          l.stop(0);
        } catch (e) {}l = null;
      }a = !0, c = !1, s = 0, f = !1, d = 0;
    }function i() {
      var e = n.currentTime - d;o(), s = e, f = !1, c = !0;
    }function u() {
      o(), n = null, l = null, e = null, window.mozHack = null;
    }var a = !1,
        c = !1,
        s = 0,
        f = !1,
        l = null,
        d = 0,
        v = { play: r, pause: i, stop: o, destroy: u, duration: 0, progress: 0 };return Object.defineProperties(v, { currentTime: { get: function get() {
          return s ? s : d ? n.currentTime - d : 0;
        } }, ended: { get: function get() {
          return a;
        } }, paused: { get: function get() {
          return c;
        } }, playing: { get: function get() {
          return f;
        } }, sourceNode: { get: function get() {
          return t();
        } } }), Object.freeze(v);
  }function R(e, n) {
    function t() {
      return !l && n && (l = n.createOscillator(), l.type = e, l.frequency.value = v), l;
    }function r(e) {
      e = e || 0, e && (e = n.currentTime + e), t(), l.start(e), d = s ? n.currentTime - s : n.currentTime, a = !1, f = !0, c = !1, s = 0;
    }function o() {
      if (l) {
        try {
          l.stop(0);
        } catch (e) {}l = null;
      }a = !0, c = !1, s = 0, f = !1, d = 0;
    }function i() {
      var e = n.currentTime - d;o(), s = e, f = !1, c = !0;
    }function u() {
      o(), n = null, l = null;
    }var a = !1,
        c = !1,
        s = 0,
        f = !1,
        l = null,
        d = 0,
        v = 200,
        p = null;return p = { play: r, pause: i, stop: o, destroy: u }, Object.defineProperties(p, { currentTime: { get: function get() {
          return s ? s : d ? n.currentTime - d : 0;
        } }, duration: { value: 0 }, ended: { get: function get() {
          return a;
        } }, frequency: { get: function get() {
          return v;
        }, set: function set(e) {
          v = e, l && (l.frequency.value = e);
        } }, paused: { get: function get() {
          return c;
        } }, playing: { get: function get() {
          return f;
        } }, progress: { value: 0 }, sourceNode: { get: function get() {
          return t();
        } } }), Object.freeze(p);
  }function q(e, n) {
    function t() {
      return !g && n && (g = n.createScriptProcessor(c, 0, s)), g;
    }function r() {
      t(), g.onaudioprocess = l, h = n.currentTime - v, f = !1, d = !1, v = 0, p = !0;
    }function o(e) {
      for (var n = e.outputBuffer, t = 0; t < n.numberOfChannels; t++) {
        for (var r = n.getChannelData(t), o = 0; o < r.length; o++) {
          r[o] = 0;
        }
      }
    }function i() {
      g && (g.onaudioprocess = o), f = !0, d = !1, v = 0, p = !1, h = 0;
    }function u() {
      var e = n.currentTime - h;i(), v = e, p = !1, d = !0;
    }function a() {
      i(), n = null, l = null, g = null;
    }var c = e.bufferSize || 1024,
        s = e.channels || 1,
        f = !1,
        l = e.callback.bind(e.thisArg || this),
        d = !1,
        v = 0,
        p = !1,
        g = null,
        h = 0,
        m = null;return m = { play: r, pause: u, stop: i, destroy: a, duration: 0, progress: 0 }, Object.defineProperties(m, { currentTime: { get: function get() {
          return v ? v : h ? n.currentTime - h : 0;
        } }, ended: { get: function get() {
          return f;
        } }, paused: { get: function get() {
          return d;
        } }, playing: { get: function get() {
          return p;
        } }, sourceNode: { get: function get() {
          return t();
        } } }), Object.freeze(m);
  }function F() {
    var e = void 0,
        n = void 0;return function (t, r) {
      if (!window.Float32Array || !window.AudioBuffer) return [];var o = e === t,
          i = n && n.length === r;if (o && i) return n;if (n && n.length === r || (n = new Float32Array(r)), !t) return n;e = t;for (var u = Math.floor(e.length / r), a = 5, c = Math.max(Math.floor(u / a), 1), s = 0, f = 0; f < e.numberOfChannels; f++) {
        for (var l = e.getChannelData(f), d = 0; d < r; d++) {
          for (var v = d * u, p = v + u; v < p; v += c) {
            var g = l[v];g < 0 && (g = -g), g > n[d] && (n[d] = g), g > s && (s = g);
          }
        }
      }for (var h = 1 / s, m = 0; m < n.length; m++) {
        n[m] *= h;
      }return n;
    };
  }function z(e, n) {
    function t(n) {
      if (l = n, ie.isAudioBuffer(l)) w = new k(l, e, function () {
        return T.emit("ended", T);
      });else if (ie.isMediaElement(l)) w = new D(l, e, function () {
        return T.emit("ended", T);
      });else if (ie.isMediaStream(l)) w = new P(l, e);else if (ie.isOscillatorType(l && l.type || l)) w = new R(l.type || l, e);else {
        if (!ie.isScriptConfig(l)) throw new Error("Cannot detect data type: " + l);w = new q(l, e);
      }d.setSource(w.sourceNode), T.emit("ready", T), b && b();
    }function r(n) {
      var r = ie.getSupportedFile(n.src || n.url || n.data || n);return w && l && l.tagName ? w.load(r) : (h = h || new C(r), h.audioContext = n.asMediaElement ? null : e, h.isTouchLocked = g, h.once("loaded", function (e) {
        t(e), T.emit("loaded", T);
      })), T;
    }function o(n, t) {
      return !w || g ? (b = function b() {
        w && o(n, t);
      }, T) : (b = null, d.setSource(w.sourceNode), e || (T.volume = v.gain.value), w.play(n, t), w.hasOwnProperty("loop") && (w.loop = m), T.emit("play", T), T);
    }function i() {
      return w && w.pause(), T.emit("pause", T), T;
    }function u(e) {
      return w && w.stop(e || 0), T.emit("stop", T), T;
    }function a(e) {
      return w && (w.stop(), o(0, w.duration * e)), T;
    }function c(n, t) {
      if (!w) return T;var r = v.gain;if (e) {
        var o = e.currentTime;r.cancelScheduledValues(o), r.setValueAtTime(r.value, o), r.linearRampToValueAtTime(n, o + t);
      } else "function" == typeof w.fade && (w.fade(n, t), r.value = n);return T;
    }function s() {
      w && w.destroy(), d && d.destroy(), v && v.disconnect(), h && h.destroy(), T.off("loaded"), T.off("ended"), v = null, e = null, l = null, b = null, w = null, d = null, h = null, p = null, T.emit("destroy", T), T.off("destroy");
    }var f = void 0,
        l = void 0,
        d = new A(e),
        v = d.gain(),
        p = F(),
        g = !1,
        h = void 0,
        m = !1,
        y = 1,
        b = void 0,
        w = void 0,
        T = null;return e && (d.setDestination(v), v.connect(n || e.destination)), T = Object.create(se.prototype, { _events: { value: {} }, constructor: { value: z }, play: { value: o }, pause: { value: i }, load: { value: r }, seek: { value: a }, stop: { value: u }, fade: { value: c }, destroy: { value: s }, context: { value: e }, currentTime: { get: function get() {
          return w ? w.currentTime : 0;
        }, set: function set(e) {
          w && w.stop(), o(0, e);
        } }, data: { get: function get() {
          return l;
        }, set: function set(e) {
          e && t(e);
        } }, duration: { get: function get() {
          return w ? w.duration : 0;
        } }, effect: { value: d }, ended: { get: function get() {
          return !!w && w.ended;
        } }, frequency: { get: function get() {
          return w ? w.frequency : 0;
        }, set: function set(e) {
          w && w.hasOwnProperty("frequency") && (w.frequency = e);
        } }, gain: { value: v }, id: { get: function get() {
          return f;
        }, set: function set(e) {
          f = e;
        } }, isTouchLocked: { set: function set(e) {
          g = e, h && (h.isTouchLocked = e), !e && b && b();
        } }, loader: { get: function get() {
          return h;
        } }, loop: { get: function get() {
          return m;
        }, set: function set(e) {
          m = !!e, w && w.hasOwnProperty("loop") && w.loop !== m && (w.loop = m);
        } }, paused: { get: function get() {
          return !!w && w.paused;
        } }, playing: { get: function get() {
          return !!w && w.playing;
        } }, playbackRate: { get: function get() {
          return y;
        }, set: function set(e) {
          y = e, w && (w.playbackRate = y);
        } }, progress: { get: function get() {
          return w ? w.progress : 0;
        } }, sourceNode: { get: function get() {
          return w ? w.sourceNode : null;
        } }, volume: { get: function get() {
          return e ? v.gain.value : w && w.hasOwnProperty("volume") ? w.volume : 1;
        }, set: function set(n) {
          if (!isNaN(n)) {
            var t = v.gain;if (e) {
              var r = e.currentTime;t.cancelScheduledValues(r), t.value = n, t.setValueAtTime(n, r);
            } else t.value = n, w && w.hasOwnProperty("volume") && (w.volume = n);
          }
        } }, groupVolume: { get: function get() {
          return w.groupVolume;
        }, set: function set(e) {
          w && w.hasOwnProperty("groupVolume") && (w.groupVolume = e);
        } }, waveform: { value: function value(e) {
          return l || T.once("ready", function () {
            return p(l, e);
          }), p(l, e);
        } }, userData: { value: {} } }), Object.freeze(T);
  }function j(e, n) {
    function t() {
      o.length && (a = o.slice(0).sort(function (e, n) {
        return n.duration - e.duration;
      })[0]);
    }var r = new O(e, n),
        o = r.sounds,
        i = 1,
        u = !1,
        a = void 0,
        c = r.add;r.add = function (e) {
      return c(e), t(), r;
    };var s = r.rmeove;return r.remove = function (e) {
      return s(e), t(), r;
    }, Object.defineProperties(r, { currentTime: { get: function get() {
          return a ? a.currentTime : 0;
        }, set: function set(e) {
          this.stop(), this.play(0, e);
        } }, duration: { get: function get() {
          return a ? a.duration : 0;
        } }, loop: { get: function get() {
          return u;
        }, set: function set(e) {
          u = !!e, o.forEach(function (e) {
            e.loop = u;
          });
        } }, paused: { get: function get() {
          return !!a && a.paused;
        } }, progress: { get: function get() {
          return a ? a.progress : 0;
        } }, playbackRate: { get: function get() {
          return i;
        }, set: function set(e) {
          i = e, o.forEach(function (e) {
            e.playbackRate = i;
          });
        } }, playing: { get: function get() {
          return !!a && a.playing;
        } } }), r;
  }function G(e, n, t) {
    function r() {
      return i ? (navigator.getUserMedia({ audio: !0 }, function (n) {
        a = n, e(a);
      }, function (e) {
        n && "PermissionDeniedError" === e.name || "PERMISSION_DENIED" === e ? n() : t(e.message || e);
      }), u) : u;
    }function o() {
      return a && (a.stop(), a = null), u;
    }navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia, t = t || function () {};var i = !!navigator.getUserMedia,
        u = {},
        a = null;return Object.defineProperties(u, { connect: { value: r }, disconnect: { value: o }, isSupported: { value: i }, stream: { get: function get() {
          return a;
        } } }), Object.freeze(u);
  }function B(e) {
    function n() {
      s ? (y.fillStyle = s, y.fillRect(d, v, h, m)) : y.clearRect(d, v, h, m), y.lineWidth = f, b = null, "function" != typeof c && (y.strokeStyle = c, y.beginPath());
    }function t(e, n, t) {
      if ("function" == typeof c) {
        var r = c(e, n, t);r !== b && (b = r, y.stroke(), y.strokeStyle = b, y.beginPath());
      }
    }function r(e, n, t) {
      return "function" == typeof p ? p(e, n, t) : e;
    }function o(n, t) {
      return n && "function" == typeof n.waveform ? n.waveform(t) : n ? n : e.waveform ? e.waveform : e.sound ? e.sound.waveform(t) : null;
    }function i(e) {
      if (n(), "circular" === a) {
        var i = o(e, 360),
            c = Math.floor(i.length * l),
            s = le / c,
            p = void 0,
            g = void 0,
            b = void 0,
            x = void 0;for (w = 0; w < c; w++) {
          var L = r(i[w], w, c);t(w, c, L), p = w * s - fe, x = Math.cos(p), b = Math.sin(p), "fill" === u && (T = E + O * x, M = S + O * b, y.moveTo(T, M)), g = O + (A - O) * L, T = E + g * x, M = S + g * b, "line" === u && 0 === w && y.moveTo(T, M), y.lineTo(T, M);
        }"line" === u && y.closePath();
      } else {
        var _ = o(e, h),
            C = Math.min(_.length, h - f / 2);for (C = Math.floor(C * l), w = 0; w < C; w++) {
          var k = r(_[w], w, C);t(w, C, k), "line" === u && w > 0 && y.lineTo(T, M), T = d + w, M = v + m - Math.round(m * k), M = Math.floor(Math.min(M, v + m - f / 2)), "fill" === u ? (y.moveTo(T, M), y.lineTo(T, v + m)) : y.lineTo(T, M);
        }
      }y.stroke();
    }var u = e.style || "fill",
        a = e.shape || "linear",
        c = e.color || 0,
        s = e.bgColor,
        f = e.lineWidth || 1,
        l = e.percent || 1,
        d = e.x || 0,
        v = e.y || 0,
        p = e.transform,
        g = e.canvas,
        h = e.width || g && g.width,
        m = e.height || g && g.height,
        y = null,
        b = void 0,
        w = void 0,
        T = void 0,
        M = void 0,
        A = void 0,
        O = void 0,
        E = void 0,
        S = void 0;return g || e.context || (g = document.createElement("canvas"), h = h || g.width, m = m || g.height, g.width = m, g.height = m), "circular" === a && (A = e.radius || Math.min(m / 2, h / 2), O = e.innerRadius || A / 2, E = d + h / 2, S = v + m / 2), y = e.context || g.getContext("2d"), i.canvas = g, (e.waveform || e.sound) && i(), i;
  }function V() {
    if (de) return de;var e = window.AudioContext || window.webkitAudioContext;de = e ? new e() : null;var n = de && "suspended" === de.state;return n && "function" == typeof de.resume && window.setTimeout(function () {
      de.resume();
    }, 1e3), de;
  }function N(e, n, t) {
    if (ve) return ve;e = e || 2, t = t || 44100, n = t || e;var r = window.OfflineAudioContext || window.webkitOfflineAudioContext;return ve = r ? new r(e, n, t) : null;
  }function I(e) {
    if (!de) return e;for (var n = e.numberOfChannels, t = de.createBuffer(n, e.length, e.sampleRate), r = 0; r < n; r++) {
      t.getChannelData(r).set(e.getChannelData(r));
    }return t;
  }function U(e) {
    for (var n = e.numberOfChannels, t = 0; t < n; t++) {
      Array.prototype.reverse.call(e.getChannelData(t));
    }return e;
  }function W(e, n, t, r, o) {
    de && (e.setValueAtTime(n, de.currentTime), o ? e.linearRampToValueAtTime(t, de.currentTime + r) : e.exponentialRampToValueAtTime(t, de.currentTime + r));
  }function H(e) {
    if (!de) return 0;var n = 40,
        t = de.sampleRate / 2,
        r = Math.log(t / n) / Math.LN2,
        o = Math.pow(2, r * (e - 1));return t * o;
  }function X(e, n, t) {
    return new G(e, n, t);
  }function Z(e) {
    var n = arguments.length <= 1 || void 0 === arguments[1] ? ":" : arguments[1],
        t = Math.floor(e / 60),
        r = Math.floor(e % 3600 % 60),
        o = (t < 10 ? "0" + t : t) + n,
        i = r < 10 ? "0" + r : r;return o + i;
  }function Q() {
    function e(e) {
      return T.find(e);
    }function n(e) {
      var n = new j(b, T.gain);return e && e.forEach(function (e) {
        return n.add(e);
      }), n;
    }function t(e) {
      var n = e && e.webAudio === !1 ? null : b,
          t = new z(n, T.gain);return t.isTouchLocked = A, e && (t.id = e.id || e.name || "", t.loop = !!e.loop, t.volume = e.volume), T.add(t), t;
    }function r(e, n) {
      var r = t(e).load(e);return n && n.add(r.loader), r;
    }function o(e) {
      var n = e.src || e.url || e.data || e,
          t = void 0,
          o = void 0;if (ie.containsURL(n)) t = r(e), o = t.loader;else {
        if (!Array.isArray(n) || !ie.containsURL(n[0].src || n[0].url)) {
          var i = "sono.load: No audio file URLs found in config.";if (!e.onError) throw new Error(i);return e.onError("[ERROR] " + i), null;
        }t = [], o = new C.Group(), n.forEach(function (e) {
          return t.push(r(e, o));
        });
      }return e.onProgress && o.on("progress", function (n) {
        return e.onProgress(n);
      }), e.onComplete && o.once("complete", function () {
        o.off("progress"), e.onComplete(t);
      }), o.once("error", function (n) {
        o.off("error"), e.onError ? e.onError(n) : console.error.call(console, "[ERROR] sono.load: " + n);
      }), o.start(), t;
    }function i(e) {
      if (ie.containsURL(e)) return o(e);var n = t(e);return n.data = e.data || e, n;
    }function u(e) {
      return T.find(e, function (e) {
        return e.destroy();
      }), M;
    }function a() {
      return T.destroy(), M;
    }function c() {
      return T.mute(), M;
    }function s() {
      return T.unMute(), M;
    }function f(e, n) {
      return T.fade(e, n), M;
    }function l() {
      return T.pause(), M;
    }function d() {
      return T.resume(), M;
    }function v() {
      return T.stop(), M;
    }function p(e, n, t) {
      return T.find(e, function (e) {
        return e.play(n, t);
      }), M;
    }function g(e) {
      return T.find(e, function (e) {
        return e.pause();
      }), M;
    }function h(e) {
      return T.find(e, function (e) {
        return e.stop();
      }), M;
    }function m() {
      var e = "sono " + y,
          n = "Supported:" + M.isSupported + " WebAudioAPI:" + M.hasWebAudio + " TouchLocked:" + A + " State:" + (b && b.state) + " Extensions:" + ie.extensions;if (navigator.userAgent.indexOf("Chrome") > -1) {
        var t = ["%c ♫ " + e + " ♫ %c " + n + " ", "color: #FFFFFF; background: #379F7A", "color: #1F1C0D; background: #E0FBAC"];console.log.apply(console, t);
      } else window.console && window.console.log.call && console.log.call(console, e + " " + n);
    }var y = "0.1.8",
        b = pe.getContext(),
        w = b ? b.destination : null,
        T = new O(b, w),
        M = null,
        A = !1;return A = K.handleTouchLock(b, function () {
      A = !1, T.sounds.forEach(function (e) {
        return e.isTouchLocked = !1;
      });
    }), function () {
      function e() {
        T.sounds.forEach(function (e) {
          e.playing && (e.pause(), t.push(e));
        });
      }function n() {
        for (; t.length;) {
          t.pop().play();
        }
      }var t = [];K.handlePageVisibility(e, n);
    }(), M = { createSound: i, destroySound: u, destroyAll: a, getSound: e, createGroup: n, file: ie, load: o, mute: c, unMute: s, fade: f, pauseAll: l, resumeAll: d, stopAll: v, play: p, pause: g, stop: h, log: m, canPlay: ie.canPlay, context: b, getOfflineContext: pe.getOfflineContext, effect: T.effect, extensions: ie.extensions, hasWebAudio: !!b, isSupported: ie.extensions.length > 0, gain: T.gain, utils: pe, VERSION: y, Sound: z, Group: O }, Object.defineProperties(M, { isTouchLocked: { get: function get() {
          return A;
        } }, sounds: { get: function get() {
          return T.sounds.slice(0);
        } }, volume: { get: function get() {
          return T.volume;
        }, set: function set(e) {
          T.volume = e;
        } } }), Object.freeze(M);
  }var K = {};K.handlePageVisibility = function (e, n) {
    function t() {
      document[r] ? e() : n();
    }var r = void 0,
        o = void 0;"undefined" != typeof document.hidden ? (r = "hidden", o = "visibilitychange") : "undefined" != typeof document.mozHidden ? (r = "mozHidden", o = "mozvisibilitychange") : "undefined" != typeof document.msHidden ? (r = "msHidden", o = "msvisibilitychange") : "undefined" != typeof document.webkitHidden && (r = "webkitHidden", o = "webkitvisibilitychange"), "undefined" != typeof o && document.addEventListener(o, t, !1);
  }, K.handleTouchLock = function (e, n) {
    function t() {
      e && "suspended" === e.state ? e.resume().then(function () {
        var r = e.createBuffer(1, 1, 22050),
            o = e.createBufferSource();o.buffer = r, o.connect(e.destination), o.start(0), o.stop(0), o.disconnect(), document.body.removeEventListener("touchend", t), n();
      }) : (document.body.removeEventListener("touchend", t), n());
    }var r = navigator.userAgent,
        o = !!r.match(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Windows Phone|SymbianOS/i);return o && document.body.addEventListener("touchend", t, !1), o;
  };var J = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
    return typeof e === "undefined" ? "undefined" : _typeof(e);
  } : function (e) {
    return e && "function" == typeof Symbol && e.constructor === Symbol ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
  },
      Y = function Y(e, n) {
    if (!(e instanceof n)) throw new TypeError("Cannot call a class as a function");
  },
      $ = function $(e, n) {
    if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function, not " + (typeof n === "undefined" ? "undefined" : _typeof(n)));e.prototype = Object.create(n && n.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), n && (Object.setPrototypeOf ? Object.setPrototypeOf(e, n) : e.__proto__ = n);
  },
      ee = function ee(e, n) {
    if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !n || "object" != (typeof n === "undefined" ? "undefined" : _typeof(n)) && "function" != typeof n ? e : n;
  },
      ne = [],
      te = {},
      re = [{ ext: "ogg", type: 'audio/ogg; codecs="vorbis"' }, { ext: "mp3", type: "audio/mpeg;" }, { ext: "opus", type: 'audio/ogg; codecs="opus"' }, { ext: "wav", type: 'audio/wav; codecs="1"' }, { ext: "m4a", type: "audio/x-m4a;" }, { ext: "m4a", type: "audio/aac;" }],
      oe = document.createElement("audio");oe && (re.forEach(function (e) {
    var n = !!oe.canPlayType(e.type);n && ne.indexOf(e.ext) === -1 && ne.push(e.ext), te[e.ext] = n;
  }), oe = null);var ie = { canPlay: te, containsURL: s, extensions: ne, getFileExtension: e, getSupportedFile: n, isAudioBuffer: t, isMediaElement: o, isMediaStream: i, isOscillatorType: u, isScriptConfig: a, isURL: c },
      ue = 22050;b.defaults = { panningModel: "HRTF", distanceModel: "linear", refDistance: 1, maxDistance: 1e3, rolloffFactor: 1, coneInnerAngle: 360, coneOuterAngle: 0, coneOuterGain: 0 }, O.Effect = A;var ae = E;E.EventEmitter = E, E.prototype._events = void 0, E.prototype._maxListeners = void 0, E.defaultMaxListeners = 10, E.prototype.setMaxListeners = function (e) {
    if (!x(e) || e < 0 || isNaN(e)) throw TypeError("n must be a positive number");return this._maxListeners = e, this;
  }, E.prototype.emit = function (e) {
    var n, t, r, o, i, u;if (this._events || (this._events = {}), "error" === e && (!this._events.error || L(this._events.error) && !this._events.error.length)) {
      if (n = arguments[1], n instanceof Error) throw n;var a = new Error('Uncaught, unspecified "error" event. (' + n + ")");throw a.context = n, a;
    }if (t = this._events[e], _(t)) return !1;if (S(t)) switch (arguments.length) {case 1:
        t.call(this);break;case 2:
        t.call(this, arguments[1]);break;case 3:
        t.call(this, arguments[1], arguments[2]);break;default:
        o = Array.prototype.slice.call(arguments, 1), t.apply(this, o);} else if (L(t)) for (o = Array.prototype.slice.call(arguments, 1), u = t.slice(), r = u.length, i = 0; i < r; i++) {
      u[i].apply(this, o);
    }return !0;
  }, E.prototype.addListener = function (e, n) {
    var t;if (!S(n)) throw TypeError("listener must be a function");return this._events || (this._events = {}), this._events.newListener && this.emit("newListener", e, S(n.listener) ? n.listener : n), this._events[e] ? L(this._events[e]) ? this._events[e].push(n) : this._events[e] = [this._events[e], n] : this._events[e] = n, L(this._events[e]) && !this._events[e].warned && (t = _(this._maxListeners) ? E.defaultMaxListeners : this._maxListeners, t && t > 0 && this._events[e].length > t && (this._events[e].warned = !0, "function" == typeof console.trace)), this;
  }, E.prototype.on = E.prototype.addListener, E.prototype.once = function (e, n) {
    function t() {
      this.removeListener(e, t), r || (r = !0, n.apply(this, arguments));
    }if (!S(n)) throw TypeError("listener must be a function");var r = !1;return t.listener = n, this.on(e, t), this;
  }, E.prototype.removeListener = function (e, n) {
    var t, r, o, i;if (!S(n)) throw TypeError("listener must be a function");if (!this._events || !this._events[e]) return this;if (t = this._events[e], o = t.length, r = -1, t === n || S(t.listener) && t.listener === n) delete this._events[e], this._events.removeListener && this.emit("removeListener", e, n);else if (L(t)) {
      for (i = o; i-- > 0;) {
        if (t[i] === n || t[i].listener && t[i].listener === n) {
          r = i;break;
        }
      }if (r < 0) return this;1 === t.length ? (t.length = 0, delete this._events[e]) : t.splice(r, 1), this._events.removeListener && this.emit("removeListener", e, n);
    }return this;
  }, E.prototype.removeAllListeners = function (e) {
    var n, t;if (!this._events) return this;if (!this._events.removeListener) return 0 === arguments.length ? this._events = {} : this._events[e] && delete this._events[e], this;if (0 === arguments.length) {
      for (n in this._events) {
        "removeListener" !== n && this.removeAllListeners(n);
      }return this.removeAllListeners("removeListener"), this._events = {}, this;
    }if (t = this._events[e], S(t)) this.removeListener(e, t);else if (t) for (; t.length;) {
      this.removeListener(e, t[t.length - 1]);
    }return delete this._events[e], this;
  }, E.prototype.listeners = function (e) {
    var n;return n = this._events && this._events[e] ? S(this._events[e]) ? [this._events[e]] : this._events[e].slice() : [];
  }, E.prototype.listenerCount = function (e) {
    if (this._events) {
      var n = this._events[e];if (S(n)) return 1;if (n) return n.length;
    }return 0;
  }, E.listenerCount = function (e, n) {
    return e.listenerCount(n);
  };var ce = ae.EventEmitter,
      se = function (e) {
    function n() {
      return Y(this, n), ee(this, e.call(this));
    }return $(n, e), n.prototype.off = function (e, n) {
      return n ? this.removeListener(e, n) : e ? this.removeAllListeners(e) : this.removeAllListeners();
    }, n;
  }(ce);C.Group = function () {
    function e(e) {
      var n = s + e;a.emit("progress", n / f);
    }function n() {
      s++, o(), a.emit("progress", s / f), r();
    }function t(e) {
      console.error.call(console, e), o(), a.emit("error", e), r();
    }function r() {
      return 0 === c.length ? (l = null, void a.emit("complete")) : (l = c.pop(), l.on("progress", e), l.once("loaded", n), l.once("error", t), void l.start());
    }function o() {
      l.off("progress", e), l.off("loaded", n), l.off("error", t);
    }function i(e) {
      return c.push(e), f++, e;
    }function u() {
      f = c.length, r();
    }var a = new se(),
        c = [],
        s = 0,
        f = 0,
        l = void 0;return Object.freeze({ on: a.on.bind(a), once: a.once.bind(a), off: a.off.bind(a), add: i, start: u });
  }, z.__source = { BufferSource: k, MediaSource: D, MicrophoneSource: P, OscillatorSource: R, ScriptSource: q };var fe = Math.PI / 2,
      le = 2 * Math.PI,
      de = void 0,
      ve = void 0,
      pe = Object.freeze({ getContext: V, getOfflineContext: N, cloneBuffer: I, reverseBuffer: U, ramp: W, getFrequency: H, microphone: X, timeCode: Z, waveformer: B }),
      ge = new Q();return ge;
});

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; // addControls.js

var _Settings = __webpack_require__(7);

var _Settings2 = _interopRequireDefault(_Settings);

var _Config = __webpack_require__(1);

var _Config2 = _interopRequireDefault(_Config);

var _utils = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var simulateKey = function simulateKey(keyCode, type, modifiers) {
	var evtName = typeof type === "string" ? "key" + type : "keydown";
	var modifier = (typeof modifiers === 'undefined' ? 'undefined' : _typeof(modifiers)) === "object" ? modifier : {};

	var event = document.createEvent("HTMLEvents");
	event.initEvent(evtName, true, false);
	event.keyCode = keyCode;

	for (var i in modifiers) {
		event[i] = modifiers[i];
	}

	document.dispatchEvent(event);
};

exports.default = function (scene) {
	setTimeout(function () {
		console.log('setup gui');
		// gui.add(Config, 'numTrees', 1, 100).step(1).onFinishChange(Settings.reload);
		// gui.add(Config, 'treeScale', 0, 5).onChange(Settings.refresh);
		// gui.add(Config, 'floorRadius', 1, 5).onFinishChange(Settings.reload);
		// gui.add(Config, 'maxFloorHeight', 0, 1).onFinishChange(Settings.refresh);
		// gui.add(Config, 'treeBumpHeight', 0, 1).onFinishChange(Settings.reload);
		gui.add(_Config2.default, 'numSlides', 1, 1000).step(1).onFinishChange(_Settings2.default.reload);
		// gui.add(Config, 'noiseScale', 1, 10).onFinishChange(Settings.reload);
		// gui.add(Config, 'overlayOpacity', 0, 1).onChange(Settings.refresh);
		// gui.add(Config, 'bloomStrength', 0, 1).onChange(Settings.refresh);
		// gui.add(Config, 'fogMovingSpeed', 0, 1).onChange(Settings.refresh);
		// gui.add(Config, 'pixelateMixing', 0, 1).onChange(Settings.refresh);
		// gui.add(Config, 'snowSpeed', 0, 1).onChange(Settings.refresh);
		// gui.add(Config, 'showSnow').name('Show Snow').onChange(Settings.refresh);
		// gui.add(Config, 'gradientMap', 0, 1).name('Gradient Map').onChange(Settings.refresh);
		// gui.add(Config, 'fxaa').name('Post Effect').onChange(Settings.refresh);
		// gui.add(scene, 'resetCamera');


		var o = {
			saveSettings: function saveSettings() {
				(0, _utils.saveJson)(_Config2.default, 'xmas-settings');
			}

			// gui.add(o, 'saveSettings').name('Save Settings');
		};setTimeout(function () {
			// simulateKey(72);
		}, 500);
	}, 500);
};

/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TweenMax", function() { return TweenMax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TweenMax; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__TweenMaxBase_js__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__CSSPlugin_js__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__AttrPlugin_js__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__RoundPropsPlugin_js__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__DirectionalRotationPlugin_js__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__TimelineLite_js__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__TimelineMax_js__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__BezierPlugin_js__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__EasePack_js__ = __webpack_require__(79);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "TweenLite", function() { return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "TimelineLite", function() { return __WEBPACK_IMPORTED_MODULE_6__TimelineLite_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "TimelineMax", function() { return __WEBPACK_IMPORTED_MODULE_7__TimelineMax_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "CSSPlugin", function() { return __WEBPACK_IMPORTED_MODULE_2__CSSPlugin_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "AttrPlugin", function() { return __WEBPACK_IMPORTED_MODULE_3__AttrPlugin_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "BezierPlugin", function() { return __WEBPACK_IMPORTED_MODULE_8__BezierPlugin_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalRotationPlugin", function() { return __WEBPACK_IMPORTED_MODULE_5__DirectionalRotationPlugin_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "RoundPropsPlugin", function() { return __WEBPACK_IMPORTED_MODULE_4__RoundPropsPlugin_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "TweenPlugin", function() { return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["j"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Ease", function() { return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Power0", function() { return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Power1", function() { return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["e"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Power2", function() { return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["f"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Power3", function() { return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Power4", function() { return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["h"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Linear", function() { return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Back", function() { return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Elastic", function() { return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Bounce", function() { return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "RoughEase", function() { return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "SlowMo", function() { return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["i"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "SteppedEase", function() { return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["j"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Circ", function() { return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Expo", function() { return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["e"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Sine", function() { return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["h"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ExpoScaleEase", function() { return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["f"]; });
/*!
 * VERSION: 2.0.2
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/












//the following two lines are designed to prevent tree shaking of the classes that were historically included with TweenMax (otherwise, folks would have to reference CSSPlugin, for example, to ensure their CSS-related animations worked)
var TweenMax = __WEBPACK_IMPORTED_MODULE_1__TweenMaxBase_js__["a" /* default */];
TweenMax._autoActivated = [__WEBPACK_IMPORTED_MODULE_6__TimelineLite_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_7__TimelineMax_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_2__CSSPlugin_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_3__AttrPlugin_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_8__BezierPlugin_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_4__RoundPropsPlugin_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_5__DirectionalRotationPlugin_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["a" /* Back */], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["d" /* Elastic */], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["b" /* Bounce */], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["g" /* RoughEase */], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["i" /* SlowMo */], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["j" /* SteppedEase */], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["c" /* Circ */], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["e" /* Expo */], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["h" /* Sine */], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["f" /* ExpoScaleEase */]];





/***/ }),
/* 71 */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if(!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true,
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export TweenMax */
/* unused harmony export TweenMaxBase */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TweenMax; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(2);
/* unused harmony reexport TweenLite */
/* unused harmony reexport Ease */
/* unused harmony reexport Power0 */
/* unused harmony reexport Power1 */
/* unused harmony reexport Power2 */
/* unused harmony reexport Power3 */
/* unused harmony reexport Power4 */
/* unused harmony reexport Linear */
/*!
 * VERSION: 2.0.2
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/




__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */]._gsDefine("TweenMax", ["core.Animation","core.SimpleTimeline","TweenLite"], function() {

		var _slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			_applyCycle = function(vars, targets, i) {
				var alt = vars.cycle,
					p, val;
				for (p in alt) {
					val = alt[p];
					vars[p] = (typeof(val) === "function") ? val(i, targets[i]) : val[i % val.length];
				}
				delete vars.cycle;
			},
			TweenMax = function(target, duration, vars) {
				__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].call(this, target, duration, vars);
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true || !!this.vars.yoyoEase);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				if (this._repeat) {
					this._uncache(true); //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
				}
				this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */]._internals,
			_isSelector = TweenLiteInternals.isSelector,
			_isArray = TweenLiteInternals.isArray,
			p = TweenMax.prototype = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].to({}, 0.1, {}),
			_blankArray = [];

		TweenMax.version = "2.0.2";
		p.constructor = TweenMax;
		p.kill()._gc = false;
		TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].killTweensOf;
		TweenMax.getTweensOf = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].getTweensOf;
		TweenMax.lagSmoothing = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].lagSmoothing;
		TweenMax.ticker = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].ticker;
		TweenMax.render = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].render;

		p.invalidate = function() {
			this._yoyo = (this.vars.yoyo === true || !!this.vars.yoyoEase);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._yoyoEase = null;
			this._uncache(true);
			return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].prototype.invalidate.call(this);
		};

		p.updateTo = function(vars, resetDuration) {
			var curRatio = this.ratio,
				immediate = this.vars.immediateRender || vars.immediateRender,
				p;
			if (resetDuration && this._startTime < this._timeline._time) {
				this._startTime = this._timeline._time;
				this._uncache(false);
				if (this._gc) {
					this._enabled(true, false);
				} else {
					this._timeline.insert(this, this._startTime - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			for (p in vars) {
				this.vars[p] = vars[p];
			}
			if (this._initted || immediate) {
				if (resetDuration) {
					this._initted = false;
					if (immediate) {
						this.render(0, true, true);
					}
				} else {
					if (this._gc) {
						this._enabled(true, false);
					}
					if (this._notifyPluginsOfEnabled && this._firstPT) {
						__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */]._onPluginEvent("_onDisable", this); //in case a plugin like MotionBlur must perform some cleanup tasks
					}
					if (this._time / this._duration > 0.998) { //if the tween has finished (or come extremely close to finishing), we just need to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens that are close to finishing (but haven't quite finished) to work this way too because otherwise, the values are so small when determining where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when run backwards.
						var prevTime = this._totalTime;
						this.render(0, true, false);
						this._initted = false;
						this.render(prevTime, true, false);
					} else {
						this._initted = false;
						this._init();
						if (this._time > 0 || immediate) {
							var inv = 1 / (1 - curRatio),
								pt = this._firstPT, endValue;
							while (pt) {
								endValue = pt.s + pt.c;
								pt.c *= inv;
								pt.s = endValue - pt.c;
								pt = pt._next;
							}
						}
					}
				}
			}
			return this;
		};

		p.render = function(time, suppressEvents, force) {
			if (!this._initted) if (this._duration === 0 && this.vars.repeat) { //zero duration tweens that render immediately have render() called from TweenLite's constructor, before TweenMax's constructor has finished setting _repeat, _repeatDelay, and _yoyo which are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.
				this.invalidate();
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevTime = this._time,
				prevTotalTime = this._totalTime,
				prevCycle = this._cycle,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, cycleDuration, r, type, pow, rawPrevTime, yoyoEase;
			if (time >= totalDur - 0.0000001 && time >= 0) { //to work around occasional floating point math artifacts.
				this._totalTime = totalDur;
				this._cycle = this._repeat;
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = 0;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				} else {
					this._time = duration;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				}
				if (!this._reversed) {
					isComplete = true;
					callback = "onComplete";
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (prevRawPrevTime < 0 || (time <= 0 && time >= -0.0000001) || (prevRawPrevTime === _tinyNum && this.data !== "isPause")) if (prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = this._cycle = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTotalTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;
				if (this._repeat !== 0) {
					cycleDuration = duration + this._repeatDelay;
					this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)
					if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
						this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
					}
					this._time = this._totalTime - (this._cycle * cycleDuration);
					if (this._yoyo) if ((this._cycle & 1) !== 0) {
						this._time = duration - this._time;
						yoyoEase = this._yoyoEase || this.vars.yoyoEase; //note: we don't set this._yoyoEase in _init() like we do other properties because it's TweenMax-specific and doing it here allows us to optimize performance (most tweens don't have a yoyoEase). Note that we also must skip the this.ratio calculation further down right after we _init() in this function, because we're doing it here.
						if (yoyoEase) {
							if (!this._yoyoEase) {
								if (yoyoEase === true && !this._initted) { //if it's not initted and yoyoEase is true, this._ease won't have been populated yet so we must discern it here.
									yoyoEase = this.vars.ease;
									this._yoyoEase = yoyoEase = !yoyoEase ? __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].defaultEase : (yoyoEase instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["b" /* Ease */]) ? yoyoEase : (typeof(yoyoEase) === "function") ? new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["b" /* Ease */](yoyoEase, this.vars.easeParams) : __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["b" /* Ease */].map[yoyoEase] || __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].defaultEase;
								} else {
									this._yoyoEase = yoyoEase = (yoyoEase === true) ? this._ease : (yoyoEase instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["b" /* Ease */]) ? yoyoEase : __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["b" /* Ease */].map[yoyoEase];
								}
							}
							this.ratio = yoyoEase ? 1 - yoyoEase.getRatio((duration - this._time) / duration) : 0;
						}
					}
					if (this._time > duration) {
						this._time = duration;
					} else if (this._time < 0) {
						this._time = 0;
					}
				}
				if (this._easeType && !yoyoEase) {
					r = this._time / duration;
					type = this._easeType;
					pow = this._easePower;
					if (type === 1 || (type === 3 && r >= 0.5)) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (this._time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - (r / 2);
					}

				} else if (!yoyoEase) {
					this.ratio = this._ease.getRatio(this._time / duration);
				}

			}

			if (prevTime === this._time && !force && prevCycle === this._cycle) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._callback("onUpdate");
				}
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) { //we stick it in the queue for rendering at the very end of the tick - this is a performance optimization because browsers invalidate styles and force a recalculation if you read, write, and then read style data (so it's better to read/read/read/write/write/write than read/write/read/write/read/write). The down side, of course, is that usually you WANT things to render immediately because you may have code running right after that which depends on the change. Like imagine running TweenLite.set(...) and then immediately after that, creating a nother tween that animates the same property to another value; the starting values of that 2nd tween wouldn't be accurate if lazy is true.
					this._time = prevTime;
					this._totalTime = prevTotalTime;
					this._rawPrevTime = prevRawPrevTime;
					this._cycle = prevCycle;
					TweenLiteInternals.lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete && !yoyoEase) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd && !yoyoEase) {
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
				}
			}
			if (this._lazy !== false) {
				this._lazy = false;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTotalTime === 0) {
				if (this._initted === 2 && time > 0) {
					//this.invalidate();
					this._init(); //will just apply overwriting since _initted of (2) means it was a from() tween that had immediateRender:true
				}
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, true, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._totalTime !== 0 || duration === 0) if (!suppressEvents) {
					this._callback("onStart");
				}
			}

			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}

			if (this._onUpdate) {
				if (time < 0) if (this._startAt && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._totalTime !== prevTotalTime || callback) {
					this._callback("onUpdate");
				}
			}
			if (this._cycle !== prevCycle) if (!suppressEvents) if (!this._gc) if (this.vars.onRepeat) {
				this._callback("onRepeat");
			}
			if (callback) if (!this._gc || force) { //check gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, true, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};

//---- STATIC FUNCTIONS -----------------------------------------------------------------------------------------------------------

		TweenMax.to = function(target, duration, vars) {
			return new TweenMax(target, duration, vars);
		};

		TweenMax.from = function(target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenMax(target, duration, vars);
		};

		TweenMax.fromTo = function(target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return new TweenMax(target, duration, toVars);
		};

		TweenMax.staggerTo = TweenMax.allTo = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			stagger = stagger || 0;
			var delay = 0,
				a = [],
				finalComplete = function() {
					if (vars.onComplete) {
						vars.onComplete.apply(vars.onCompleteScope || this, arguments);
					}
					onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
				},
				cycle = vars.cycle,
				fromCycle = (vars.startAt && vars.startAt.cycle),
				l, copy, i, p;
			if (!_isArray(targets)) {
				if (typeof(targets) === "string") {
					targets = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].selector(targets) || targets;
				}
				if (_isSelector(targets)) {
					targets = _slice(targets);
				}
			}
			targets = targets || [];
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			l = targets.length - 1;
			for (i = 0; i <= l; i++) {
				copy = {};
				for (p in vars) {
					copy[p] = vars[p];
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				if (fromCycle) {
					fromCycle = copy.startAt = {};
					for (p in vars.startAt) {
						fromCycle[p] = vars.startAt[p];
					}
					_applyCycle(copy.startAt, targets, i);
				}
				copy.delay = delay + (copy.delay || 0);
				if (i === l && onCompleteAll) {
					copy.onComplete = finalComplete;
				}
				a[i] = new TweenMax(targets[i], duration, copy);
				delay += stagger;
			}
			return a;
		};

		TweenMax.staggerFrom = TweenMax.allFrom = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		TweenMax.staggerFromTo = TweenMax.allFromTo = function(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		TweenMax.delayedCall = function(delay, callback, params, scope, useFrames) {
			return new TweenMax(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, callbackScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, immediateRender:false, useFrames:useFrames, overwrite:0});
		};

		TweenMax.set = function(target, vars) {
			return new TweenMax(target, 0, vars);
		};

		TweenMax.isTweening = function(target) {
			return (__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].getTweensOf(target, true).length > 0);
		};

		var _getChildrenOf = function(timeline, includeTimelines) {
				var a = [],
					cnt = 0,
					tween = timeline._first;
				while (tween) {
					if (tween instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */]) {
						a[cnt++] = tween;
					} else {
						if (includeTimelines) {
							a[cnt++] = tween;
						}
						a = a.concat(_getChildrenOf(tween, includeTimelines));
						cnt = a.length;
					}
					tween = tween._next;
				}
				return a;
			},
			getAllTweens = TweenMax.getAllTweens = function(includeTimelines) {
				return _getChildrenOf(__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["a" /* Animation */]._rootTimeline, includeTimelines).concat( _getChildrenOf(__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["a" /* Animation */]._rootFramesTimeline, includeTimelines) );
			};

		TweenMax.killAll = function(complete, tweens, delayedCalls, timelines) {
			if (tweens == null) {
				tweens = true;
			}
			if (delayedCalls == null) {
				delayedCalls = true;
			}
			var a = getAllTweens((timelines != false)),
				l = a.length,
				allTrue = (tweens && delayedCalls && timelines),
				isDC, tween, i;
			for (i = 0; i < l; i++) {
				tween = a[i];
				if (allTrue || (tween instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["i" /* SimpleTimeline */]) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
					if (complete) {
						tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
					} else {
						tween._enabled(false, false);
					}
				}
			}
		};

		TweenMax.killChildTweensOf = function(parent, complete) {
			if (parent == null) {
				return;
			}
			var tl = TweenLiteInternals.tweenLookup,
				a, curParent, p, i, l;
			if (typeof(parent) === "string") {
				parent = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].selector(parent) || parent;
			}
			if (_isSelector(parent)) {
				parent = _slice(parent);
			}
			if (_isArray(parent)) {
				i = parent.length;
				while (--i > -1) {
					TweenMax.killChildTweensOf(parent[i], complete);
				}
				return;
			}
			a = [];
			for (p in tl) {
				curParent = tl[p].target.parentNode;
				while (curParent) {
					if (curParent === parent) {
						a = a.concat(tl[p].tweens);
					}
					curParent = curParent.parentNode;
				}
			}
			l = a.length;
			for (i = 0; i < l; i++) {
				if (complete) {
					a[i].totalTime(a[i].totalDuration());
				}
				a[i]._enabled(false, false);
			}
		};

		var _changePause = function(pause, tweens, delayedCalls, timelines) {
			tweens = (tweens !== false);
			delayedCalls = (delayedCalls !== false);
			timelines = (timelines !== false);
			var a = getAllTweens(timelines),
				allTrue = (tweens && delayedCalls && timelines),
				i = a.length,
				isDC, tween;
			while (--i > -1) {
				tween = a[i];
				if (allTrue || (tween instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["i" /* SimpleTimeline */]) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
					tween.paused(pause);
				}
			}
		};

		TweenMax.pauseAll = function(tweens, delayedCalls, timelines) {
			_changePause(true, tweens, delayedCalls, timelines);
		};

		TweenMax.resumeAll = function(tweens, delayedCalls, timelines) {
			_changePause(false, tweens, delayedCalls, timelines);
		};

		TweenMax.globalTimeScale = function(value) {
			var tl = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["a" /* Animation */]._rootTimeline,
				t = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].ticker.time;
			if (!arguments.length) {
				return tl._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["a" /* Animation */]._rootFramesTimeline;
			t = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].ticker.frame;
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl._timeScale = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["a" /* Animation */]._rootTimeline._timeScale = value;
			return value;
		};


//---- GETTERS / SETTERS ----------------------------------------------------------------------------------------------------------

		p.progress = function(value, suppressEvents) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
		};

		p.totalProgress = function(value, suppressEvents) {
			return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime( this.totalDuration() * value, suppressEvents);
		};

		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.duration = function(value) {
			if (!arguments.length) {
				return this._duration; //don't set _dirty = false because there could be repeats that haven't been factored into the _totalDuration yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration would not be correct, thus repeats wouldn't take effect.
			}
			return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["a" /* Animation */].prototype.duration.call(this, value);
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					//instead of Infinity, we use 999999999999 so that we can accommodate reverses
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return (this._repeat === -1) ? this : this.duration( (value - (this._repeat * this._repeatDelay)) / (this._repeat + 1) );
		};

		p.repeat = function(value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};

		p.repeatDelay = function(value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};

		p.yoyo = function(value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};


		return TweenMax;

	}, true);

var TweenMax = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["m" /* globals */].TweenMax;
var TweenMaxBase = TweenMax;




/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CSSPlugin */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CSSPlugin; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(2);
/*!
 * VERSION: 2.0.2
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */


	__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */]._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin","TweenLite"], function() {

		/** @constructor **/
		var CSSPlugin = function() {
				__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["j" /* TweenPlugin */].call(this, "css");
				this._overwriteProps.length = 0;
				this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this "hot" method)
			},
			_globals = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */]._gsDefine.globals,
			_hasPriority, //turns true whenever a CSSPropTween instance is created that has a priority other than 0. This helps us discern whether or not we should spend the time organizing the linked list or not after a CSSPlugin's _onInitTween() method is called.
			_suffixMap, //we set this in _onInitTween() each time as a way to have a persistent variable we can use in other methods like _parse() without having to pass it around as a parameter and we keep _parse() decoupled from a particular CSSPlugin instance
			_cs, //computed style (we store this in a shared variable to conserve memory and make minification tighter
			_overwriteProps, //alias to the currently instantiating CSSPlugin's _overwriteProps array. We use this closure in order to avoid having to pass a reference around from method to method and aid in minification.
			_specialProps = {},
			p = CSSPlugin.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["j" /* TweenPlugin */]("css");

		p.constructor = CSSPlugin;
		CSSPlugin.version = "2.0.2";
		CSSPlugin.API = 2;
		CSSPlugin.defaultTransformPerspective = 0;
		CSSPlugin.defaultSkewType = "compensated";
		CSSPlugin.defaultSmoothOrigin = true;
		p = "px"; //we'll reuse the "p" variable to keep file size down
		CSSPlugin.suffixMap = {top:p, right:p, bottom:p, left:p, width:p, height:p, fontSize:p, padding:p, margin:p, perspective:p, lineHeight:""};


		var _numExp = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
			_relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
			_valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, //finds all the values that begin with numbers or += or -= and then a number. Includes suffixes. We use this to split complex values apart like "1px 5px 20px rgb(255,102,51)"
			_NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, //also allows scientific notation and doesn't kill the leading -/+ in -= and +=
			_suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
			_opacityExp = /opacity *= *([^)]*)/i,
			_opacityValExp = /opacity:([^;]*)/i,
			_alphaFilterExp = /alpha\(opacity *=.+?\)/i,
			_rgbhslExp = /^(rgb|hsl)/,
			_capsExp = /([A-Z])/g,
			_camelExp = /-([a-z])/gi,
			_urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, //for pulling out urls from url(...) or url("...") strings (some browsers wrap urls in quotes, some don't when reporting things like backgroundImage)
			_camelFunc = function(s, g) { return g.toUpperCase(); },
			_horizExp = /(?:Left|Right|Width)/i,
			_ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
			_ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
			_commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi, //finds any commas that are not within parenthesis
			_complexExp = /[\s,\(]/i, //for testing a string to find if it has a space, comma, or open parenthesis (clues that it's a complex value)
			_DEG2RAD = Math.PI / 180,
			_RAD2DEG = 180 / Math.PI,
			_forcePT = {},
			_dummyElement = {style:{}},
			_doc = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */].document || {createElement: function() {return _dummyElement;}},
			_createElement = function(type, ns) {
				return _doc.createElementNS ? _doc.createElementNS(ns || "http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
			},
			_tempDiv = _createElement("div"),
			_tempImg = _createElement("img"),
			_internals = CSSPlugin._internals = {_specialProps:_specialProps}, //provides a hook to a few internal methods that we need to access from inside other plugins
			_agent = (__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */].navigator || {}).userAgent || "",
			_autoRound,
			_reqSafariFix, //we won't apply the Safari transform fix until we actually come across a tween that affects a transform property (to maintain best performance).

			_isSafari,
			_isFirefox, //Firefox has a bug that causes 3D transformed elements to randomly disappear unless a repaint is forced after each update on each element.
			_isSafariLT6, //Safari (and Android 4 which uses a flavor of Safari) has a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's WebkitBackfaceVisibility to hidden (weird, I know). Doing this for Android 3 and earlier seems to actually cause other problems, though (fun!)
			_ieVers,
			_supportsOpacity = (function() { //we set _isSafari, _ieVers, _isFirefox, and _supportsOpacity all in one function here to reduce file size slightly, especially in the minified version.
				var i = _agent.indexOf("Android"),
					a = _createElement("a");
				_isSafari = (_agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || parseFloat(_agent.substr(i+8, 2)) > 3));
				_isSafariLT6 = (_isSafari && (parseFloat(_agent.substr(_agent.indexOf("Version/")+8, 2)) < 6));
				_isFirefox = (_agent.indexOf("Firefox") !== -1);
				if ((/MSIE ([0-9]{1,}[\.0-9]{0,})/).exec(_agent) || (/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/).exec(_agent)) {
					_ieVers = parseFloat( RegExp.$1 );
				}
				if (!a) {
					return false;
				}
				a.style.cssText = "top:1px;opacity:.55;";
				return /^0.55/.test(a.style.opacity);
			}()),
			_getIEOpacity = function(v) {
				return (_opacityExp.test( ((typeof(v) === "string") ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ) ? ( parseFloat( RegExp.$1 ) / 100 ) : 1);
			},
			_log = function(s) {//for logging messages, but in a way that won't throw errors in old versions of IE.
				if (__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */].console) {
					console.log(s);
				}
			},
			_target, //when initting a CSSPlugin, we set this variable so that we can access it from within many other functions without having to pass it around as params
			_index, //when initting a CSSPlugin, we set this variable so that we can access it from within many other functions without having to pass it around as params

			_prefixCSS = "", //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"
			_prefix = "", //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".

			// @private feed in a camelCase property name like "transform" and it will check to see if it is valid as-is or if it needs a vendor prefix. It returns the corrected camelCase property name (i.e. "WebkitTransform" or "MozTransform" or "transform" or null if no such property is found, like if the browser is IE8 or before, "transform" won't be found at all)
			_checkPropPrefix = function(p, e) {
				e = e || _tempDiv;
				var s = e.style,
					a, i;
				if (s[p] !== undefined) {
					return p;
				}
				p = p.charAt(0).toUpperCase() + p.substr(1);
				a = ["O","Moz","ms","Ms","Webkit"];
				i = 5;
				while (--i > -1 && s[a[i]+p] === undefined) { }
				if (i >= 0) {
					_prefix = (i === 3) ? "ms" : a[i];
					_prefixCSS = "-" + _prefix.toLowerCase() + "-";
					return _prefix + p;
				}
				return null;
			},

			_getComputedStyle = (typeof(window) !== "undefined" ? window : _doc.defaultView || {getComputedStyle:function() {}}).getComputedStyle,

			/**
			 * @private Returns the css style for a particular property of an element. For example, to get whatever the current "left" css value for an element with an ID of "myElement", you could do:
			 * var currentLeft = CSSPlugin.getStyle( document.getElementById("myElement"), "left");
			 *
			 * @param {!Object} t Target element whose style property you want to query
			 * @param {!string} p Property name (like "left" or "top" or "marginTop", etc.)
			 * @param {Object=} cs Computed style object. This just provides a way to speed processing if you're going to get several properties on the same element in quick succession - you can reuse the result of the getComputedStyle() call.
			 * @param {boolean=} calc If true, the value will not be read directly from the element's "style" property (if it exists there), but instead the getComputedStyle() result will be used. This can be useful when you want to ensure that the browser itself is interpreting the value.
			 * @param {string=} dflt Default value that should be returned in the place of null, "none", "auto" or "auto auto".
			 * @return {?string} The current property value
			 */
			_getStyle = CSSPlugin.getStyle = function(t, p, cs, calc, dflt) {
				var rv;
				if (!_supportsOpacity) if (p === "opacity") { //several versions of IE don't use the standard "opacity" property - they use things like filter:alpha(opacity=50), so we parse that here.
					return _getIEOpacity(t);
				}
				if (!calc && t.style[p]) {
					rv = t.style[p];
				} else if ((cs = cs || _getComputedStyle(t))) {
					rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
				} else if (t.currentStyle) {
					rv = t.currentStyle[p];
				}
				return (dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto")) ? dflt : rv;
			},

			/**
			 * @private Pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number.
			 * @param {!Object} t Target element
			 * @param {!string} p Property name (like "left", "top", "marginLeft", etc.)
			 * @param {!number} v Value
			 * @param {string=} sfx Suffix (like "px" or "%" or "em")
			 * @param {boolean=} recurse If true, the call is a recursive one. In some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
			 * @return {number} value in pixels
			 */
			_convertToPixels = _internals.convertToPixels = function(t, p, v, sfx, recurse) {
				if (sfx === "px" || (!sfx && p !== "lineHeight")) { return v; }
				if (sfx === "auto" || !v) { return 0; }
				var horiz = _horizExp.test(p),
					node = t,
					style = _tempDiv.style,
					neg = (v < 0),
					precise = (v === 1),
					pix, cache, time;
				if (neg) {
					v = -v;
				}
				if (precise) {
					v *= 100;
				}
				if (p === "lineHeight" && !sfx) { //special case of when a simple lineHeight (without a unit) is used. Set it to the value, read back the computed value, and then revert.
					cache = _getComputedStyle(t).lineHeight;
					t.style.lineHeight = v;
					pix = parseFloat(_getComputedStyle(t).lineHeight);
					t.style.lineHeight = cache;
				} else if (sfx === "%" && p.indexOf("border") !== -1) {
					pix = (v / 100) * (horiz ? t.clientWidth : t.clientHeight);
				} else {
					style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
					if (sfx === "%" || !node.appendChild || sfx.charAt(0) === "v" || sfx === "rem") {
						node = t.parentNode || _doc.body;
						if (_getStyle(node, "display").indexOf("flex") !== -1) { //Edge and IE11 have a bug that causes offsetWidth to report as 0 if the container has display:flex and the child is position:relative. Switching to position: absolute solves it.
							style.position = "absolute";
						}
						cache = node._gsCache;
						time = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].ticker.frame;
						if (cache && horiz && cache.time === time) { //performance optimization: we record the width of elements along with the ticker frame so that we can quickly get it again on the same tick (seems relatively safe to assume it wouldn't change on the same tick)
							return cache.width * v / 100;
						}
						style[(horiz ? "width" : "height")] = v + sfx;
					} else {
						style[(horiz ? "borderLeftWidth" : "borderTopWidth")] = v + sfx;
					}
					node.appendChild(_tempDiv);
					pix = parseFloat(_tempDiv[(horiz ? "offsetWidth" : "offsetHeight")]);
					node.removeChild(_tempDiv);
					if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
						cache = node._gsCache = node._gsCache || {};
						cache.time = time;
						cache.width = pix / v * 100;
					}
					if (pix === 0 && !recurse) {
						pix = _convertToPixels(t, p, v, sfx, true);
					}
				}
				if (precise) {
					pix /= 100;
				}
				return neg ? -pix : pix;
			},
			_calculateOffset = _internals.calculateOffset = function(t, p, cs) { //for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
				if (_getStyle(t, "position", cs) !== "absolute") { return 0; }
				var dim = ((p === "left") ? "Left" : "Top"),
					v = _getStyle(t, "margin" + dim, cs);
				return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
			},

			// @private returns at object containing ALL of the style properties in camelCase and their associated values.
			_getAllStyles = function(t, cs) {
				var s = {},
					i, tr, p;
				if ((cs = cs || _getComputedStyle(t, null))) {
					if ((i = cs.length)) {
						while (--i > -1) {
							p = cs[i];
							if (p.indexOf("-transform") === -1 || _transformPropCSS === p) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
								s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);
							}
						}
					} else { //some browsers behave differently - cs.length is always 0, so we must do a for...in loop.
						for (i in cs) {
							if (i.indexOf("Transform") === -1 || _transformProp === i) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
								s[i] = cs[i];
							}
						}
					}
				} else if ((cs = t.currentStyle || t.style)) {
					for (i in cs) {
						if (typeof(i) === "string" && s[i] === undefined) {
							s[i.replace(_camelExp, _camelFunc)] = cs[i];
						}
					}
				}
				if (!_supportsOpacity) {
					s.opacity = _getIEOpacity(t);
				}
				tr = _getTransform(t, cs, false);
				s.rotation = tr.rotation;
				s.skewX = tr.skewX;
				s.scaleX = tr.scaleX;
				s.scaleY = tr.scaleY;
				s.x = tr.x;
				s.y = tr.y;
				if (_supports3D) {
					s.z = tr.z;
					s.rotationX = tr.rotationX;
					s.rotationY = tr.rotationY;
					s.scaleZ = tr.scaleZ;
				}
				if (s.filters) {
					delete s.filters;
				}
				return s;
			},

			// @private analyzes two style objects (as returned by _getAllStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object with a "difs" property which refers to an object containing only those isolated properties and values for tweening, and a "firstMPT" property which refers to the first MiniPropTween instance in a linked list that recorded all the starting values of the different properties so that we can revert to them at the end or beginning of the tween - we don't want the cascading to get messed up. The forceLookup parameter is an optional generic object with properties that should be forced into the results - this is necessary for className tweens that are overwriting others because imagine a scenario where a rollover/rollout adds/removes a class and the user swipes the mouse over the target SUPER fast, thus nothing actually changed yet and the subsequent comparison of the properties would indicate they match (especially when px rounding is taken into consideration), thus no tweening is necessary even though it SHOULD tween and remove those properties after the tween (otherwise the inline styles will contaminate things). See the className SpecialProp code for details.
			_cssDif = function(t, s1, s2, vars, forceLookup) {
				var difs = {},
					style = t.style,
					val, p, mpt;
				for (p in s2) {
					if (p !== "cssText") if (p !== "length") if (isNaN(p)) if (s1[p] !== (val = s2[p]) || (forceLookup && forceLookup[p])) if (p.indexOf("Origin") === -1) if (typeof(val) === "number" || typeof(val) === "string") {
						difs[p] = (val === "auto" && (p === "left" || p === "top")) ? _calculateOffset(t, p) : ((val === "" || val === "auto" || val === "none") && typeof(s1[p]) === "string" && s1[p].replace(_NaNExp, "") !== "") ? 0 : val; //if the ending value is defaulting ("" or "auto"), we check the starting value and if it can be parsed into a number (a string which could have a suffix too, like 700px), then we swap in 0 for "" or "auto" so that things actually tween.
						if (style[p] !== undefined) { //for className tweens, we must remember which properties already existed inline - the ones that didn't should be removed when the tween isn't in progress because they were only introduced to facilitate the transition between classes.
							mpt = new MiniPropTween(style, p, style[p], mpt);
						}
					}
				}
				if (vars) {
					for (p in vars) { //copy properties (except className)
						if (p !== "className") {
							difs[p] = vars[p];
						}
					}
				}
				return {difs:difs, firstMPT:mpt};
			},
			_dimensions = {width:["Left","Right"], height:["Top","Bottom"]},
			_margins = ["marginLeft","marginRight","marginTop","marginBottom"],

			/**
			 * @private Gets the width or height of an element
			 * @param {!Object} t Target element
			 * @param {!string} p Property name ("width" or "height")
			 * @param {Object=} cs Computed style object (if one exists). Just a speed optimization.
			 * @return {number} Dimension (in pixels)
			 */
			_getDimension = function(t, p, cs) {
				if ((t.nodeName + "").toLowerCase() === "svg") { //Chrome no longer supports offsetWidth/offsetHeight on SVG elements.
					return (cs || _getComputedStyle(t))[p] || 0;
				} else if (t.getCTM && _isSVG(t)) {
					return t.getBBox()[p] || 0;
				}
				var v = parseFloat((p === "width") ? t.offsetWidth : t.offsetHeight),
					a = _dimensions[p],
					i = a.length;
				cs = cs || _getComputedStyle(t, null);
				while (--i > -1) {
					v -= parseFloat( _getStyle(t, "padding" + a[i], cs, true) ) || 0;
					v -= parseFloat( _getStyle(t, "border" + a[i] + "Width", cs, true) ) || 0;
				}
				return v;
			},

			// @private Parses position-related complex strings like "top left" or "50px 10px" or "70% 20%", etc. which are used for things like transformOrigin or backgroundPosition. Optionally decorates a supplied object (recObj) with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
			_parsePosition = function(v, recObj) {
				if (v === "contain" || v === "auto" || v === "auto auto") { //note: Firefox uses "auto auto" as default whereas Chrome uses "auto".
					return v + " ";
				}
				if (v == null || v === "") {
					v = "0 0";
				}
				var a = v.split(" "),
					x = (v.indexOf("left") !== -1) ? "0%" : (v.indexOf("right") !== -1) ? "100%" : a[0],
					y = (v.indexOf("top") !== -1) ? "0%" : (v.indexOf("bottom") !== -1) ? "100%" : a[1],
					i;
				if (a.length > 3 && !recObj) { //multiple positions
					a = v.split(", ").join(",").split(",");
					v = [];
					for (i = 0; i < a.length; i++) {
						v.push(_parsePosition(a[i]));
					}
					return v.join(",");
				}
				if (y == null) {
					y = (x === "center") ? "50%" : "0";
				} else if (y === "center") {
					y = "50%";
				}
				if (x === "center" || (isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1)) { //remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
					x = "50%";
				}
				v = x + " " + y + ((a.length > 2) ? " " + a[2] : "");
				if (recObj) {
					recObj.oxp = (x.indexOf("%") !== -1);
					recObj.oyp = (y.indexOf("%") !== -1);
					recObj.oxr = (x.charAt(1) === "=");
					recObj.oyr = (y.charAt(1) === "=");
					recObj.ox = parseFloat(x.replace(_NaNExp, ""));
					recObj.oy = parseFloat(y.replace(_NaNExp, ""));
					recObj.v = v;
				}
				return recObj || v;
			},

			/**
			 * @private Takes an ending value (typically a string, but can be a number) and a starting value and returns the change between the two, looking for relative value indicators like += and -= and it also ignores suffixes (but make sure the ending value starts with a number or +=/-= and that the starting value is a NUMBER!)
			 * @param {(number|string)} e End value which is typically a string, but could be a number
			 * @param {(number|string)} b Beginning value which is typically a string but could be a number
			 * @return {number} Amount of change between the beginning and ending values (relative values that have a "+=" or "-=" are recognized)
			 */
			_parseChange = function(e, b) {
				if (typeof(e) === "function") {
					e = e(_index, _target);
				}
				return (typeof(e) === "string" && e.charAt(1) === "=") ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : (parseFloat(e) - parseFloat(b)) || 0;
			},

			/**
			 * @private Takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
			 * @param {Object} v Value to be parsed
			 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
			 * @return {number} Parsed value
			 */
			_parseVal = function(v, d) {
				if (typeof(v) === "function") {
					v = v(_index, _target);
				}
				var isRelative = (typeof(v) === "string" && v.charAt(1) === "=");
				if (typeof(v) === "string" && v.charAt(v.length - 2) === "v") { //convert vw and vh into px-equivalents.
					v = (isRelative ? v.substr(0, 2) : 0) + (window["inner" + ((v.substr(-2) === "vh") ? "Height" : "Width")] * (parseFloat(isRelative ? v.substr(2) : v) / 100));
				}
				return (v == null) ? d : isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v) || 0;
			},

			/**
			 * @private Translates strings like "40deg" or "40" or 40rad" or "+=40deg" or "270_short" or "-90_cw" or "+=45_ccw" to a numeric radian angle. Of course a starting/default value must be fed in too so that relative values can be calculated properly.
			 * @param {Object} v Value to be parsed
			 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
			 * @param {string=} p property name for directionalEnd (optional - only used when the parsed value is directional ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation). Property name would be "rotation", "rotationX", or "rotationY"
			 * @param {Object=} directionalEnd An object that will store the raw end values for directional angles ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation.
			 * @return {number} parsed angle in radians
			 */
			_parseAngle = function(v, d, p, directionalEnd) {
				var min = 0.000001,
					cap, split, dif, result, isRelative;
				if (typeof(v) === "function") {
					v = v(_index, _target);
				}
				if (v == null) {
					result = d;
				} else if (typeof(v) === "number") {
					result = v;
				} else {
					cap = 360;
					split = v.split("_");
					isRelative = (v.charAt(1) === "=");
					dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * ((v.indexOf("rad") === -1) ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
					if (split.length) {
						if (directionalEnd) {
							directionalEnd[p] = d + dif;
						}
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = (dif < 0) ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						}
					}
					result = d + dif;
				}
				if (result < min && result > -min) {
					result = 0;
				}
				return result;
			},

			_colorLookup = {aqua:[0,255,255],
				lime:[0,255,0],
				silver:[192,192,192],
				black:[0,0,0],
				maroon:[128,0,0],
				teal:[0,128,128],
				blue:[0,0,255],
				navy:[0,0,128],
				white:[255,255,255],
				fuchsia:[255,0,255],
				olive:[128,128,0],
				yellow:[255,255,0],
				orange:[255,165,0],
				gray:[128,128,128],
				purple:[128,0,128],
				green:[0,128,0],
				red:[255,0,0],
				pink:[255,192,203],
				cyan:[0,255,255],
				transparent:[255,255,255,0]},

			_hue = function(h, m1, m2) {
				h = (h < 0) ? h + 1 : (h > 1) ? h - 1 : h;
				return ((((h * 6 < 1) ? m1 + (m2 - m1) * h * 6 : (h < 0.5) ? m2 : (h * 3 < 2) ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255) + 0.5) | 0;
			},

			/**
			 * @private Parses a color (like #9F0, #FF9900, rgb(255,51,153) or hsl(108, 50%, 10%)) into an array with 3 elements for red, green, and blue or if toHSL parameter is true, it will populate the array with hue, saturation, and lightness values. If a relative value is found in an hsl() or hsla() string, it will preserve those relative prefixes and all the values in the array will be strings instead of numbers (in all other cases it will be populated with numbers).
			 * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
			 * @param {(boolean)} toHSL If true, an hsl() or hsla() value will be returned instead of rgb() or rgba()
			 * @return {Array.<number>} An array containing red, green, and blue (and optionally alpha) in that order, or if the toHSL parameter was true, the array will contain hue, saturation and lightness (and optionally alpha) in that order. Always numbers unless there's a relative prefix found in an hsl() or hsla() string and toHSL is true.
			 */
			_parseColor = CSSPlugin.parseColor = function(v, toHSL) {
				var a, r, g, b, h, s, l, max, min, d, wasHSL;
				if (!v) {
					a = _colorLookup.black;
				} else if (typeof(v) === "number") {
					a = [v >> 16, (v >> 8) & 255, v & 255];
				} else {
					if (v.charAt(v.length - 1) === ",") { //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
						v = v.substr(0, v.length - 1);
					}
					if (_colorLookup[v]) {
						a = _colorLookup[v];
					} else if (v.charAt(0) === "#") {
						if (v.length === 4) { //for shorthand like #9F0
							r = v.charAt(1);
							g = v.charAt(2);
							b = v.charAt(3);
							v = "#" + r + r + g + g + b + b;
						}
						v = parseInt(v.substr(1), 16);
						a = [v >> 16, (v >> 8) & 255, v & 255];
					} else if (v.substr(0, 3) === "hsl") {
						a = wasHSL = v.match(_numExp);
						if (!toHSL) {
							h = (Number(a[0]) % 360) / 360;
							s = Number(a[1]) / 100;
							l = Number(a[2]) / 100;
							g = (l <= 0.5) ? l * (s + 1) : l + s - l * s;
							r = l * 2 - g;
							if (a.length > 3) {
								a[3] = Number(a[3]);
							}
							a[0] = _hue(h + 1 / 3, r, g);
							a[1] = _hue(h, r, g);
							a[2] = _hue(h - 1 / 3, r, g);
						} else if (v.indexOf("=") !== -1) { //if relative values are found, just return the raw strings with the relative prefixes in place.
							return v.match(_relNumExp);
						}
					} else {
						a = v.match(_numExp) || _colorLookup.transparent;
					}
					a[0] = Number(a[0]);
					a[1] = Number(a[1]);
					a[2] = Number(a[2]);
					if (a.length > 3) {
						a[3] = Number(a[3]);
					}
				}
				if (toHSL && !wasHSL) {
					r = a[0] / 255;
					g = a[1] / 255;
					b = a[2] / 255;
					max = Math.max(r, g, b);
					min = Math.min(r, g, b);
					l = (max + min) / 2;
					if (max === min) {
						h = s = 0;
					} else {
						d = max - min;
						s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
						h = (max === r) ? (g - b) / d + (g < b ? 6 : 0) : (max === g) ? (b - r) / d + 2 : (r - g) / d + 4;
						h *= 60;
					}
					a[0] = (h + 0.5) | 0;
					a[1] = (s * 100 + 0.5) | 0;
					a[2] = (l * 100 + 0.5) | 0;
				}
				return a;
			},
			_formatColors = function(s, toHSL) {
				var colors = s.match(_colorExp) || [],
					charIndex = 0,
					parsed = "",
					i, color, temp;
				if (!colors.length) {
					return s;
				}
				for (i = 0; i < colors.length; i++) {
					color = colors[i];
					temp = s.substr(charIndex, s.indexOf(color, charIndex)-charIndex);
					charIndex += temp.length + color.length;
					color = _parseColor(color, toHSL);
					if (color.length === 3) {
						color.push(1);
					}
					parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
				}
				return parsed + s.substr(charIndex);
			},
			_colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.

		for (p in _colorLookup) {
			_colorExp += "|" + p + "\\b";
		}
		_colorExp = new RegExp(_colorExp+")", "gi");

		CSSPlugin.colorStringFilter = function(a) {
			var combined = a[0] + " " + a[1],
				toHSL;
			if (_colorExp.test(combined)) {
				toHSL = (combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1);
				a[0] = _formatColors(a[0], toHSL);
				a[1] = _formatColors(a[1], toHSL);
			}
			_colorExp.lastIndex = 0;
		};

		if (!__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].defaultStringFilter) {
			__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].defaultStringFilter = CSSPlugin.colorStringFilter;
		}

		/**
		 * @private Returns a formatter function that handles taking a string (or number in some cases) and returning a consistently formatted one in terms of delimiters, quantity of values, etc. For example, we may get boxShadow values defined as "0px red" or "0px 0px 10px rgb(255,0,0)" or "0px 0px 20px 20px #F00" and we need to ensure that what we get back is described with 4 numbers and a color. This allows us to feed it into the _parseComplex() method and split the values up appropriately. The neat thing about this _getFormatter() function is that the dflt defines a pattern as well as a default, so for example, _getFormatter("0px 0px 0px 0px #777", true) not only sets the default as 0px for all distances and #777 for the color, but also sets the pattern such that 4 numbers and a color will always get returned.
		 * @param {!string} dflt The default value and pattern to follow. So "0px 0px 0px 0px #777" will ensure that 4 numbers and a color will always get returned.
		 * @param {boolean=} clr If true, the values should be searched for color-related data. For example, boxShadow values typically contain a color whereas borderRadius don't.
		 * @param {boolean=} collapsible If true, the value is a top/left/right/bottom style one that acts like margin or padding, where if only one value is received, it's used for all 4; if 2 are received, the first is duplicated for 3rd (bottom) and the 2nd is duplicated for the 4th spot (left), etc.
		 * @return {Function} formatter function
		 */
		var _getFormatter = function(dflt, clr, collapsible, multi) {
				if (dflt == null) {
					return function(v) {return v;};
				}
				var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
					dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
					pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
					sfx = (dflt.charAt(dflt.length - 1) === ")") ? ")" : "",
					delim = (dflt.indexOf(" ") !== -1) ? " " : ",",
					numVals = dVals.length,
					dSfx = (numVals > 0) ? dVals[0].replace(_numExp, "") : "",
					formatter;
				if (!numVals) {
					return function(v) {return v;};
				}
				if (clr) {
					formatter = function(v) {
						var color, vals, i, a;
						if (typeof(v) === "number") {
							v += dSfx;
						} else if (multi && _commasOutsideParenExp.test(v)) {
							a = v.replace(_commasOutsideParenExp, "|").split("|");
							for (i = 0; i < a.length; i++) {
								a[i] = formatter(a[i]);
							}
							return a.join(",");
						}
						color = (v.match(_colorExp) || [dColor])[0];
						vals = v.split(color).join("").match(_valuesExp) || [];
						i = vals.length;
						if (numVals > i--) {
							while (++i < numVals) {
								vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
							}
						}
						return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
					};
					return formatter;

				}
				formatter = function(v) {
					var vals, a, i;
					if (typeof(v) === "number") {
						v += dSfx;
					} else if (multi && _commasOutsideParenExp.test(v)) {
						a = v.replace(_commasOutsideParenExp, "|").split("|");
						for (i = 0; i < a.length; i++) {
							a[i] = formatter(a[i]);
						}
						return a.join(",");
					}
					vals = v.match(_valuesExp) || [];
					i = vals.length;
					if (numVals > i--) {
						while (++i < numVals) {
							vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
						}
					}
					return pfx + vals.join(delim) + sfx;
				};
				return formatter;
			},

			/**
			 * @private returns a formatter function that's used for edge-related values like marginTop, marginLeft, paddingBottom, paddingRight, etc. Just pass a comma-delimited list of property names related to the edges.
			 * @param {!string} props a comma-delimited list of property names in order from top to left, like "marginTop,marginRight,marginBottom,marginLeft"
			 * @return {Function} a formatter function
			 */
			_getEdgeParser = function(props) {
				props = props.split(",");
				return function(t, e, p, cssp, pt, plugin, vars) {
					var a = (e + "").split(" "),
						i;
					vars = {};
					for (i = 0; i < 4; i++) {
						vars[props[i]] = a[i] = a[i] || a[(((i - 1) / 2) >> 0)];
					}
					return cssp.parse(t, vars, pt, plugin);
				};
			},

			// @private used when other plugins must tween values first, like BezierPlugin or ThrowPropsPlugin, etc. That plugin's setRatio() gets called first so that the values are updated, and then we loop through the MiniPropTweens which handle copying the values into their appropriate slots so that they can then be applied correctly in the main CSSPlugin setRatio() method. Remember, we typically create a proxy object that has a bunch of uniquely-named properties that we feed to the sub-plugin and it does its magic normally, and then we must interpret those values and apply them to the css because often numbers must get combined/concatenated, suffixes added, etc. to work with css, like boxShadow could have 4 values plus a color.
			_setPluginRatio = _internals._setPluginRatio = function(v) {
				this.plugin.setRatio(v);
				var d = this.data,
					proxy = d.proxy,
					mpt = d.firstMPT,
					min = 0.000001,
					val, pt, i, str, p;
				while (mpt) {
					val = proxy[mpt.v];
					if (mpt.r) {
						val = mpt.r(val);
					} else if (val < min && val > -min) {
						val = 0;
					}
					mpt.t[mpt.p] = val;
					mpt = mpt._next;
				}
				if (d.autoRotate) {
					d.autoRotate.rotation = d.mod ? d.mod.call(this._tween, proxy.rotation, this.t, this._tween) : proxy.rotation; //special case for ModifyPlugin to hook into an auto-rotating bezier
				}
				//at the end, we must set the CSSPropTween's "e" (end) value dynamically here because that's what is used in the final setRatio() method. Same for "b" at the beginning.
				if (v === 1 || v === 0) {
					mpt = d.firstMPT;
					p = (v === 1) ? "e" : "b";
					while (mpt) {
						pt = mpt.t;
						if (!pt.type) {
							pt[p] = pt.s + pt.xs0;
						} else if (pt.type === 1) {
							str = pt.xs0 + pt.s + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn"+i] + pt["xs"+(i+1)];
							}
							pt[p] = str;
						}
						mpt = mpt._next;
					}
				}
			},

			/**
			 * @private @constructor Used by a few SpecialProps to hold important values for proxies. For example, _parseToProxy() creates a MiniPropTween instance for each property that must get tweened on the proxy, and we record the original property name as well as the unique one we create for the proxy, plus whether or not the value needs to be rounded plus the original value.
			 * @param {!Object} t target object whose property we're tweening (often a CSSPropTween)
			 * @param {!string} p property name
			 * @param {(number|string|object)} v value
			 * @param {MiniPropTween=} next next MiniPropTween in the linked list
			 * @param {boolean=} r if true, the tweened value should be rounded to the nearest integer
			 */
			MiniPropTween = function(t, p, v, next, r) {
				this.t = t;
				this.p = p;
				this.v = v;
				this.r = r;
				if (next) {
					next._prev = this;
					this._next = next;
				}
			},

			/**
			 * @private Most other plugins (like BezierPlugin and ThrowPropsPlugin and others) can only tween numeric values, but CSSPlugin must accommodate special values that have a bunch of extra data (like a suffix or strings between numeric values, etc.). For example, boxShadow has values like "10px 10px 20px 30px rgb(255,0,0)" which would utterly confuse other plugins. This method allows us to split that data apart and grab only the numeric data and attach it to uniquely-named properties of a generic proxy object ({}) so that we can feed that to virtually any plugin to have the numbers tweened. However, we must also keep track of which properties from the proxy go with which CSSPropTween values and instances. So we create a linked list of MiniPropTweens. Each one records a target (the original CSSPropTween), property (like "s" or "xn1" or "xn2") that we're tweening and the unique property name that was used for the proxy (like "boxShadow_xn1" and "boxShadow_xn2") and whether or not they need to be rounded. That way, in the _setPluginRatio() method we can simply copy the values over from the proxy to the CSSPropTween instance(s). Then, when the main CSSPlugin setRatio() method runs and applies the CSSPropTween values accordingly, they're updated nicely. So the external plugin tweens the numbers, _setPluginRatio() copies them over, and setRatio() acts normally, applying css-specific values to the element.
			 * This method returns an object that has the following properties:
			 *  - proxy: a generic object containing the starting values for all the properties that will be tweened by the external plugin.  This is what we feed to the external _onInitTween() as the target
			 *  - end: a generic object containing the ending values for all the properties that will be tweened by the external plugin. This is what we feed to the external plugin's _onInitTween() as the destination values
			 *  - firstMPT: the first MiniPropTween in the linked list
			 *  - pt: the first CSSPropTween in the linked list that was created when parsing. If shallow is true, this linked list will NOT attach to the one passed into the _parseToProxy() as the "pt" (4th) parameter.
			 * @param {!Object} t target object to be tweened
			 * @param {!(Object|string)} vars the object containing the information about the tweening values (typically the end/destination values) that should be parsed
			 * @param {!CSSPlugin} cssp The CSSPlugin instance
			 * @param {CSSPropTween=} pt the next CSSPropTween in the linked list
			 * @param {TweenPlugin=} plugin the external TweenPlugin instance that will be handling tweening the numeric values
			 * @param {boolean=} shallow if true, the resulting linked list from the parse will NOT be attached to the CSSPropTween that was passed in as the "pt" (4th) parameter.
			 * @return An object containing the following properties: proxy, end, firstMPT, and pt (see above for descriptions)
			 */
			_parseToProxy = _internals._parseToProxy = function(t, vars, cssp, pt, plugin, shallow) {
				var bpt = pt,
					start = {},
					end = {},
					transform = cssp._transform,
					oldForce = _forcePT,
					i, p, xp, mpt, firstPT;
				cssp._transform = null;
				_forcePT = vars;
				pt = firstPT = cssp.parse(t, vars, pt, plugin);
				_forcePT = oldForce;
				//break off from the linked list so the new ones are isolated.
				if (shallow) {
					cssp._transform = transform;
					if (bpt) {
						bpt._prev = null;
						if (bpt._prev) {
							bpt._prev._next = null;
						}
					}
				}
				while (pt && pt !== bpt) {
					if (pt.type <= 1) {
						p = pt.p;
						end[p] = pt.s + pt.c;
						start[p] = pt.s;
						if (!shallow) {
							mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
							pt.c = 0;
						}
						if (pt.type === 1) {
							i = pt.l;
							while (--i > 0) {
								xp = "xn" + i;
								p = pt.p + "_" + xp;
								end[p] = pt.data[xp];
								start[p] = pt[xp];
								if (!shallow) {
									mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
								}
							}
						}
					}
					pt = pt._next;
				}
				return {proxy:start, end:end, firstMPT:mpt, pt:firstPT};
			},



			/**
			 * @constructor Each property that is tweened has at least one CSSPropTween associated with it. These instances store important information like the target, property, starting value, amount of change, etc. They can also optionally have a number of "extra" strings and numeric values named xs1, xn1, xs2, xn2, xs3, xn3, etc. where "s" indicates string and "n" indicates number. These can be pieced together in a complex-value tween (type:1) that has alternating types of data like a string, number, string, number, etc. For example, boxShadow could be "5px 5px 8px rgb(102, 102, 51)". In that value, there are 6 numbers that may need to tween and then pieced back together into a string again with spaces, suffixes, etc. xs0 is special in that it stores the suffix for standard (type:0) tweens, -OR- the first string (prefix) in a complex-value (type:1) CSSPropTween -OR- it can be the non-tweening value in a type:-1 CSSPropTween. We do this to conserve memory.
			 * CSSPropTweens have the following optional properties as well (not defined through the constructor):
			 *  - l: Length in terms of the number of extra properties that the CSSPropTween has (default: 0). For example, for a boxShadow we may need to tween 5 numbers in which case l would be 5; Keep in mind that the start/end values for the first number that's tweened are always stored in the s and c properties to conserve memory. All additional values thereafter are stored in xn1, xn2, etc.
			 *  - xfirst: The first instance of any sub-CSSPropTweens that are tweening properties of this instance. For example, we may split up a boxShadow tween so that there's a main CSSPropTween of type:1 that has various xs* and xn* values associated with the h-shadow, v-shadow, blur, color, etc. Then we spawn a CSSPropTween for each of those that has a higher priority and runs BEFORE the main CSSPropTween so that the values are all set by the time it needs to re-assemble them. The xfirst gives us an easy way to identify the first one in that chain which typically ends at the main one (because they're all prepende to the linked list)
			 *  - plugin: The TweenPlugin instance that will handle the tweening of any complex values. For example, sometimes we don't want to use normal subtweens (like xfirst refers to) to tween the values - we might want ThrowPropsPlugin or BezierPlugin some other plugin to do the actual tweening, so we create a plugin instance and store a reference here. We need this reference so that if we get a request to round values or disable a tween, we can pass along that request.
			 *  - data: Arbitrary data that needs to be stored with the CSSPropTween. Typically if we're going to have a plugin handle the tweening of a complex-value tween, we create a generic object that stores the END values that we're tweening to and the CSSPropTween's xs1, xs2, etc. have the starting values. We store that object as data. That way, we can simply pass that object to the plugin and use the CSSPropTween as the target.
			 *  - setRatio: Only used for type:2 tweens that require custom functionality. In this case, we call the CSSPropTween's setRatio() method and pass the ratio each time the tween updates. This isn't quite as efficient as doing things directly in the CSSPlugin's setRatio() method, but it's very convenient and flexible.
			 * @param {!Object} t Target object whose property will be tweened. Often a DOM element, but not always. It could be anything.
			 * @param {string} p Property to tween (name). For example, to tween element.width, p would be "width".
			 * @param {number} s Starting numeric value
			 * @param {number} c Change in numeric value over the course of the entire tween. For example, if element.width starts at 5 and should end at 100, c would be 95.
			 * @param {CSSPropTween=} next The next CSSPropTween in the linked list. If one is defined, we will define its _prev as the new instance, and the new instance's _next will be pointed at it.
			 * @param {number=} type The type of CSSPropTween where -1 = a non-tweening value, 0 = a standard simple tween, 1 = a complex value (like one that has multiple numbers in a comma- or space-delimited string like border:"1px solid red"), and 2 = one that uses a custom setRatio function that does all of the work of applying the values on each update.
			 * @param {string=} n Name of the property that should be used for overwriting purposes which is typically the same as p but not always. For example, we may need to create a subtween for the 2nd part of a "clip:rect(...)" tween in which case "p" might be xs1 but "n" is still "clip"
			 * @param {boolean=} r If true, the value(s) should be rounded
			 * @param {number=} pr Priority in the linked list order. Higher priority CSSPropTweens will be updated before lower priority ones. The default priority is 0.
			 * @param {string=} b Beginning value. We store this to ensure that it is EXACTLY what it was when the tween began without any risk of interpretation issues.
			 * @param {string=} e Ending value. We store this to ensure that it is EXACTLY what the user defined at the end of the tween without any risk of interpretation issues.
			 */
			CSSPropTween = _internals.CSSPropTween = function(t, p, s, c, next, type, n, r, pr, b, e) {
				this.t = t; //target
				this.p = p; //property
				this.s = s; //starting value
				this.c = c; //change value
				this.n = n || p; //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting looks at)
				if (!(t instanceof CSSPropTween)) {
					_overwriteProps.push(this.n);
				}
				this.r = !r ? r : (typeof(r) === "function") ? r : Math.round; //round (boolean)
				this.type = type || 0; //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target's property, like tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work
				if (pr) {
					this.pr = pr;
					_hasPriority = true;
				}
				this.b = (b === undefined) ? s : b;
				this.e = (e === undefined) ? s + c : e;
				if (next) {
					this._next = next;
					next._prev = this;
				}
			},

			_addNonTweeningNumericPT = function(target, prop, start, end, next, overwriteProp) { //cleans up some code redundancies and helps minification. Just a fast way to add a NUMERIC non-tweening CSSPropTween
				var pt = new CSSPropTween(target, prop, start, end - start, next, -1, overwriteProp);
				pt.b = start;
				pt.e = pt.xs0 = end;
				return pt;
			},

			/**
			 * Takes a target, the beginning value and ending value (as strings) and parses them into a CSSPropTween (possibly with child CSSPropTweens) that accommodates multiple numbers, colors, comma-delimited values, etc. For example:
			 * sp.parseComplex(element, "boxShadow", "5px 10px 20px rgb(255,102,51)", "0px 0px 0px red", true, "0px 0px 0px rgb(0,0,0,0)", pt);
			 * It will walk through the beginning and ending values (which should be in the same format with the same number and type of values) and figure out which parts are numbers, what strings separate the numeric/tweenable values, and then create the CSSPropTweens accordingly. If a plugin is defined, no child CSSPropTweens will be created. Instead, the ending values will be stored in the "data" property of the returned CSSPropTween like: {s:-5, xn1:-10, xn2:-20, xn3:255, xn4:0, xn5:0} so that it can be fed to any other plugin and it'll be plain numeric tweens but the recomposition of the complex value will be handled inside CSSPlugin's setRatio().
			 * If a setRatio is defined, the type of the CSSPropTween will be set to 2 and recomposition of the values will be the responsibility of that method.
			 *
			 * @param {!Object} t Target whose property will be tweened
			 * @param {!string} p Property that will be tweened (its name, like "left" or "backgroundColor" or "boxShadow")
			 * @param {string} b Beginning value
			 * @param {string} e Ending value
			 * @param {boolean} clrs If true, the value could contain a color value like "rgb(255,0,0)" or "#F00" or "red". The default is false, so no colors will be recognized (a performance optimization)
			 * @param {(string|number|Object)} dflt The default beginning value that should be used if no valid beginning value is defined or if the number of values inside the complex beginning and ending values don't match
			 * @param {?CSSPropTween} pt CSSPropTween instance that is the current head of the linked list (we'll prepend to this).
			 * @param {number=} pr Priority in the linked list order. Higher priority properties will be updated before lower priority ones. The default priority is 0.
			 * @param {TweenPlugin=} plugin If a plugin should handle the tweening of extra properties, pass the plugin instance here. If one is defined, then NO subtweens will be created for any extra properties (the properties will be created - just not additional CSSPropTween instances to tween them) because the plugin is expected to do so. However, the end values WILL be populated in the "data" property, like {s:100, xn1:50, xn2:300}
			 * @param {function(number)=} setRatio If values should be set in a custom function instead of being pieced together in a type:1 (complex-value) CSSPropTween, define that custom function here.
			 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parseComplex() call.
			 */
			_parseComplex = CSSPlugin.parseComplex = function(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
				//DEBUG: _log("parseComplex: "+p+", b: "+b+", e: "+e);
				b = b || dflt || "";
				if (typeof(e) === "function") {
					e = e(_index, _target);
				}
				pt = new CSSPropTween(t, p, 0, 0, pt, (setRatio ? 2 : 1), null, false, pr, b, e);
				e += ""; //ensures it's a string
				if (clrs && _colorExp.test(e + b)) { //if colors are found, normalize the formatting to rgba() or hsla().
					e = [b, e];
					CSSPlugin.colorStringFilter(e);
					b = e[0];
					e = e[1];
				}
				var ba = b.split(", ").join(",").split(" "), //beginning array
					ea = e.split(", ").join(",").split(" "), //ending array
					l = ba.length,
					autoRound = (_autoRound !== false),
					i, xi, ni, bv, ev, bnums, enums, bn, hasAlpha, temp, cv, str, useHSL;
				if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
					if ((e + b).indexOf("rgb") !== -1 || (e + b).indexOf("hsl") !== -1) { //keep rgb(), rgba(), hsl(), and hsla() values together! (remember, we're splitting on spaces)
						ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
						ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
					} else {
						ba = ba.join(" ").split(",").join(", ").split(" ");
						ea = ea.join(" ").split(",").join(", ").split(" ");
					}
					l = ba.length;
				}
				if (l !== ea.length) {
					//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
					ba = (dflt || "").split(" ");
					l = ba.length;
				}
				pt.plugin = plugin;
				pt.setRatio = setRatio;
				_colorExp.lastIndex = 0;
				for (i = 0; i < l; i++) {
					bv = ba[i];
					ev = ea[i] + "";
					bn = parseFloat(bv);
					//if the value begins with a number (most common). It's fine if it has a suffix like px
					if (bn || bn === 0) {
						pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), (autoRound && ev.indexOf("px") !== -1) ? Math.round : false, true);

					//if the value is a color
					} else if (clrs && _colorExp.test(bv)) {
						str = ev.indexOf(")") + 1;
						str = ")" + (str ? ev.substr(str) : ""); //if there's a comma or ) at the end, retain it.
						useHSL = (ev.indexOf("hsl") !== -1 && _supportsOpacity);
						temp = ev; //original string value so we can look for any prefix later.
						bv = _parseColor(bv, useHSL);
						ev = _parseColor(ev, useHSL);
						hasAlpha = (bv.length + ev.length > 6);
						if (hasAlpha && !_supportsOpacity && ev[3] === 0) { //older versions of IE don't support rgba(), so if the destination alpha is 0, just use "transparent" for the end color
							pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
							pt.e = pt.e.split(ea[i]).join("transparent");
						} else {
							if (!_supportsOpacity) { //old versions of IE don't support rgba().
								hasAlpha = false;
							}
							if (useHSL) {
								pt.appendXtra(temp.substr(0, temp.indexOf("hsl")) + (hasAlpha ? "hsla(" : "hsl("), bv[0], _parseChange(ev[0], bv[0]), ",", false, true)
									.appendXtra("", bv[1], _parseChange(ev[1], bv[1]), "%,", false)
									.appendXtra("", bv[2], _parseChange(ev[2], bv[2]), (hasAlpha ? "%," : "%" + str), false);
							} else {
								pt.appendXtra(temp.substr(0, temp.indexOf("rgb")) + (hasAlpha ? "rgba(" : "rgb("), bv[0], ev[0] - bv[0], ",", Math.round, true)
									.appendXtra("", bv[1], ev[1] - bv[1], ",", Math.round)
									.appendXtra("", bv[2], ev[2] - bv[2], (hasAlpha ? "," : str), Math.round);
							}

							if (hasAlpha) {
								bv = (bv.length < 4) ? 1 : bv[3];
								pt.appendXtra("", bv, ((ev.length < 4) ? 1 : ev[3]) - bv, str, false);
							}
						}
						_colorExp.lastIndex = 0; //otherwise the test() on the RegExp could move the lastIndex and taint future results.

					} else {
						bnums = bv.match(_numExp); //gets each group of numbers in the beginning value string and drops them into an array

						//if no number is found, treat it as a non-tweening value and just append the string to the current xs.
						if (!bnums) {
							pt["xs" + pt.l] += (pt.l || pt["xs" + pt.l]) ? " " + ev : ev;

						//loop through all the numbers that are found and construct the extra values on the pt.
						} else {
							enums = ev.match(_relNumExp); //get each group of numbers in the end value string and drop them into an array. We allow relative values too, like +=50 or -=.5
							if (!enums || enums.length !== bnums.length) {
								//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
								return pt;
							}
							ni = 0;
							for (xi = 0; xi < bnums.length; xi++) {
								cv = bnums[xi];
								temp = bv.indexOf(cv, ni);
								pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", (autoRound && bv.substr(temp + cv.length, 2) === "px") ? Math.round : false, (xi === 0));
								ni = temp + cv.length;
							}
							pt["xs" + pt.l] += bv.substr(ni);
						}
					}
				}
				//if there are relative values ("+=" or "-=" prefix), we need to adjust the ending value to eliminate the prefixes and combine the values properly.
				if (e.indexOf("=") !== -1) if (pt.data) {
					str = pt.xs0 + pt.data.s;
					for (i = 1; i < pt.l; i++) {
						str += pt["xs" + i] + pt.data["xn" + i];
					}
					pt.e = str + pt["xs" + i];
				}
				if (!pt.l) {
					pt.type = -1;
					pt.xs0 = pt.e;
				}
				return pt.xfirst || pt;
			},
			i = 9;


		p = CSSPropTween.prototype;
		p.l = p.pr = 0; //length (number of extra properties like xn1, xn2, xn3, etc.
		while (--i > 0) {
			p["xn" + i] = 0;
			p["xs" + i] = "";
		}
		p.xs0 = "";
		p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;


		/**
		 * Appends and extra tweening value to a CSSPropTween and automatically manages any prefix and suffix strings. The first extra value is stored in the s and c of the main CSSPropTween instance, but thereafter any extras are stored in the xn1, xn2, xn3, etc. The prefixes and suffixes are stored in the xs0, xs1, xs2, etc. properties. For example, if I walk through a clip value like "rect(10px, 5px, 0px, 20px)", the values would be stored like this:
		 * xs0:"rect(", s:10, xs1:"px, ", xn1:5, xs2:"px, ", xn2:0, xs3:"px, ", xn3:20, xn4:"px)"
		 * And they'd all get joined together when the CSSPlugin renders (in the setRatio() method).
		 * @param {string=} pfx Prefix (if any)
		 * @param {!number} s Starting value
		 * @param {!number} c Change in numeric value over the course of the entire tween. For example, if the start is 5 and the end is 100, the change would be 95.
		 * @param {string=} sfx Suffix (if any)
		 * @param {boolean=} r Round (if true).
		 * @param {boolean=} pad If true, this extra value should be separated by the previous one by a space. If there is no previous extra and pad is true, it will automatically drop the space.
		 * @return {CSSPropTween} returns itself so that multiple methods can be chained together.
		 */
		p.appendXtra = function(pfx, s, c, sfx, r, pad) {
			var pt = this,
				l = pt.l;
			pt["xs" + l] += (pad && (l || pt["xs" + l])) ? " " + pfx : pfx || "";
			if (!c) if (l !== 0 && !pt.plugin) { //typically we'll combine non-changing values right into the xs to optimize performance, but we don't combine them when there's a plugin that will be tweening the values because it may depend on the values being split apart, like for a bezier, if a value doesn't change between the first and second iteration but then it does on the 3rd, we'll run into trouble because there's no xn slot for that value!
				pt["xs" + l] += s + (sfx || "");
				return pt;
			}
			pt.l++;
			pt.type = pt.setRatio ? 2 : 1;
			pt["xs" + pt.l] = sfx || "";
			if (l > 0) {
				pt.data["xn" + l] = s + c;
				pt.rxp["xn" + l] = r; //round extra property (we need to tap into this in the _parseToProxy() method)
				pt["xn" + l] = s;
				if (!pt.plugin) {
					pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
					pt.xfirst.xs0 = 0; //just to ensure that the property stays numeric which helps modern browsers speed up processing. Remember, in the setRatio() method, we do pt.t[pt.p] = val + pt.xs0 so if pt.xs0 is "" (the default), it'll cast the end value as a string. When a property is a number sometimes and a string sometimes, it prevents the compiler from locking in the data type, slowing things down slightly.
				}
				return pt;
			}
			pt.data = {s:s + c};
			pt.rxp = {};
			pt.s = s;
			pt.c = c;
			pt.r = r;
			return pt;
		};

		/**
		 * @constructor A SpecialProp is basically a css property that needs to be treated in a non-standard way, like if it may contain a complex value like boxShadow:"5px 10px 15px rgb(255, 102, 51)" or if it is associated with another plugin like ThrowPropsPlugin or BezierPlugin. Every SpecialProp is associated with a particular property name like "boxShadow" or "throwProps" or "bezier" and it will intercept those values in the vars object that's passed to the CSSPlugin and handle them accordingly.
		 * @param {!string} p Property name (like "boxShadow" or "throwProps")
		 * @param {Object=} options An object containing any of the following configuration options:
		 *                      - defaultValue: the default value
		 *                      - parser: A function that should be called when the associated property name is found in the vars. This function should return a CSSPropTween instance and it should ensure that it is properly inserted into the linked list. It will receive 4 paramters: 1) The target, 2) The value defined in the vars, 3) The CSSPlugin instance (whose _firstPT should be used for the linked list), and 4) A computed style object if one was calculated (this is a speed optimization that allows retrieval of starting values quicker)
		 *                      - formatter: a function that formats any value received for this special property (for example, boxShadow could take "5px 5px red" and format it to "5px 5px 0px 0px red" so that both the beginning and ending values have a common order and quantity of values.)
		 *                      - prefix: if true, we'll determine whether or not this property requires a vendor prefix (like Webkit or Moz or ms or O)
		 *                      - color: set this to true if the value for this SpecialProp may contain color-related values like rgb(), rgba(), etc.
		 *                      - priority: priority in the linked list order. Higher priority SpecialProps will be updated before lower priority ones. The default priority is 0.
		 *                      - multi: if true, the formatter should accommodate a comma-delimited list of values, like boxShadow could have multiple boxShadows listed out.
		 *                      - collapsible: if true, the formatter should treat the value like it's a top/right/bottom/left value that could be collapsed, like "5px" would apply to all, "5px, 10px" would use 5px for top/bottom and 10px for right/left, etc.
		 *                      - keyword: a special keyword that can [optionally] be found inside the value (like "inset" for boxShadow). This allows us to validate beginning/ending values to make sure they match (if the keyword is found in one, it'll be added to the other for consistency by default).
		 */
		var SpecialProp = function(p, options) {
				options = options || {};
				this.p = options.prefix ? _checkPropPrefix(p) || p : p;
				_specialProps[p] = _specialProps[this.p] = this;
				this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
				if (options.parser) {
					this.parse = options.parser;
				}
				this.clrs = options.color;
				this.multi = options.multi;
				this.keyword = options.keyword;
				this.dflt = options.defaultValue;
				this.pr = options.priority || 0;
			},

			//shortcut for creating a new SpecialProp that can accept multiple properties as a comma-delimited list (helps minification). dflt can be an array for multiple values (we don't do a comma-delimited list because the default value may contain commas, like rect(0px,0px,0px,0px)). We attach this method to the SpecialProp class/object instead of using a private _createSpecialProp() method so that we can tap into it externally if necessary, like from another plugin.
			_registerComplexSpecialProp = _internals._registerComplexSpecialProp = function(p, options, defaults) {
				if (typeof(options) !== "object") {
					options = {parser:defaults}; //to make backwards compatible with older versions of BezierPlugin and ThrowPropsPlugin
				}
				var a = p.split(","),
					d = options.defaultValue,
					i, temp;
				defaults = defaults || [d];
				for (i = 0; i < a.length; i++) {
					options.prefix = (i === 0 && options.prefix);
					options.defaultValue = defaults[i] || d;
					temp = new SpecialProp(a[i], options);
				}
			},

			//creates a placeholder special prop for a plugin so that the property gets caught the first time a tween of it is attempted, and at that time it makes the plugin register itself, thus taking over for all future tweens of that property. This allows us to not mandate that things load in a particular order and it also allows us to log() an error that informs the user when they attempt to tween an external plugin-related property without loading its .js file.
			_registerPluginProp = _internals._registerPluginProp = function(p) {
				if (!_specialProps[p]) {
					var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
					_registerComplexSpecialProp(p, {parser:function(t, e, p, cssp, pt, plugin, vars) {
						var pluginClass = _globals.com.greensock.plugins[pluginName];
						if (!pluginClass) {
							_log("Error: " + pluginName + " js file not loaded.");
							return pt;
						}
						pluginClass._cssRegister();
						return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
					}});
				}
			};


		p = SpecialProp.prototype;

		/**
		 * Alias for _parseComplex() that automatically plugs in certain values for this SpecialProp, like its property name, whether or not colors should be sensed, the default value, and priority. It also looks for any keyword that the SpecialProp defines (like "inset" for boxShadow) and ensures that the beginning and ending values have the same number of values for SpecialProps where multi is true (like boxShadow and textShadow can have a comma-delimited list)
		 * @param {!Object} t target element
		 * @param {(string|number|object)} b beginning value
		 * @param {(string|number|object)} e ending (destination) value
		 * @param {CSSPropTween=} pt next CSSPropTween in the linked list
		 * @param {TweenPlugin=} plugin If another plugin will be tweening the complex value, that TweenPlugin instance goes here.
		 * @param {function=} setRatio If a custom setRatio() method should be used to handle this complex value, that goes here.
		 * @return {CSSPropTween=} First CSSPropTween in the linked list
		 */
		p.parseComplex = function(t, b, e, pt, plugin, setRatio) {
			var kwd = this.keyword,
				i, ba, ea, l, bi, ei;
			//if this SpecialProp's value can contain a comma-delimited list of values (like boxShadow or textShadow), we must parse them in a special way, and look for a keyword (like "inset" for boxShadow) and ensure that the beginning and ending BOTH have it if the end defines it as such. We also must ensure that there are an equal number of values specified (we can't tween 1 boxShadow to 3 for example)
			if (this.multi) if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
				ba = b.replace(_commasOutsideParenExp, "|").split("|");
				ea = e.replace(_commasOutsideParenExp, "|").split("|");
			} else if (kwd) {
				ba = [b];
				ea = [e];
			}
			if (ea) {
				l = (ea.length > ba.length) ? ea.length : ba.length;
				for (i = 0; i < l; i++) {
					b = ba[i] = ba[i] || this.dflt;
					e = ea[i] = ea[i] || this.dflt;
					if (kwd) {
						bi = b.indexOf(kwd);
						ei = e.indexOf(kwd);
						if (bi !== ei) {
							if (ei === -1) { //if the keyword isn't in the end value, remove it from the beginning one.
								ba[i] = ba[i].split(kwd).join("");
							} else if (bi === -1) { //if the keyword isn't in the beginning, add it.
								ba[i] += " " + kwd;
							}
						}
					}
				}
				b = ba.join(", ");
				e = ea.join(", ");
			}
			return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
		};

		/**
		 * Accepts a target and end value and spits back a CSSPropTween that has been inserted into the CSSPlugin's linked list and conforms with all the conventions we use internally, like type:-1, 0, 1, or 2, setting up any extra property tweens, priority, etc. For example, if we have a boxShadow SpecialProp and call:
		 * this._firstPT = sp.parse(element, "5px 10px 20px rgb(2550,102,51)", "boxShadow", this);
		 * It should figure out the starting value of the element's boxShadow, compare it to the provided end value and create all the necessary CSSPropTweens of the appropriate types to tween the boxShadow. The CSSPropTween that gets spit back should already be inserted into the linked list (the 4th parameter is the current head, so prepend to that).
		 * @param {!Object} t Target object whose property is being tweened
		 * @param {Object} e End value as provided in the vars object (typically a string, but not always - like a throwProps would be an object).
		 * @param {!string} p Property name
		 * @param {!CSSPlugin} cssp The CSSPlugin instance that should be associated with this tween.
		 * @param {?CSSPropTween} pt The CSSPropTween that is the current head of the linked list (we'll prepend to it)
		 * @param {TweenPlugin=} plugin If a plugin will be used to tween the parsed value, this is the plugin instance.
		 * @param {Object=} vars Original vars object that contains the data for parsing.
		 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parse() call.
		 */
		p.parse = function(t, e, p, cssp, pt, plugin, vars) {
			return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
		};

		/**
		 * Registers a special property that should be intercepted from any "css" objects defined in tweens. This allows you to handle them however you want without CSSPlugin doing it for you. The 2nd parameter should be a function that accepts 3 parameters:
		 *  1) Target object whose property should be tweened (typically a DOM element)
		 *  2) The end/destination value (could be a string, number, object, or whatever you want)
		 *  3) The tween instance (you probably don't need to worry about this, but it can be useful for looking up information like the duration)
		 *
		 * Then, your function should return a function which will be called each time the tween gets rendered, passing a numeric "ratio" parameter to your function that indicates the change factor (usually between 0 and 1). For example:
		 *
		 * CSSPlugin.registerSpecialProp("myCustomProp", function(target, value, tween) {
		 *      var start = target.style.width;
		 *      return function(ratio) {
		 *              target.style.width = (start + value * ratio) + "px";
		 *              console.log("set width to " + target.style.width);
		 *          }
		 * }, 0);
		 *
		 * Then, when I do this tween, it will trigger my special property:
		 *
		 * TweenLite.to(element, 1, {css:{myCustomProp:100}});
		 *
		 * In the example, of course, we're just changing the width, but you can do anything you want.
		 *
		 * @param {!string} name Property name (or comma-delimited list of property names) that should be intercepted and handled by your function. For example, if I define "myCustomProp", then it would handle that portion of the following tween: TweenLite.to(element, 1, {css:{myCustomProp:100}})
		 * @param {!function(Object, Object, Object, string):function(number)} onInitTween The function that will be called when a tween of this special property is performed. The function will receive 4 parameters: 1) Target object that should be tweened, 2) Value that was passed to the tween, 3) The tween instance itself (rarely used), and 4) The property name that's being tweened. Your function should return a function that should be called on every update of the tween. That function will receive a single parameter that is a "change factor" value (typically between 0 and 1) indicating the amount of change as a ratio. You can use this to determine how to set the values appropriately in your function.
		 * @param {number=} priority Priority that helps the engine determine the order in which to set the properties (default: 0). Higher priority properties will be updated before lower priority ones.
		 */
		CSSPlugin.registerSpecialProp = function(name, onInitTween, priority) {
			_registerComplexSpecialProp(name, {parser:function(t, e, p, cssp, pt, plugin, vars) {
				var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
				rv.plugin = plugin;
				rv.setRatio = onInitTween(t, e, cssp._tween, p);
				return rv;
			}, priority:priority});
		};






		//transform-related methods and properties
		CSSPlugin.useSVGTransformAttr = true; //Safari and Firefox both have some rendering bugs when applying CSS transforms to SVG elements, so default to using the "transform" attribute instead (users can override this).
		var _transformProps = ("scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent").split(","),
			_transformProp = _checkPropPrefix("transform"), //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
			_transformPropCSS = _prefixCSS + "transform",
			_transformOriginProp = _checkPropPrefix("transformOrigin"),
			_supports3D = (_checkPropPrefix("perspective") !== null),
			Transform = _internals.Transform = function() {
				this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
				this.force3D = (CSSPlugin.defaultForce3D === false || !_supports3D) ? false : CSSPlugin.defaultForce3D || "auto";
			},
			_SVGElement = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */].SVGElement,
			_useSVGTransformAttr,
			//Some browsers (like Firefox and IE) don't honor transform-origin properly in SVG elements, so we need to manually adjust the matrix accordingly. We feature detect here rather than always doing the conversion for certain browsers because they may fix the problem at some point in the future.

			_createSVG = function(type, container, attributes) {
				var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
					reg = /([a-z])([A-Z])/g,
					p;
				for (p in attributes) {
					element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
				}
				container.appendChild(element);
				return element;
			},
			_docElement = _doc.documentElement || {},
			_forceSVGTransformAttr = (function() {
				//IE and Android stock don't support CSS transforms on SVG elements, so we must write them to the "transform" attribute. We populate this variable in the _parseTransform() method, and only if/when we come across an SVG element
				var force = _ieVers || (/Android/i.test(_agent) && !__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */].chrome),
					svg, rect, width;
				if (_doc.createElementNS && !force) { //IE8 and earlier doesn't support SVG anyway
					svg = _createSVG("svg", _docElement);
					rect = _createSVG("rect", svg, {width:100, height:50, x:100});
					width = rect.getBoundingClientRect().width;
					rect.style[_transformOriginProp] = "50% 50%";
					rect.style[_transformProp] = "scaleX(0.5)";
					force = (width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D)); //note: Firefox fails the test even though it does support CSS transforms in 3D. Since we can't push 3D stuff into the transform attribute, we force Firefox to pass the test here (as long as it does truly support 3D).
					_docElement.removeChild(svg);
				}
				return force;
			})(),
			_parseSVGOrigin = function(e, local, decoratee, absolute, smoothOrigin, skipRecord) {
				var tm = e._gsTransform,
					m = _getMatrix(e, true),
					v, x, y, xOrigin, yOrigin, a, b, c, d, tx, ty, determinant, xOriginOld, yOriginOld;
				if (tm) {
					xOriginOld = tm.xOrigin; //record the original values before we alter them.
					yOriginOld = tm.yOrigin;
				}
				if (!absolute || (v = absolute.split(" ")).length < 2) {
					b = e.getBBox();
					if (b.x === 0 && b.y === 0 && b.width + b.height === 0) { //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.
						b = {x: parseFloat(e.hasAttribute("x") ? e.getAttribute("x") : e.hasAttribute("cx") ? e.getAttribute("cx") : 0) || 0, y: parseFloat(e.hasAttribute("y") ? e.getAttribute("y") : e.hasAttribute("cy") ? e.getAttribute("cy") : 0) || 0, width:0, height:0};
					}
					local = _parsePosition(local).split(" ");
					v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * b.width : parseFloat(local[0])) + b.x,
						 (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * b.height : parseFloat(local[1])) + b.y];
				}
				decoratee.xOrigin = xOrigin = parseFloat(v[0]);
				decoratee.yOrigin = yOrigin = parseFloat(v[1]);
				if (absolute && m !== _identity2DMatrix) { //if svgOrigin is being set, we must invert the matrix and determine where the absolute point is, factoring in the current transforms. Otherwise, the svgOrigin would be based on the element's non-transformed position on the canvas.
					a = m[0];
					b = m[1];
					c = m[2];
					d = m[3];
					tx = m[4];
					ty = m[5];
					determinant = (a * d - b * c);
					if (determinant) { //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
						x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + ((c * ty - d * tx) / determinant);
						y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - ((a * ty - b * tx) / determinant);
						xOrigin = decoratee.xOrigin = v[0] = x;
						yOrigin = decoratee.yOrigin = v[1] = y;
					}
				}
				if (tm) { //avoid jump when transformOrigin is changed - adjust the x/y values accordingly
					if (skipRecord) {
						decoratee.xOffset = tm.xOffset;
						decoratee.yOffset = tm.yOffset;
						tm = decoratee;
					}
					if (smoothOrigin || (smoothOrigin !== false && CSSPlugin.defaultSmoothOrigin !== false)) {
						x = xOrigin - xOriginOld;
						y = yOrigin - yOriginOld;
						//originally, we simply adjusted the x and y values, but that would cause problems if, for example, you created a rotational tween part-way through an x/y tween. Managing the offset in a separate variable gives us ultimate flexibility.
						//tm.x -= x - (x * m[0] + y * m[2]);
						//tm.y -= y - (x * m[1] + y * m[3]);
						tm.xOffset += (x * m[0] + y * m[2]) - x;
						tm.yOffset += (x * m[1] + y * m[3]) - y;
					} else {
						tm.xOffset = tm.yOffset = 0;
					}
				}
				if (!skipRecord) {
					e.setAttribute("data-svg-origin", v.join(" "));
				}
			},
			_getBBoxHack = function(swapIfPossible) { //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
				var svg = _createElement("svg", (this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns")) || "http://www.w3.org/2000/svg"),
					oldParent = this.parentNode,
					oldSibling = this.nextSibling,
					oldCSS = this.style.cssText,
					bbox;
				_docElement.appendChild(svg);
				svg.appendChild(this);
				this.style.display = "block";
				if (swapIfPossible) {
					try {
						bbox = this.getBBox();
						this._originalGetBBox = this.getBBox;
						this.getBBox = _getBBoxHack;
					} catch (e) { }
				} else if (this._originalGetBBox) {
					bbox = this._originalGetBBox();
				}
				if (oldSibling) {
					oldParent.insertBefore(this, oldSibling);
				} else {
					oldParent.appendChild(this);
				}
				_docElement.removeChild(svg);
				this.style.cssText = oldCSS;
				return bbox;
			},
			_getBBox = function(e) {
				try {
					return e.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
				} catch (error) {
					return _getBBoxHack.call(e, true);
				}
			},
			_isSVG = function(e) { //reports if the element is an SVG on which getBBox() actually works
				return !!(_SVGElement && e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
			},
			_identity2DMatrix = [1,0,0,1,0,0],
			_getMatrix = function(e, force2D) {
				var tm = e._gsTransform || new Transform(),
					rnd = 100000,
					style = e.style,
					isDefault, s, m, n, dec, none;
				if (_transformProp) {
					s = _getStyle(e, _transformPropCSS, null, true);
				} else if (e.currentStyle) {
					//for older versions of IE, we need to interpret the filter portion that is in the format: progid:DXImageTransform.Microsoft.Matrix(M11=6.123233995736766e-17, M12=-1, M21=1, M22=6.123233995736766e-17, sizingMethod='auto expand') Notice that we need to swap b and c compared to a normal matrix.
					s = e.currentStyle.filter.match(_ieGetMatrixExp);
					s = (s && s.length === 4) ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), (tm.x || 0), (tm.y || 0)].join(",") : "";
				}
				isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
				if (_transformProp && ((none = (!_getComputedStyle(e) || _getComputedStyle(e).display === "none")) || !e.parentNode)) { //note: Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
					if (none) { //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
						n = style.display;
						style.display = "block";
					}
					if (!e.parentNode) {
						dec = 1; //flag
						_docElement.appendChild(e);
					}
					s = _getStyle(e, _transformPropCSS, null, true);
					isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
					if (n) {
						style.display = n;
					} else if (none) {
						_removeProp(style, "display");
					}
					if (dec) {
						_docElement.removeChild(e);
					}
				}
				if (tm.svg || (e.getCTM && _isSVG(e))) {
					if (isDefault && (style[_transformProp] + "").indexOf("matrix") !== -1) { //some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values
						s = style[_transformProp];
						isDefault = 0;
					}
					m = e.getAttribute("transform");
					if (isDefault && m) {
						m = e.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.
						s = "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + m.e + "," + m.f + ")";
						isDefault = 0;
					}
				}
				if (isDefault) {
					return _identity2DMatrix;
				}
				//split the matrix values out into an array (m for matrix)
				m = (s || "").match(_numExp) || [];
				i = m.length;
				while (--i > -1) {
					n = Number(m[i]);
					m[i] = (dec = n - (n |= 0)) ? ((dec * rnd + (dec < 0 ? -0.5 : 0.5)) | 0) / rnd + n : n; //convert strings to Numbers and round to 5 decimal places to avoid issues with tiny numbers. Roughly 20x faster than Number.toFixed(). We also must make sure to round before dividing so that values like 0.9999999999 become 1 to avoid glitches in browser rendering and interpretation of flipped/rotated 3D matrices. And don't just multiply the number by rnd, floor it, and then divide by rnd because the bitwise operations max out at a 32-bit signed integer, thus it could get clipped at a relatively low value (like 22,000.00000 for example).
				}
				return (force2D && m.length > 6) ? [m[0], m[1], m[4], m[5], m[12], m[13]] : m;
			},

			/**
			 * Parses the transform values for an element, returning an object with x, y, z, scaleX, scaleY, scaleZ, rotation, rotationX, rotationY, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
			 * @param {!Object} t target element
			 * @param {Object=} cs computed style object (optional)
			 * @param {boolean=} rec if true, the transform values will be recorded to the target element's _gsTransform object, like target._gsTransform = {x:0, y:0, z:0, scaleX:1...}
			 * @param {boolean=} parse if true, we'll ignore any _gsTransform values that already exist on the element, and force a reparsing of the css (calculated style)
			 * @return {object} object containing all of the transform properties/values like {x:0, y:0, z:0, scaleX:1...}
			 */
			_getTransform = _internals.getTransform = function(t, cs, rec, parse) {
				if (t._gsTransform && rec && !parse) {
					return t._gsTransform; //if the element already has a _gsTransform, use that. Note: some browsers don't accurately return the calculated style for the transform (particularly for SVG), so it's almost always safest to just use the values we've already applied rather than re-parsing things.
				}
				var tm = rec ? t._gsTransform || new Transform() : new Transform(),
					invX = (tm.scaleX < 0), //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
					min = 0.00002,
					rnd = 100000,
					zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin  || 0 : 0,
					defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
					m, i, scaleX, scaleY, rotation, skewX;

				tm.svg = !!(t.getCTM && _isSVG(t));
				if (tm.svg) {
					_parseSVGOrigin(t, _getStyle(t, _transformOriginProp, cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
					_useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
				}
				m = _getMatrix(t);
				if (m !== _identity2DMatrix) {

					if (m.length === 16) {
						//we'll only look at these position-related 6 variables first because if x/y/z all match, it's relatively safe to assume we don't need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would look the same as rotation:180 - there's no way to know for sure which direction was taken based solely on the matrix3d() values)
						var a11 = m[0], a21 = m[1], a31 = m[2], a41 = m[3],
							a12 = m[4], a22 = m[5], a32 = m[6], a42 = m[7],
							a13 = m[8], a23 = m[9], a33 = m[10],
							a14 = m[12], a24 = m[13], a34 = m[14],
							a43 = m[11],
							angle = Math.atan2(a32, a33),
							t1, t2, t3, t4, cos, sin;
						//we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari
						if (tm.zOrigin) {
							a34 = -tm.zOrigin;
							a14 = a13*a34-m[12];
							a24 = a23*a34-m[13];
							a34 = a33*a34+tm.zOrigin-m[14];
						}
						//note for possible future consolidation: rotationX: Math.atan2(a32, a33), rotationY: Math.atan2(-a31, Math.sqrt(a33 * a33 + a32 * a32)), rotation: Math.atan2(a21, a11), skew: Math.atan2(a12, a22). However, it doesn't seem to be quite as reliable as the full-on backwards rotation procedure.
						tm.rotationX = angle * _RAD2DEG;
						//rotationX
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							t1 = a12*cos+a13*sin;
							t2 = a22*cos+a23*sin;
							t3 = a32*cos+a33*sin;
							a13 = a12*-sin+a13*cos;
							a23 = a22*-sin+a23*cos;
							a33 = a32*-sin+a33*cos;
							a43 = a42*-sin+a43*cos;
							a12 = t1;
							a22 = t2;
							a32 = t3;
						}
						//rotationY
						angle = Math.atan2(-a31, a33);
						tm.rotationY = angle * _RAD2DEG;
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							t1 = a11*cos-a13*sin;
							t2 = a21*cos-a23*sin;
							t3 = a31*cos-a33*sin;
							a23 = a21*sin+a23*cos;
							a33 = a31*sin+a33*cos;
							a43 = a41*sin+a43*cos;
							a11 = t1;
							a21 = t2;
							a31 = t3;
						}
						//rotationZ
						angle = Math.atan2(a21, a11);
						tm.rotation = angle * _RAD2DEG;
						if (angle) {
							cos = Math.cos(angle);
							sin = Math.sin(angle);
							t1 = a11*cos+a21*sin;
							t2 = a12*cos+a22*sin;
							t3 = a13*cos+a23*sin;
							a21 = a21*cos-a11*sin;
							a22 = a22*cos-a12*sin;
							a23 = a23*cos-a13*sin;
							a11 = t1;
							a12 = t2;
							a13 = t3;
						}

						if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) { //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
							tm.rotationX = tm.rotation = 0;
							tm.rotationY = 180 - tm.rotationY;
						}

						//skewX
						angle = Math.atan2(a12, a22);

						//scales
						tm.scaleX = ((Math.sqrt(a11 * a11 + a21 * a21 + a31 * a31) * rnd + 0.5) | 0) / rnd;
						tm.scaleY = ((Math.sqrt(a22 * a22 + a32 * a32) * rnd + 0.5) | 0) / rnd;
						tm.scaleZ = ((Math.sqrt(a13 * a13 + a23 * a23 + a33 * a33) * rnd + 0.5) | 0) / rnd;
						a11 /= tm.scaleX;
						a12 /= tm.scaleY;
						a21 /= tm.scaleX;
						a22 /= tm.scaleY;
						if (Math.abs(angle) > min) {
							tm.skewX = angle * _RAD2DEG;
							a12 = 0; //unskews
							if (tm.skewType !== "simple") {
								tm.scaleY *= 1 / Math.cos(angle); //by default, we compensate the scale based on the skew so that the element maintains a similar proportion when skewed, so we have to alter the scaleY here accordingly to match the default (non-adjusted) skewing that CSS does (stretching more and more as it skews).
							}

						} else {
							tm.skewX = 0;
						}

						/* //for testing purposes
						var transform = "matrix3d(",
							comma = ",",
							zero = "0";
						a13 /= tm.scaleZ;
						a23 /= tm.scaleZ;
						a31 /= tm.scaleX;
						a32 /= tm.scaleY;
						a33 /= tm.scaleZ;
						transform += ((a11 < min && a11 > -min) ? zero : a11) + comma + ((a21 < min && a21 > -min) ? zero : a21) + comma + ((a31 < min && a31 > -min) ? zero : a31);
						transform += comma + ((a41 < min && a41 > -min) ? zero : a41) + comma + ((a12 < min && a12 > -min) ? zero : a12) + comma + ((a22 < min && a22 > -min) ? zero : a22);
						transform += comma + ((a32 < min && a32 > -min) ? zero : a32) + comma + ((a42 < min && a42 > -min) ? zero : a42) + comma + ((a13 < min && a13 > -min) ? zero : a13);
						transform += comma + ((a23 < min && a23 > -min) ? zero : a23) + comma + ((a33 < min && a33 > -min) ? zero : a33) + comma + ((a43 < min && a43 > -min) ? zero : a43) + comma;
						transform += a14 + comma + a24 + comma + a34 + comma + (tm.perspective ? (1 + (-a34 / tm.perspective)) : 1) + ")";
						console.log(transform);
						document.querySelector(".test").style[_transformProp] = transform;
						*/

						tm.perspective = a43 ? 1 / ((a43 < 0) ? -a43 : a43) : 0;
						tm.x = a14;
						tm.y = a24;
						tm.z = a34;
						if (tm.svg) {
							tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
							tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);
						}

					} else if ((!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || (!tm.rotationX && !tm.rotationY))) { //sometimes a 6-element matrix is returned even when we performed 3D transforms, like if rotationX and rotationY are 180. In cases like this, we still need to honor the 3D transforms. If we just rely on the 2D info, it could affect how the data is interpreted, like scaleY might get set to -1 or rotation could get offset by 180 degrees. For example, do a TweenLite.to(element, 1, {css:{rotationX:180, rotationY:180}}) and then later, TweenLite.to(element, 1, {css:{rotationX:0}}) and without this conditional logic in place, it'd jump to a state of being unrotated when the 2nd tween starts. Then again, we need to honor the fact that the user COULD alter the transforms outside of CSSPlugin, like by manually applying new css, so we try to sense that by looking at x and y because if those changed, we know the changes were made outside CSSPlugin and we force a reinterpretation of the matrix values. Also, in Webkit browsers, if the element's "display" is "none", its calculated style value will always return empty, so if we've already recorded the values in the _gsTransform object, we'll just rely on those.
						var k = (m.length >= 6),
							a = k ? m[0] : 1,
							b = m[1] || 0,
							c = m[2] || 0,
							d = k ? m[3] : 1;
						tm.x = m[4] || 0;
						tm.y = m[5] || 0;
						scaleX = Math.sqrt(a * a + b * b);
						scaleY = Math.sqrt(d * d + c * c);
						rotation = (a || b) ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
						skewX = (c || d) ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
						tm.scaleX = scaleX;
						tm.scaleY = scaleY;
						tm.rotation = rotation;
						tm.skewX = skewX;
						if (_supports3D) {
							tm.rotationX = tm.rotationY = tm.z = 0;
							tm.perspective = defaultTransformPerspective;
							tm.scaleZ = 1;
						}
						if (tm.svg) {
							tm.x -= tm.xOrigin - (tm.xOrigin * a + tm.yOrigin * c);
							tm.y -= tm.yOrigin - (tm.xOrigin * b + tm.yOrigin * d);
						}
					}
					if (Math.abs(tm.skewX) > 90 && Math.abs(tm.skewX) < 270) {
						if (invX) {
							tm.scaleX *= -1;
							tm.skewX += (tm.rotation <= 0) ? 180 : -180;
							tm.rotation += (tm.rotation <= 0) ? 180 : -180;
						} else {
							tm.scaleY *= -1;
							tm.skewX += (tm.skewX <= 0) ? 180 : -180;
						}
					}
					tm.zOrigin = zOrigin;
					//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs(). Also, browsers tend to render a SLIGHTLY rotated object in a fuzzy way, so we need to snap to exactly 0 when appropriate.
					for (i in tm) {
						if (tm[i] < min) if (tm[i] > -min) {
							tm[i] = 0;
						}
					}
				}
				//DEBUG: _log("parsed rotation of " + t.getAttribute("id")+": "+(tm.rotationX)+", "+(tm.rotationY)+", "+(tm.rotation)+", scale: "+tm.scaleX+", "+tm.scaleY+", "+tm.scaleZ+", position: "+tm.x+", "+tm.y+", "+tm.z+", perspective: "+tm.perspective+ ", origin: "+ tm.xOrigin+ ","+ tm.yOrigin);
				if (rec) {
					t._gsTransform = tm; //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)
					if (tm.svg) { //if we're supposed to apply transforms to the SVG element's "transform" attribute, make sure there aren't any CSS transforms applied or they'll override the attribute ones. Also clear the transform attribute if we're using CSS, just to be clean.
						if (_useSVGTransformAttr && t.style[_transformProp]) {
							__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].delayedCall(0.001, function(){ //if we apply this right away (before anything has rendered), we risk there being no transforms for a brief moment and it also interferes with adjusting the transformOrigin in a tween with immediateRender:true (it'd try reading the matrix and it wouldn't have the appropriate data in place because we just removed it).
								_removeProp(t.style, _transformProp);
							});
						} else if (!_useSVGTransformAttr && t.getAttribute("transform")) {
							__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].delayedCall(0.001, function(){
								t.removeAttribute("transform");
							});
						}
					}
				}
				return tm;
			},

			//for setting 2D transforms in IE6, IE7, and IE8 (must use a "filter" to emulate the behavior of modern day browser transforms)
			_setIETransformRatio = function(v) {
				var t = this.data, //refers to the element's _gsTransform object
					ang = -t.rotation * _DEG2RAD,
					skew = ang + t.skewX * _DEG2RAD,
					rnd = 100000,
					a = ((Math.cos(ang) * t.scaleX * rnd) | 0) / rnd,
					b = ((Math.sin(ang) * t.scaleX * rnd) | 0) / rnd,
					c = ((Math.sin(skew) * -t.scaleY * rnd) | 0) / rnd,
					d = ((Math.cos(skew) * t.scaleY * rnd) | 0) / rnd,
					style = this.t.style,
					cs = this.t.currentStyle,
					filters, val;
				if (!cs) {
					return;
				}
				val = b; //just for swapping the variables an inverting them (reused "val" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)
				b = -c;
				c = -val;
				filters = cs.filter;
				style.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight
				var w = this.t.offsetWidth,
					h = this.t.offsetHeight,
					clip = (cs.position !== "absolute"),
					m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
					ox = t.x + (w * t.xPercent / 100),
					oy = t.y + (h * t.yPercent / 100),
					dx, dy;

				//if transformOrigin is being used, adjust the offset x and y
				if (t.ox != null) {
					dx = ((t.oxp) ? w * t.ox * 0.01 : t.ox) - w / 2;
					dy = ((t.oyp) ? h * t.oy * 0.01 : t.oy) - h / 2;
					ox += dx - (dx * a + dy * b);
					oy += dy - (dx * c + dy * d);
				}

				if (!clip) {
					m += ", sizingMethod='auto expand')";
				} else {
					dx = (w / 2);
					dy = (h / 2);
					//translate to ensure that transformations occur around the correct origin (default is center).
					m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
				}
				if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
					style.filter = filters.replace(_ieSetMatrixExp, m);
				} else {
					style.filter = m + " " + filters; //we must always put the transform/matrix FIRST (before alpha(opacity=xx)) to avoid an IE bug that slices part of the object when rotation is applied with alpha.
				}

				//at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.
				if (v === 0 || v === 1) if (a === 1) if (b === 0) if (c === 0) if (d === 1) if (!clip || m.indexOf("Dx=0, Dy=0") !== -1) if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100) if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
					style.removeAttribute("filter");
				}

				//we must set the margins AFTER applying the filter in order to avoid some bugs in IE8 that could (in rare scenarios) cause them to be ignored intermittently (vibration).
				if (!clip) {
					var mult = (_ieVers < 8) ? 1 : -1, //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
						marg, prop, dif;
					dx = t.ieOffsetX || 0;
					dy = t.ieOffsetY || 0;
					t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
					t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
					for (i = 0; i < 4; i++) {
						prop = _margins[i];
						marg = cs[prop];
						//we need to get the current margin in case it is being tweened separately (we want to respect that tween's changes)
						val = (marg.indexOf("px") !== -1) ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
						if (val !== t[prop]) {
							dif = (i < 2) ? -t.ieOffsetX : -t.ieOffsetY; //if another tween is controlling a margin, we cannot only apply the difference in the ieOffsets, so we essentially zero-out the dx and dy here in that case. We record the margin(s) later so that we can keep comparing them, making this code very flexible.
						} else {
							dif = (i < 2) ? dx - t.ieOffsetX : dy - t.ieOffsetY;
						}
						style[prop] = (t[prop] = Math.round( val - dif * ((i === 0 || i === 2) ? 1 : mult) )) + "px";
					}
				}
			},

			/* translates a super small decimal to a string WITHOUT scientific notation
			_safeDecimal = function(n) {
				var s = (n < 0 ? -n : n) + "",
					a = s.split("e-");
				return (n < 0 ? "-0." : "0.") + new Array(parseInt(a[1], 10) || 0).join("0") + a[0].split(".").join("");
			},
			*/

			_setTransformRatio = _internals.set3DTransformRatio = _internals.setTransformRatio = function(v) {
				var t = this.data, //refers to the element's _gsTransform object
					style = this.t.style,
					angle = t.rotation,
					rotationX = t.rotationX,
					rotationY = t.rotationY,
					sx = t.scaleX,
					sy = t.scaleY,
					sz = t.scaleZ,
					x = t.x,
					y = t.y,
					z = t.z,
					isSVG = t.svg,
					perspective = t.perspective,
					force3D = t.force3D,
					skewY = t.skewY,
					skewX = t.skewX,
					t1,	a11, a12, a13, a21, a22, a23, a31, a32, a33, a41, a42, a43,
					zOrigin, min, cos, sin, t2, transform, comma, zero, skew, rnd;
				if (skewY) { //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
					skewX += skewY;
					angle += skewY;
				}

				//check to see if we should render as 2D (and SVGs must use 2D when _useSVGTransformAttr is true)
				if (((((v === 1 || v === 0) && force3D === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime)) || !force3D) && !z && !perspective && !rotationY && !rotationX && sz === 1) || (_useSVGTransformAttr && isSVG) || !_supports3D) { //on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve performance especially on mobile devices. Check the tween's totalTime/totalDuration too in order to make sure it doesn't happen between repeats if it's a repeating tween.

					//2D
					if (angle || skewX || isSVG) {
						angle *= _DEG2RAD;
						skew = skewX * _DEG2RAD;
						rnd = 100000;
						a11 = Math.cos(angle) * sx;
						a21 = Math.sin(angle) * sx;
						a12 = Math.sin(angle - skew) * -sy;
						a22 = Math.cos(angle - skew) * sy;
						if (skew && t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
							t1 = Math.tan(skew - skewY * _DEG2RAD);
							t1 = Math.sqrt(1 + t1 * t1);
							a12 *= t1;
							a22 *= t1;
							if (skewY) {
								t1 = Math.tan(skewY * _DEG2RAD);
								t1 = Math.sqrt(1 + t1 * t1);
								a11 *= t1;
								a21 *= t1;
							}
						}
						if (isSVG) {
							x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
							y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
							if (_useSVGTransformAttr && (t.xPercent || t.yPercent)) { //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the matrix to simulate it.
								min = this.t.getBBox();
								x += t.xPercent * 0.01 * min.width;
								y += t.yPercent * 0.01 * min.height;
							}
							min = 0.000001;
							if (x < min) if (x > -min) {
								x = 0;
							}
							if (y < min) if (y > -min) {
								y = 0;
							}
						}
						transform = (((a11 * rnd) | 0) / rnd) + "," + (((a21 * rnd) | 0) / rnd) + "," + (((a12 * rnd) | 0) / rnd) + "," + (((a22 * rnd) | 0) / rnd) + "," + x + "," + y + ")";
						if (isSVG && _useSVGTransformAttr) {
							this.t.setAttribute("transform", "matrix(" + transform);
						} else {
							//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 5 decimal places.
							style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + transform;
						}
					} else {
						style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
					}
					return;

				}
				if (_isFirefox) { //Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as black when displayed inside an iframe and the 3D scale is very small and doesn't change sufficiently enough between renders (like if you use a Power4.easeInOut to scale from 0 to 1 where the beginning values only change a tiny amount to begin the tween before accelerating). In this case, we force the scale to be 0.00002 instead which is visually the same but works around the Firefox issue.
					min = 0.0001;
					if (sx < min && sx > -min) {
						sx = sz = 0.00002;
					}
					if (sy < min && sy > -min) {
						sy = sz = 0.00002;
					}
					if (perspective && !t.z && !t.rotationX && !t.rotationY) { //Firefox has a bug that causes elements to have an odd super-thin, broken/dotted black border on elements that have a perspective set but aren't utilizing 3D space (no rotationX, rotationY, or z).
						perspective = 0;
					}
				}
				if (angle || skewX) {
					angle *= _DEG2RAD;
					cos = a11 = Math.cos(angle);
					sin = a21 = Math.sin(angle);
					if (skewX) {
						angle -= skewX * _DEG2RAD;
						cos = Math.cos(angle);
						sin = Math.sin(angle);
						if (t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
							t1 = Math.tan((skewX - skewY) * _DEG2RAD);
							t1 = Math.sqrt(1 + t1 * t1);
							cos *= t1;
							sin *= t1;
							if (t.skewY) {
								t1 = Math.tan(skewY * _DEG2RAD);
								t1 = Math.sqrt(1 + t1 * t1);
								a11 *= t1;
								a21 *= t1;
							}
						}
					}
					a12 = -sin;
					a22 = cos;

				} else if (!rotationY && !rotationX && sz === 1 && !perspective && !isSVG) { //if we're only translating and/or 2D scaling, this is faster...
					style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z +"px)" + ((sx !== 1 || sy !== 1) ? " scale(" + sx + "," + sy + ")" : "");
					return;
				} else {
					a11 = a22 = 1;
					a12 = a21 = 0;
				}
				// KEY  INDEX   AFFECTS a[row][column]
				// a11  0       rotation, rotationY, scaleX
				// a21  1       rotation, rotationY, scaleX
				// a31  2       rotationY, scaleX
				// a41  3       rotationY, scaleX
				// a12  4       rotation, skewX, rotationX, scaleY
				// a22  5       rotation, skewX, rotationX, scaleY
				// a32  6       rotationX, scaleY
				// a42  7       rotationX, scaleY
				// a13  8       rotationY, rotationX, scaleZ
				// a23  9       rotationY, rotationX, scaleZ
				// a33  10      rotationY, rotationX, scaleZ
				// a43  11      rotationY, rotationX, perspective, scaleZ
				// a14  12      x, zOrigin, svgOrigin
				// a24  13      y, zOrigin, svgOrigin
				// a34  14      z, zOrigin
				// a44  15
				// rotation: Math.atan2(a21, a11)
				// rotationY: Math.atan2(a13, a33) (or Math.atan2(a13, a11))
				// rotationX: Math.atan2(a32, a33)
				a33 = 1;
				a13 = a23 = a31 = a32 = a41 = a42 = 0;
				a43 = (perspective) ? -1 / perspective : 0;
				zOrigin = t.zOrigin;
				min = 0.000001; //threshold below which browsers use scientific notation which won't work.
				comma = ",";
				zero = "0";
				angle = rotationY * _DEG2RAD;
				if (angle) {
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					a31 = -sin;
					a41 = a43*-sin;
					a13 = a11*sin;
					a23 = a21*sin;
					a33 = cos;
					a43 *= cos;
					a11 *= cos;
					a21 *= cos;
				}
				angle = rotationX * _DEG2RAD;
				if (angle) {
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					t1 = a12*cos+a13*sin;
					t2 = a22*cos+a23*sin;
					a32 = a33*sin;
					a42 = a43*sin;
					a13 = a12*-sin+a13*cos;
					a23 = a22*-sin+a23*cos;
					a33 = a33*cos;
					a43 = a43*cos;
					a12 = t1;
					a22 = t2;
				}
				if (sz !== 1) {
					a13*=sz;
					a23*=sz;
					a33*=sz;
					a43*=sz;
				}
				if (sy !== 1) {
					a12*=sy;
					a22*=sy;
					a32*=sy;
					a42*=sy;
				}
				if (sx !== 1) {
					a11*=sx;
					a21*=sx;
					a31*=sx;
					a41*=sx;
				}

				if (zOrigin || isSVG) {
					if (zOrigin) {
						x += a13*-zOrigin;
						y += a23*-zOrigin;
						z += a33*-zOrigin+zOrigin;
					}
					if (isSVG) { //due to bugs in some browsers, we need to manage the transform-origin of SVG manually
						x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
						y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
					}
					if (x < min && x > -min) {
						x = zero;
					}
					if (y < min && y > -min) {
						y = zero;
					}
					if (z < min && z > -min) {
						z = 0; //don't use string because we calculate perspective later and need the number.
					}
				}

				//optimized way of concatenating all the values into a string. If we do it all in one shot, it's slower because of the way browsers have to create temp strings and the way it affects memory. If we do it piece-by-piece with +=, it's a bit slower too. We found that doing it in these sized chunks works best overall:
				transform = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(");
				transform += ((a11 < min && a11 > -min) ? zero : a11) + comma + ((a21 < min && a21 > -min) ? zero : a21) + comma + ((a31 < min && a31 > -min) ? zero : a31);
				transform += comma + ((a41 < min && a41 > -min) ? zero : a41) + comma + ((a12 < min && a12 > -min) ? zero : a12) + comma + ((a22 < min && a22 > -min) ? zero : a22);
				if (rotationX || rotationY || sz !== 1) { //performance optimization (often there's no rotationX or rotationY, so we can skip these calculations)
					transform += comma + ((a32 < min && a32 > -min) ? zero : a32) + comma + ((a42 < min && a42 > -min) ? zero : a42) + comma + ((a13 < min && a13 > -min) ? zero : a13);
					transform += comma + ((a23 < min && a23 > -min) ? zero : a23) + comma + ((a33 < min && a33 > -min) ? zero : a33) + comma + ((a43 < min && a43 > -min) ? zero : a43) + comma;
				} else {
					transform += ",0,0,0,0,1,0,";
				}
				transform += x + comma + y + comma + z + comma + (perspective ? (1 + (-z / perspective)) : 1) + ")";

				style[_transformProp] = transform;
			};

		p = Transform.prototype;
		p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = p.xOffset = p.yOffset = 0;
		p.scaleX = p.scaleY = p.scaleZ = 1;

		_registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {parser:function(t, e, parsingProp, cssp, pt, plugin, vars) {
			if (cssp._lastParsedTransform === vars) { return pt; } //only need to parse the transform once, and only if the browser supports it.
			cssp._lastParsedTransform = vars;
			var scaleFunc = (vars.scale && typeof(vars.scale) === "function") ? vars.scale : 0, //if there's a function-based "scale" value, swap in the resulting numeric value temporarily. Otherwise, if it's called for both scaleX and scaleY independently, they may not match (like if the function uses Math.random()).
				swapFunc;
			if (typeof(vars[parsingProp]) === "function") { //whatever property triggers the initial parsing might be a function-based value in which case it already got called in parse(), thus we don't want to call it again in here. The most efficient way to avoid this is to temporarily swap the value directly into the vars object, and then after we do all our parsing in this function, we'll swap it back again.
				swapFunc = vars[parsingProp];
				vars[parsingProp] = e;
			}
			if (scaleFunc) {
				vars.scale = scaleFunc(_index, t);
			}
			var originalGSTransform = t._gsTransform,
				style = t.style,
				min = 0.000001,
				i = _transformProps.length,
				v = vars,
				endRotations = {},
				transformOriginString = "transformOrigin",
				m1 = _getTransform(t, _cs, true, v.parseTransform),
				orig = v.transform && ((typeof(v.transform) === "function") ? v.transform(_index, _target) : v.transform),
				m2, copy, has3D, hasChange, dr, x, y, matrix, p;
			m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;
			cssp._transform = m1;
			if ("rotationZ" in v) {
				v.rotation = v.rotationZ;
			}
			if (orig && typeof(orig) === "string" && _transformProp) { //for values like transform:"rotate(60deg) scale(0.5, 0.8)"
				copy = _tempDiv.style; //don't use the original target because it might be SVG in which case some browsers don't report computed style correctly.
				copy[_transformProp] = orig;
				copy.display = "block"; //if display is "none", the browser often refuses to report the transform properties correctly.
				copy.position = "absolute";
				if (orig.indexOf("%") !== -1) { //%-based translations will fail unless we set the width/height to match the original target...
					copy.width = _getStyle(t, "width");
					copy.height = _getStyle(t, "height");
				}
				_doc.body.appendChild(_tempDiv);
				m2 = _getTransform(_tempDiv, null, false);
				if (m1.skewType === "simple") { //the default _getTransform() reports the skewX/scaleY as if skewType is "compensated", thus we need to adjust that here if skewType is "simple".
					m2.scaleY *= Math.cos(m2.skewX * _DEG2RAD);
				}
				if (m1.svg) { //if it's an SVG element, x/y part of the matrix will be affected by whatever we use as the origin and the offsets, so compensate here...
					x = m1.xOrigin;
					y = m1.yOrigin;
					m2.x -= m1.xOffset;
					m2.y -= m1.yOffset;
					if (v.transformOrigin || v.svgOrigin) { //if this tween is altering the origin, we must factor that in here. The actual work of recording the transformOrigin values and setting up the PropTween is done later (still inside this function) so we cannot leave the changes intact here - we only want to update the x/y accordingly.
						orig = {};
						_parseSVGOrigin(t, _parsePosition(v.transformOrigin), orig, v.svgOrigin, v.smoothOrigin, true);
						x = orig.xOrigin;
						y = orig.yOrigin;
						m2.x -= orig.xOffset - m1.xOffset;
						m2.y -= orig.yOffset - m1.yOffset;
					}
					if (x || y) {
						matrix = _getMatrix(_tempDiv, true);
						m2.x -= x - (x * matrix[0] + y * matrix[2]);
						m2.y -= y - (x * matrix[1] + y * matrix[3]);
					}
				}
				_doc.body.removeChild(_tempDiv);
				if (!m2.perspective) {
					m2.perspective = m1.perspective; //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
				}
				if (v.xPercent != null) {
					m2.xPercent = _parseVal(v.xPercent, m1.xPercent);
				}
				if (v.yPercent != null) {
					m2.yPercent = _parseVal(v.yPercent, m1.yPercent);
				}
			} else if (typeof(v) === "object") { //for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)
				m2 = {scaleX:_parseVal((v.scaleX != null) ? v.scaleX : v.scale, m1.scaleX),
					scaleY:_parseVal((v.scaleY != null) ? v.scaleY : v.scale, m1.scaleY),
					scaleZ:_parseVal(v.scaleZ, m1.scaleZ),
					x:_parseVal(v.x, m1.x),
					y:_parseVal(v.y, m1.y),
					z:_parseVal(v.z, m1.z),
					xPercent:_parseVal(v.xPercent, m1.xPercent),
					yPercent:_parseVal(v.yPercent, m1.yPercent),
					perspective:_parseVal(v.transformPerspective, m1.perspective)};
				dr = v.directionalRotation;
				if (dr != null) {
					if (typeof(dr) === "object") {
						for (copy in dr) {
							v[copy] = dr[copy];
						}
					} else {
						v.rotation = dr;
					}
				}
				if (typeof(v.x) === "string" && v.x.indexOf("%") !== -1) {
					m2.x = 0;
					m2.xPercent = _parseVal(v.x, m1.xPercent);
				}
				if (typeof(v.y) === "string" && v.y.indexOf("%") !== -1) {
					m2.y = 0;
					m2.yPercent = _parseVal(v.y, m1.yPercent);
				}

				m2.rotation = _parseAngle(("rotation" in v) ? v.rotation : ("shortRotation" in v) ? v.shortRotation + "_short" : m1.rotation, m1.rotation, "rotation", endRotations);
				if (_supports3D) {
					m2.rotationX = _parseAngle(("rotationX" in v) ? v.rotationX : ("shortRotationX" in v) ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
					m2.rotationY = _parseAngle(("rotationY" in v) ? v.rotationY : ("shortRotationY" in v) ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
				}
				m2.skewX = _parseAngle(v.skewX, m1.skewX);
				m2.skewY = _parseAngle(v.skewY, m1.skewY);
			}
			if (_supports3D && v.force3D != null) {
				m1.force3D = v.force3D;
				hasChange = true;
			}

			has3D = (m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective);
			if (!has3D && v.scale != null) {
				m2.scaleZ = 1; //no need to tween scaleZ.
			}

			while (--i > -1) {
				p = _transformProps[i];
				orig = m2[p] - m1[p];
				if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
					hasChange = true;
					pt = new CSSPropTween(m1, p, m1[p], orig, pt);
					if (p in endRotations) {
						pt.e = endRotations[p]; //directional rotations typically have compensated values during the tween, but we need to make sure they end at exactly what the user requested
					}
					pt.xs0 = 0; //ensures the value stays numeric in setRatio()
					pt.plugin = plugin;
					cssp._overwriteProps.push(pt.n);
				}
			}

			orig = v.transformOrigin;
			if (m1.svg && (orig || v.svgOrigin)) {
				x = m1.xOffset; //when we change the origin, in order to prevent things from jumping we adjust the x/y so we must record those here so that we can create PropTweens for them and flip them at the same time as the origin
				y = m1.yOffset;
				_parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin, v.smoothOrigin);
				pt = _addNonTweeningNumericPT(m1, "xOrigin", (originalGSTransform ? m1 : m2).xOrigin, m2.xOrigin, pt, transformOriginString); //note: if there wasn't a transformOrigin defined yet, just start with the destination one; it's wasteful otherwise, and it causes problems with fromTo() tweens. For example, TweenLite.to("#wheel", 3, {rotation:180, transformOrigin:"50% 50%", delay:1}); TweenLite.fromTo("#wheel", 3, {scale:0.5, transformOrigin:"50% 50%"}, {scale:1, delay:2}); would cause a jump when the from values revert at the beginning of the 2nd tween.
				pt = _addNonTweeningNumericPT(m1, "yOrigin", (originalGSTransform ? m1 : m2).yOrigin, m2.yOrigin, pt, transformOriginString);
				if (x !== m1.xOffset || y !== m1.yOffset) {
					pt = _addNonTweeningNumericPT(m1, "xOffset", (originalGSTransform ? x : m1.xOffset), m1.xOffset, pt, transformOriginString);
					pt = _addNonTweeningNumericPT(m1, "yOffset", (originalGSTransform ? y : m1.yOffset), m1.yOffset, pt, transformOriginString);
				}
				orig = "0px 0px"; //certain browsers (like firefox) completely botch transform-origin, so we must remove it to prevent it from contaminating transforms. We manage it ourselves with xOrigin and yOrigin
			}
			if (orig || (_supports3D && has3D && m1.zOrigin)) { //if anything 3D is happening and there's a transformOrigin with a z component that's non-zero, we must ensure that the transformOrigin's z-component is set to 0 so that we can manually do those calculations to get around Safari bugs. Even if the user didn't specifically define a "transformOrigin" in this particular tween (maybe they did it via css directly).
				if (_transformProp) {
					hasChange = true;
					p = _transformOriginProp;
					orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + ""; //cast as string to avoid errors
					pt = new CSSPropTween(style, p, 0, 0, pt, -1, transformOriginString);
					pt.b = style[p];
					pt.plugin = plugin;
					if (_supports3D) {
						copy = m1.zOrigin;
						orig = orig.split(" ");
						m1.zOrigin = ((orig.length > 2 && !(copy !== 0 && orig[2] === "0px")) ? parseFloat(orig[2]) : copy) || 0; //Safari doesn't handle the z part of transformOrigin correctly, so we'll manually handle it in the _set3DTransformRatio() method.
						pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px"; //we must define a z value of 0px specifically otherwise iOS 5 Safari will stick with the old one (if one was defined)!
						pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n); //we must create a CSSPropTween for the _gsTransform.zOrigin so that it gets reset properly at the beginning if the tween runs backward (as opposed to just setting m1.zOrigin here)
						pt.b = copy;
						pt.xs0 = pt.e = m1.zOrigin;
					} else {
						pt.xs0 = pt.e = orig;
					}

					//for older versions of IE (6-8), we need to manually calculate things inside the setRatio() function. We record origin x and y (ox and oy) and whether or not the values are percentages (oxp and oyp).
				} else {
					_parsePosition(orig + "", m1);
				}
			}
			if (hasChange) {
				cssp._transformType = (!(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3)) ? 3 : 2; //quicker than calling cssp._enableTransforms();
			}
			if (swapFunc) {
				vars[parsingProp] = swapFunc;
			}
			if (scaleFunc) {
				vars.scale = scaleFunc;
			}
			return pt;
		}, prefix:true});

		_registerComplexSpecialProp("boxShadow", {defaultValue:"0px 0px 0px 0px #999", prefix:true, color:true, multi:true, keyword:"inset"});

		_registerComplexSpecialProp("borderRadius", {defaultValue:"0px", parser:function(t, e, p, cssp, pt, plugin) {
			e = this.format(e);
			var props = ["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],
				style = t.style,
				ea1, i, es2, bs2, bs, es, bn, en, w, h, esfx, bsfx, rel, hn, vn, em;
			w = parseFloat(t.offsetWidth);
			h = parseFloat(t.offsetHeight);
			ea1 = e.split(" ");
			for (i = 0; i < props.length; i++) { //if we're dealing with percentages, we must convert things separately for the horizontal and vertical axis!
				if (this.p.indexOf("border")) { //older browsers used a prefix
					props[i] = _checkPropPrefix(props[i]);
				}
				bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
				if (bs.indexOf(" ") !== -1) {
					bs2 = bs.split(" ");
					bs = bs2[0];
					bs2 = bs2[1];
				}
				es = es2 = ea1[i];
				bn = parseFloat(bs);
				bsfx = bs.substr((bn + "").length);
				rel = (es.charAt(1) === "=");
				if (rel) {
					en = parseInt(es.charAt(0)+"1", 10);
					es = es.substr(2);
					en *= parseFloat(es);
					esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
				} else {
					en = parseFloat(es);
					esfx = es.substr((en + "").length);
				}
				if (esfx === "") {
					esfx = _suffixMap[p] || bsfx;
				}
				if (esfx !== bsfx) {
					hn = _convertToPixels(t, "borderLeft", bn, bsfx); //horizontal number (we use a bogus "borderLeft" property just because the _convertToPixels() method searches for the keywords "Left", "Right", "Top", and "Bottom" to determine of it's a horizontal or vertical property, and we need "border" in the name so that it knows it should measure relative to the element itself, not its parent.
					vn = _convertToPixels(t, "borderTop", bn, bsfx); //vertical number
					if (esfx === "%") {
						bs = (hn / w * 100) + "%";
						bs2 = (vn / h * 100) + "%";
					} else if (esfx === "em") {
						em = _convertToPixels(t, "borderLeft", 1, "em");
						bs = (hn / em) + "em";
						bs2 = (vn / em) + "em";
					} else {
						bs = hn + "px";
						bs2 = vn + "px";
					}
					if (rel) {
						es = (parseFloat(bs) + en) + esfx;
						es2 = (parseFloat(bs2) + en) + esfx;
					}
				}
				pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
			}
			return pt;
		}, prefix:true, formatter:_getFormatter("0px 0px 0px 0px", false, true)});
		_registerComplexSpecialProp("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {defaultValue:"0px", parser:function(t, e, p, cssp, pt, plugin) {
			return _parseComplex(t.style, p, this.format(_getStyle(t, p, _cs, false, "0px 0px")), this.format(e), false, "0px", pt);
		}, prefix:true, formatter:_getFormatter("0px 0px", false, true)});
		_registerComplexSpecialProp("backgroundPosition", {defaultValue:"0 0", parser:function(t, e, p, cssp, pt, plugin) {
			var bp = "background-position",
				cs = (_cs || _getComputedStyle(t, null)),
				bs = this.format( ((cs) ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), //Internet Explorer doesn't report background-position correctly - we must query background-position-x and background-position-y and combine them (even in IE10). Before IE9, we must do the same with the currentStyle object and use camelCase
				es = this.format(e),
				ba, ea, i, pct, overlap, src;
			if ((bs.indexOf("%") !== -1) !== (es.indexOf("%") !== -1) && es.split(",").length < 2) {
				src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
				if (src && src !== "none") {
					ba = bs.split(" ");
					ea = es.split(" ");
					_tempImg.setAttribute("src", src); //set the temp IMG's src to the background-image so that we can measure its width/height
					i = 2;
					while (--i > -1) {
						bs = ba[i];
						pct = (bs.indexOf("%") !== -1);
						if (pct !== (ea[i].indexOf("%") !== -1)) {
							overlap = (i === 0) ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
							ba[i] = pct ? (parseFloat(bs) / 100 * overlap) + "px" : (parseFloat(bs) / overlap * 100) + "%";
						}
					}
					bs = ba.join(" ");
				}
			}
			return this.parseComplex(t.style, bs, es, pt, plugin);
		}, formatter:_parsePosition});
		_registerComplexSpecialProp("backgroundSize", {defaultValue:"0 0", formatter:function(v) {
			v += ""; //ensure it's a string
			return (v.substr(0,2) === "co") ? v : _parsePosition(v.indexOf(" ") === -1 ? v + " " + v : v); //if set to something like "100% 100%", Safari typically reports the computed style as just "100%" (no 2nd value), but we should ensure that there are two values, so copy the first one. Otherwise, it'd be interpreted as "100% 0" (wrong). Also remember that it could be "cover" or "contain" which we can't tween but should be able to set.
		}});
		_registerComplexSpecialProp("perspective", {defaultValue:"0px", prefix:true});
		_registerComplexSpecialProp("perspectiveOrigin", {defaultValue:"50% 50%", prefix:true});
		_registerComplexSpecialProp("transformStyle", {prefix:true});
		_registerComplexSpecialProp("backfaceVisibility", {prefix:true});
		_registerComplexSpecialProp("userSelect", {prefix:true});
		_registerComplexSpecialProp("margin", {parser:_getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")});
		_registerComplexSpecialProp("padding", {parser:_getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")});
		_registerComplexSpecialProp("clip", {defaultValue:"rect(0px,0px,0px,0px)", parser:function(t, e, p, cssp, pt, plugin){
			var b, cs, delim;
			if (_ieVers < 9) { //IE8 and earlier don't report a "clip" value in the currentStyle - instead, the values are split apart into clipTop, clipRight, clipBottom, and clipLeft. Also, in IE7 and earlier, the values inside rect() are space-delimited, not comma-delimited.
				cs = t.currentStyle;
				delim = _ieVers < 8 ? " " : ",";
				b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
				e = this.format(e).split(",").join(delim);
			} else {
				b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
				e = this.format(e);
			}
			return this.parseComplex(t.style, b, e, pt, plugin);
		}});
		_registerComplexSpecialProp("textShadow", {defaultValue:"0px 0px 0px #999", color:true, multi:true});
		_registerComplexSpecialProp("autoRound,strictUnits", {parser:function(t, e, p, cssp, pt) {return pt;}}); //just so that we can ignore these properties (not tween them)
		_registerComplexSpecialProp("border", {defaultValue:"0px solid #000", parser:function(t, e, p, cssp, pt, plugin) {
			var bw = _getStyle(t, "borderTopWidth", _cs, false, "0px"),
				end = this.format(e).split(" "),
				esfx = end[0].replace(_suffixExp, "");
			if (esfx !== "px") { //if we're animating to a non-px value, we need to convert the beginning width to that unit.
				bw = (parseFloat(bw) / _convertToPixels(t, "borderTopWidth", 1, esfx)) + esfx;
			}
			return this.parseComplex(t.style, this.format(bw + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), end.join(" "), pt, plugin);
			}, color:true, formatter:function(v) {
				var a = v.split(" ");
				return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
			}});
		_registerComplexSpecialProp("borderWidth", {parser:_getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")}); //Firefox doesn't pick up on borderWidth set in style sheets (only inline).
		_registerComplexSpecialProp("float,cssFloat,styleFloat", {parser:function(t, e, p, cssp, pt, plugin) {
			var s = t.style,
				prop = ("cssFloat" in s) ? "cssFloat" : "styleFloat";
			return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
		}});

		//opacity-related
		var _setIEOpacityRatio = function(v) {
				var t = this.t, //refers to the element's style property
					filters = t.filter || _getStyle(this.data, "filter") || "",
					val = (this.s + this.c * v) | 0,
					skip;
				if (val === 100) { //for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance, but make sure there isn't a transform (matrix) or gradient in the filters.
					if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
						t.removeAttribute("filter");
						skip = (!_getStyle(this.data, "filter")); //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
					} else {
						t.filter = filters.replace(_alphaFilterExp, "");
						skip = true;
					}
				}
				if (!skip) {
					if (this.xn1) {
						t.filter = filters = filters || ("alpha(opacity=" + val + ")"); //works around bug in IE7/8 that prevents changes to "visibility" from being applied properly if the filter is changed to a different alpha on the same frame.
					}
					if (filters.indexOf("pacity") === -1) { //only used if browser doesn't support the standard opacity style property (IE 7 and 8). We omit the "O" to avoid case-sensitivity issues
						if (val !== 0 || !this.xn1) { //bugs in IE7/8 won't render the filter properly if opacity is ADDED on the same frame/render as "visibility" changes (this.xn1 is 1 if this tween is an "autoAlpha" tween)
							t.filter = filters + " alpha(opacity=" + val + ")"; //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
						}
					} else {
						t.filter = filters.replace(_opacityExp, "opacity=" + val);
					}
				}
			};
		_registerComplexSpecialProp("opacity,alpha,autoAlpha", {defaultValue:"1", parser:function(t, e, p, cssp, pt, plugin) {
			var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
				style = t.style,
				isAutoAlpha = (p === "autoAlpha");
			if (typeof(e) === "string" && e.charAt(1) === "=") {
				e = ((e.charAt(0) === "-") ? -1 : 1) * parseFloat(e.substr(2)) + b;
			}
			if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) { //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
				b = 0;
			}
			if (_supportsOpacity) {
				pt = new CSSPropTween(style, "opacity", b, e - b, pt);
			} else {
				pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
				pt.xn1 = isAutoAlpha ? 1 : 0; //we need to record whether or not this is an autoAlpha so that in the setRatio(), we know to duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.
				style.zoom = 1; //helps correct an IE issue.
				pt.type = 2;
				pt.b = "alpha(opacity=" + pt.s + ")";
				pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
				pt.data = t;
				pt.plugin = plugin;
				pt.setRatio = _setIEOpacityRatio;
			}
			if (isAutoAlpha) { //we have to create the "visibility" PropTween after the opacity one in the linked list so that they run in the order that works properly in IE8 and earlier
				pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, ((b !== 0) ? "inherit" : "hidden"), ((e === 0) ? "hidden" : "inherit"));
				pt.xs0 = "inherit";
				cssp._overwriteProps.push(pt.n);
				cssp._overwriteProps.push(p);
			}
			return pt;
		}});


		var _removeProp = function(s, p) {
				if (p) {
					if (s.removeProperty) {
						if (p.substr(0,2) === "ms" || p.substr(0,6) === "webkit") { //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
							p = "-" + p;
						}
						s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
					} else { //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
						s.removeAttribute(p);
					}
				}
			},
			_setClassNameRatio = function(v) {
				this.t._gsClassPT = this;
				if (v === 1 || v === 0) {
					this.t.setAttribute("class", (v === 0) ? this.b : this.e);
					var mpt = this.data, //first MiniPropTween
						s = this.t.style;
					while (mpt) {
						if (!mpt.v) {
							_removeProp(s, mpt.p);
						} else {
							s[mpt.p] = mpt.v;
						}
						mpt = mpt._next;
					}
					if (v === 1 && this.t._gsClassPT === this) {
						this.t._gsClassPT = null;
					}
				} else if (this.t.getAttribute("class") !== this.e) {
					this.t.setAttribute("class", this.e);
				}
			};
		_registerComplexSpecialProp("className", {parser:function(t, e, p, cssp, pt, plugin, vars) {
			var b = t.getAttribute("class") || "", //don't use t.className because it doesn't work consistently on SVG elements; getAttribute("class") and setAttribute("class", value") is more reliable.
				cssText = t.style.cssText,
				difData, bs, cnpt, cnptLookup, mpt;
			pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
			pt.setRatio = _setClassNameRatio;
			pt.pr = -11;
			_hasPriority = true;
			pt.b = b;
			bs = _getAllStyles(t, _cs);
			//if there's a className tween already operating on the target, force it to its end so that the necessary inline styles are removed and the class name is applied before we determine the end state (we don't want inline styles interfering that were there just for class-specific values)
			cnpt = t._gsClassPT;
			if (cnpt) {
				cnptLookup = {};
				mpt = cnpt.data; //first MiniPropTween which stores the inline styles - we need to force these so that the inline styles don't contaminate things. Otherwise, there's a small chance that a tween could start and the inline values match the destination values and they never get cleaned.
				while (mpt) {
					cnptLookup[mpt.p] = 1;
					mpt = mpt._next;
				}
				cnpt.setRatio(1);
			}
			t._gsClassPT = pt;
			pt.e = (e.charAt(1) !== "=") ? e : b.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ((e.charAt(0) === "+") ? " " + e.substr(2) : "");
			t.setAttribute("class", pt.e);
			difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
			t.setAttribute("class", b);
			pt.data = difData.firstMPT;
			t.style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
			pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin); //we record the CSSPropTween as the xfirst so that we can handle overwriting propertly (if "className" gets overwritten, we must kill all the properties associated with the className part of the tween, so we can loop through from xfirst to the pt itself)
			return pt;
		}});


		var _setClearPropsRatio = function(v) {
			if (v === 1 || v === 0) if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") { //this.data refers to the tween. Only clear at the END of the tween (remember, from() tweens make the ratio go from 1 to 0, so we can't just check that and if the tween is the zero-duration one that's created internally to render the starting values in a from() tween, ignore that because otherwise, for example, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in).
				var s = this.t.style,
					transformParse = _specialProps.transform.parse,
					a, p, i, clearTransform, transform;
				if (this.e === "all") {
					s.cssText = "";
					clearTransform = true;
				} else {
					a = this.e.split(" ").join("").split(",");
					i = a.length;
					while (--i > -1) {
						p = a[i];
						if (_specialProps[p]) {
							if (_specialProps[p].parse === transformParse) {
								clearTransform = true;
							} else {
								p = (p === "transformOrigin") ? _transformOriginProp : _specialProps[p].p; //ensures that special properties use the proper browser-specific property name, like "scaleX" might be "-webkit-transform" or "boxShadow" might be "-moz-box-shadow"
							}
						}
						_removeProp(s, p);
					}
				}
				if (clearTransform) {
					_removeProp(s, _transformProp);
					transform = this.t._gsTransform;
					if (transform) {
						if (transform.svg) {
							this.t.removeAttribute("data-svg-origin");
							this.t.removeAttribute("transform");
						}
						delete this.t._gsTransform;
					}
				}

			}
		};
		_registerComplexSpecialProp("clearProps", {parser:function(t, e, p, cssp, pt) {
			pt = new CSSPropTween(t, p, 0, 0, pt, 2);
			pt.setRatio = _setClearPropsRatio;
			pt.e = e;
			pt.pr = -10;
			pt.data = cssp._tween;
			_hasPriority = true;
			return pt;
		}});

		p = "bezier,throwProps,physicsProps,physics2D".split(",");
		i = p.length;
		while (i--) {
			_registerPluginProp(p[i]);
		}








		p = CSSPlugin.prototype;
		p._firstPT = p._lastParsedTransform = p._transform = null;

		//gets called when the tween renders for the first time. This kicks everything off, recording start/end values, etc.
		p._onInitTween = function(target, vars, tween, index) {
			if (!target.nodeType) { //css is only for dom elements
				return false;
			}
			this._target = _target = target;
			this._tween = tween;
			this._vars = vars;
			_index = index;
			_autoRound = vars.autoRound;
			_hasPriority = false;
			_suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
			_cs = _getComputedStyle(target, "");
			_overwriteProps = this._overwriteProps;
			var style = target.style,
				v, pt, pt2, first, last, next, zIndex, tpt, threeD;
			if (_reqSafariFix) if (style.zIndex === "") {
				v = _getStyle(target, "zIndex", _cs);
				if (v === "auto" || v === "") {
					//corrects a bug in [non-Android] Safari that prevents it from repainting elements in their new positions if they don't have a zIndex set. We also can't just apply this inside _parseTransform() because anything that's moved in any way (like using "left" or "top" instead of transforms like "x" and "y") can be affected, so it is best to ensure that anything that's tweening has a z-index. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly. Plus zIndex is less memory-intensive.
					this._addLazySet(style, "zIndex", 0);
				}
			}

			if (typeof(vars) === "string") {
				first = style.cssText;
				v = _getAllStyles(target, _cs);
				style.cssText = first + ";" + vars;
				v = _cssDif(target, v, _getAllStyles(target)).difs;
				if (!_supportsOpacity && _opacityValExp.test(vars)) {
					v.opacity = parseFloat( RegExp.$1 );
				}
				vars = v;
				style.cssText = first;
			}

			if (vars.className) { //className tweens will combine any differences they find in the css with the vars that are passed in, so {className:"myClass", scale:0.5, left:20} would work.
				this._firstPT = pt = _specialProps.className.parse(target, vars.className, "className", this, null, null, vars);
			} else {
				this._firstPT = pt = this.parse(target, vars, null);
			}

			if (this._transformType) {
				threeD = (this._transformType === 3);
				if (!_transformProp) {
					style.zoom = 1; //helps correct an IE issue.
				} else if (_isSafari) {
					_reqSafariFix = true;
					//if zIndex isn't set, iOS Safari doesn't repaint things correctly sometimes (seemingly at random).
					if (style.zIndex === "") {
						zIndex = _getStyle(target, "zIndex", _cs);
						if (zIndex === "auto" || zIndex === "") {
							this._addLazySet(style, "zIndex", 0);
						}
					}
					//Setting WebkitBackfaceVisibility corrects 3 bugs:
					// 1) [non-Android] Safari skips rendering changes to "top" and "left" that are made on the same frame/render as a transform update.
					// 2) iOS Safari sometimes neglects to repaint elements in their new positions. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly.
					// 3) Safari sometimes displayed odd artifacts when tweening the transform (or WebkitTransform) property, like ghosts of the edges of the element remained. Definitely a browser bug.
					//Note: we allow the user to override the auto-setting by defining WebkitBackfaceVisibility in the vars of the tween.
					if (_isSafariLT6) {
						this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
					}
				}
				pt2 = pt;
				while (pt2 && pt2._next) {
					pt2 = pt2._next;
				}
				tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
				this._linkCSSP(tpt, null, pt2);
				tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio;
				tpt.data = this._transform || _getTransform(target, _cs, true);
				tpt.tween = tween;
				tpt.pr = -1; //ensures that the transforms get applied after the components are updated.
				_overwriteProps.pop(); //we don't want to force the overwrite of all "transform" tweens of the target - we only care about individual transform properties like scaleX, rotation, etc. The CSSPropTween constructor automatically adds the property to _overwriteProps which is why we need to pop() here.
			}

			if (_hasPriority) {
				//reorders the linked list in order of pr (priority)
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if ((pt._prev = pt2 ? pt2._prev : last)) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if ((pt._next = pt2)) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				this._firstPT = first;
			}
			return true;
		};


		p.parse = function(target, vars, pt, plugin) {
			var style = target.style,
				p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel;
			for (p in vars) {
				es = vars[p]; //ending value string
				if (typeof(es) === "function") {
					es = es(_index, _target);
				}
				sp = _specialProps[p]; //SpecialProp lookup.
				if (sp) {
					pt = sp.parse(target, es, p, this, pt, plugin, vars);
				} else if (p.substr(0,2) === "--") { //for tweening CSS variables (which always start with "--"). To maximize performance and simplicity, we bypass CSSPlugin altogether and just add a normal property tween to the tween instance itself.
					this._tween._propLookup[p] = this._addTween.call(this._tween, target.style, "setProperty", _getComputedStyle(target).getPropertyValue(p) + "", es + "", p, false, p);
					continue;
				} else {
					bs = _getStyle(target, p, _cs) + "";
					isStr = (typeof(es) === "string");
					if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || (isStr && _rgbhslExp.test(es))) { //Opera uses background: to define color sometimes in addition to backgroundColor:
						if (!isStr) {
							es = _parseColor(es);
							es = ((es.length > 3) ? "rgba(" : "rgb(") + es.join(",") + ")";
						}
						pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);

					} else if (isStr && _complexExp.test(es)) {
						pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);

					} else {
						bn = parseFloat(bs);
						bsfx = (bn || bn === 0) ? bs.substr((bn + "").length) : ""; //remember, bs could be non-numeric like "normal" for fontWeight, so we should default to a blank suffix in that case.

						if (bs === "" || bs === "auto") {
							if (p === "width" || p === "height") {
								bn = _getDimension(target, p, _cs);
								bsfx = "px";
							} else if (p === "left" || p === "top") {
								bn = _calculateOffset(target, p, _cs);
								bsfx = "px";
							} else {
								bn = (p !== "opacity") ? 0 : 1;
								bsfx = "";
							}
						}

						rel = (isStr && es.charAt(1) === "=");
						if (rel) {
							en = parseInt(es.charAt(0) + "1", 10);
							es = es.substr(2);
							en *= parseFloat(es);
							esfx = es.replace(_suffixExp, "");
						} else {
							en = parseFloat(es);
							esfx = isStr ? es.replace(_suffixExp, "") : "";
						}

						if (esfx === "") {
							esfx = (p in _suffixMap) ? _suffixMap[p] : bsfx; //populate the end suffix, prioritizing the map, then if none is found, use the beginning suffix.
						}

						es = (en || en === 0) ? (rel ? en + bn : en) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn't match the beginning value's suffix.
						//if the beginning/ending suffixes don't match, normalize them...
						if (bsfx !== esfx) if (esfx !== "" || p === "lineHeight") if (en || en === 0) if (bn) { //note: if the beginning value (bn) is 0, we don't need to convert units!
							bn = _convertToPixels(target, p, bn, bsfx);
							if (esfx === "%") {
								bn /= _convertToPixels(target, p, 100, "%") / 100;
								if (vars.strictUnits !== true) { //some browsers report only "px" values instead of allowing "%" with getComputedStyle(), so we assume that if we're tweening to a %, we should start there too unless strictUnits:true is defined. This approach is particularly useful for responsive designs that use from() tweens.
									bs = bn + "%";
								}

							} else if (esfx === "em" || esfx === "rem" || esfx === "vw" || esfx === "vh") {
								bn /= _convertToPixels(target, p, 1, esfx);

							//otherwise convert to pixels.
							} else if (esfx !== "px") {
								en = _convertToPixels(target, p, en, esfx);
								esfx = "px"; //we don't use bsfx after this, so we don't need to set it to px too.
							}
							if (rel) if (en || en === 0) {
								es = (en + bn) + esfx; //the changes we made affect relative calculations, so adjust the end value here.
							}
						}

						if (rel) {
							en += bn;
						}

						if ((bn || bn === 0) && (en || en === 0)) { //faster than isNaN(). Also, previously we required en !== bn but that doesn't really gain much performance and it prevents _parseToProxy() from working properly if beginning and ending values match but need to get tweened by an external plugin anyway. For example, a bezier tween where the target starts at left:0 and has these points: [{left:50},{left:0}] wouldn't work properly because when parsing the last point, it'd match the first (current) one and a non-tweening CSSPropTween would be recorded when we actually need a normal tween (type:0) so that things get updated during the tween properly.
							pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, (_autoRound !== false && (esfx === "px" || p === "zIndex")), 0, bs, es);
							pt.xs0 = esfx;
							//DEBUG: _log("tween "+p+" from "+pt.b+" ("+bn+esfx+") to "+pt.e+" with suffix: "+pt.xs0);
						} else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
							_log("invalid " + p + " tween value: " + vars[p]);
						} else {
							pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
							pt.xs0 = (es === "none" && (p === "display" || p.indexOf("Style") !== -1)) ? bs : es; //intermediate value should typically be set immediately (end value) except for "display" or things like borderTopStyle, borderBottomStyle, etc. which should use the beginning value during the tween.
							//DEBUG: _log("non-tweening value "+p+": "+pt.xs0);
						}
					}
				}
				if (plugin) if (pt && !pt.plugin) {
					pt.plugin = plugin;
				}
			}
			return pt;
		};


		//gets called every time the tween updates, passing the new ratio (typically a value between 0 and 1, but not always (for example, if an Elastic.easeOut is used, the value can jump above 1 mid-tween). It will always start and 0 and end at 1.
		p.setRatio = function(v) {
			var pt = this._firstPT,
				min = 0.000001,
				val, str, i;
			//at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like "position" or "float" or whatever) are set and so that if the beginning/ending suffixes (units) didn't match and we normalized to px, the value that the user passed in is used here. We check to see if the tween is at its beginning in case it's a from() tween in which case the ratio will actually go from 1 to 0 over the course of the tween (backwards).
			if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
				while (pt) {
					if (pt.type !== 2) {
						if (pt.r && pt.type !== -1) {
							val = pt.r(pt.s + pt.c);
							if (!pt.type) {
								pt.t[pt.p] = val + pt.xs0;
							} else if (pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
								i = pt.l;
								str = pt.xs0 + val + pt.xs1;
								for (i = 1; i < pt.l; i++) {
									str += pt["xn"+i] + pt["xs"+(i+1)];
								}
								pt.t[pt.p] = str;
							}
						} else {
							pt.t[pt.p] = pt.e;
						}
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}

			} else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
				while (pt) {
					val = pt.c * v + pt.s;
					if (pt.r) {
						val = pt.r(val);
					} else if (val < min) if (val > -min) {
						val = 0;
					}
					if (!pt.type) {
						pt.t[pt.p] = val + pt.xs0;
					} else if (pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
						i = pt.l;
						if (i === 2) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
						} else if (i === 3) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
						} else if (i === 4) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
						} else if (i === 5) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
						} else {
							str = pt.xs0 + val + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn"+i] + pt["xs"+(i+1)];
							}
							pt.t[pt.p] = str;
						}

					} else if (pt.type === -1) { //non-tweening value
						pt.t[pt.p] = pt.xs0;

					} else if (pt.setRatio) { //custom setRatio() for things like SpecialProps, external plugins, etc.
						pt.setRatio(v);
					}
					pt = pt._next;
				}

			//if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different units (like % instead of px or em or whatever).
			} else {
				while (pt) {
					if (pt.type !== 2) {
						pt.t[pt.p] = pt.b;
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}
			}
		};

		/**
		 * @private
		 * Forces rendering of the target's transforms (rotation, scale, etc.) whenever the CSSPlugin's setRatio() is called.
		 * Basically, this tells the CSSPlugin to create a CSSPropTween (type 2) after instantiation that runs last in the linked
		 * list and calls the appropriate (3D or 2D) rendering function. We separate this into its own method so that we can call
		 * it from other plugins like BezierPlugin if, for example, it needs to apply an autoRotation and this CSSPlugin
		 * doesn't have any transform-related properties of its own. You can call this method as many times as you
		 * want and it won't create duplicate CSSPropTweens.
		 *
		 * @param {boolean} threeD if true, it should apply 3D tweens (otherwise, just 2D ones are fine and typically faster)
		 */
		p._enableTransforms = function(threeD) {
			this._transform = this._transform || _getTransform(this._target, _cs, true); //ensures that the element has a _gsTransform property with the appropriate values.
			this._transformType = (!(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3)) ? 3 : 2;
		};

		var lazySet = function(v) {
			this.t[this.p] = this.e;
			this.data._linkCSSP(this, this._next, null, true); //we purposefully keep this._next even though it'd make sense to null it, but this is a performance optimization, as this happens during the while (pt) {} loop in setRatio() at the bottom of which it sets pt = pt._next, so if we null it, the linked list will be broken in that loop.
		};
		/** @private Gives us a way to set a value on the first render (and only the first render). **/
		p._addLazySet = function(t, p, v) {
			var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
			pt.e = v;
			pt.setRatio = lazySet;
			pt.data = this;
		};

		/** @private **/
		p._linkCSSP = function(pt, next, prev, remove) {
			if (pt) {
				if (next) {
					next._prev = pt;
				}
				if (pt._next) {
					pt._next._prev = pt._prev;
				}
				if (pt._prev) {
					pt._prev._next = pt._next;
				} else if (this._firstPT === pt) {
					this._firstPT = pt._next;
					remove = true; //just to prevent resetting this._firstPT 5 lines down in case pt._next is null. (optimized for speed)
				}
				if (prev) {
					prev._next = pt;
				} else if (!remove && this._firstPT === null) {
					this._firstPT = pt;
				}
				pt._next = next;
				pt._prev = prev;
			}
			return pt;
		};

		p._mod = function(lookup) {
			var pt = this._firstPT;
			while (pt) {
				if (typeof(lookup[pt.p]) === "function") { //only gets called by RoundPropsPlugin (ModifyPlugin manages all the rendering internally for CSSPlugin properties that need modification). Remember, we handle rounding a bit differently in this plugin for performance reasons, leveraging "r" as an indicator that the value should be rounded internally.
					pt.r = lookup[pt.p];
				}
				pt = pt._next;
			}
		};

		//we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.
		p._kill = function(lookup) {
			var copy = lookup,
				pt, p, xfirst;
			if (lookup.autoAlpha || lookup.alpha) {
				copy = {};
				for (p in lookup) { //copy the lookup so that we're not changing the original which may be passed elsewhere.
					copy[p] = lookup[p];
				}
				copy.opacity = 1;
				if (copy.autoAlpha) {
					copy.visibility = 1;
				}
			}
			if (lookup.className && (pt = this._classNamePT)) { //for className tweens, we need to kill any associated CSSPropTweens too; a linked list starts at the className's "xfirst".
				xfirst = pt.xfirst;
				if (xfirst && xfirst._prev) {
					this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev); //break off the prev
				} else if (xfirst === this._firstPT) {
					this._firstPT = pt._next;
				}
				if (pt._next) {
					this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
				}
				this._classNamePT = null;
			}
			pt = this._firstPT;
			while (pt) {
				if (pt.plugin && pt.plugin !== p && pt.plugin._kill) { //for plugins that are registered with CSSPlugin, we should notify them of the kill.
					pt.plugin._kill(lookup);
					p = pt.plugin;
				}
				pt = pt._next;
			}
			return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["j" /* TweenPlugin */].prototype._kill.call(this, copy);
		};



		//used by cascadeTo() for gathering all the style properties of each child element into an array for comparison.
		var _getChildStyles = function(e, props, targets) {
				var children, i, child, type;
				if (e.slice) {
					i = e.length;
					while (--i > -1) {
						_getChildStyles(e[i], props, targets);
					}
					return;
				}
				children = e.childNodes;
				i = children.length;
				while (--i > -1) {
					child = children[i];
					type = child.type;
					if (child.style) {
						props.push(_getAllStyles(child));
						if (targets) {
							targets.push(child);
						}
					}
					if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
						_getChildStyles(child, props, targets);
					}
				}
			};

		/**
		 * Typically only useful for className tweens that may affect child elements, this method creates a TweenLite
		 * and then compares the style properties of all the target's child elements at the tween's start and end, and
		 * if any are different, it also creates tweens for those and returns an array containing ALL of the resulting
		 * tweens (so that you can easily add() them to a TimelineLite, for example). The reason this functionality is
		 * wrapped into a separate static method of CSSPlugin instead of being integrated into all regular className tweens
		 * is because it creates entirely new tweens that may have completely different targets than the original tween,
		 * so if they were all lumped into the original tween instance, it would be inconsistent with the rest of the API
		 * and it would create other problems. For example:
		 *  - If I create a tween of elementA, that tween instance may suddenly change its target to include 50 other elements (unintuitive if I specifically defined the target I wanted)
		 *  - We can't just create new independent tweens because otherwise, what happens if the original/parent tween is reversed or pause or dropped into a TimelineLite for tight control? You'd expect that tween's behavior to affect all the others.
		 *  - Analyzing every style property of every child before and after the tween is an expensive operation when there are many children, so this behavior shouldn't be imposed on all className tweens by default, especially since it's probably rare that this extra functionality is needed.
		 *
		 * @param {Object} target object to be tweened
		 * @param {number} Duration in seconds (or frames for frames-based tweens)
		 * @param {Object} Object containing the end values, like {className:"newClass", ease:Linear.easeNone}
		 * @return {Array} An array of TweenLite instances
		 */
		CSSPlugin.cascadeTo = function(target, duration, vars) {
			var tween = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].to(target, duration, vars),
				results = [tween],
				b = [],
				e = [],
				targets = [],
				_reservedProps = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */]._internals.reservedProps,
				i, difs, p, from;
			target = tween._targets || tween.target;
			_getChildStyles(target, b, targets);
			tween.render(duration, true, true);
			_getChildStyles(target, e);
			tween.render(0, true, true);
			tween._enabled(true);
			i = targets.length;
			while (--i > -1) {
				difs = _cssDif(targets[i], b[i], e[i]);
				if (difs.firstMPT) {
					difs = difs.difs;
					for (p in vars) {
						if (_reservedProps[p]) {
							difs[p] = vars[p];
						}
					}
					from = {};
					for (p in difs) {
						from[p] = b[i][p];
					}
					results.push(__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].fromTo(targets[i], duration, from, difs));
				}
			}
			return results;
		};

		__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["j" /* TweenPlugin */].activate([CSSPlugin]);
		return CSSPlugin;

	}, true);

var CSSPlugin = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["m" /* globals */].CSSPlugin;


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export AttrPlugin */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AttrPlugin; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(2);
/*!
 * VERSION: 0.6.1
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */



var AttrPlugin = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */]._gsDefine.plugin({
	propName: "attr",
	API: 2,
	version: "0.6.1",

	//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
	init: function(target, value, tween, index) {
		var p, end;
		if (typeof(target.setAttribute) !== "function") {
			return false;
		}
		for (p in value) {
			end = value[p];
			if (typeof(end) === "function") {
				end = end(index, target);
			}
			this._addTween(target, "setAttribute", target.getAttribute(p) + "", end + "", p, false, p);
			this._overwriteProps.push(p);
		}
		return true;
	}

});







/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export RoundPropsPlugin */
/* unused harmony export _getRoundFunc */
/* unused harmony export _roundLinkedList */
/* unused harmony export p */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RoundPropsPlugin; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(2);
/*!
 * VERSION: 1.6.0
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/


var RoundPropsPlugin = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */]._gsDefine.plugin({
				propName: "roundProps",
				version: "1.7.0",
				priority: -1,
				API: 2,

				//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
				init: function(target, value, tween) {
					this._tween = tween;
					return true;
				}

			}),
			_getRoundFunc = function(v) { //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
				var p = v < 1 ? Math.pow(10, (v + "").length - 2) : 1; //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed()
				return function(n) {
					return ((Math.round(n / v) * v * p) | 0) / p;
				};
			},
			_roundLinkedList = function(node, mod) {
				while (node) {
					if (!node.f && !node.blob) {
						node.m = mod || Math.round;
					}
					node = node._next;
				}
			},
			p = RoundPropsPlugin.prototype;

		p._onInitAllProps = function() {
			var tween = this._tween,
				rp = tween.vars.roundProps,
				lookup = {},
				rpt = tween._propLookup.roundProps,
				pt, next, i, p;
			if (typeof(rp) === "object" && !rp.push) {
				for (p in rp) {
					lookup[p] = _getRoundFunc(rp[p]);
				}
			} else {
				if (typeof(rp) === "string") {
					rp = rp.split(",");
				}
				i = rp.length;
				while (--i > -1) {
					lookup[rp[i]] = Math.round;
				}
			}

			for (p in lookup) {
				pt = tween._firstPT;
				while (pt) {
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t._mod(lookup);
					} else if (pt.n === p) {
						if (pt.f === 2 && pt.t) { //a blob (text containing multiple numeric values)
							_roundLinkedList(pt.t._firstPT, lookup[p]);
						} else {
							this._add(pt.t, p, pt.s, pt.c, lookup[p]);
							//remove from linked list
							if (next) {
								next._prev = pt._prev;
							}
							if (pt._prev) {
								pt._prev._next = next;
							} else if (tween._firstPT === pt) {
								tween._firstPT = next;
							}
							pt._next = pt._prev = null;
							tween._propLookup[p] = rpt;
						}
					}
					pt = next;
				}
			}
			return false;
		};

		p._add = function(target, p, s, c, mod) {
			this._addTween(target, p, s, s + c, p, mod || Math.round);
			this._overwriteProps.push(p);
		};




/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DirectionalRotationPlugin */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DirectionalRotationPlugin; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(2);
/*!
 * VERSION: 0.3.1
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/



var DirectionalRotationPlugin = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */]._gsDefine.plugin({
		propName: "directionalRotation",
		version: "0.3.1",
		API: 2,

		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function(target, value, tween, index) {
			if (typeof(value) !== "object") {
				value = {rotation:value};
			}
			this.finals = {};
			var cap = (value.useRadians === true) ? Math.PI * 2 : 360,
				min = 0.000001,
				p, v, start, end, dif, split;
			for (p in value) {
				if (p !== "useRadians") {
					end = value[p];
					if (typeof(end) === "function") {
						end = end(index, target);
					}
					split = (end + "").split("_");
					v = split[0];
					start = parseFloat( (typeof(target[p]) !== "function") ? target[p] : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]() );
					end = this.finals[p] = (typeof(v) === "string" && v.charAt(1) === "=") ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
					dif = end - start;
					if (split.length) {
						v = split.join("_");
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = (dif < 0) ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						}
					}
					if (dif > min || dif < -min) {
						this._addTween(target, p, start, start + dif, p);
						this._overwriteProps.push(p);
					}
				}
			}
			return true;
		},

		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function(ratio) {
			var pt;
			if (ratio !== 1) {
				this._super.setRatio.call(this, ratio);
			} else {
				pt = this._firstPT;
				while (pt) {
					if (pt.f) {
						pt.t[pt.p](this.finals[pt.p]);
					} else {
						pt.t[pt.p] = this.finals[pt.p];
					}
					pt = pt._next;
				}
			}
		}

	});

DirectionalRotationPlugin._autoCSS = true;



/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export TimelineMax */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TimelineMax; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__TimelineLite_js__ = __webpack_require__(11);
/* unused harmony reexport TimelineLite */
/*!
 * VERSION: 2.0.2
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */




__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */]._gsDefine("TimelineMax", ["TimelineLite","TweenLite","easing.Ease"], function() {
		
		var TimelineMax = function(vars) {
				__WEBPACK_IMPORTED_MODULE_1__TimelineLite_js__["a" /* default */].call(this, vars);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._dirty = true;
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */]._internals,
			_lazyTweens = TweenLiteInternals.lazyTweens,
			_lazyRender = TweenLiteInternals.lazyRender,
			_globals = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */]._gsDefine.globals,
			_easeNone = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["b" /* Ease */](null, null, 1, 0),
			p = TimelineMax.prototype = new __WEBPACK_IMPORTED_MODULE_1__TimelineLite_js__["a" /* default */]();
			
		p.constructor = TimelineMax;
		p.kill()._gc = false;
		TimelineMax.version = "2.0.2";
		
		p.invalidate = function() {
			this._yoyo = (this.vars.yoyo === true);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return __WEBPACK_IMPORTED_MODULE_1__TimelineLite_js__["a" /* default */].prototype.invalidate.call(this);
		};
		
		p.addCallback = function(callback, position, params, scope) {
			return this.add( __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */].delayedCall(0, callback, params, scope), position);
		};
		
		p.removeCallback = function(callback, position) {
			if (callback) {
				if (position == null) {
					this._kill(null, callback);
				} else {
					var a = this.getTweensOf(callback, false),
						i = a.length,
						time = this._parseTimeOrLabel(position);
					while (--i > -1) {
						if (a[i]._startTime === time) {
							a[i]._enabled(false, false);
						}
					}
				}
			}
			return this;
		};

		p.removePause = function(position) {
			return this.removeCallback(__WEBPACK_IMPORTED_MODULE_1__TimelineLite_js__["a" /* default */]._internals.pauseCallback, position);
		};

		p.tweenTo = function(position, vars) {
			vars = vars || {};
			var copy = {ease:_easeNone, useFrames:this.usesFrames(), immediateRender:false, lazy:false},
				Engine = (vars.repeat && _globals.TweenMax) || __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["l" /* default */],
				duration, p, t;
			for (p in vars) {
				copy[p] = vars[p];
			}
			copy.time = this._parseTimeOrLabel(position);
			duration = (Math.abs(Number(copy.time) - this._time) / this._timeScale) || 0.001;
			t = new Engine(this, duration, copy);
			copy.onStart = function() {
				t.target.paused(true);
				if (t.vars.time !== t.target.time() && duration === t.duration() && !t.isFromTo) { //don't make the duration zero - if it's supposed to be zero, don't worry because it's already initting the tween and will complete immediately, effectively making the duration zero anyway. If we make duration zero, the tween won't run at all.
					t.duration( Math.abs( t.vars.time - t.target.time()) / t.target._timeScale ).render(t.time(), true, true); //render() right away to ensure that things look right, especially in the case of .tweenTo(0).
				}
				if (vars.onStart) { //in case the user had an onStart in the vars - we don't want to overwrite it.
					vars.onStart.apply(vars.onStartScope || vars.callbackScope || t, vars.onStartParams || []); //don't use t._callback("onStart") or it'll point to the copy.onStart and we'll get a recursion error.
				}
			};
			return t;
		};

		p.tweenFromTo = function(fromPosition, toPosition, vars) {
			vars = vars || {};
			fromPosition = this._parseTimeOrLabel(fromPosition);
			vars.startAt = {onComplete:this.seek, onCompleteParams:[fromPosition], callbackScope:this};
			vars.immediateRender = (vars.immediateRender !== false);
			var t = this.tweenTo(toPosition, vars);
			t.isFromTo = 1; //to ensure we don't mess with the duration in the onStart (we've got the start and end values here, so lock it in)
			return t.duration((Math.abs( t.vars.time - fromPosition) / this._timeScale) || 0.001);
		};
		
		p.render = function(time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var prevTime = this._time,
				totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				dur = this._duration,
				prevTotalTime = this._totalTime,
				prevStart = this._startTime, 
				prevTimeScale = this._timeScale, 
				prevRawPrevTime = this._rawPrevTime,
				prevPaused = this._paused, 
				prevCycle = this._cycle, 
				tween, isComplete, next, callback, internalForce, cycleDuration, pauseTween, curTime;
			if (prevTime !== this._time) { //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
				time += this._time - prevTime;
			}
			if (time >= totalDur - 0.0000001 && time >= 0) { //to work around occasional floating point math artifacts.
				if (!this._locked) {
					this._totalTime = totalDur;
					this._cycle = this._repeat;
				}
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if ((time <= 0 && time >= -0.0000001) || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time && this._first) {
						internalForce = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = time = 0;
				} else {
					this._time = dur;
					time = dur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7. We cannot do less then 0.0001 because the same issue can occur when the duration is extremely large like 999999999999 in which case adding 0.00000001, for example, causes it to act like nothing was added.
				}
				
			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				if (!this._locked) {
					this._totalTime = this._cycle = 0;
				}
				this._time = 0;
				if (prevTime !== 0 || (dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || (time < 0 && prevRawPrevTime >= 0)) && !this._locked)) { //edge case for checking time < 0 && prevRawPrevTime >= 0: a zero-duration fromTo() tween inside a zero-duration timeline (yeah, very rare)
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) {
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (prevRawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = (dur || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}
				
			} else {
				if (dur === 0 && prevRawPrevTime < 0) { //without this, zero-duration repeating timelines (like with a simple callback nested at the very beginning and a repeatDelay) wouldn't render the first time through.
					internalForce = true;
				}
				this._time = this._rawPrevTime = time;
				if (!this._locked) {
					this._totalTime = time;
					if (this._repeat !== 0) {
						cycleDuration = dur + this._repeatDelay;
						this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but it gets reported as 0.79999999!)
						if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
							this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
						}
						this._time = this._totalTime - (this._cycle * cycleDuration);
						if (this._yoyo) if ((this._cycle & 1) !== 0) {
							this._time = dur - this._time;
						}
						if (this._time > dur) {
							this._time = dur;
							time = dur + 0.0001; //to avoid occasional floating point rounding error
						} else if (this._time < 0) {
							this._time = time = 0;
						} else {
							time = this._time;
						}
					}
				}

				if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
					time = this._time;
					if (time >= prevTime || (this._repeat && prevCycle !== this._cycle)) {
						tween = this._first;
						while (tween && tween._startTime <= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
								pauseTween = tween;
							}
							tween = tween._next;
						}
					} else {
						tween = this._last;
						while (tween && tween._startTime >= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
								pauseTween = tween;
							}
							tween = tween._prev;
						}
					}
					if (pauseTween && pauseTween._startTime < dur) {
						this._time = time = pauseTween._startTime;
						this._totalTime = time + (this._cycle * (this._totalDuration + this._repeatDelay));
					}
				}

			}
			
			if (this._cycle !== prevCycle) if (!this._locked) {
				/*
				make sure children at the end/beginning of the timeline are rendered properly. If, for example, 
				a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
				would get transated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
				could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So 
				we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
				ensure that zero-duration tweens at the very beginning or end of the TimelineMax work. 
				*/
				var backwards = (this._yoyo && (prevCycle & 1) !== 0),
					wrap = (backwards === (this._yoyo && (this._cycle & 1) !== 0)),
					recTotalTime = this._totalTime,
					recCycle = this._cycle,
					recRawPrevTime = this._rawPrevTime,
					recTime = this._time;
				
				this._totalTime = prevCycle * dur;
				if (this._cycle < prevCycle) {
					backwards = !backwards;
				} else {
					this._totalTime += dur;
				}
				this._time = prevTime; //temporarily revert _time so that render() renders the children in the correct order. Without this, tweens won't rewind correctly. We could arhictect things in a "cleaner" way by splitting out the rendering queue into a separate method but for performance reasons, we kept it all inside this method.
				
				this._rawPrevTime = (dur === 0) ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
				this._cycle = prevCycle;
				this._locked = true; //prevents changes to totalTime and skips repeat/yoyo behavior when we recursively call render()
				prevTime = (backwards) ? 0 : dur;
				this.render(prevTime, suppressEvents, (dur === 0));
				if (!suppressEvents) if (!this._gc) {
					if (this.vars.onRepeat) {
						this._cycle = recCycle; //in case the onRepeat alters the playhead or invalidates(), we shouldn't stay locked or use the previous cycle.
						this._locked = false;
						this._callback("onRepeat");
					}
				}
				if (prevTime !== this._time) { //in case there's a callback like onComplete in a nested tween/timeline that changes the playhead position, like via seek(), we should just abort.
					return;
				}
				if (wrap) {
					this._cycle = prevCycle; //if there's an onRepeat, we reverted this above, so make sure it's set properly again. We also unlocked in that scenario, so reset that too.
					this._locked = true;
					prevTime = (backwards) ? dur + 0.0001 : -0.0001;
					this.render(prevTime, true, false);
				}
				this._locked = false;
				if (this._paused && !prevPaused) { //if the render() triggered callback that paused this timeline, we should abort (very rare, but possible)
					return;
				}
				this._time = recTime;
				this._totalTime = recTotalTime;
				this._cycle = recCycle;
				this._rawPrevTime = recRawPrevTime;
			}

			if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._callback("onUpdate");
				}
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}
			
			if (prevTotalTime === 0) if (this.vars.onStart) if (this._totalTime !== 0 || !this._totalDuration) if (!suppressEvents) {
				this._callback("onStart");
			}

			curTime = this._time;
			if (curTime >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
						if (pauseTween === tween) {
							pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
							while (pauseTween && pauseTween.endTime() > this._time) {
								pauseTween.render( (pauseTween._reversed ? pauseTween.totalDuration() - ((time - pauseTween._startTime) * pauseTween._timeScale) : (time - pauseTween._startTime) * pauseTween._timeScale), suppressEvents, force);
								pauseTween = pauseTween._prev;
							}
							pauseTween = null;
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			}
			
			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._callback("onUpdate");
			}
			if (callback) if (!this._locked) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
			}
		};
		
		p.getActive = function(nested, tweens, timelines) {
			if (nested == null) {
				nested = true;
			}
			if (tweens == null) {
				tweens = true;
			}
			if (timelines == null) {
				timelines = false;
			}
			var a = [], 
				all = this.getChildren(nested, tweens, timelines), 
				cnt = 0, 
				l = all.length,
				i, tween;
			for (i = 0; i < l; i++) {
				tween = all[i];
				if (tween.isActive()) {
					a[cnt++] = tween;
				}
			}
			return a;
		};
		
		
		p.getLabelAfter = function(time) {
			if (!time) if (time !== 0) { //faster than isNan()
				time = this._time;
			}
			var labels = this.getLabelsArray(),
				l = labels.length,
				i;
			for (i = 0; i < l; i++) {
				if (labels[i].time > time) {
					return labels[i].name;
				}
			}
			return null;
		};
		
		p.getLabelBefore = function(time) {
			if (time == null) {
				time = this._time;
			}
			var labels = this.getLabelsArray(),
				i = labels.length;
			while (--i > -1) {
				if (labels[i].time < time) {
					return labels[i].name;
				}
			}
			return null;
		};
		
		p.getLabelsArray = function() {
			var a = [],
				cnt = 0,
				p;
			for (p in this._labels) {
				a[cnt++] = {time:this._labels[p], name:p};
			}
			a.sort(function(a,b) {
				return a.time - b.time;
			});
			return a;
		};

		p.invalidate = function() {
			this._locked = false; //unlock and set cycle in case invalidate() is called from inside an onRepeat
			return __WEBPACK_IMPORTED_MODULE_1__TimelineLite_js__["a" /* default */].prototype.invalidate.call(this);
		};

		
//---- GETTERS / SETTERS -------------------------------------------------------------------------------------------------------
		
		p.progress = function(value, suppressEvents) {
			return (!arguments.length) ? (this._time / this.duration()) || 0 : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
		};
		
		p.totalProgress = function(value, suppressEvents) {
			return (!arguments.length) ? (this._totalTime / this.totalDuration()) || 0 : this.totalTime( this.totalDuration() * value, suppressEvents);
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					__WEBPACK_IMPORTED_MODULE_1__TimelineLite_js__["a" /* default */].prototype.totalDuration.call(this); //just forces refresh
					//Instead of Infinity, we use 999999999999 so that we can accommodate reverses.
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
				}
				return this._totalDuration;
			}
			return (this._repeat === -1 || !value) ? this : this.timeScale( this.totalDuration() / value );
		};
		
		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};
		
		p.repeat = function(value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};
		
		p.repeatDelay = function(value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};
		
		p.yoyo = function(value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};
		
		p.currentLabel = function(value) {
			if (!arguments.length) {
				return this.getLabelBefore(this._time + 0.00000001);
			}
			return this.seek(value, true);
		};
		
		return TimelineMax;
		
	}, true);

var TimelineMax = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["m" /* globals */].TimelineMax;


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export BezierPlugin */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BezierPlugin; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(2);
/*!
 * VERSION: 1.3.8
 * DATE: 2018-05-30
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/


		var _RAD2DEG = 180 / Math.PI,
			_r1 = [],
			_r2 = [],
			_r3 = [],
			_corProps = {},
			_globals = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */]._gsDefine.globals,
			Segment = function(a, b, c, d) {
				if (c === d) { //if c and d match, the final autoRotate value could lock at -90 degrees, so differentiate them slightly.
					c = d - (d - b) / 1000000;
				}
				if (a === b) { //if a and b match, the starting autoRotate value could lock at -90 degrees, so differentiate them slightly.
					b = a + (c - a) / 1000000;
				}
				this.a = a;
				this.b = b;
				this.c = c;
				this.d = d;
				this.da = d - a;
				this.ca = c - a;
				this.ba = b - a;
			},
			_correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
			cubicToQuadratic = function(a, b, c, d) {
				var q1 = {a:a},
					q2 = {},
					q3 = {},
					q4 = {c:d},
					mab = (a + b) / 2,
					mbc = (b + c) / 2,
					mcd = (c + d) / 2,
					mabc = (mab + mbc) / 2,
					mbcd = (mbc + mcd) / 2,
					m8 = (mbcd - mabc) / 8;
				q1.b = mab + (a - mab) / 4;
				q2.b = mabc + m8;
				q1.c = q2.a = (q1.b + q2.b) / 2;
				q2.c = q3.a = (mabc + mbcd) / 2;
				q3.b = mbcd - m8;
				q4.b = mcd + (d - mcd) / 4;
				q3.c = q4.a = (q3.b + q4.b) / 2;
				return [q1, q2, q3, q4];
			},
			_calculateControlPoints = function(a, curviness, quad, basic, correlate) {
				var l = a.length - 1,
					ii = 0,
					cp1 = a[0].a,
					i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl;
				for (i = 0; i < l; i++) {
					seg = a[ii];
					p1 = seg.a;
					p2 = seg.d;
					p3 = a[ii+1].d;

					if (correlate) {
						r1 = _r1[i];
						r2 = _r2[i];
						tl = ((r2 + r1) * curviness * 0.25) / (basic ? 0.5 : _r3[i] || 0.5);
						m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : (r1 !== 0 ? tl / r1 : 0));
						m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : (r2 !== 0 ? tl / r2 : 0));
						mm = p2 - (m1 + (((m2 - m1) * ((r1 * 3 / (r1 + r2)) + 0.5) / 4) || 0));
					} else {
						m1 = p2 - (p2 - p1) * curviness * 0.5;
						m2 = p2 + (p3 - p2) * curviness * 0.5;
						mm = p2 - (m1 + m2) / 2;
					}
					m1 += mm;
					m2 += mm;

					seg.c = cp2 = m1;
					if (i !== 0) {
						seg.b = cp1;
					} else {
						seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
					}

					seg.da = p2 - p1;
					seg.ca = cp2 - p1;
					seg.ba = cp1 - p1;

					if (quad) {
						qb = cubicToQuadratic(p1, cp1, cp2, p2);
						a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
						ii += 4;
					} else {
						ii++;
					}

					cp1 = m2;
				}
				seg = a[ii];
				seg.b = cp1;
				seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.
				seg.da = seg.d - seg.a;
				seg.ca = seg.c - seg.a;
				seg.ba = cp1 - seg.a;
				if (quad) {
					qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
					a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
				}
			},
			_parseAnchors = function(values, p, correlate, prepend) {
				var a = [],
					l, i, p1, p2, p3, tmp;
				if (prepend) {
					values = [prepend].concat(values);
					i = values.length;
					while (--i > -1) {
						if (typeof( (tmp = values[i][p]) ) === "string") if (tmp.charAt(1) === "=") {
							values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
						}
					}
				}
				l = values.length - 2;
				if (l < 0) {
					a[0] = new Segment(values[0][p], 0, 0, values[0][p]);
					return a;
				}
				for (i = 0; i < l; i++) {
					p1 = values[i][p];
					p2 = values[i+1][p];
					a[i] = new Segment(p1, 0, 0, p2);
					if (correlate) {
						p3 = values[i+2][p];
						_r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
						_r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
					}
				}
				a[i] = new Segment(values[i][p], 0, 0, values[i+1][p]);
				return a;
			},
			bezierThrough = function(values, curviness, quadratic, basic, correlate, prepend) {
				var obj = {},
					props = [],
					first = prepend || values[0],
					i, p, a, j, r, l, seamless, last;
				correlate = (typeof(correlate) === "string") ? ","+correlate+"," : _correlate;
				if (curviness == null) {
					curviness = 1;
				}
				for (p in values[0]) {
					props.push(p);
				}
				//check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)
				if (values.length > 1) {
					last = values[values.length - 1];
					seamless = true;
					i = props.length;
					while (--i > -1) {
						p = props[i];
						if (Math.abs(first[p] - last[p]) > 0.05) { //build in a tolerance of +/-0.05 to accommodate rounding errors.
							seamless = false;
							break;
						}
					}
					if (seamless) {
						values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens
						if (prepend) {
							values.unshift(prepend);
						}
						values.push(values[1]);
						prepend = values[values.length - 3];
					}
				}
				_r1.length = _r2.length = _r3.length = 0;
				i = props.length;
				while (--i > -1) {
					p = props[i];
					_corProps[p] = (correlate.indexOf(","+p+",") !== -1);
					obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
				}
				i = _r1.length;
				while (--i > -1) {
					_r1[i] = Math.sqrt(_r1[i]);
					_r2[i] = Math.sqrt(_r2[i]);
				}
				if (!basic) {
					i = props.length;
					while (--i > -1) {
						if (_corProps[p]) {
							a = obj[props[i]];
							l = a.length - 1;
							for (j = 0; j < l; j++) {
								r = (a[j+1].da / _r2[j] + a[j].da / _r1[j]) || 0;
								_r3[j] = (_r3[j] || 0) + r * r;
							}
						}
					}
					i = _r3.length;
					while (--i > -1) {
						_r3[i] = Math.sqrt(_r3[i]);
					}
				}
				i = props.length;
				j = quadratic ? 4 : 1;
				while (--i > -1) {
					p = props[i];
					a = obj[p];
					_calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties
					if (seamless) {
						a.splice(0, j);
						a.splice(a.length - j, j);
					}
				}
				return obj;
			},
			_parseBezierData = function(values, type, prepend) {
				type = type || "soft";
				var obj = {},
					inc = (type === "cubic") ? 3 : 2,
					soft = (type === "soft"),
					props = [],
					a, b, c, d, cur, i, j, l, p, cnt, tmp;
				if (soft && prepend) {
					values = [prepend].concat(values);
				}
				if (values == null || values.length < inc + 1) { throw "invalid Bezier data"; }
				for (p in values[0]) {
					props.push(p);
				}
				i = props.length;
				while (--i > -1) {
					p = props[i];
					obj[p] = cur = [];
					cnt = 0;
					l = values.length;
					for (j = 0; j < l; j++) {
						a = (prepend == null) ? values[j][p] : (typeof( (tmp = values[j][p]) ) === "string" && tmp.charAt(1) === "=") ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
						if (soft) if (j > 1) if (j < l - 1) {
							cur[cnt++] = (a + cur[cnt-2]) / 2;
						}
						cur[cnt++] = a;
					}
					l = cnt - inc + 1;
					cnt = 0;
					for (j = 0; j < l; j += inc) {
						a = cur[j];
						b = cur[j+1];
						c = cur[j+2];
						d = (inc === 2) ? 0 : cur[j+3];
						cur[cnt++] = tmp = (inc === 3) ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
					}
					cur.length = cnt;
				}
				return obj;
			},
			_addCubicLengths = function(a, steps, resolution) {
				var inc = 1 / resolution,
					j = a.length,
					d, d1, s, da, ca, ba, p, i, inv, bez, index;
				while (--j > -1) {
					bez = a[j];
					s = bez.a;
					da = bez.d - s;
					ca = bez.c - s;
					ba = bez.b - s;
					d = d1 = 0;
					for (i = 1; i <= resolution; i++) {
						p = inc * i;
						inv = 1 - p;
						d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
						index = j * resolution + i - 1;
						steps[index] = (steps[index] || 0) + d * d;
					}
				}
			},
			_parseLengthData = function(obj, resolution) {
				resolution = resolution >> 0 || 6;
				var a = [],
					lengths = [],
					d = 0,
					total = 0,
					threshold = resolution - 1,
					segments = [],
					curLS = [], //current length segments array
					p, i, l, index;
				for (p in obj) {
					_addCubicLengths(obj[p], a, resolution);
				}
				l = a.length;
				for (i = 0; i < l; i++) {
					d += Math.sqrt(a[i]);
					index = i % resolution;
					curLS[index] = d;
					if (index === threshold) {
						total += d;
						index = (i / resolution) >> 0;
						segments[index] = curLS;
						lengths[index] = total;
						d = 0;
						curLS = [];
					}
				}
				return {length:total, lengths:lengths, segments:segments};
			},



			BezierPlugin = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */]._gsDefine.plugin({
					propName: "bezier",
					priority: -1,
					version: "1.3.8",
					API: 2,
					global:true,

					//gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
					init: function(target, vars, tween) {
						this._target = target;
						if (vars instanceof Array) {
							vars = {values:vars};
						}
						this._func = {};
						this._mod = {};
						this._props = [];
						this._timeRes = (vars.timeResolution == null) ? 6 : parseInt(vars.timeResolution, 10);
						var values = vars.values || [],
							first = {},
							second = values[0],
							autoRotate = vars.autoRotate || tween.vars.orientToBezier,
							p, isFunc, i, j, prepend;

						this._autoRotate = autoRotate ? (autoRotate instanceof Array) ? autoRotate : [["x","y","rotation",((autoRotate === true) ? 0 : Number(autoRotate) || 0)]] : null;
						for (p in second) {
							this._props.push(p);
						}

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];

							this._overwriteProps.push(p);
							isFunc = this._func[p] = (typeof(target[p]) === "function");
							first[p] = (!isFunc) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
							if (!prepend) if (first[p] !== values[0][p]) {
								prepend = first;
							}
						}
						this._beziers = (vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft") ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, (vars.type === "thruBasic"), vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
						this._segCount = this._beziers[p].length;

						if (this._timeRes) {
							var ld = _parseLengthData(this._beziers, this._timeRes);
							this._length = ld.length;
							this._lengths = ld.lengths;
							this._segments = ld.segments;
							this._l1 = this._li = this._s1 = this._si = 0;
							this._l2 = this._lengths[0];
							this._curSeg = this._segments[0];
							this._s2 = this._curSeg[0];
							this._prec = 1 / this._curSeg.length;
						}

						if ((autoRotate = this._autoRotate)) {
							this._initialRotations = [];
							if (!(autoRotate[0] instanceof Array)) {
								this._autoRotate = autoRotate = [autoRotate];
							}
							i = autoRotate.length;
							while (--i > -1) {
								for (j = 0; j < 3; j++) {
									p = autoRotate[i][j];
									this._func[p] = (typeof(target[p]) === "function") ? target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ] : false;
								}
								p = autoRotate[i][2];
								this._initialRotations[i] = (this._func[p] ? this._func[p].call(this._target) : this._target[p]) || 0;
								this._overwriteProps.push(p);
							}
						}
						this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always 0 unless the tween has runBackwards:true (indicating it's a from() tween) in which case it's 1.
						return true;
					},

					//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
					set: function(v) {
						var segments = this._segCount,
							func = this._func,
							target = this._target,
							notStart = (v !== this._startRatio),
							curIndex, inv, i, p, b, t, val, l, lengths, curSeg;
						if (!this._timeRes) {
							curIndex = (v < 0) ? 0 : (v >= 1) ? segments - 1 : (segments * v) >> 0;
							t = (v - (curIndex * (1 / segments))) * segments;
						} else {
							lengths = this._lengths;
							curSeg = this._curSeg;
							v *= this._length;
							i = this._li;
							//find the appropriate segment (if the currently cached one isn't correct)
							if (v > this._l2 && i < segments - 1) {
								l = segments - 1;
								while (i < l && (this._l2 = lengths[++i]) <= v) {	}
								this._l1 = lengths[i-1];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s2 = curSeg[(this._s1 = this._si = 0)];
							} else if (v < this._l1 && i > 0) {
								while (i > 0 && (this._l1 = lengths[--i]) >= v) { }
								if (i === 0 && v < this._l1) {
									this._l1 = 0;
								} else {
									i++;
								}
								this._l2 = lengths[i];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
								this._s2 = curSeg[this._si];
							}
							curIndex = i;
							//now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)
							v -= this._l1;
							i = this._si;
							if (v > this._s2 && i < curSeg.length - 1) {
								l = curSeg.length - 1;
								while (i < l && (this._s2 = curSeg[++i]) <= v) {	}
								this._s1 = curSeg[i-1];
								this._si = i;
							} else if (v < this._s1 && i > 0) {
								while (i > 0 && (this._s1 = curSeg[--i]) >= v) {	}
								if (i === 0 && v < this._s1) {
									this._s1 = 0;
								} else {
									i++;
								}
								this._s2 = curSeg[i];
								this._si = i;
							}
							t = ((i + (v - this._s1) / (this._s2 - this._s1)) * this._prec) || 0;
						}
						inv = 1 - t;

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];
							b = this._beziers[p][curIndex];
							val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
							if (this._mod[p]) {
								val = this._mod[p](val, target);
							}
							if (func[p]) {
								target[p](val);
							} else {
								target[p] = val;
							}
						}

						if (this._autoRotate) {
							var ar = this._autoRotate,
								b2, x1, y1, x2, y2, add, conv;
							i = ar.length;
							while (--i > -1) {
								p = ar[i][2];
								add = ar[i][3] || 0;
								conv = (ar[i][4] === true) ? 1 : _RAD2DEG;
								b = this._beziers[ar[i][0]];
								b2 = this._beziers[ar[i][1]];

								if (b && b2) { //in case one of the properties got overwritten.
									b = b[curIndex];
									b2 = b2[curIndex];

									x1 = b.a + (b.b - b.a) * t;
									x2 = b.b + (b.c - b.b) * t;
									x1 += (x2 - x1) * t;
									x2 += ((b.c + (b.d - b.c) * t) - x2) * t;

									y1 = b2.a + (b2.b - b2.a) * t;
									y2 = b2.b + (b2.c - b2.b) * t;
									y1 += (y2 - y1) * t;
									y2 += ((b2.c + (b2.d - b2.c) * t) - y2) * t;

									val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];

									if (this._mod[p]) {
										val = this._mod[p](val, target); //for modProps
									}

									if (func[p]) {
										target[p](val);
									} else {
										target[p] = val;
									}
								}
							}
						}
					}
			}),
			p = BezierPlugin.prototype;


		BezierPlugin.bezierThrough = bezierThrough;
		BezierPlugin.cubicToQuadratic = cubicToQuadratic;
		BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
		BezierPlugin.quadraticToCubic = function(a, b, c) {
			return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
		};

		BezierPlugin._cssRegister = function() {
			var CSSPlugin = _globals.CSSPlugin;
			if (!CSSPlugin) {
				return;
			}
			var _internals = CSSPlugin._internals,
				_parseToProxy = _internals._parseToProxy,
				_setPluginRatio = _internals._setPluginRatio,
				CSSPropTween = _internals.CSSPropTween;
			_internals._registerComplexSpecialProp("bezier", {parser:function(t, e, prop, cssp, pt, plugin) {
				if (e instanceof Array) {
					e = {values:e};
				}
				plugin = new BezierPlugin();
				var values = e.values,
					l = values.length - 1,
					pluginValues = [],
					v = {},
					i, p, data;
				if (l < 0) {
					return pt;
				}
				for (i = 0; i <= l; i++) {
					data = _parseToProxy(t, values[i], cssp, pt, plugin, (l !== i));
					pluginValues[i] = data.end;
				}
				for (p in e) {
					v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
				}
				v.values = pluginValues;
				pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
				pt.data = data;
				pt.plugin = plugin;
				pt.setRatio = _setPluginRatio;
				if (v.autoRotate === 0) {
					v.autoRotate = true;
				}
				if (v.autoRotate && !(v.autoRotate instanceof Array)) {
					i = (v.autoRotate === true) ? 0 : Number(v.autoRotate);
					v.autoRotate = (data.end.left != null) ? [["left","top","rotation",i,false]] : (data.end.x != null) ? [["x","y","rotation",i,false]] : false;
				}
				if (v.autoRotate) {
					if (!cssp._transform) {
						cssp._enableTransforms(false);
					}
					data.autoRotate = cssp._target._gsTransform;
					data.proxy.rotation = data.autoRotate.rotation || 0;
					cssp._overwriteProps.push("rotation");
				}
				plugin._onInitTween(data.proxy, v, cssp._tween);
				return pt;
			}});
		};

		p._mod = function(lookup) {
			var op = this._overwriteProps,
				i = op.length,
				val;
			while (--i > -1) {
				val = lookup[op[i]];
				if (val && typeof(val) === "function") {
					this._mod[op[i]] = val;
				}
			}
		};

		p._kill = function(lookup) {
			var a = this._props,
				p, i;
			for (p in this._beziers) {
				if (p in lookup) {
					delete this._beziers[p];
					delete this._func[p];
					i = a.length;
					while (--i > -1) {
						if (a[i] === p) {
							a.splice(i, 1);
						}
					}
				}
			}
			a = this._autoRotate;
			if (a) {
				i = a.length;
				while (--i > -1) {
					if (lookup[a[i][2]]) {
						a.splice(i, 1);
					}
				}
			}
			return this._super._kill.call(this, lookup);
		};



/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Back; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return Elastic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Bounce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return RoughEase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return SlowMo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return SteppedEase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return Circ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return Expo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return Sine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return ExpoScaleEase; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(2);
/* unused harmony reexport Linear */
/* unused harmony reexport Power0 */
/* unused harmony reexport Power1 */
/* unused harmony reexport Power2 */
/* unused harmony reexport Power3 */
/* unused harmony reexport Power4 */
/*!
 * VERSION: 1.16.1
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/



__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */]._gsDefine("easing.Back", ["easing.Ease"], function() {
		
		var w = (__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */].GreenSockGlobals || __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["k" /* _gsScope */]),
			gs = w.com.greensock,
			_2PI = Math.PI * 2,
			_HALF_PI = Math.PI / 2,
			_class = gs._class,
			_create = function(n, f) {
				var C = _class("easing." + n, function(){}, true),
					p = C.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["b" /* Ease */]();
				p.constructor = C;
				p.getRatio = f;
				return C;
			},
			_easeReg = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["b" /* Ease */].register || function(){}, //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
			_wrap = function(name, EaseOut, EaseIn, EaseInOut, aliases) {
				var C = _class("easing."+name, {
					easeOut:new EaseOut(),
					easeIn:new EaseIn(),
					easeInOut:new EaseInOut()
				}, true);
				_easeReg(C, name);
				return C;
			},
			EasePoint = function(time, value, next) {
				this.t = time;
				this.v = value;
				if (next) {
					this.next = next;
					next.prev = this;
					this.c = next.v - value;
					this.gap = next.t - time;
				}
			},

			//Back
			_createBack = function(n, f) {
				var C = _class("easing." + n, function(overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}, true), 
					p = C.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["b" /* Ease */]();
				p.constructor = C;
				p.getRatio = f;
				p.config = function(overshoot) {
					return new C(overshoot);
				};
				return C;
			},

			Back = _wrap("Back",
				_createBack("BackOut", function(p) {
					return ((p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1);
				}),
				_createBack("BackIn", function(p) {
					return p * p * ((this._p1 + 1) * p - this._p1);
				}),
				_createBack("BackInOut", function(p) {
					return ((p *= 2) < 1) ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
				})
			),


			//SlowMo
			SlowMo = _class("easing.SlowMo", function(linearRatio, power, yoyoMode) {
				power = (power || power === 0) ? power : 0.7;
				if (linearRatio == null) {
					linearRatio = 0.7;
				} else if (linearRatio > 1) {
					linearRatio = 1;
				}
				this._p = (linearRatio !== 1) ? power : 0;
				this._p1 = (1 - linearRatio) / 2;
				this._p2 = linearRatio;
				this._p3 = this._p1 + this._p2;
				this._calcEnd = (yoyoMode === true);
			}, true),
			p = SlowMo.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["b" /* Ease */](),
			SteppedEase, ExpoScaleEase, RoughEase, _createElastic;
			
		p.constructor = SlowMo;
		p.getRatio = function(p) {
			var r = p + (0.5 - p) * this._p;
			if (p < this._p1) {
				return this._calcEnd ? 1 - ((p = 1 - (p / this._p1)) * p) : r - ((p = 1 - (p / this._p1)) * p * p * p * r);
			} else if (p > this._p3) {
				return this._calcEnd ? (p === 1 ? 0 : 1 - (p = (p - this._p3) / this._p1) * p) : r + ((p - r) * (p = (p - this._p3) / this._p1) * p * p * p); //added p === 1 ? 0 to avoid floating point rounding errors from affecting the final value, like 1 - 0.7 = 0.30000000000000004 instead of 0.3
			}
			return this._calcEnd ? 1 : r;
		};
		SlowMo.ease = new SlowMo(0.7, 0.7);
		
		p.config = SlowMo.config = function(linearRatio, power, yoyoMode) {
			return new SlowMo(linearRatio, power, yoyoMode);
		};


		//SteppedEase
		SteppedEase = _class("easing.SteppedEase", function(steps, immediateStart) {
				steps = steps || 1;
				this._p1 = 1 / steps;
				this._p2 = steps + (immediateStart ? 0 : 1);
				this._p3 = immediateStart ? 1 : 0;
			}, true);
		p = SteppedEase.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["b" /* Ease */]();	
		p.constructor = SteppedEase;
		p.getRatio = function(p) {
			if (p < 0) {
				p = 0;
			} else if (p >= 1) {
				p = 0.999999999;
			}
			return (((this._p2 * p) | 0) + this._p3) * this._p1;
		};
		p.config = SteppedEase.config = function(steps, immediateStart) {
			return new SteppedEase(steps, immediateStart);
		};


		//ExpoScaleEase
		ExpoScaleEase = _class("easing.ExpoScaleEase", function(start, end, ease) {
			this._p1 = Math.log(end / start);
			this._p2 = end - start;
			this._p3 = start;
			this._ease = ease;
		}, true);
		p = ExpoScaleEase.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["b" /* Ease */]();
		p.constructor = ExpoScaleEase;
		p.getRatio = function(p) {
			if (this._ease) {
				p = this._ease.getRatio(p);
			}
			return (this._p3 * Math.exp(this._p1 * p) - this._p3) / this._p2;
		};
		p.config = ExpoScaleEase.config = function(start, end, ease) {
			return new ExpoScaleEase(start, end, ease);
		};


		//RoughEase
		RoughEase = _class("easing.RoughEase", function(vars) {
			vars = vars || {};
			var taper = vars.taper || "none",
				a = [],
				cnt = 0,
				points = (vars.points || 20) | 0,
				i = points,
				randomize = (vars.randomize !== false),
				clamp = (vars.clamp === true),
				template = (vars.template instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["b" /* Ease */]) ? vars.template : null,
				strength = (typeof(vars.strength) === "number") ? vars.strength * 0.4 : 0.4,
				x, y, bump, invX, obj, pnt;
			while (--i > -1) {
				x = randomize ? Math.random() : (1 / points) * i;
				y = template ? template.getRatio(x) : x;
				if (taper === "none") {
					bump = strength;
				} else if (taper === "out") {
					invX = 1 - x;
					bump = invX * invX * strength;
				} else if (taper === "in") {
					bump = x * x * strength;
				} else if (x < 0.5) {  //"both" (start)
					invX = x * 2;
					bump = invX * invX * 0.5 * strength;
				} else {				//"both" (end)
					invX = (1 - x) * 2;
					bump = invX * invX * 0.5 * strength;
				}
				if (randomize) {
					y += (Math.random() * bump) - (bump * 0.5);
				} else if (i % 2) {
					y += bump * 0.5;
				} else {
					y -= bump * 0.5;
				}
				if (clamp) {
					if (y > 1) {
						y = 1;
					} else if (y < 0) {
						y = 0;
					}
				}
				a[cnt++] = {x:x, y:y};
			}
			a.sort(function(a, b) {
				return a.x - b.x;
			});

			pnt = new EasePoint(1, 1, null);
			i = points;
			while (--i > -1) {
				obj = a[i];
				pnt = new EasePoint(obj.x, obj.y, pnt);
			}

			this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);
		}, true);
		p = RoughEase.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["b" /* Ease */]();
		p.constructor = RoughEase;
		p.getRatio = function(p) {
			var pnt = this._prev;
			if (p > pnt.t) {
				while (pnt.next && p >= pnt.t) {
					pnt = pnt.next;
				}
				pnt = pnt.prev;
			} else {
				while (pnt.prev && p <= pnt.t) {
					pnt = pnt.prev;
				}
			}
			this._prev = pnt;
			return (pnt.v + ((p - pnt.t) / pnt.gap) * pnt.c);
		};
		p.config = function(vars) {
			return new RoughEase(vars);
		};
		RoughEase.ease = new RoughEase();


		//Bounce
		_wrap("Bounce",
			_create("BounceOut", function(p) {
				if (p < 1 / 2.75) {
					return 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				}
				return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
			}),
			_create("BounceIn", function(p) {
				if ((p = 1 - p) < 1 / 2.75) {
					return 1 - (7.5625 * p * p);
				} else if (p < 2 / 2.75) {
					return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
				} else if (p < 2.5 / 2.75) {
					return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
				}
				return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
			}),
			_create("BounceInOut", function(p) {
				var invert = (p < 0.5);
				if (invert) {
					p = 1 - (p * 2);
				} else {
					p = (p * 2) - 1;
				}
				if (p < 1 / 2.75) {
					p = 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				} else {
					p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
				}
				return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
			})
		);


		//CIRC
		_wrap("Circ",
			_create("CircOut", function(p) {
				return Math.sqrt(1 - (p = p - 1) * p);
			}),
			_create("CircIn", function(p) {
				return -(Math.sqrt(1 - (p * p)) - 1);
			}),
			_create("CircInOut", function(p) {
				return ((p*=2) < 1) ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
			})
		);


		//Elastic
		_createElastic = function(n, f, def) {
			var C = _class("easing." + n, function(amplitude, period) {
					this._p1 = (amplitude >= 1) ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}, true),
				p = C.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["b" /* Ease */]();
			p.constructor = C;
			p.getRatio = f;
			p.config = function(amplitude, period) {
				return new C(amplitude, period);
			};
			return C;
		};
		_wrap("Elastic",
			_createElastic("ElasticOut", function(p) {
				return this._p1 * Math.pow(2, -10 * p) * Math.sin( (p - this._p3) * this._p2 ) + 1;
			}, 0.3),
			_createElastic("ElasticIn", function(p) {
				return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2 ));
			}, 0.3),
			_createElastic("ElasticInOut", function(p) {
				return ((p *= 2) < 1) ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 *(p -= 1)) * Math.sin( (p - this._p3) * this._p2 ) * 0.5 + 1;
			}, 0.45)
		);


		//Expo
		_wrap("Expo",
			_create("ExpoOut", function(p) {
				return 1 - Math.pow(2, -10 * p);
			}),
			_create("ExpoIn", function(p) {
				return Math.pow(2, 10 * (p - 1)) - 0.001;
			}),
			_create("ExpoInOut", function(p) {
				return ((p *= 2) < 1) ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
			})
		);


		//Sine
		_wrap("Sine",
			_create("SineOut", function(p) {
				return Math.sin(p * _HALF_PI);
			}),
			_create("SineIn", function(p) {
				return -Math.cos(p * _HALF_PI) + 1;
			}),
			_create("SineInOut", function(p) {
				return -0.5 * (Math.cos(Math.PI * p) - 1);
			})
		);

		_class("easing.EaseLookup", {
				find:function(s) {
					return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["b" /* Ease */].map[s];
				}
			}, true);

		//register the non-standard eases
		_easeReg(w.SlowMo, "SlowMo", "ease,");
		_easeReg(RoughEase, "RoughEase", "ease,");
		_easeReg(SteppedEase, "SteppedEase", "ease,");
		
		return Back;
		
	}, true);

var Back = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["m" /* globals */].Back;
var Elastic = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["m" /* globals */].Elastic;
var Bounce = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["m" /* globals */].Bounce;
var RoughEase = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["m" /* globals */].RoughEase;
var SlowMo = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["m" /* globals */].SlowMo;
var SteppedEase = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["m" /* globals */].SteppedEase;
var Circ = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["m" /* globals */].Circ;
var Expo = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["m" /* globals */].Expo;
var Sine = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["m" /* globals */].Sine;
var ExpoScaleEase = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["m" /* globals */].ExpoScaleEase;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assetsLoader = __webpack_require__(81);
assetsLoader.stats = __webpack_require__(13);

module.exports = assetsLoader;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Emitter = __webpack_require__(12);
var createLoader = __webpack_require__(83);
var autoId = 0;

module.exports = function createGroup(config) {
    var group;
    var map = {};
    var assets = [];
    var queue = [];
    var numLoaded = 0;
    var numTotal = 0;
    var loaders = {};

    var add = function(options) {
        // console.debug('add', options);
        if (Array.isArray(options)) {
            options.forEach(add);
            return group;
        }
        var isGroup = !!options.assets && Array.isArray(options.assets);
        // console.debug('isGroup', isGroup);
        var loader;
        if (isGroup) {
            loader = createGroup(configure(options, config));
        } else {
            loader = createLoader(configure(options, config));
        }
        loader.once('destroy', destroyHandler);
        queue.push(loader);
        loaders[loader.id] = loader;
        return group;
    };

    var get = function(id) {
        if (!arguments.length) {
            return assets;
        }
        if (map[id]) {
            return map[id];
        }
        return loaders[id];
    };

    var find = function(id) {
        if (get(id)) {
            return get(id);
        }
        var found = null;
        Object.keys(loaders).some(function(key) {
            found = loaders[key].find && loaders[key].find(id);
            return !!found;
        });
        return found;
    };

    var getExtension = function(url) {
        return url && url.split('?')[0].split('.').pop().toLowerCase();
    };

    var configure = function(options, defaults) {
        if (typeof options === 'string') {
            var url = options;
            options = {
                url: url
            };
        }

        if (options.isTouchLocked === undefined) {
            options.isTouchLocked = defaults.isTouchLocked;
        }

        if (options.blob === undefined) {
            options.blob = defaults.blob;
        }

        if (options.basePath === undefined) {
            options.basePath = defaults.basePath;
        }

        options.id = options.id || options.url || String(++autoId);
        options.type = options.type || getExtension(options.url);
        options.crossOrigin = options.crossOrigin || defaults.crossOrigin;
        options.webAudioContext = options.webAudioContext || defaults.webAudioContext;
        options.log = defaults.log;

        return options;
    };

    var start = function() {
        numTotal = queue.length;

        queue.forEach(function(loader) {
            loader
                .on('progress', progressHandler)
                .once('complete', completeHandler)
                .once('error', errorHandler)
                .start();
        });

        queue = [];

        return group;
    };

    var progressHandler = function(progress) {
        var loaded = numLoaded + progress;
        group.emit('progress', loaded / numTotal);
    };

    var completeHandler = function(asset, id, type) {
        if (Array.isArray(asset)) {
            asset = { id: id, file: asset, type: type };
        }
        numLoaded++;
        group.emit('progress', numLoaded / numTotal);
        map[asset.id] = asset.file;
        assets.push(asset);
        group.emit('childcomplete', asset);
        checkComplete();
    };

    var errorHandler = function(err) {
        numTotal--;
        if (group.listeners('error').length) {
            group.emit('error', err);
        } else {
            console.error(err);
        }
        checkComplete();
    };

    var destroyHandler = function(id) {
        loaders[id] = null;
        delete loaders[id];

        map[id] = null;
        delete map[id];

        assets.some(function(asset, i) {
            if (asset.id === id) {
                assets.splice(i, 1);
                return true;
            }
        });
    };

    var checkComplete = function() {
        if (numLoaded >= numTotal) {
            group.emit('complete', assets, map, config.id, 'group');
        }
    };

    var destroy = function() {
        while (queue.length) {
            queue.pop().destroy();
        }
        group.off('error');
        group.off('progress');
        group.off('complete');
        assets = [];
        map = {};
        config.webAudioContext = null;
        numTotal = 0;
        numLoaded = 0;

        Object.keys(loaders).forEach(function(key) {
            loaders[key].destroy();
        });
        loaders = {};

        group.emit('destroy', group.id);

        return group;
    };

    // emits: progress, error, complete, destroy

    group = Object.create(Emitter.prototype, {
        _events: {
            value: {}
        },
        id: {
            get: function() {
                return config.id;
            }
        },
        add: {
            value: add
        },
        start: {
            value: start
        },
        get: {
            value: get
        },
        find: {
            value: find
        },
        getLoader: {
            value: function(id) {
                return loaders[id];
            }
        },
        loaded: {
            get: function() {
                return numLoaded >= numTotal;
            }
        },
        file: {
            get: function() {
                return assets;
            }
        },
        destroy: {
            value: destroy
        }
    });

    config = configure(config || {}, {
        basePath: '',
        blob: false,
        touchLocked: false,
        crossOrigin: null,
        webAudioContext: null,
        log: false
    });

    if (Array.isArray(config.assets)) {
        add(config.assets);
    }

    return Object.freeze(group);
};


/***/ }),
/* 82 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Emitter = __webpack_require__(12);
var browserHasBlob = __webpack_require__(84);
var stats = __webpack_require__(13);

module.exports = function(options) {
    var id = options.id;
    var basePath = options.basePath || '';
    var url = options.url;
    var type = options.type;
    var crossOrigin = options.crossOrigin;
    var isTouchLocked = options.isTouchLocked;
    var blob = options.blob && browserHasBlob;
    var webAudioContext = options.webAudioContext;
    var log = options.log;

    var loader;
    var loadHandler;
    var request;
    var startTime;
    var timeout;
    var file;

    var start = function() {
        startTime = Date.now();

        switch (type) {
            case 'json':
                loadJSON();
                break;
            case 'jpg':
            case 'png':
            case 'gif':
            case 'webp':
                loadImage();
                break;
            case 'mp3':
            case 'ogg':
            case 'opus':
            case 'wav':
            case 'm4a':
                loadAudio();
                break;
            case 'ogv':
            case 'mp4':
            case 'webm':
            case 'hls':
                loadVideo();
                break;
            case 'bin':
            case 'binary':
                loadXHR('arraybuffer');
                break;
            case 'txt':
            case 'text':
                loadXHR('text');
                break;
            default:
                throw 'AssetsLoader ERROR: Unknown type for file with URL: ' + basePath + url + ' (' + type + ')';
        }
    };

    var dispatchComplete = function(data) {
        if (!data) {
            return;
        }
        file = {id: id, file: data, type: type};
        loader.emit('progress', 1);
        loader.emit('complete', file, id, type);
        removeListeners();
    };

    var loadXHR = function(responseType, customLoadHandler) {
        loadHandler = customLoadHandler || completeHandler;

        request = new XMLHttpRequest();
        request.open('GET', basePath + url, true);
        request.responseType = responseType;
        request.addEventListener('progress', progressHandler);
        request.addEventListener('load', loadHandler);
        request.addEventListener('error', errorHandler);
        request.send();
    };

    var progressHandler = function(event) {
        if (event.lengthComputable) {
            loader.emit('progress', event.loaded / event.total);
        }
    };

    var completeHandler = function() {
        if (success()) {
            dispatchComplete(request.response);
        }
    };

    var success = function() {
        // console.log('success', url, request.status);
        if (request && request.status < 400) {
            stats.update(request, startTime, url, log);
            return true;
        }
        errorHandler(request && request.statusText);
        return false;
    };

    // json

    var loadJSON = function() {
        loadXHR('json', function() {
            if (success()) {
                var data = request.response;
                if (typeof data === 'string') {
                    data = JSON.parse(data);
                }
                dispatchComplete(data);
            }
        });
    };

    // image

    var loadImage = function() {
        if (blob) {
            loadImageBlob();
        } else {
            loadImageElement();
        }
    };

    var loadImageElement = function() {
        request = new Image();
        if (crossOrigin) {
            request.crossOrigin = 'anonymous';
        }
        request.addEventListener('error', errorHandler, false);
        request.addEventListener('load', elementLoadHandler, false);
        request.src = basePath + url;
    };

    var elementLoadHandler = function(event) {
        window.clearTimeout(timeout);
        if (!event && (request.error || !request.readyState)) {
            errorHandler();
            return;
        }
        dispatchComplete(request);
    };

    var loadImageBlob = function() {
        loadXHR('blob', function() {
            if (success()) {
                request = new Image();
                request.addEventListener('error', errorHandler, false);
                request.addEventListener('load', imageBlobHandler, false);
                request.src = window.URL.createObjectURL(request.response);
            }
        });
    };

    var imageBlobHandler = function() {
        window.URL.revokeObjectURL(request.src);
        dispatchComplete(request);
    };

    // audio

    var loadAudio = function() {
        if (webAudioContext) {
            loadAudioBuffer();
        } else {
            loadMediaElement('audio');
        }
    };

    // video

    var loadVideo = function() {
        if (blob) {
            loadXHR('blob');
        } else {
            loadMediaElement('video');
        }
    };

    // audio buffer

    var loadAudioBuffer = function() {
        loadXHR('arraybuffer', function() {
            if (success()) {
                webAudioContext.decodeAudioData(
                    request.response,
                    function(buffer) {
                        request = null;
                        dispatchComplete(buffer);
                    },
                    function(e) {
                        errorHandler(e);
                    }
                );
            }
        });
    };

    // media element

    var loadMediaElement = function(tagName) {
        request = document.createElement(tagName);

        if (!isTouchLocked) {
            // timeout because sometimes canplaythrough doesn't fire
            window.clearTimeout(timeout);
            timeout = window.setTimeout(elementLoadHandler, 2000);
            request.addEventListener('canplaythrough', elementLoadHandler, false);
        }

        request.addEventListener('error', errorHandler, false);
        request.preload = 'auto';
        request.src = basePath + url;
        request.load();

        if (isTouchLocked) {
            dispatchComplete(request);
        }
    };

    // error

    var errorHandler = function(err) {
        // console.log('errorHandler', url, err);
        window.clearTimeout(timeout);

        var message = err;

        if (request && request.tagName && request.error) {
            var ERROR_STATE = ['', 'ABORTED', 'NETWORK', 'DECODE', 'SRC_NOT_SUPPORTED'];
            message = 'MediaError: ' + ERROR_STATE[request.error.code] + ' ' + request.src;
        } else if (request && request.statusText) {
            message = request.statusText;
        } else if (err && err.message) {
            message = err.message;
        } else if (err && err.type) {
            message = err.type;
        }

        loader.emit('error', 'Error loading "' + basePath + url + '" ' + message);

        destroy();
    };

    // clean up

    var removeListeners = function() {
        loader.off('error');
        loader.off('progress');
        loader.off('complete');

        if (request) {
            request.removeEventListener('progress', progressHandler);
            request.removeEventListener('load', loadHandler);
            request.removeEventListener('error', errorHandler);
            request.removeEventListener('load', elementLoadHandler);
            request.removeEventListener('canplaythrough', elementLoadHandler);
            request.removeEventListener('load', imageBlobHandler);
        }
    };

    var destroy = function() {
        removeListeners();

        if (request && request.abort && request.readyState < 4) {
            request.abort();
        }

        request = null;
        webAudioContext = null;
        file = null;

        window.clearTimeout(timeout);

        loader.emit('destroy', id);
    };

    // emits: progress, error, complete

    loader = Object.create(Emitter.prototype, {
        _events: {
            value: {}
        },
        id: {
            value: options.id
        },
        start: {
            value: start
        },
        loaded: {
            get: function() {
                return !!file;
            }
        },
        file: {
            get: function() {
                return file;
            }
        },
        destroy: {
            value: destroy
        }
    });

    return Object.freeze(loader);
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = (function() {
    try {
        return !!new Blob();
    } catch (e) {
        return false;
    }
}());


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _alfrid = __webpack_require__(0);

var _alfrid2 = _interopRequireDefault(_alfrid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // LoadingAnim.js

var CANVAS_SIZE = 200;
var COLOR_BLACK = "#000";
var COLOR_WHITE = "#fff";

//*/
var COLOR_PINK = "#a0a0a0";
/*/
const COLOR_PINK = "#f69882";
//*/

var LoadingAnim = function (_alfrid$EventDispatch) {
	_inherits(LoadingAnim, _alfrid$EventDispatch);

	function LoadingAnim() {
		_classCallCheck(this, LoadingAnim);

		var _this = _possibleConstructorReturn(this, (LoadingAnim.__proto__ || Object.getPrototypeOf(LoadingAnim)).call(this));

		_this.canvas = document.body.querySelector('.loading-anim');
		_this.context = _this.canvas.getContext('2d');

		_this._hasAnimationCompleted = false;
		_this._hasCalledClose = false;
		_this.startAnimation();
		return _this;
	}

	_createClass(LoadingAnim, [{
		key: "startAnimation",
		value: function startAnimation() {
			var _this2 = this;

			var context = this.context;

			var animationList = [{ type: 'arc', start: 0, end: -360, sAngle: 0, radius: 400, x: 400, y: 400, delay: .55, duration: 1, color: COLOR_PINK, reverse: true }, { type: 'eye' }, { type: 'arc', start: 180, end: 360, sAngle: 180, radius: 404, x: 400, y: 400, delay: 1.5, duration: .85, color: COLOR_WHITE, reverse: false }, { type: 'arc', start: 0, end: 360, sAngle: 0, radius: 112, x: 620, y: 385, delay: 1.6, duration: 1, color: COLOR_WHITE, reverse: false }, { type: 'arc', start: 0, end: -180, sAngle: 0, radius: 83, x: 400, y: 667, delay: 1.15, duration: 1, color: COLOR_PINK, reverse: true }, { type: 'arc', start: 0, end: -360, sAngle: 0, radius: 112, x: 180, y: 385, delay: 1.85, duration: 1, color: COLOR_PINK, reverse: true }, { type: 'arc', start: 0, end: 180, sAngle: 0, radius: 83, x: 400, y: 667, delay: 1.65, duration: 1, color: COLOR_WHITE, reverse: false }, { type: 'radius', start: 0, end: 54, x: 180, y: 385, delay: .00, duration: 1, color: COLOR_BLACK }, { type: 'radius', start: 0, end: 54, x: 620, y: 385, delay: .06, duration: 1, color: COLOR_BLACK }, { type: 'radius', start: 0, end: 34, x: 400, y: 667, delay: .03, duration: 1, color: COLOR_BLACK }, { type: 'arc', start: 0, end: -180, sAngle: 0, radius: 27, x: 400, y: 125, delay: 1.65, duration: 1, color: COLOR_BLACK, reverse: true }, { type: 'arc', start: 0, end: -180, sAngle: 0, radius: 27, x: 400, y: 210, delay: 1.77, duration: 1, color: COLOR_BLACK, reverse: true }, { type: 'arc', start: 0, end: -180, sAngle: 0, radius: 27, x: 400, y: 295, delay: 1.85, duration: 1, color: COLOR_BLACK, reverse: true }, { type: 'arc', start: 0, end: -180, sAngle: 0, radius: 27, x: 400, y: 380, delay: 1.95, duration: 1, color: COLOR_BLACK, reverse: true }];

			var eye = {

				radius: 82 / 4,
				center: { x: 620 / 4, y: 385 / 4, x1: 620 / 4, y1: 385 / 4, x2: 620 / 4, y2: 385 / 4 },
				start: { x: 485 / 4, y: 520 / 4 },
				end: { x: 755 / 4, y: 250 / 4 }

			};

			var timeline = null;
			timeline = new TimelineLite({

				delay: 1,
				onStart: function onStart() {},
				onUpdate: function onUpdate() {

					animationList.map(function (item) {
						if (item.type == 'radius') _this2.drawArc(context, item.color, item.x, item.y, 0, item.start, 0, 360);else if (item.type == 'arc') _this2.drawArc(context, item.color, item.x, item.y, 0, item.radius, item.sAngle, item.start, item.reverse);else {
							context.fillStyle = COLOR_BLACK;
							context.beginPath();
							context.moveTo(eye.start.x, eye.start.y);
							context.quadraticCurveTo(eye.center.x1, eye.center.y1, eye.end.x, eye.end.y);
							context.moveTo(eye.start.x, eye.start.y);
							context.fill();
							context.beginPath();
							context.moveTo(eye.start.x, eye.start.y);
							context.quadraticCurveTo(eye.center.x2, eye.center.y2, eye.end.x, eye.end.y);
							context.moveTo(eye.start.x, eye.start.y);
							context.fill();
						};
					});
				},
				onComplete: function onComplete() {
					return _this2.onAnimationComplete();
				}

			});

			timeline.pause();

			animationList.map(function (item) {

				timeline.insert(new TweenLite(item, item.duration, {
					delay: item.delay,
					start: item.end,
					ease: Expo.easeInOut
				}));
			});

			timeline.insert(new TweenLite(eye.center, .75, {

				delay: 2.25,
				x1: eye.center.x + eye.radius,
				y1: eye.center.y + eye.radius,
				x2: eye.center.x - eye.radius,
				y2: eye.center.y - eye.radius,
				ease: Expo.easeInOut

			}));

			timeline.play();
		}
	}, {
		key: "onAnimationComplete",
		value: function onAnimationComplete() {
			this._hasAnimationCompleted = true;
		}
	}, {
		key: "close",
		value: function close() {
			var _this3 = this;

			if (!this._hasAnimationCompleted) {
				this._hasCalledClose = true;
				_alfrid2.default.Scheduler.next(function () {
					return _this3.close();
				});
				return;
			}

			setTimeout(function () {
				_this3.canvas.classList.add('close');
			}, this._hasCalledClose ? 500 : 1);

			setTimeout(function () {
				_this3.trigger('onAnimClosed');
			}, this._hasCalledClose ? 1500 : 1000);
		}
	}, {
		key: "drawArc",
		value: function drawArc(ctx, color, centerX, centerY, innerRadius, outerRadius, startAngle, endAngle, anticlockwise) {

			centerX = centerX / 4;
			centerY = centerY / 4;
			innerRadius = innerRadius / 4;
			outerRadius = outerRadius / 4;

			startAngle -= 90;
			endAngle -= 90;

			var th1 = startAngle * Math.PI / 180;
			var th2 = endAngle * Math.PI / 180;
			var startOfOuterArcX = outerRadius * Math.cos(th2) + centerX;
			var startOfOuterArcY = outerRadius * Math.sin(th2) + centerY;

			ctx.fillStyle = color;
			ctx.beginPath();
			ctx.arc(centerX, centerY, innerRadius, th1, th2, anticlockwise);
			ctx.lineTo(startOfOuterArcX, startOfOuterArcY);
			ctx.arc(centerX, centerY, outerRadius, th2, th1, !anticlockwise);
			ctx.closePath();
			ctx.fill();
		}
	}]);

	return LoadingAnim;
}(_alfrid2.default.EventDispatcher);

exports.default = LoadingAnim;

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNDJiOGIyMjU0NjRlMzU0YTVjMWYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsZnJpZC9idWlsZC9hbGZyaWQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL0NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3NhcC9Ud2VlbkxpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL0Fzc2V0cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2Nzcy9nbG9iYWwuc2NzcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2Fzc2V0LWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL1NldHRpbmdzLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvZGVwdGguZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvVmlld0ZvZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3NhcC9UaW1lbGluZUxpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fzc2V0cy1sb2FkZXIvc3JjL2VtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fzc2V0cy1sb2FkZXIvc3JjL3N0YXRzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Njc3MvZ2xvYmFsLnNjc3M/OTczNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2RlYnVnL2RlYnVnUG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL1NjZW5lQXBwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYXN0LXVybC1wYXJzZXIvc3JjL3VybHBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZ3BhcnNlci9qcy9xdWVyeXN0cmluZ3BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmdwYXJzZXIvanMvcXVlcnlzdHJpbmdzZXJpYWxpemVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9Ob2lzZTNELmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9Ob2lzZTNEVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9ub2lzZS5mcmFnIiwid2VicGFjazovLy8uL3NyYy9qcy91dGlscy9nZW5lcmF0ZVRyZWVzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy91dGlscy9nZW5lcmF0ZUhlaWdodE1hcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbHMvRmJvUGluZ1BvbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvdHJlZUhlaWdodC5mcmFnIiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL2hpbGwuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbHMvZ2V0Qm91bmRpbmdCb3guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWxzL3NhdmVKc29uLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9WaWV3Rmxvb3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvZmxvb3IudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvVmlld1RyZWVzLmpzIiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL3RyZWVzLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL1ZpZXdCZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9iZy52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL2JnLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL1ZpZXdHcm91bmQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvZ3JvdW5kLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvZ3JvdW5kLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvZm9nLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvZm9nLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL1ZpZXdGb2dzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9WaWV3RlhBQS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9meGFhLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL1ZpZXdBbmltYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvYW5pbWFsLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvYW5pbWFsLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL1ZpZXdTcXVhcmVzLmpzIiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL3NxdWFyZXMudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9zcXVhcmVzLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL1ZpZXdDb3Zlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvVmlld1Nub3cuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvc25vdy52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy9qcy9QYXNzQmxvb20uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvdGhyZXNob2xkLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvYmxvb20uZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9ibG9vbUNvbXBvc2UuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvU291bmRNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWJzL3Nvbm8uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2RlYnVnL2FkZENvbnRyb2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nc2FwL1R3ZWVuTWF4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9oYXJtb255LW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3NhcC9Ud2Vlbk1heEJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dzYXAvQ1NTUGx1Z2luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nc2FwL0F0dHJQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dzYXAvUm91bmRQcm9wc1BsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3NhcC9EaXJlY3Rpb25hbFJvdGF0aW9uUGx1Z2luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nc2FwL1RpbWVsaW5lTWF4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nc2FwL0JlemllclBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3NhcC9FYXNlUGFjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNzZXRzLWxvYWRlci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fzc2V0cy1sb2FkZXIvc3JjL2dyb3VwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3NldHMtbG9hZGVyL3NyYy9sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fzc2V0cy1sb2FkZXIvc3JjL2Jyb3dzZXItaGFzLWJsb2IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL0xvYWRpbmdBbmltLmpzIl0sIm5hbWVzIjpbIm51bVRyZWVzIiwidHJlZVNjYWxlIiwiZmxvb3JSYWRpdXMiLCJtYXhGbG9vckhlaWdodCIsInRyZWVCdW1wSGVpZ2h0IiwibnVtU2xpZGVzIiwibm9pc2VOdW0iLCJub2lzZVNjYWxlIiwiYW5pbWF0ZWQiLCJmeGFhIiwib3ZlcmxheU9wYWNpdHkiLCJibG9vbVN0cmVuZ3RoIiwicGl4ZWxhdGVNaXhpbmciLCJhbmltYWwiLCJmb2dNb3ZpbmdTcGVlZCIsImdyYWRpZW50TWFwIiwic2hvd1Nub3ciLCJzbm93U3BlZWQiLCJBc3NldHMiLCJfYXNzZXRzIiwiZ2V0QXNzZXQiLCJpZCIsImFzc2V0cyIsImZpbmQiLCJhIiwiZmlsZSIsImdldEV4dGVuc2lvbiIsIm1GaWxlIiwiYXJ5Iiwic3BsaXQiLCJsZW5ndGgiLCJpbml0IiwiaGRyQ3ViZW1hcHMiLCJtYXAiLCJvIiwiZXh0IiwidXJsIiwidGV4dHVyZSIsImN1YmVtYXBOYW1lIiwiSERSTG9hZGVyIiwicGFyc2UiLCJvQXNzZXQiLCJwdXNoIiwicGFyc2VERFMiLCJtZXNoIiwicyIsImNvbnNvbGUiLCJsb2ciLCJnZXQiLCJHTEN1YmVUZXh0dXJlIiwiZGVidWciLCJ0YWJsZSIsIm1JZCIsImdlbmVyYXRlVHJlZXMiLCJnZW5lcmF0ZUhlaWdodE1hcCIsImdldEJvdW5kaW5nQm94Iiwic2F2ZUpzb24iLCJhc3NldHNUb0xvYWQiLCJxdWVyeVN0cmluZyIsInJlcXVpcmUiLCJlbmFibGVkIiwicmVsb2FkIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwib3JpZ2luIiwicGF0aG5hbWUiLCJKU09OIiwic3RyaW5naWZ5IiwicmVmcmVzaCIsImhpc3RvcnkiLCJwdXNoU3RhdGUiLCJkZWxheUluZGV4IiwiZGVsYXlSZWxvYWQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwibUVuYWJsZWQiLCJwYXJzZWQiLCJzZWFyY2giLCJxdWVyeSIsImNvbmZpZyIsIm9Db25maWciLCJrZXkiLCJWaWV3Rm9nIiwicmVzZXQiLCJtTnVtU2xpZGVzIiwiX251bVNsaWRlcyIsIkdlb20iLCJwbGFuZSIsInBvc09mZnNldCIsImkiLCJ6Iiwib2Zmc2V0IiwiYnVmZmVySW5zdGFuY2UiLCJ0ZXh0dXJlMCIsInRleHR1cmUxIiwicGVyY2VudCIsImVuYWJsZUFkZGl0aXZlQmxlbmRpbmciLCJzaGFkZXIiLCJiaW5kIiwidW5pZm9ybSIsImRyYXciLCJlbmFibGVBbHBoYUJsZW5kaW5nIiwiVmlldyIsImxvYWRpbmdBbmltIiwiZG9jdW1lbnQiLCJib2R5IiwiX2luaXQiLCJhZGRFdmVudExpc3RlbmVyIiwiY2xhc3NMaXN0IiwiYWRkIiwibG9hZGVyIiwib24iLCJlcnJvciIsInAiLCJxdWVyeVNlbGVjdG9yIiwic3R5bGUiLCJ3aWR0aCIsIl9vbkltYWdlTG9hZGVkIiwic3RhcnQiLCJfaW5pdDNEIiwicmVtb3ZlIiwiY29udGFpbmVyIiwiY2FudmFzIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImFwcGVuZENoaWxkIiwiaWdub3JlV2ViZ2wyIiwiaXNNb2JpbGUiLCJ1YSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInRlc3QiLCJzY2VuZSIsImJ0bkZTIiwiYnRuRlNUZXh0IiwiaXNJbkZ1bGxTY3JlZW4iLCJlIiwid2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4iLCJFbGVtZW50IiwiQUxMT1dfS0VZQk9BUkRfSU5QVVQiLCJpbm5lckhUTUwiLCJ3ZWJraXRFeGl0RnVsbHNjcmVlbiIsIm9wZW4iLCJjbG9zZSIsImd1aSIsImZib1NjYWxlIiwiaW50ZXJ2YWwiLCJyYW5kb20iLCJtaW4iLCJtYXgiLCJNYXRoIiwiU2NlbmVBcHAiLCJyZXNpemUiLCJvcmJpdGFsQ29udHJvbCIsInJhZGl1cyIsInZhbHVlIiwibGltaXQiLCJyeCIsImVhc2luZyIsInJ5IiwibXR4IiwibWF0NCIsImNyZWF0ZSIsInRyYW5zbGF0ZSIsInZlYzMiLCJmcm9tVmFsdWVzIiwiY2FtZXJhRnJvbnQiLCJDYW1lcmFQZXJzcGVjdGl2ZSIsImZvdiIsIlBJIiwiZmFyIiwibmVhciIsImNhbWVyYSIsInNldFBlcnNwZWN0aXZlIiwiYXNwZWN0UmF0aW8iLCJsb29rQXQiLCJfYmlhc01hdHJpeCIsIl9tdHhGcm9udCIsIm11bCIsInByb2plY3Rpb24iLCJtYXRyaXgiLCJfdlNxdWFyZXMiLCJzZXRNYXRyaWNlcyIsIl9pc0luVHJhbnNpdGlvbiIsIl9oYXNPcGVuZWQiLCJfaGFzUHJvZmlsZWRGb2ciLCJfcmVzaXplVGltZW91dCIsIl9nb29kRm9nUmVuZGVyQ291bnQiLCJfY291bnQiLCJrZXlDb2RlIiwibmV4dCIsIl9oYXNsb2NrZWQiLCJfYW5nbGVzIiwieCIsInkiLCJfdk9wZW5pbmdDb3ZlciIsIl9mYm9DYXB0dXJlIiwiRnJhbWVCdWZmZXIiLCJoZWlnaHQiLCJtaW5GaWx0ZXIiLCJMSU5FQVIiLCJtYWdGaWx0ZXIiLCJfZmJvUmVuZGVyIiwiX2Zib1RlbXAiLCJfbm9pc2VzIiwiX2JDb3B5IiwiQmF0Y2hDb3B5IiwiX2JCYWxsIiwiQmF0Y2hCYWxsIiwiX3ZGbG9vciIsIl92VHJlZXMiLCJfdkJnIiwiX3ZBbmltYWwiLCJfdlNub3ciLCJfdkdyb3VuZCIsIl92Rm9ncyIsIl92RnhhYSIsIl92Q292ZXIiLCJvcGFjaXR5Iiwic2V0VG8iLCJfcGFzc0Jsb29tIiwiX3Jlc2V0VHJlZVBvc2l0aW9uIiwiY29udGFpbnMiLCJhbmltYWxzIiwiaW5kZXgiLCJpbmRleE9mIiwiY2xlYXIiLCJyZW5kZXJTY2VuZSIsInVuYmluZCIsIl9sb29wIiwibG9jayIsInNldEFuaW1hbCIsIl9jYXB0dXJlIiwia2lsbFR3ZWVuc09mIiwidG8iLCJlYXNlIiwiQ2lyYyIsImVhc2VJbk91dCIsIl90cmVlcyIsIl90ZXh0dXJlRmxvb3IiLCJ1cGRhdGUiLCJ1cGRhdGVGb2ciLCJkaXNhYmxlIiwiREVQVEhfVEVTVCIsImdldFRleHR1cmUiLCJyZW5kZXIiLCJlbmFibGUiLCJyb3RhdGUiLCJtUmVuZGVyRm9nIiwicG9zaXRpb24iLCJ0MCIsInBlcmZvcm1hbmNlIiwibm93IiwidHQwIiwiRGF0ZSIsImdldFRpbWUiLCJ0MSIsInR0MSIsInJlbmRlclRpbWUiLCJyZW5kZXJUaW1lMCIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsImRldmljZVBpeGVsUmF0aW8iLCJzZXRTaXplIiwic2V0QXNwZWN0UmF0aW8iLCJpZGVudGl0eSIsIk5vaXNlM0QiLCJtTnVtIiwibU5vaXNlU2NhbGUiLCJfc2VlZCIsInNwZWVkIiwiYiIsInN3YXAiLCJub2lzZTEiLCJyZXZlcnNlIiwiTm9pc2UzRFRleHR1cmUiLCJtU2VlZCIsIl9udW0iLCJiaWdUcmlhbmdsZSIsIlNoYWRlckxpYnMiLCJiaWdUcmlhbmdsZVZlcnQiLCJfbm9pc2VTaXplIiwiZmJvU2l6ZSIsInBvdyIsIl9mYm9Ob2lzZSIsIndyYXBTIiwiTUlSUk9SRURfUkVQRUFUIiwid3JhcFQiLCJzaXplIiwiaiIsInZpZXdwb3J0IiwiY2hlY2tCb3giLCJib3giLCJyIiwibWFyZ2luIiwiY29zIiwic2luIiwibGVmdCIsInJpZ2h0IiwiZnJvbnQiLCJiYWNrIiwiaGl0IiwibWFyZ2lucyIsImRlZXIiLCJsYXB1dGEiLCJ3aGFsZSIsImJlYXIiLCJidWxsIiwicG9zaXRpb25zIiwicnIiLCJjb3VudCIsInNxcnQiLCJmYm8iLCJzaGFkZXJIaWxsIiwidHJlZXMiLCJHTCIsIkxJTkVBUl9NSVBNQVBfTkVBUkVTVCIsIkdMU2hhZGVyIiwiZmxvb3JTaXplIiwicmVhZCIsIndyaXRlIiwicG9zIiwidSIsInYiLCJyZWFkVGV4dHVyZSIsIkZib1BpbmdQb25nIiwic2V0dGluZ3MiLCJfZmJvcyIsImNhY2hlcyIsInZlcnRpY2VzIiwiZm9yRWFjaCIsIm9iaiIsIm5hbWUiLCJzdHIiLCJkYXRhIiwiZW5jb2RlIiwiYmxvYiIsIkJsb2IiLCJ0eXBlIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwibGluayIsInNldEF0dHJpYnV0ZSIsImV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0TW91c2VFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJvdXQiLCJjaGFyQ29kZUF0IiwiVWludDhBcnJheSIsIlZpZXdGbG9vciIsIlZpZXdUcmVlcyIsIm1lc2gxIiwibWVzaDIiLCJoYWxmIiwiZGF0YTEiLCJkYXRhMiIsIm1DYW1Qb3MiLCJWaWV3QmciLCJzcGhlcmUiLCJWaWV3R3JvdW5kIiwiVmlld0ZvZ3MiLCJfdmlld3MiLCJuZXh0VmlldyIsImN1cnJlbnRWaWV3IiwiVmlld0ZYQUEiLCJ0ZXh0dXJlTm9pc2UiLCJSRVBFQVQiLCJORUFSRVNUIiwidGV4dHVyZU1hcCIsInRleHR1cmVCbG9vbSIsIlZpZXdBbmltYWwiLCJDVUxMX0ZBQ0UiLCJWaWV3U3F1YXJlcyIsIlR3ZWVuTnVtYmVyIiwidmlld0ludmVydCIsInByb2pJbnZlcnQiLCJpbnZlcnQiLCJleHRyYXMiLCJtTWF0cml4IiwibVRleHR1cmUiLCJWaWV3Q292ZXIiLCJzaW1wbGVDb2xvckZyYWciLCJFYXNlTnVtYmVyIiwiVmlld1Nub3ciLCJudW0iLCJleHRyYSIsIlNjaGVkdWxlciIsImRlbHRhVGltZSIsIlBhc3NCbG9vbSIsIm1OdW1NaXBzIiwibVN0YXJ0aW5nU2NhbGUiLCJfbnVtTWlwcyIsIl9zdGFydGluZ1NjYWxlIiwiX2luaXRUZXh0dXJlcyIsIl9pbml0Vmlld3MiLCJyb3VuZCIsImZib1YiLCJmYm9IIiwib1NldHRpbmdzIiwiX2Zib1RocmVzaG9sZCIsIl9mYm9Db21wb3NlIiwidnNUcmkiLCJzaGFkZXJUaHJlc2hvbGQiLCJ1bmlmb3Jtc1RocmVzaG9sZCIsImx1bWlub3NpdHlUaHJlc2hvbGQiLCJzbW9vdGhXaWR0aCIsImRlZmF1bHRPcGFjaXR5IiwiZGVmYXVsdENvbG9yIiwia2VybmVsU2l6ZUFycmF5IiwiX3NoYWRlcnNCbG9vbSIsImtlcm5lbFNpemUiLCJmcyIsInJlcGxhY2UiLCJ1bmlmb3Jtc0NvbXBvc2UiLCJibG9vbVJhZGl1cyIsInN0ckJsb29tIiwidGludENvbG9yIiwic2hhZGVyQ29tcG9zZSIsImNvbmNhdCIsImlucHV0VGV4dHVyZSIsIlNvdW5kTWFuYWdlciIsIl9oYXNTdGFydGVkIiwiX2lzUGxheWluZyIsIl9idG4iLCJ0b2dnbGUiLCJfc291bmQiLCJjcmVhdGVTb3VuZCIsInNyYyIsImxvb3AiLCJ2b2x1bWUiLCJwYXVzZSIsInBsYXkiLCJjbGFzcyIsIm4iLCJleHBvcnRzIiwibW9kdWxlIiwic29ubyIsInNsaWNlIiwibWF0Y2giLCJ0b0xvd2VyQ2FzZSIsImxhc3RJbmRleE9mIiwidCIsInBvcCIsIkFycmF5IiwiaXNBcnJheSIsIm5lIiwiSiIsIk9iamVjdCIsImtleXMiLCJzb21lIiwiQXVkaW9CdWZmZXIiLCJBcnJheUJ1ZmZlciIsIkhUTUxNZWRpYUVsZW1lbnQiLCJnZXRBdWRpb1RyYWNrcyIsIk1lZGlhU3RyZWFtVHJhY2siLCJidWZmZXJTaXplIiwiY2hhbm5lbHMiLCJjYWxsYmFjayIsImMiLCJmIiwiZmxvb3IiLCJmZnRTaXplIiwiRmxvYXQzMkFycmF5IiwiY3JlYXRlQW5hbHlzZXIiLCJmbG9hdCIsImwiLCJkIiwic21vb3RoaW5nVGltZUNvbnN0YW50Iiwic21vb3RoaW5nIiwibWluRGVjaWJlbHMiLCJtYXhEZWNpYmVscyIsImciLCJoIiwiV29ya2VyIiwibSIsInciLCJUIiwiTSIsImhlcnR6Iiwibm90ZSIsIm5vdGVJbmRleCIsImRldHVuZUNlbnRzIiwiZGV0dW5lIiwib25tZXNzYWdlIiwiZ2V0V2F2ZWZvcm0iLCJhcmd1bWVudHMiLCJnZXRGbG9hdFRpbWVEb21haW5EYXRhIiwiZ2V0Qnl0ZVRpbWVEb21haW5EYXRhIiwiZ2V0UGl0Y2giLCJzZXQiLCJwb3N0TWVzc2FnZSIsInNhbXBsZVJhdGUiLCJidWZmZXIiLCJnZXRGcmVxdWVuY2llcyIsImZyZXF1ZW5jeUJpbkNvdW50IiwiZ2V0RmxvYXRGcmVxdWVuY3lEYXRhIiwiZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEiLCJnZXRBbXBsaXR1ZGUiLCJzdW0iLCJieXRlTGVuZ3RoIiwibnVtU2FtcGxlcyIsImRlZmluZVByb3BlcnRpZXMiLCJpc05hTiIsImNyZWF0ZVdhdmVTaGFwZXIiLCJ1ZSIsImN1cnZlIiwiYWJzIiwiYW1vdW50IiwiY3JlYXRlR2FpbiIsImNyZWF0ZURlbGF5IiwiZGVsYXlUaW1lIiwiZ2FpbiIsImZlZWRiYWNrIiwiY29ubmVjdCIsIl9vdXRwdXQiLCJkZWxheSIsImRlZmF1bHRWYWx1ZSIsImxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lIiwic2V0VmFsdWVBdFRpbWUiLCJleHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lIiwic2V0VGFyZ2V0QXRUaW1lIiwic2V0VmFsdWVDdXJ2ZUF0VGltZSIsImNhbmNlbFNjaGVkdWxlZFZhbHVlcyIsImRpc2Nvbm5lY3QiLCJwYW5uaW5nTW9kZWwiLCJzZXRQb3NpdGlvbiIsInNldE9yaWVudGF0aW9uIiwic2V0VmVsb2NpdHkiLCJkaXN0YW5jZU1vZGVsIiwicmVmRGlzdGFuY2UiLCJtYXhEaXN0YW5jZSIsInJvbGxvZmZGYWN0b3IiLCJjb25lSW5uZXJBbmdsZSIsImNvbmVPdXRlckFuZ2xlIiwiY29uZU91dGVyR2FpbiIsImZyZXF1ZW5jeSIsIlEiLCJ0aHJlc2hvbGQiLCJrbmVlIiwicmF0aW8iLCJhdHRhY2siLCJyZWxlYXNlIiwicmVkdWN0aW9uIiwib3ZlcnNhbXBsZSIsImR1cmF0aW9uIiwibnVtYmVyT2ZDaGFubmVscyIsImdldENoYW5uZWxEYXRhIiwiY29weUZyb21DaGFubmVsIiwiY29weVRvQ2hhbm5lbCIsImRvcHBsZXJGYWN0b3IiLCJzcGVlZE9mU291bmQiLCJjcmVhdGVCdWZmZXIiLCJjcmVhdGVCaXF1YWRGaWx0ZXIiLCJjcmVhdGVDaGFubmVsTWVyZ2VyIiwiY3JlYXRlQ2hhbm5lbFNwbGl0dGVyIiwiY3JlYXRlRHluYW1pY3NDb21wcmVzc29yIiwiY3JlYXRlQ29udm9sdmVyIiwiY3JlYXRlT3NjaWxsYXRvciIsImNyZWF0ZVBhbm5lciIsImNyZWF0ZVNjcmlwdFByb2Nlc3NvciIsImxpc3RlbmVyIiwiY3VycmVudFRpbWUiLCJMTjIiLCJzZXRCeVBlcmNlbnQiLCJxIiwibGZvRnJlcXVlbmN5IiwibGZvR2FpbiIsInN0ZXJlbyIsImRpc3Bvc2UiLCJkZWZhdWx0cyIsInBvb2wiLCJzZXRTb3VyY2VQb3NpdGlvbiIsInNldFNvdXJjZU9yaWVudGF0aW9uIiwic2V0TGlzdGVuZXJQb3NpdGlvbiIsInNldExpc3RlbmVyT3JpZW50YXRpb24iLCJnZXREZWZhdWx0cyIsInNldERlZmF1bHRzIiwic3RhZ2VzIiwib25hdWRpb3Byb2Nlc3MiLCJkZXN0aW5hdGlvbiIsImlucHV0QnVmZmVyIiwib3V0cHV0QnVmZmVyIiwiaXNSZWNvcmRpbmciLCJzdG9wIiwiZ2V0RHVyYXRpb24iLCJ0aW1lIiwiZGVjYXkiLCJBIiwiWCIsIloiLCJIIiwic3BsaWNlIiwiVyIsIk8iLCJFIiwiUyIsIkwiLCJfIiwiQyIsImsiLCJEIiwiUCIsIlIiLCJGIiwiRyIsIkIiLCJWIiwiaW5wdXRDaGFubmVscyIsIm91dHB1dENoYW5uZWxzIiwidGhpc0FyZyIsImNvbnRleHQiLCJOIiwiSSIsIlUiLCJub2RlTGlzdCIsInBhbm5pbmciLCJoYXMiLCJyZW1vdmVBbGwiLCJkZXN0cm95Iiwic2V0U291cmNlIiwic2V0RGVzdGluYXRpb24iLCJhbmFseXNlciIsImNvbXByZXNzb3IiLCJjb252b2x2ZXIiLCJlY2hvIiwiZGlzdG9ydGlvbiIsImZpbHRlciIsImxvd3Bhc3MiLCJoaWdocGFzcyIsImJhbmRwYXNzIiwibG93c2hlbGYiLCJoaWdoc2hlbGYiLCJwZWFraW5nIiwibm90Y2giLCJhbGxwYXNzIiwiZmxhbmdlciIsInBhbm5lciIsInBoYXNlciIsInJlY29yZGVyIiwicmV2ZXJiIiwic2NyaXB0IiwiZnJlZXplIiwib25jZSIsInBsYXlpbmciLCJwYXVzZWQiLCJzZWVrIiwiZmFkZSIsInJlc3VtZSIsInNldFZvbHVtZSIsIm11dGUiLCJ1bk11dGUiLCJlZmZlY3QiLCJzb3VuZHMiLCJncm91cFZvbHVtZSIsIl9ldmVudHMiLCJfbWF4TGlzdGVuZXJzIiwib2ZmIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImVtaXQiLCJsZW5ndGhDb21wdXRhYmxlIiwibG9hZGVkIiwidG90YWwiLCJjb2RlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImRlY29kZUF1ZGlvRGF0YSIsInJlc3BvbnNlIiwicmVhZHlTdGF0ZSIsImFib3J0IiwiWE1MSHR0cFJlcXVlc3QiLCJyZXNwb25zZVR5cGUiLCJzZW5kIiwidGFnTmFtZSIsInByZWxvYWQiLCJsb2FkIiwic2UiLCJjYW5jZWwiLCJwcm9ncmVzcyIsImF1ZGlvQ29udGV4dCIsImlzVG91Y2hMb2NrZWQiLCJjcmVhdGVCdWZmZXJTb3VyY2UiLCJvbmVuZGVkIiwicGxheWJhY2tSYXRlIiwiZW5kZWQiLCJzb3VyY2VOb2RlIiwiY3JlYXRlTWVkaWFFbGVtZW50U291cmNlIiwiY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UiLCJtb3pHZXRVc2VyTWVkaWEiLCJtb3pIYWNrIiwiaWUiLCJpc0F1ZGlvQnVmZmVyIiwiaXNNZWRpYUVsZW1lbnQiLCJpc01lZGlhU3RyZWFtIiwiaXNPc2NpbGxhdG9yVHlwZSIsImlzU2NyaXB0Q29uZmlnIiwiRXJyb3IiLCJnZXRTdXBwb3J0ZWRGaWxlIiwiYXNNZWRpYUVsZW1lbnQiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3RvdHlwZSIsImNvbnN0cnVjdG9yIiwid2F2ZWZvcm0iLCJ1c2VyRGF0YSIsInNvcnQiLCJybWVvdmUiLCJnZXRVc2VyTWVkaWEiLCJhdWRpbyIsIm1lc3NhZ2UiLCJ3ZWJraXRHZXRVc2VyTWVkaWEiLCJtc0dldFVzZXJNZWRpYSIsImlzU3VwcG9ydGVkIiwic3RyZWFtIiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJjbGVhclJlY3QiLCJsaW5lV2lkdGgiLCJzdHJva2VTdHlsZSIsImJlZ2luUGF0aCIsInN0cm9rZSIsInNvdW5kIiwibGUiLCJmZSIsIm1vdmVUbyIsImxpbmVUbyIsImNsb3NlUGF0aCIsInNoYXBlIiwiY29sb3IiLCJiZ0NvbG9yIiwidHJhbnNmb3JtIiwiaW5uZXJSYWRpdXMiLCJnZXRDb250ZXh0IiwiZGUiLCJBdWRpb0NvbnRleHQiLCJ3ZWJraXRBdWRpb0NvbnRleHQiLCJzdGF0ZSIsInZlIiwiT2ZmbGluZUF1ZGlvQ29udGV4dCIsIndlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQiLCJjYWxsIiwid2ViQXVkaW8iLCJjb250YWluc1VSTCIsIm9uRXJyb3IiLCJHcm91cCIsIm9uUHJvZ3Jlc3MiLCJvbkNvbXBsZXRlIiwiaGFzV2ViQXVkaW8iLCJleHRlbnNpb25zIiwiYXBwbHkiLCJwZSIsIksiLCJoYW5kbGVUb3VjaExvY2siLCJoYW5kbGVQYWdlVmlzaWJpbGl0eSIsImRlc3Ryb3lTb3VuZCIsImRlc3Ryb3lBbGwiLCJnZXRTb3VuZCIsImNyZWF0ZUdyb3VwIiwicGF1c2VBbGwiLCJyZXN1bWVBbGwiLCJzdG9wQWxsIiwiY2FuUGxheSIsImdldE9mZmxpbmVDb250ZXh0IiwidXRpbHMiLCJWRVJTSU9OIiwiU291bmQiLCJoaWRkZW4iLCJtb3pIaWRkZW4iLCJtc0hpZGRlbiIsIndlYmtpdEhpZGRlbiIsInRoZW4iLCJTeW1ib2wiLCJpdGVyYXRvciIsIlkiLCJUeXBlRXJyb3IiLCIkIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJlZSIsIlJlZmVyZW5jZUVycm9yIiwidGUiLCJyZSIsIm9lIiwiY2FuUGxheVR5cGUiLCJnZXRGaWxlRXh0ZW5zaW9uIiwiaXNVUkwiLCJFZmZlY3QiLCJhZSIsIkV2ZW50RW1pdHRlciIsImRlZmF1bHRNYXhMaXN0ZW5lcnMiLCJzZXRNYXhMaXN0ZW5lcnMiLCJhZGRMaXN0ZW5lciIsIm5ld0xpc3RlbmVyIiwid2FybmVkIiwidHJhY2UiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImxpc3RlbmVycyIsImxpc3RlbmVyQ291bnQiLCJjZSIsIl9fc291cmNlIiwiQnVmZmVyU291cmNlIiwiTWVkaWFTb3VyY2UiLCJNaWNyb3Bob25lU291cmNlIiwiT3NjaWxsYXRvclNvdXJjZSIsIlNjcmlwdFNvdXJjZSIsImNsb25lQnVmZmVyIiwicmV2ZXJzZUJ1ZmZlciIsInJhbXAiLCJnZXRGcmVxdWVuY3kiLCJtaWNyb3Bob25lIiwidGltZUNvZGUiLCJ3YXZlZm9ybWVyIiwiZ2UiLCJzaW11bGF0ZUtleSIsIm1vZGlmaWVycyIsImV2dE5hbWUiLCJtb2RpZmllciIsImluaXRFdmVudCIsInN0ZXAiLCJvbkZpbmlzaENoYW5nZSIsInNhdmVTZXR0aW5ncyIsIkNBTlZBU19TSVpFIiwiQ09MT1JfQkxBQ0siLCJDT0xPUl9XSElURSIsIkNPTE9SX1BJTksiLCJMb2FkaW5nQW5pbSIsIl9oYXNBbmltYXRpb25Db21wbGV0ZWQiLCJfaGFzQ2FsbGVkQ2xvc2UiLCJzdGFydEFuaW1hdGlvbiIsImFuaW1hdGlvbkxpc3QiLCJlbmQiLCJzQW5nbGUiLCJleWUiLCJjZW50ZXIiLCJ4MSIsInkxIiwieDIiLCJ5MiIsInRpbWVsaW5lIiwiVGltZWxpbmVMaXRlIiwib25TdGFydCIsIm9uVXBkYXRlIiwiaXRlbSIsImRyYXdBcmMiLCJxdWFkcmF0aWNDdXJ2ZVRvIiwiZmlsbCIsIm9uQW5pbWF0aW9uQ29tcGxldGUiLCJpbnNlcnQiLCJUd2VlbkxpdGUiLCJFeHBvIiwidHJpZ2dlciIsImN0eCIsImNlbnRlclgiLCJjZW50ZXJZIiwib3V0ZXJSYWRpdXMiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJhbnRpY2xvY2t3aXNlIiwidGgxIiwidGgyIiwic3RhcnRPZk91dGVyQXJjWCIsInN0YXJ0T2ZPdXRlckFyY1kiLCJhcmMiLCJFdmVudERpc3BhdGNo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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJOztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLGdOQUFnTjtBQUN0UDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLCtHQUErRztBQUMvRyxxQ0FBcUM7QUFDckM7QUFDQTtB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDL1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVU7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixVQUFVO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVU7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxTQUFTO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxVQUFVLFNBQVM7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDclpB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLG9NQUFvTTtBQUN6Tzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwWEE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNMQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSCxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM3U0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxT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LEVBQXVDSyxHQUF2QyxFQUE0Q0QsR0FBNUMsRUFBaUQsQ0FBQ0QsYUFBbEQ7QUFDQU4sT0FBSWpJLFNBQUo7QUFDQWlJLE9BQUlOLElBQUo7QUFFQTs7OztFQTNKd0IsaUJBQU9rQixlOztrQkErSmxCdEMsVyIsImZpbGUiOiJhc3NldHMvanMvYXBwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0ZnVuY3Rpb24gaG90RGlzcG9zZUNodW5rKGNodW5rSWQpIHtcbiBcdFx0ZGVsZXRlIGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcbiBcdH1cbiBcdHZhciBwYXJlbnRIb3RVcGRhdGVDYWxsYmFjayA9IHdpbmRvd1tcIndlYnBhY2tIb3RVcGRhdGVcIl07XG4gXHR3aW5kb3dbXCJ3ZWJwYWNrSG90VXBkYXRlXCJdID0gXHJcbiBcdGZ1bmN0aW9uIHdlYnBhY2tIb3RVcGRhdGVDYWxsYmFjayhjaHVua0lkLCBtb3JlTW9kdWxlcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0aG90QWRkVXBkYXRlQ2h1bmsoY2h1bmtJZCwgbW9yZU1vZHVsZXMpO1xyXG4gXHRcdGlmKHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrKSBwYXJlbnRIb3RVcGRhdGVDYWxsYmFjayhjaHVua0lkLCBtb3JlTW9kdWxlcyk7XHJcbiBcdH0gO1xyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90RG93bmxvYWRVcGRhdGVDaHVuayhjaHVua0lkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHR2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcclxuIFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcclxuIFx0XHRzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XHJcbiBcdFx0c2NyaXB0LmNoYXJzZXQgPSBcInV0Zi04XCI7XHJcbiBcdFx0c2NyaXB0LnNyYyA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIFwiXCIgKyBjaHVua0lkICsgXCIuXCIgKyBob3RDdXJyZW50SGFzaCArIFwiLmhvdC11cGRhdGUuanNcIjtcclxuIFx0XHQ7XHJcbiBcdFx0aGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3REb3dubG9hZE1hbmlmZXN0KHJlcXVlc3RUaW1lb3V0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHRyZXF1ZXN0VGltZW91dCA9IHJlcXVlc3RUaW1lb3V0IHx8IDEwMDAwO1xyXG4gXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuIFx0XHRcdGlmKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gXCJ1bmRlZmluZWRcIilcclxuIFx0XHRcdFx0cmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJObyBicm93c2VyIHN1cHBvcnRcIikpO1xyXG4gXHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuIFx0XHRcdFx0dmFyIHJlcXVlc3RQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJcIiArIGhvdEN1cnJlbnRIYXNoICsgXCIuaG90LXVwZGF0ZS5qc29uXCI7XHJcbiBcdFx0XHRcdHJlcXVlc3Qub3BlbihcIkdFVFwiLCByZXF1ZXN0UGF0aCwgdHJ1ZSk7XHJcbiBcdFx0XHRcdHJlcXVlc3QudGltZW91dCA9IHJlcXVlc3RUaW1lb3V0O1xyXG4gXHRcdFx0XHRyZXF1ZXN0LnNlbmQobnVsbCk7XHJcbiBcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRyZXR1cm4gcmVqZWN0KGVycik7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRyZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG4gXHRcdFx0XHRpZihyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHJldHVybjtcclxuIFx0XHRcdFx0aWYocmVxdWVzdC5zdGF0dXMgPT09IDApIHtcclxuIFx0XHRcdFx0XHQvLyB0aW1lb3V0XHJcbiBcdFx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIHRpbWVkIG91dC5cIikpO1xyXG4gXHRcdFx0XHR9IGVsc2UgaWYocmVxdWVzdC5zdGF0dXMgPT09IDQwNCkge1xyXG4gXHRcdFx0XHRcdC8vIG5vIHVwZGF0ZSBhdmFpbGFibGVcclxuIFx0XHRcdFx0XHRyZXNvbHZlKCk7XHJcbiBcdFx0XHRcdH0gZWxzZSBpZihyZXF1ZXN0LnN0YXR1cyAhPT0gMjAwICYmIHJlcXVlc3Quc3RhdHVzICE9PSAzMDQpIHtcclxuIFx0XHRcdFx0XHQvLyBvdGhlciBmYWlsdXJlXHJcbiBcdFx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIGZhaWxlZC5cIikpO1xyXG4gXHRcdFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0XHRcdC8vIHN1Y2Nlc3NcclxuIFx0XHRcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRcdFx0dmFyIHVwZGF0ZSA9IEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xyXG4gXHRcdFx0XHRcdH0gY2F0Y2goZSkge1xyXG4gXHRcdFx0XHRcdFx0cmVqZWN0KGUpO1xyXG4gXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRyZXNvbHZlKHVwZGF0ZSk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH07XHJcbiBcdFx0fSk7XHJcbiBcdH1cclxuXG4gXHRcclxuIFx0XHJcbiBcdHZhciBob3RBcHBseU9uVXBkYXRlID0gdHJ1ZTtcclxuIFx0dmFyIGhvdEN1cnJlbnRIYXNoID0gXCI0MmI4YjIyNTQ2NGUzNTRhNWMxZlwiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdHZhciBob3RSZXF1ZXN0VGltZW91dCA9IDEwMDAwO1xyXG4gXHR2YXIgaG90Q3VycmVudE1vZHVsZURhdGEgPSB7fTtcclxuIFx0dmFyIGhvdEN1cnJlbnRDaGlsZE1vZHVsZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHR2YXIgaG90Q3VycmVudFBhcmVudHMgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHR2YXIgaG90Q3VycmVudFBhcmVudHNUZW1wID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdHZhciBtZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdGlmKCFtZSkgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX187XHJcbiBcdFx0dmFyIGZuID0gZnVuY3Rpb24ocmVxdWVzdCkge1xyXG4gXHRcdFx0aWYobWUuaG90LmFjdGl2ZSkge1xyXG4gXHRcdFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdKSB7XHJcbiBcdFx0XHRcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XS5wYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpIDwgMClcclxuIFx0XHRcdFx0XHRcdGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cy5wdXNoKG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0XHRob3RDdXJyZW50UGFyZW50cyA9IFttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0aG90Q3VycmVudENoaWxkTW9kdWxlID0gcmVxdWVzdDtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihtZS5jaGlsZHJlbi5pbmRleE9mKHJlcXVlc3QpIDwgMClcclxuIFx0XHRcdFx0XHRtZS5jaGlsZHJlbi5wdXNoKHJlcXVlc3QpO1xyXG4gXHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICsgcmVxdWVzdCArIFwiKSBmcm9tIGRpc3Bvc2VkIG1vZHVsZSBcIiArIG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbXTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHJlcXVlc3QpO1xyXG4gXHRcdH07XHJcbiBcdFx0dmFyIE9iamVjdEZhY3RvcnkgPSBmdW5jdGlvbiBPYmplY3RGYWN0b3J5KG5hbWUpIHtcclxuIFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuIFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuIFx0XHRcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfX1tuYW1lXTtcclxuIFx0XHRcdFx0fSxcclxuIFx0XHRcdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gXHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX19bbmFtZV0gPSB2YWx1ZTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fTtcclxuIFx0XHR9O1xyXG4gXHRcdGZvcih2YXIgbmFtZSBpbiBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX193ZWJwYWNrX3JlcXVpcmVfXywgbmFtZSkgJiYgbmFtZSAhPT0gXCJlXCIpIHtcclxuIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBuYW1lLCBPYmplY3RGYWN0b3J5KG5hbWUpKTtcclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFx0Zm4uZSA9IGZ1bmN0aW9uKGNodW5rSWQpIHtcclxuIFx0XHRcdGlmKGhvdFN0YXR1cyA9PT0gXCJyZWFkeVwiKVxyXG4gXHRcdFx0XHRob3RTZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xyXG4gXHRcdFx0aG90Q2h1bmtzTG9hZGluZysrO1xyXG4gXHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uZShjaHVua0lkKS50aGVuKGZpbmlzaENodW5rTG9hZGluZywgZnVuY3Rpb24oZXJyKSB7XHJcbiBcdFx0XHRcdGZpbmlzaENodW5rTG9hZGluZygpO1xyXG4gXHRcdFx0XHR0aHJvdyBlcnI7XHJcbiBcdFx0XHR9KTtcclxuIFx0XHJcbiBcdFx0XHRmdW5jdGlvbiBmaW5pc2hDaHVua0xvYWRpbmcoKSB7XHJcbiBcdFx0XHRcdGhvdENodW5rc0xvYWRpbmctLTtcclxuIFx0XHRcdFx0aWYoaG90U3RhdHVzID09PSBcInByZXBhcmVcIikge1xyXG4gXHRcdFx0XHRcdGlmKCFob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0pIHtcclxuIFx0XHRcdFx0XHRcdGhvdEVuc3VyZVVwZGF0ZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRpZihob3RDaHVua3NMb2FkaW5nID09PSAwICYmIGhvdFdhaXRpbmdGaWxlcyA9PT0gMCkge1xyXG4gXHRcdFx0XHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH07XHJcbiBcdFx0cmV0dXJuIGZuO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RDcmVhdGVNb2R1bGUobW9kdWxlSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdHZhciBob3QgPSB7XHJcbiBcdFx0XHQvLyBwcml2YXRlIHN0dWZmXHJcbiBcdFx0XHRfYWNjZXB0ZWREZXBlbmRlbmNpZXM6IHt9LFxyXG4gXHRcdFx0X2RlY2xpbmVkRGVwZW5kZW5jaWVzOiB7fSxcclxuIFx0XHRcdF9zZWxmQWNjZXB0ZWQ6IGZhbHNlLFxyXG4gXHRcdFx0X3NlbGZEZWNsaW5lZDogZmFsc2UsXHJcbiBcdFx0XHRfZGlzcG9zZUhhbmRsZXJzOiBbXSxcclxuIFx0XHRcdF9tYWluOiBob3RDdXJyZW50Q2hpbGRNb2R1bGUgIT09IG1vZHVsZUlkLFxyXG4gXHRcclxuIFx0XHRcdC8vIE1vZHVsZSBBUElcclxuIFx0XHRcdGFjdGl2ZTogdHJ1ZSxcclxuIFx0XHRcdGFjY2VwdDogZnVuY3Rpb24oZGVwLCBjYWxsYmFjaykge1xyXG4gXHRcdFx0XHRpZih0eXBlb2YgZGVwID09PSBcInVuZGVmaW5lZFwiKVxyXG4gXHRcdFx0XHRcdGhvdC5fc2VsZkFjY2VwdGVkID0gdHJ1ZTtcclxuIFx0XHRcdFx0ZWxzZSBpZih0eXBlb2YgZGVwID09PSBcImZ1bmN0aW9uXCIpXHJcbiBcdFx0XHRcdFx0aG90Ll9zZWxmQWNjZXB0ZWQgPSBkZXA7XHJcbiBcdFx0XHRcdGVsc2UgaWYodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIilcclxuIFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxyXG4gXHRcdFx0XHRcdFx0aG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBbaV1dID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcclxuIFx0XHRcdFx0ZWxzZVxyXG4gXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0ZGVjbGluZTogZnVuY3Rpb24oZGVwKSB7XHJcbiBcdFx0XHRcdGlmKHR5cGVvZiBkZXAgPT09IFwidW5kZWZpbmVkXCIpXHJcbiBcdFx0XHRcdFx0aG90Ll9zZWxmRGVjbGluZWQgPSB0cnVlO1xyXG4gXHRcdFx0XHRlbHNlIGlmKHR5cGVvZiBkZXAgPT09IFwib2JqZWN0XCIpXHJcbiBcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKylcclxuIFx0XHRcdFx0XHRcdGhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IHRydWU7XHJcbiBcdFx0XHRcdGVsc2VcclxuIFx0XHRcdFx0XHRob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcF0gPSB0cnVlO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGRpc3Bvc2U6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiBcdFx0XHRcdGhvdC5fZGlzcG9zZUhhbmRsZXJzLnB1c2goY2FsbGJhY2spO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGFkZERpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gXHRcdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRyZW1vdmVEaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuIFx0XHRcdFx0dmFyIGlkeCA9IGhvdC5fZGlzcG9zZUhhbmRsZXJzLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gXHRcdFx0XHRpZihpZHggPj0gMCkgaG90Ll9kaXNwb3NlSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcclxuIFx0XHRcdC8vIE1hbmFnZW1lbnQgQVBJXHJcbiBcdFx0XHRjaGVjazogaG90Q2hlY2ssXHJcbiBcdFx0XHRhcHBseTogaG90QXBwbHksXHJcbiBcdFx0XHRzdGF0dXM6IGZ1bmN0aW9uKGwpIHtcclxuIFx0XHRcdFx0aWYoIWwpIHJldHVybiBob3RTdGF0dXM7XHJcbiBcdFx0XHRcdGhvdFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0YWRkU3RhdHVzSGFuZGxlcjogZnVuY3Rpb24obCkge1xyXG4gXHRcdFx0XHRob3RTdGF0dXNIYW5kbGVycy5wdXNoKGwpO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdHJlbW92ZVN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uKGwpIHtcclxuIFx0XHRcdFx0dmFyIGlkeCA9IGhvdFN0YXR1c0hhbmRsZXJzLmluZGV4T2YobCk7XHJcbiBcdFx0XHRcdGlmKGlkeCA+PSAwKSBob3RTdGF0dXNIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcclxuIFx0XHRcdH0sXHJcbiBcdFxyXG4gXHRcdFx0Ly9pbmhlcml0IGZyb20gcHJldmlvdXMgZGlzcG9zZSBjYWxsXHJcbiBcdFx0XHRkYXRhOiBob3RDdXJyZW50TW9kdWxlRGF0YVttb2R1bGVJZF1cclxuIFx0XHR9O1xyXG4gXHRcdGhvdEN1cnJlbnRDaGlsZE1vZHVsZSA9IHVuZGVmaW5lZDtcclxuIFx0XHRyZXR1cm4gaG90O1xyXG4gXHR9XHJcbiBcdFxyXG4gXHR2YXIgaG90U3RhdHVzSGFuZGxlcnMgPSBbXTtcclxuIFx0dmFyIGhvdFN0YXR1cyA9IFwiaWRsZVwiO1xyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90U2V0U3RhdHVzKG5ld1N0YXR1cykge1xyXG4gXHRcdGhvdFN0YXR1cyA9IG5ld1N0YXR1cztcclxuIFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgaG90U3RhdHVzSGFuZGxlcnMubGVuZ3RoOyBpKyspXHJcbiBcdFx0XHRob3RTdGF0dXNIYW5kbGVyc1tpXS5jYWxsKG51bGwsIG5ld1N0YXR1cyk7XHJcbiBcdH1cclxuIFx0XHJcbiBcdC8vIHdoaWxlIGRvd25sb2FkaW5nXHJcbiBcdHZhciBob3RXYWl0aW5nRmlsZXMgPSAwO1xyXG4gXHR2YXIgaG90Q2h1bmtzTG9hZGluZyA9IDA7XHJcbiBcdHZhciBob3RXYWl0aW5nRmlsZXNNYXAgPSB7fTtcclxuIFx0dmFyIGhvdFJlcXVlc3RlZEZpbGVzTWFwID0ge307XHJcbiBcdHZhciBob3RBdmFpbGFibGVGaWxlc01hcCA9IHt9O1xyXG4gXHR2YXIgaG90RGVmZXJyZWQ7XHJcbiBcdFxyXG4gXHQvLyBUaGUgdXBkYXRlIGluZm9cclxuIFx0dmFyIGhvdFVwZGF0ZSwgaG90VXBkYXRlTmV3SGFzaDtcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIHRvTW9kdWxlSWQoaWQpIHtcclxuIFx0XHR2YXIgaXNOdW1iZXIgPSAoK2lkKSArIFwiXCIgPT09IGlkO1xyXG4gXHRcdHJldHVybiBpc051bWJlciA/ICtpZCA6IGlkO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RDaGVjayhhcHBseSkge1xyXG4gXHRcdGlmKGhvdFN0YXR1cyAhPT0gXCJpZGxlXCIpIHRocm93IG5ldyBFcnJvcihcImNoZWNrKCkgaXMgb25seSBhbGxvd2VkIGluIGlkbGUgc3RhdHVzXCIpO1xyXG4gXHRcdGhvdEFwcGx5T25VcGRhdGUgPSBhcHBseTtcclxuIFx0XHRob3RTZXRTdGF0dXMoXCJjaGVja1wiKTtcclxuIFx0XHRyZXR1cm4gaG90RG93bmxvYWRNYW5pZmVzdChob3RSZXF1ZXN0VGltZW91dCkudGhlbihmdW5jdGlvbih1cGRhdGUpIHtcclxuIFx0XHRcdGlmKCF1cGRhdGUpIHtcclxuIFx0XHRcdFx0aG90U2V0U3RhdHVzKFwiaWRsZVwiKTtcclxuIFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcCA9IHt9O1xyXG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzTWFwID0ge307XHJcbiBcdFx0XHRob3RBdmFpbGFibGVGaWxlc01hcCA9IHVwZGF0ZS5jO1xyXG4gXHRcdFx0aG90VXBkYXRlTmV3SGFzaCA9IHVwZGF0ZS5oO1xyXG4gXHRcclxuIFx0XHRcdGhvdFNldFN0YXR1cyhcInByZXBhcmVcIik7XHJcbiBcdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gXHRcdFx0XHRob3REZWZlcnJlZCA9IHtcclxuIFx0XHRcdFx0XHRyZXNvbHZlOiByZXNvbHZlLFxyXG4gXHRcdFx0XHRcdHJlamVjdDogcmVqZWN0XHJcbiBcdFx0XHRcdH07XHJcbiBcdFx0XHR9KTtcclxuIFx0XHRcdGhvdFVwZGF0ZSA9IHt9O1xyXG4gXHRcdFx0dmFyIGNodW5rSWQgPSAwO1xyXG4gXHRcdFx0eyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxvbmUtYmxvY2tzXHJcbiBcdFx0XHRcdC8qZ2xvYmFscyBjaHVua0lkICovXHJcbiBcdFx0XHRcdGhvdEVuc3VyZVVwZGF0ZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdFx0aWYoaG90U3RhdHVzID09PSBcInByZXBhcmVcIiAmJiBob3RDaHVua3NMb2FkaW5nID09PSAwICYmIGhvdFdhaXRpbmdGaWxlcyA9PT0gMCkge1xyXG4gXHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRyZXR1cm4gcHJvbWlzZTtcclxuIFx0XHR9KTtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90QWRkVXBkYXRlQ2h1bmsoY2h1bmtJZCwgbW9yZU1vZHVsZXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdGlmKCFob3RBdmFpbGFibGVGaWxlc01hcFtjaHVua0lkXSB8fCAhaG90UmVxdWVzdGVkRmlsZXNNYXBbY2h1bmtJZF0pXHJcbiBcdFx0XHRyZXR1cm47XHJcbiBcdFx0aG90UmVxdWVzdGVkRmlsZXNNYXBbY2h1bmtJZF0gPSBmYWxzZTtcclxuIFx0XHRmb3IodmFyIG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRob3RVcGRhdGVbbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHRpZigtLWhvdFdhaXRpbmdGaWxlcyA9PT0gMCAmJiBob3RDaHVua3NMb2FkaW5nID09PSAwKSB7XHJcbiBcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XHJcbiBcdFx0fVxyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKSB7XHJcbiBcdFx0aWYoIWhvdEF2YWlsYWJsZUZpbGVzTWFwW2NodW5rSWRdKSB7XHJcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0gPSB0cnVlO1xyXG4gXHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSA9IHRydWU7XHJcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXMrKztcclxuIFx0XHRcdGhvdERvd25sb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XHJcbiBcdFx0fVxyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RVcGRhdGVEb3dubG9hZGVkKCkge1xyXG4gXHRcdGhvdFNldFN0YXR1cyhcInJlYWR5XCIpO1xyXG4gXHRcdHZhciBkZWZlcnJlZCA9IGhvdERlZmVycmVkO1xyXG4gXHRcdGhvdERlZmVycmVkID0gbnVsbDtcclxuIFx0XHRpZighZGVmZXJyZWQpIHJldHVybjtcclxuIFx0XHRpZihob3RBcHBseU9uVXBkYXRlKSB7XHJcbiBcdFx0XHQvLyBXcmFwIGRlZmVycmVkIG9iamVjdCBpbiBQcm9taXNlIHRvIG1hcmsgaXQgYXMgYSB3ZWxsLWhhbmRsZWQgUHJvbWlzZSB0b1xyXG4gXHRcdFx0Ly8gYXZvaWQgdHJpZ2dlcmluZyB1bmNhdWdodCBleGNlcHRpb24gd2FybmluZyBpbiBDaHJvbWUuXHJcbiBcdFx0XHQvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDY1NjY2XHJcbiBcdFx0XHRQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xyXG4gXHRcdFx0XHRyZXR1cm4gaG90QXBwbHkoaG90QXBwbHlPblVwZGF0ZSk7XHJcbiBcdFx0XHR9KS50aGVuKFxyXG4gXHRcdFx0XHRmdW5jdGlvbihyZXN1bHQpIHtcclxuIFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XHJcbiBcdFx0XHRcdH0sXHJcbiBcdFx0XHRcdGZ1bmN0aW9uKGVycikge1xyXG4gXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdChlcnIpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHQpO1xyXG4gXHRcdH0gZWxzZSB7XHJcbiBcdFx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XHJcbiBcdFx0XHRmb3IodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xyXG4gXHRcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaG90VXBkYXRlLCBpZCkpIHtcclxuIFx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaCh0b01vZHVsZUlkKGlkKSk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHRcdGRlZmVycmVkLnJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcclxuIFx0XHR9XHJcbiBcdH1cclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdEFwcGx5KG9wdGlvbnMpIHtcclxuIFx0XHRpZihob3RTdGF0dXMgIT09IFwicmVhZHlcIikgdGhyb3cgbmV3IEVycm9yKFwiYXBwbHkoKSBpcyBvbmx5IGFsbG93ZWQgaW4gcmVhZHkgc3RhdHVzXCIpO1xyXG4gXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gXHRcclxuIFx0XHR2YXIgY2I7XHJcbiBcdFx0dmFyIGk7XHJcbiBcdFx0dmFyIGo7XHJcbiBcdFx0dmFyIG1vZHVsZTtcclxuIFx0XHR2YXIgbW9kdWxlSWQ7XHJcbiBcdFxyXG4gXHRcdGZ1bmN0aW9uIGdldEFmZmVjdGVkU3R1ZmYodXBkYXRlTW9kdWxlSWQpIHtcclxuIFx0XHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbdXBkYXRlTW9kdWxlSWRdO1xyXG4gXHRcdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XHJcbiBcdFxyXG4gXHRcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLnNsaWNlKCkubWFwKGZ1bmN0aW9uKGlkKSB7XHJcbiBcdFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdFx0Y2hhaW46IFtpZF0sXHJcbiBcdFx0XHRcdFx0aWQ6IGlkXHJcbiBcdFx0XHRcdH07XHJcbiBcdFx0XHR9KTtcclxuIFx0XHRcdHdoaWxlKHF1ZXVlLmxlbmd0aCA+IDApIHtcclxuIFx0XHRcdFx0dmFyIHF1ZXVlSXRlbSA9IHF1ZXVlLnBvcCgpO1xyXG4gXHRcdFx0XHR2YXIgbW9kdWxlSWQgPSBxdWV1ZUl0ZW0uaWQ7XHJcbiBcdFx0XHRcdHZhciBjaGFpbiA9IHF1ZXVlSXRlbS5jaGFpbjtcclxuIFx0XHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdGlmKCFtb2R1bGUgfHwgbW9kdWxlLmhvdC5fc2VsZkFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRpZihtb2R1bGUuaG90Ll9zZWxmRGVjbGluZWQpIHtcclxuIFx0XHRcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWRlY2xpbmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXHJcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcclxuIFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGlmKG1vZHVsZS5ob3QuX21haW4pIHtcclxuIFx0XHRcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRcdFx0dHlwZTogXCJ1bmFjY2VwdGVkXCIsXHJcbiBcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXHJcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcclxuIFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtb2R1bGUucGFyZW50cy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0XHRcdHZhciBwYXJlbnRJZCA9IG1vZHVsZS5wYXJlbnRzW2ldO1xyXG4gXHRcdFx0XHRcdHZhciBwYXJlbnQgPSBpbnN0YWxsZWRNb2R1bGVzW3BhcmVudElkXTtcclxuIFx0XHRcdFx0XHRpZighcGFyZW50KSBjb250aW51ZTtcclxuIFx0XHRcdFx0XHRpZihwYXJlbnQuaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcclxuIFx0XHRcdFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZGVjbGluZWRcIixcclxuIFx0XHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcclxuIFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxyXG4gXHRcdFx0XHRcdFx0XHRwYXJlbnRJZDogcGFyZW50SWRcclxuIFx0XHRcdFx0XHRcdH07XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGlmKG91dGRhdGVkTW9kdWxlcy5pbmRleE9mKHBhcmVudElkKSA+PSAwKSBjb250aW51ZTtcclxuIFx0XHRcdFx0XHRpZihwYXJlbnQuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcclxuIFx0XHRcdFx0XHRcdGlmKCFvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0pXHJcbiBcdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSA9IFtdO1xyXG4gXHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdLCBbbW9kdWxlSWRdKTtcclxuIFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRkZWxldGUgb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdO1xyXG4gXHRcdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHBhcmVudElkKTtcclxuIFx0XHRcdFx0XHRxdWV1ZS5wdXNoKHtcclxuIFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbi5jb25jYXQoW3BhcmVudElkXSksXHJcbiBcdFx0XHRcdFx0XHRpZDogcGFyZW50SWRcclxuIFx0XHRcdFx0XHR9KTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcclxuIFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdHR5cGU6IFwiYWNjZXB0ZWRcIixcclxuIFx0XHRcdFx0bW9kdWxlSWQ6IHVwZGF0ZU1vZHVsZUlkLFxyXG4gXHRcdFx0XHRvdXRkYXRlZE1vZHVsZXM6IG91dGRhdGVkTW9kdWxlcyxcclxuIFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXM6IG91dGRhdGVkRGVwZW5kZW5jaWVzXHJcbiBcdFx0XHR9O1xyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0ZnVuY3Rpb24gYWRkQWxsVG9TZXQoYSwgYikge1xyXG4gXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdFx0dmFyIGl0ZW0gPSBiW2ldO1xyXG4gXHRcdFx0XHRpZihhLmluZGV4T2YoaXRlbSkgPCAwKVxyXG4gXHRcdFx0XHRcdGEucHVzaChpdGVtKTtcclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIGF0IGJlZ2luIGFsbCB1cGRhdGVzIG1vZHVsZXMgYXJlIG91dGRhdGVkXHJcbiBcdFx0Ly8gdGhlIFwib3V0ZGF0ZWRcIiBzdGF0dXMgY2FuIHByb3BhZ2F0ZSB0byBwYXJlbnRzIGlmIHRoZXkgZG9uJ3QgYWNjZXB0IHRoZSBjaGlsZHJlblxyXG4gXHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xyXG4gXHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbXTtcclxuIFx0XHR2YXIgYXBwbGllZFVwZGF0ZSA9IHt9O1xyXG4gXHRcclxuIFx0XHR2YXIgd2FyblVuZXhwZWN0ZWRSZXF1aXJlID0gZnVuY3Rpb24gd2FyblVuZXhwZWN0ZWRSZXF1aXJlKCkge1xyXG4gXHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICsgcmVzdWx0Lm1vZHVsZUlkICsgXCIpIHRvIGRpc3Bvc2VkIG1vZHVsZVwiKTtcclxuIFx0XHR9O1xyXG4gXHRcclxuIFx0XHRmb3IodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhvdFVwZGF0ZSwgaWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZUlkID0gdG9Nb2R1bGVJZChpZCk7XHJcbiBcdFx0XHRcdHZhciByZXN1bHQ7XHJcbiBcdFx0XHRcdGlmKGhvdFVwZGF0ZVtpZF0pIHtcclxuIFx0XHRcdFx0XHRyZXN1bHQgPSBnZXRBZmZlY3RlZFN0dWZmKG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0XHRyZXN1bHQgPSB7XHJcbiBcdFx0XHRcdFx0XHR0eXBlOiBcImRpc3Bvc2VkXCIsXHJcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogaWRcclxuIFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdHZhciBhYm9ydEVycm9yID0gZmFsc2U7XHJcbiBcdFx0XHRcdHZhciBkb0FwcGx5ID0gZmFsc2U7XHJcbiBcdFx0XHRcdHZhciBkb0Rpc3Bvc2UgPSBmYWxzZTtcclxuIFx0XHRcdFx0dmFyIGNoYWluSW5mbyA9IFwiXCI7XHJcbiBcdFx0XHRcdGlmKHJlc3VsdC5jaGFpbikge1xyXG4gXHRcdFx0XHRcdGNoYWluSW5mbyA9IFwiXFxuVXBkYXRlIHByb3BhZ2F0aW9uOiBcIiArIHJlc3VsdC5jaGFpbi5qb2luKFwiIC0+IFwiKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRzd2l0Y2gocmVzdWx0LnR5cGUpIHtcclxuIFx0XHRcdFx0XHRjYXNlIFwic2VsZi1kZWNsaW5lZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkRlY2xpbmVkKVxyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcclxuIFx0XHRcdFx0XHRcdGlmKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxyXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIG9mIHNlbGYgZGVjbGluZTogXCIgKyByZXN1bHQubW9kdWxlSWQgKyBjaGFpbkluZm8pO1xyXG4gXHRcdFx0XHRcdFx0YnJlYWs7XHJcbiBcdFx0XHRcdFx0Y2FzZSBcImRlY2xpbmVkXCI6XHJcbiBcdFx0XHRcdFx0XHRpZihvcHRpb25zLm9uRGVjbGluZWQpXHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25EZWNsaW5lZChyZXN1bHQpO1xyXG4gXHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRGVjbGluZWQpXHJcbiBcdFx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXCJBYm9ydGVkIGJlY2F1c2Ugb2YgZGVjbGluZWQgZGVwZW5kZW5jeTogXCIgKyByZXN1bHQubW9kdWxlSWQgKyBcIiBpbiBcIiArIHJlc3VsdC5wYXJlbnRJZCArIGNoYWluSW5mbyk7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRjYXNlIFwidW5hY2NlcHRlZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vblVuYWNjZXB0ZWQpXHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25VbmFjY2VwdGVkKHJlc3VsdCk7XHJcbiBcdFx0XHRcdFx0XHRpZighb3B0aW9ucy5pZ25vcmVVbmFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIFwiICsgbW9kdWxlSWQgKyBcIiBpcyBub3QgYWNjZXB0ZWRcIiArIGNoYWluSW5mbyk7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRjYXNlIFwiYWNjZXB0ZWRcIjpcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25BY2NlcHRlZClcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkFjY2VwdGVkKHJlc3VsdCk7XHJcbiBcdFx0XHRcdFx0XHRkb0FwcGx5ID0gdHJ1ZTtcclxuIFx0XHRcdFx0XHRcdGJyZWFrO1xyXG4gXHRcdFx0XHRcdGNhc2UgXCJkaXNwb3NlZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkRpc3Bvc2VkKVxyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRGlzcG9zZWQocmVzdWx0KTtcclxuIFx0XHRcdFx0XHRcdGRvRGlzcG9zZSA9IHRydWU7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRkZWZhdWx0OlxyXG4gXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5leGNlcHRpb24gdHlwZSBcIiArIHJlc3VsdC50eXBlKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihhYm9ydEVycm9yKSB7XHJcbiBcdFx0XHRcdFx0aG90U2V0U3RhdHVzKFwiYWJvcnRcIik7XHJcbiBcdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGFib3J0RXJyb3IpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGlmKGRvQXBwbHkpIHtcclxuIFx0XHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSA9IGhvdFVwZGF0ZVttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCByZXN1bHQub3V0ZGF0ZWRNb2R1bGVzKTtcclxuIFx0XHRcdFx0XHRmb3IobW9kdWxlSWQgaW4gcmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XHJcbiBcdFx0XHRcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZCkpIHtcclxuIFx0XHRcdFx0XHRcdFx0aWYoIW91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSlcclxuIFx0XHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0gPSBbXTtcclxuIFx0XHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdLCByZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKTtcclxuIFx0XHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0aWYoZG9EaXNwb3NlKSB7XHJcbiBcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCBbcmVzdWx0Lm1vZHVsZUlkXSk7XHJcbiBcdFx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSB3YXJuVW5leHBlY3RlZFJlcXVpcmU7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIFN0b3JlIHNlbGYgYWNjZXB0ZWQgb3V0ZGF0ZWQgbW9kdWxlcyB0byByZXF1aXJlIHRoZW0gbGF0ZXIgYnkgdGhlIG1vZHVsZSBzeXN0ZW1cclxuIFx0XHR2YXIgb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzID0gW107XHJcbiBcdFx0Zm9yKGkgPSAwOyBpIDwgb3V0ZGF0ZWRNb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRtb2R1bGVJZCA9IG91dGRhdGVkTW9kdWxlc1tpXTtcclxuIFx0XHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdICYmIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmhvdC5fc2VsZkFjY2VwdGVkKVxyXG4gXHRcdFx0XHRvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMucHVzaCh7XHJcbiBcdFx0XHRcdFx0bW9kdWxlOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRlcnJvckhhbmRsZXI6IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmhvdC5fc2VsZkFjY2VwdGVkXHJcbiBcdFx0XHRcdH0pO1xyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gTm93IGluIFwiZGlzcG9zZVwiIHBoYXNlXHJcbiBcdFx0aG90U2V0U3RhdHVzKFwiZGlzcG9zZVwiKTtcclxuIFx0XHRPYmplY3Qua2V5cyhob3RBdmFpbGFibGVGaWxlc01hcCkuZm9yRWFjaChmdW5jdGlvbihjaHVua0lkKSB7XHJcbiBcdFx0XHRpZihob3RBdmFpbGFibGVGaWxlc01hcFtjaHVua0lkXSA9PT0gZmFsc2UpIHtcclxuIFx0XHRcdFx0aG90RGlzcG9zZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH0pO1xyXG4gXHRcclxuIFx0XHR2YXIgaWR4O1xyXG4gXHRcdHZhciBxdWV1ZSA9IG91dGRhdGVkTW9kdWxlcy5zbGljZSgpO1xyXG4gXHRcdHdoaWxlKHF1ZXVlLmxlbmd0aCA+IDApIHtcclxuIFx0XHRcdG1vZHVsZUlkID0gcXVldWUucG9wKCk7XHJcbiBcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdGlmKCFtb2R1bGUpIGNvbnRpbnVlO1xyXG4gXHRcclxuIFx0XHRcdHZhciBkYXRhID0ge307XHJcbiBcdFxyXG4gXHRcdFx0Ly8gQ2FsbCBkaXNwb3NlIGhhbmRsZXJzXHJcbiBcdFx0XHR2YXIgZGlzcG9zZUhhbmRsZXJzID0gbW9kdWxlLmhvdC5fZGlzcG9zZUhhbmRsZXJzO1xyXG4gXHRcdFx0Zm9yKGogPSAwOyBqIDwgZGlzcG9zZUhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XHJcbiBcdFx0XHRcdGNiID0gZGlzcG9zZUhhbmRsZXJzW2pdO1xyXG4gXHRcdFx0XHRjYihkYXRhKTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdGhvdEN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXSA9IGRhdGE7XHJcbiBcdFxyXG4gXHRcdFx0Ly8gZGlzYWJsZSBtb2R1bGUgKHRoaXMgZGlzYWJsZXMgcmVxdWlyZXMgZnJvbSB0aGlzIG1vZHVsZSlcclxuIFx0XHRcdG1vZHVsZS5ob3QuYWN0aXZlID0gZmFsc2U7XHJcbiBcdFxyXG4gXHRcdFx0Ly8gcmVtb3ZlIG1vZHVsZSBmcm9tIGNhY2hlXHJcbiBcdFx0XHRkZWxldGUgaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFxyXG4gXHRcdFx0Ly8gd2hlbiBkaXNwb3NpbmcgdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGRpc3Bvc2UgaGFuZGxlclxyXG4gXHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcclxuIFx0XHJcbiBcdFx0XHQvLyByZW1vdmUgXCJwYXJlbnRzXCIgcmVmZXJlbmNlcyBmcm9tIGFsbCBjaGlsZHJlblxyXG4gXHRcdFx0Zm9yKGogPSAwOyBqIDwgbW9kdWxlLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XHJcbiBcdFx0XHRcdHZhciBjaGlsZCA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlLmNoaWxkcmVuW2pdXTtcclxuIFx0XHRcdFx0aWYoIWNoaWxkKSBjb250aW51ZTtcclxuIFx0XHRcdFx0aWR4ID0gY2hpbGQucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0aWYoaWR4ID49IDApIHtcclxuIFx0XHRcdFx0XHRjaGlsZC5wYXJlbnRzLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyByZW1vdmUgb3V0ZGF0ZWQgZGVwZW5kZW5jeSBmcm9tIG1vZHVsZSBjaGlsZHJlblxyXG4gXHRcdHZhciBkZXBlbmRlbmN5O1xyXG4gXHRcdHZhciBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcztcclxuIFx0XHRmb3IobW9kdWxlSWQgaW4gb3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRpZihtb2R1bGUpIHtcclxuIFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9IG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0XHRmb3IoaiA9IDA7IGogPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xyXG4gXHRcdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xyXG4gXHRcdFx0XHRcdFx0aWR4ID0gbW9kdWxlLmNoaWxkcmVuLmluZGV4T2YoZGVwZW5kZW5jeSk7XHJcbiBcdFx0XHRcdFx0XHRpZihpZHggPj0gMCkgbW9kdWxlLmNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gTm90IGluIFwiYXBwbHlcIiBwaGFzZVxyXG4gXHRcdGhvdFNldFN0YXR1cyhcImFwcGx5XCIpO1xyXG4gXHRcclxuIFx0XHRob3RDdXJyZW50SGFzaCA9IGhvdFVwZGF0ZU5ld0hhc2g7XHJcbiBcdFxyXG4gXHRcdC8vIGluc2VydCBuZXcgY29kZVxyXG4gXHRcdGZvcihtb2R1bGVJZCBpbiBhcHBsaWVkVXBkYXRlKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXBwbGllZFVwZGF0ZSwgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZXNbbW9kdWxlSWRdID0gYXBwbGllZFVwZGF0ZVttb2R1bGVJZF07XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBjYWxsIGFjY2VwdCBoYW5kbGVyc1xyXG4gXHRcdHZhciBlcnJvciA9IG51bGw7XHJcbiBcdFx0Zm9yKG1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0aWYobW9kdWxlKSB7XHJcbiBcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IFtdO1xyXG4gXHRcdFx0XHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbaV07XHJcbiBcdFx0XHRcdFx0XHRjYiA9IG1vZHVsZS5ob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcGVuZGVuY3ldO1xyXG4gXHRcdFx0XHRcdFx0aWYoY2IpIHtcclxuIFx0XHRcdFx0XHRcdFx0aWYoY2FsbGJhY2tzLmluZGV4T2YoY2IpID49IDApIGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRcdFx0XHRjYWxsYmFja3MucHVzaChjYik7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGZvcihpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0XHRcdFx0Y2IgPSBjYWxsYmFja3NbaV07XHJcbiBcdFx0XHRcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRcdFx0XHRjYihtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyk7XHJcbiBcdFx0XHRcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRcdFx0XHRpZihvcHRpb25zLm9uRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcclxuIFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYWNjZXB0LWVycm9yZWRcIixcclxuIFx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lJZDogbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbaV0sXHJcbiBcdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXHJcbiBcdFx0XHRcdFx0XHRcdFx0fSk7XHJcbiBcdFx0XHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0XHRcdGlmKCFlcnJvcilcclxuIFx0XHRcdFx0XHRcdFx0XHRcdGVycm9yID0gZXJyO1xyXG4gXHRcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBMb2FkIHNlbGYgYWNjZXB0ZWQgbW9kdWxlc1xyXG4gXHRcdGZvcihpID0gMDsgaSA8IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0dmFyIGl0ZW0gPSBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXNbaV07XHJcbiBcdFx0XHRtb2R1bGVJZCA9IGl0ZW0ubW9kdWxlO1xyXG4gXHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xyXG4gXHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCk7XHJcbiBcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRpZih0eXBlb2YgaXRlbS5lcnJvckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gXHRcdFx0XHRcdHRyeSB7XHJcbiBcdFx0XHRcdFx0XHRpdGVtLmVycm9ySGFuZGxlcihlcnIpO1xyXG4gXHRcdFx0XHRcdH0gY2F0Y2goZXJyMikge1xyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xyXG4gXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1hY2NlcHQtZXJyb3ItaGFuZGxlci1lcnJvcmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxyXG4gXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnIyLFxyXG4gXHRcdFx0XHRcdFx0XHRcdG9yZ2luYWxFcnJvcjogZXJyLCAvLyBUT0RPIHJlbW92ZSBpbiB3ZWJwYWNrIDRcclxuIFx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbEVycm9yOiBlcnJcclxuIFx0XHRcdFx0XHRcdFx0fSk7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHRpZighb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XHJcbiBcdFx0XHRcdFx0XHRcdGlmKCFlcnJvcilcclxuIFx0XHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjI7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHRpZighZXJyb3IpXHJcbiBcdFx0XHRcdFx0XHRcdGVycm9yID0gZXJyO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0XHRpZihvcHRpb25zLm9uRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xyXG4gXHRcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtYWNjZXB0LWVycm9yZWRcIixcclxuIFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxyXG4gXHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXHJcbiBcdFx0XHRcdFx0XHR9KTtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0aWYoIWVycm9yKVxyXG4gXHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIGhhbmRsZSBlcnJvcnMgaW4gYWNjZXB0IGhhbmRsZXJzIGFuZCBzZWxmIGFjY2VwdGVkIG1vZHVsZSBsb2FkXHJcbiBcdFx0aWYoZXJyb3IpIHtcclxuIFx0XHRcdGhvdFNldFN0YXR1cyhcImZhaWxcIik7XHJcbiBcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0aG90U2V0U3RhdHVzKFwiaWRsZVwiKTtcclxuIFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xyXG4gXHRcdFx0cmVzb2x2ZShvdXRkYXRlZE1vZHVsZXMpO1xyXG4gXHRcdH0pO1xyXG4gXHR9XHJcblxuIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aG90OiBob3RDcmVhdGVNb2R1bGUobW9kdWxlSWQpLFxuIFx0XHRcdHBhcmVudHM6IChob3RDdXJyZW50UGFyZW50c1RlbXAgPSBob3RDdXJyZW50UGFyZW50cywgaG90Q3VycmVudFBhcmVudHMgPSBbXSwgaG90Q3VycmVudFBhcmVudHNUZW1wKSxcbiBcdFx0XHRjaGlsZHJlbjogW11cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgaG90Q3JlYXRlUmVxdWlyZShtb2R1bGVJZCkpO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBfX3dlYnBhY2tfaGFzaF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhvdEN1cnJlbnRIYXNoOyB9O1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBob3RDcmVhdGVSZXF1aXJlKDE0KShfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxNCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNDJiOGIyMjU0NjRlMzU0YTVjMWYiLCIhZnVuY3Rpb24ocm9vdCxmYWN0b3J5KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1mYWN0b3J5KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShcImFsZnJpZFwiLFtdLGZhY3RvcnkpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuYWxmcmlkPWZhY3RvcnkoKTpyb290LmFsZnJpZD1mYWN0b3J5KCl9KHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24obW9kdWxlcyl7ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCl7aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pcmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7dmFyIG1vZHVsZT1pbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXT17aTptb2R1bGVJZCxsOiExLGV4cG9ydHM6e319O3JldHVybiBtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLG1vZHVsZSxtb2R1bGUuZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKSxtb2R1bGUubD0hMCxtb2R1bGUuZXhwb3J0c312YXIgaW5zdGFsbGVkTW9kdWxlcz17fTtyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5tPW1vZHVsZXMsX193ZWJwYWNrX3JlcXVpcmVfXy5jPWluc3RhbGxlZE1vZHVsZXMsX193ZWJwYWNrX3JlcXVpcmVfXy5kPWZ1bmN0aW9uKGV4cG9ydHMsbmFtZSxnZXR0ZXIpe19fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLG5hbWUpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxuYW1lLHtjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMCxnZXQ6Z2V0dGVyfSl9LF9fd2VicGFja19yZXF1aXJlX18ubj1mdW5jdGlvbihtb2R1bGUpe3ZhciBnZXR0ZXI9bW9kdWxlJiZtb2R1bGUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBtb2R1bGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gbW9kdWxlfTtyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlcixcImFcIixnZXR0ZXIpLGdldHRlcn0sX193ZWJwYWNrX3JlcXVpcmVfXy5vPWZ1bmN0aW9uKG9iamVjdCxwcm9wZXJ0eSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QscHJvcGVydHkpfSxfX3dlYnBhY2tfcmVxdWlyZV9fLnA9XCJcIixfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucz00MSl9KFtmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntkZWZhdWx0Om9ian19ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLENvbnN0cnVjdG9yKXtpZighKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fCExLGRlc2NyaXB0b3IuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGRlc2NyaXB0b3ImJihkZXNjcmlwdG9yLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpfX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7cmV0dXJuIHByb3RvUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpLHN0YXRpY1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKSxDb25zdHJ1Y3Rvcn19KCksX2dsTWF0cml4PV9fd2VicGFja19yZXF1aXJlX18oMSksX2dldEFuZEFwcGx5RXh0ZW5zaW9uPV9fd2VicGFja19yZXF1aXJlX18oNDcpLF9nZXRBbmRBcHBseUV4dGVuc2lvbjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0QW5kQXBwbHlFeHRlbnNpb24pLF9leHBvc2VBdHRyaWJ1dGVzPV9fd2VicGFja19yZXF1aXJlX18oNDgpLF9leHBvc2VBdHRyaWJ1dGVzMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHBvc2VBdHRyaWJ1dGVzKSxfZ2V0RmxvYXQ9X193ZWJwYWNrX3JlcXVpcmVfXyg0OSksX2dldEZsb2F0Mj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRGbG9hdCksX2dldEhhbGZGbG9hdD1fX3dlYnBhY2tfcmVxdWlyZV9fKDUwKSxfZ2V0SGFsZkZsb2F0Mj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRIYWxmRmxvYXQpLF9nZXRBdHRyaWJMb2M9X193ZWJwYWNrX3JlcXVpcmVfXygyNCksX0V4dGVuc2lvbnNMaXN0PShfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRBdHRyaWJMb2MpLF9fd2VicGFja19yZXF1aXJlX18oNTEpKSxfRXh0ZW5zaW9uc0xpc3QyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0V4dGVuc2lvbnNMaXN0KSxnbD12b2lkIDAsR0xUb29sPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gR0xUb29sKCl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsR0xUb29sKSx0aGlzLmNhbnZhcyx0aGlzLl92aWV3cG9ydD1bMCwwLDAsMF0sdGhpcy5fZW5hYmxlZFZlcnRleEF0dHJpYnV0ZT1bXSx0aGlzLmlkZW50aXR5TWF0cml4PV9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpLHRoaXMuX25vcm1hbE1hdHJpeD1fZ2xNYXRyaXgubWF0My5jcmVhdGUoKSx0aGlzLl9pbnZlcnNlTW9kZWxWaWV3TWF0cml4PV9nbE1hdHJpeC5tYXQzLmNyZWF0ZSgpLHRoaXMuX21vZGVsTWF0cml4PV9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpLHRoaXMuX21hdHJpeD1fZ2xNYXRyaXgubWF0NC5jcmVhdGUoKSx0aGlzLl9tYXRyaXhTdGFja3M9W10sdGhpcy5fbGFzdE1lc2g9bnVsbCx0aGlzLl91c2VXZWJHTDI9ITEsdGhpcy5faGFzQXJyYXlJbnN0YW5jZSx0aGlzLl9leHRBcnJheUluc3RhbmNlLHRoaXMuX2hhc0NoZWNrZWRFeHQ9ITEsX2dsTWF0cml4Lm1hdDQuaWRlbnRpdHkodGhpcy5pZGVudGl0eU1hdHJpeCx0aGlzLmlkZW50aXR5TWF0cml4KSx0aGlzLmlzTW9iaWxlPSExLC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmKHRoaXMuaXNNb2JpbGU9ITApfXJldHVybiBfY3JlYXRlQ2xhc3MoR0xUb29sLFt7a2V5OlwiaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKG1DYW52YXMpe3ZhciBtUGFyYW1ldGVycz1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e307aWYobnVsbD09PW1DYW52YXN8fHZvaWQgMD09PW1DYW52YXMpcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcIkNhbnZhcyBub3QgZXhpc3RcIik7dm9pZCAwIT09dGhpcy5jYW52YXMmJm51bGwhPT10aGlzLmNhbnZhcyYmdGhpcy5kZXN0cm95KCksdGhpcy5jYW52YXM9bUNhbnZhcyx0aGlzLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsd2luZG93LmlubmVySGVpZ2h0KSxtUGFyYW1ldGVycy51c2VXZWJnbDI9bVBhcmFtZXRlcnMudXNlV2ViZ2wyfHwhMTt2YXIgY3R4PXZvaWQgMDttUGFyYW1ldGVycy51c2VXZWJnbDI/KGN0eD10aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsMlwiLG1QYXJhbWV0ZXJzKXx8dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIndlYmdsMlwiLG1QYXJhbWV0ZXJzKSxjdHg/dGhpcy5fdXNlV2ViR0wyPSEwOihjdHg9dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsbVBhcmFtZXRlcnMpfHx0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsbVBhcmFtZXRlcnMpLHRoaXMuX3VzZVdlYkdMMj0hMSkpOihjdHg9dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsbVBhcmFtZXRlcnMpfHx0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsbVBhcmFtZXRlcnMpLHRoaXMuX3VzZVdlYkdMMj0hMSksY29uc29sZS5sb2coXCJVc2luZyBXZWJHTCAyID9cIix0aGlzLndlYmdsMiksdGhpcy5pbml0V2l0aEdMKGN0eCl9fSx7a2V5OlwiaW5pdFdpdGhHTFwiLHZhbHVlOmZ1bmN0aW9uKGN0eCl7dGhpcy5jYW52YXN8fCh0aGlzLmNhbnZhcz1jdHguY2FudmFzKSxnbD10aGlzLmdsPWN0eCx0aGlzLmV4dGVuc2lvbnM9e307Zm9yKHZhciBpPTA7aTxfRXh0ZW5zaW9uc0xpc3QyLmRlZmF1bHQubGVuZ3RoO2krKyl0aGlzLmV4dGVuc2lvbnNbX0V4dGVuc2lvbnNMaXN0Mi5kZWZhdWx0W2ldXT1nbC5nZXRFeHRlbnNpb24oX0V4dGVuc2lvbnNMaXN0Mi5kZWZhdWx0W2ldKTsoMCxfZXhwb3NlQXR0cmlidXRlczIuZGVmYXVsdCkoKSwoMCxfZ2V0QW5kQXBwbHlFeHRlbnNpb24yLmRlZmF1bHQpKGdsLFwiT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIiksKDAsX2dldEFuZEFwcGx5RXh0ZW5zaW9uMi5kZWZhdWx0KShnbCxcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIiksKDAsX2dldEFuZEFwcGx5RXh0ZW5zaW9uMi5kZWZhdWx0KShnbCxcIldFQkdMX2RyYXdfYnVmZmVyc1wiKSx0aGlzLmVuYWJsZSh0aGlzLkRFUFRIX1RFU1QpLHRoaXMuZW5hYmxlKHRoaXMuQ1VMTF9GQUNFKSx0aGlzLmVuYWJsZSh0aGlzLkJMRU5EKSx0aGlzLmVuYWJsZUFscGhhQmxlbmRpbmcoKX19LHtrZXk6XCJzZXRWaWV3cG9ydFwiLHZhbHVlOmZ1bmN0aW9uKHgseSx3LGgpe3ZhciBoYXNDaGFuZ2VkPSExO3ghPT10aGlzLl92aWV3cG9ydFswXSYmKGhhc0NoYW5nZWQ9ITApLHkhPT10aGlzLl92aWV3cG9ydFsxXSYmKGhhc0NoYW5nZWQ9ITApLHchPT10aGlzLl92aWV3cG9ydFsyXSYmKGhhc0NoYW5nZWQ9ITApLGghPT10aGlzLl92aWV3cG9ydFszXSYmKGhhc0NoYW5nZWQ9ITApLGhhc0NoYW5nZWQmJihnbC52aWV3cG9ydCh4LHksdyxoKSx0aGlzLl92aWV3cG9ydD1beCx5LHcsaF0pfX0se2tleTpcInNjaXNzb3JcIix2YWx1ZTpmdW5jdGlvbih4LHksdyxoKXtnbC5zY2lzc29yKHgseSx3LGgpfX0se2tleTpcImNsZWFyXCIsdmFsdWU6ZnVuY3Rpb24ocixnLGIsYSl7Z2wuY2xlYXJDb2xvcihyLGcsYixhKSxnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUfGdsLkRFUFRIX0JVRkZFUl9CSVQpfX0se2tleTpcImN1bGxGYWNlXCIsdmFsdWU6ZnVuY3Rpb24obVZhbHVlKXtnbC5jdWxsRmFjZShtVmFsdWUpfX0se2tleTpcInNldE1hdHJpY2VzXCIsdmFsdWU6ZnVuY3Rpb24obUNhbWVyYSl7dGhpcy5jYW1lcmE9bUNhbWVyYSx0aGlzLnJvdGF0ZSh0aGlzLmlkZW50aXR5TWF0cml4KX19LHtrZXk6XCJ1c2VTaGFkZXJcIix2YWx1ZTpmdW5jdGlvbihtU2hhZGVyKXt0aGlzLnNoYWRlcj1tU2hhZGVyLHRoaXMuc2hhZGVyUHJvZ3JhbT10aGlzLnNoYWRlci5zaGFkZXJQcm9ncmFtfX0se2tleTpcInJvdGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKG1Sb3RhdGlvbil7X2dsTWF0cml4Lm1hdDQuY29weSh0aGlzLl9tb2RlbE1hdHJpeCxtUm90YXRpb24pLF9nbE1hdHJpeC5tYXQ0Lm11bHRpcGx5KHRoaXMuX21hdHJpeCx0aGlzLmNhbWVyYS5tYXRyaXgsdGhpcy5fbW9kZWxNYXRyaXgpLF9nbE1hdHJpeC5tYXQzLmZyb21NYXQ0KHRoaXMuX25vcm1hbE1hdHJpeCx0aGlzLl9tYXRyaXgpLF9nbE1hdHJpeC5tYXQzLmludmVydCh0aGlzLl9ub3JtYWxNYXRyaXgsdGhpcy5fbm9ybWFsTWF0cml4KSxfZ2xNYXRyaXgubWF0My50cmFuc3Bvc2UodGhpcy5fbm9ybWFsTWF0cml4LHRoaXMuX25vcm1hbE1hdHJpeCksX2dsTWF0cml4Lm1hdDMuZnJvbU1hdDQodGhpcy5faW52ZXJzZU1vZGVsVmlld01hdHJpeCx0aGlzLl9tYXRyaXgpLF9nbE1hdHJpeC5tYXQzLmludmVydCh0aGlzLl9pbnZlcnNlTW9kZWxWaWV3TWF0cml4LHRoaXMuX2ludmVyc2VNb2RlbFZpZXdNYXRyaXgpfX0se2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbihtTWVzaCxtRHJhd2luZ1R5cGUpe2lmKG1NZXNoLmxlbmd0aClmb3IodmFyIGk9MDtpPG1NZXNoLmxlbmd0aDtpKyspdGhpcy5kcmF3KG1NZXNoW2ldKTtlbHNle21NZXNoLmJpbmQodGhpcy5zaGFkZXJQcm9ncmFtKSx2b2lkIDAhPT10aGlzLmNhbWVyYSYmKHRoaXMuc2hhZGVyLnVuaWZvcm0oXCJ1UHJvamVjdGlvbk1hdHJpeFwiLFwibWF0NFwiLHRoaXMuY2FtZXJhLnByb2plY3Rpb24pLHRoaXMuc2hhZGVyLnVuaWZvcm0oXCJ1Vmlld01hdHJpeFwiLFwibWF0NFwiLHRoaXMuY2FtZXJhLm1hdHJpeCkpLHRoaXMuc2hhZGVyLnVuaWZvcm0oXCJ1TW9kZWxNYXRyaXhcIixcIm1hdDRcIix0aGlzLl9tb2RlbE1hdHJpeCksdGhpcy5zaGFkZXIudW5pZm9ybShcInVOb3JtYWxNYXRyaXhcIixcIm1hdDNcIix0aGlzLl9ub3JtYWxNYXRyaXgpLHRoaXMuc2hhZGVyLnVuaWZvcm0oXCJ1TW9kZWxWaWV3TWF0cml4SW52ZXJzZVwiLFwibWF0M1wiLHRoaXMuX2ludmVyc2VNb2RlbFZpZXdNYXRyaXgpO3ZhciBkcmF3VHlwZT1tTWVzaC5kcmF3VHlwZTt2b2lkIDAhPT1tRHJhd2luZ1R5cGUmJihkcmF3VHlwZT1tRHJhd2luZ1R5cGUpLG1NZXNoLmlzSW5zdGFuY2VkP2dsLmRyYXdFbGVtZW50c0luc3RhbmNlZChtTWVzaC5kcmF3VHlwZSxtTWVzaC5pQnVmZmVyLm51bUl0ZW1zLGdsLlVOU0lHTkVEX1NIT1JULDAsbU1lc2gubnVtSW5zdGFuY2UpOmRyYXdUeXBlPT09Z2wuUE9JTlRTP2dsLmRyYXdBcnJheXMoZHJhd1R5cGUsMCxtTWVzaC52ZXJ0ZXhTaXplKTpnbC5kcmF3RWxlbWVudHMoZHJhd1R5cGUsbU1lc2guaUJ1ZmZlci5udW1JdGVtcyxnbC5VTlNJR05FRF9TSE9SVCwwKSxtTWVzaC51bmJpbmQoKX19fSx7a2V5OlwiZHJhd1RyYW5zZm9ybUZlZWRiYWNrXCIsdmFsdWU6ZnVuY3Rpb24obVRyYW5zZm9ybU9iamVjdCl7dmFyIG1lc2hTb3VyY2U9bVRyYW5zZm9ybU9iamVjdC5tZXNoU291cmNlLG1lc2hEZXN0aW5hdGlvbj1tVHJhbnNmb3JtT2JqZWN0Lm1lc2hEZXN0aW5hdGlvbixudW1Qb2ludHM9bVRyYW5zZm9ybU9iamVjdC5udW1Qb2ludHMsdHJhbnNmb3JtRmVlZGJhY2s9bVRyYW5zZm9ybU9iamVjdC50cmFuc2Zvcm1GZWVkYmFjazttZXNoU291cmNlLmJpbmQodGhpcy5zaGFkZXJQcm9ncmFtKSxtZXNoRGVzdGluYXRpb24uZ2VuZXJhdGVCdWZmZXJzKHRoaXMuc2hhZGVyUHJvZ3JhbSksZ2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKGdsLlRSQU5TRk9STV9GRUVEQkFDSyx0cmFuc2Zvcm1GZWVkYmFjayksbWVzaERlc3RpbmF0aW9uLmF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbihhdHRyLGkpe2dsLmJpbmRCdWZmZXJCYXNlKGdsLlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIsaSxhdHRyLmJ1ZmZlcil9KSxnbC5lbmFibGUoZ2wuUkFTVEVSSVpFUl9ESVNDQVJEKSxnbC5iZWdpblRyYW5zZm9ybUZlZWRiYWNrKGdsLlBPSU5UUyksZ2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsMCxudW1Qb2ludHMpLGdsLmVuZFRyYW5zZm9ybUZlZWRiYWNrKCksZ2wuZGlzYWJsZShnbC5SQVNURVJJWkVSX0RJU0NBUkQpLGdsLnVzZVByb2dyYW0obnVsbCksZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsbnVsbCksbWVzaERlc3RpbmF0aW9uLmF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbihhdHRyLGkpe2dsLmJpbmRCdWZmZXJCYXNlKGdsLlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIsaSxudWxsKX0pLGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayhnbC5UUkFOU0ZPUk1fRkVFREJBQ0ssbnVsbCksbWVzaFNvdXJjZS51bmJpbmQoKX19LHtrZXk6XCJzZXRTaXplXCIsdmFsdWU6ZnVuY3Rpb24obVdpZHRoLG1IZWlnaHQpe3RoaXMuX3dpZHRoPW1XaWR0aCx0aGlzLl9oZWlnaHQ9bUhlaWdodCx0aGlzLmNhbnZhcy53aWR0aD10aGlzLl93aWR0aCx0aGlzLmNhbnZhcy5oZWlnaHQ9dGhpcy5faGVpZ2h0LHRoaXMuX2FzcGVjdFJhdGlvPXRoaXMuX3dpZHRoL3RoaXMuX2hlaWdodCxnbCYmdGhpcy52aWV3cG9ydCgwLDAsdGhpcy5fd2lkdGgsdGhpcy5faGVpZ2h0KX19LHtrZXk6XCJzaG93RXh0ZW5zaW9uc1wiLHZhbHVlOmZ1bmN0aW9uKCl7Y29uc29sZS5sb2coXCJFeHRlbnNpb25zIDogXCIsdGhpcy5leHRlbnNpb25zKTtmb3IodmFyIGV4dCBpbiB0aGlzLmV4dGVuc2lvbnMpdGhpcy5leHRlbnNpb25zW2V4dF0mJmNvbnNvbGUubG9nKGV4dCxcIjpcIix0aGlzLmV4dGVuc2lvbnNbZXh0XSl9fSx7a2V5OlwiY2hlY2tFeHRlbnNpb25cIix2YWx1ZTpmdW5jdGlvbihtRXh0ZW5zaW9uKXtyZXR1cm4hIXRoaXMuZXh0ZW5zaW9uc1ttRXh0ZW5zaW9uXX19LHtrZXk6XCJnZXRFeHRlbnNpb25cIix2YWx1ZTpmdW5jdGlvbihtRXh0ZW5zaW9uKXtyZXR1cm4gdGhpcy5leHRlbnNpb25zW21FeHRlbnNpb25dfX0se2tleTpcImVuYWJsZUFscGhhQmxlbmRpbmdcIix2YWx1ZTpmdW5jdGlvbigpe2dsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsZ2wuT05FX01JTlVTX1NSQ19BTFBIQSl9fSx7a2V5OlwiZW5hYmxlQWRkaXRpdmVCbGVuZGluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7Z2wuYmxlbmRGdW5jKGdsLk9ORSxnbC5PTkUpfX0se2tleTpcInB1c2hNYXRyaXhcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBtdHg9X2dsTWF0cml4Lm1hdDQuY2xvbmUodGhpcy5fbW9kZWxNYXRyaXgpO3RoaXMuX21hdHJpeFN0YWNrcy5wdXNoKG10eCl9fSx7a2V5OlwicG9wTWF0cml4XCIsdmFsdWU6ZnVuY3Rpb24oKXtpZigwPT10aGlzLl9tYXRyaXhTdGFja3MubGVuZ3RoKXJldHVybiBudWxsO3ZhciBtdHg9dGhpcy5fbWF0cml4U3RhY2tzLnBvcCgpO3RoaXMucm90YXRlKG10eCl9fSx7a2V5OlwiZW5hYmxlXCIsdmFsdWU6ZnVuY3Rpb24obVBhcmFtZXRlcil7Z2wuZW5hYmxlKG1QYXJhbWV0ZXIpfX0se2tleTpcImRpc2FibGVcIix2YWx1ZTpmdW5jdGlvbihtUGFyYW1ldGVyKXtnbC5kaXNhYmxlKG1QYXJhbWV0ZXIpfX0se2tleTpcInZpZXdwb3J0XCIsdmFsdWU6ZnVuY3Rpb24oeCx5LHcsaCl7dGhpcy5zZXRWaWV3cG9ydCh4LHksdyxoKX19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLmNhbnZhcy5wYXJlbnROb2RlKXRyeXt0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKX1jYXRjaChlKXtjb25zb2xlLmxvZyhcIkVycm9yIDogXCIsZSl9dGhpcy5jYW52YXM9bnVsbH19LHtrZXk6XCJGTE9BVFwiLGdldDpmdW5jdGlvbigpe3JldHVybigwLF9nZXRGbG9hdDIuZGVmYXVsdCkoKX19LHtrZXk6XCJIQUxGX0ZMT0FUXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuKDAsX2dldEhhbGZGbG9hdDIuZGVmYXVsdCkoKX19LHtrZXk6XCJ3aWR0aFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl93aWR0aH19LHtrZXk6XCJoZWlnaHRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGVpZ2h0fX0se2tleTpcImFzcGVjdFJhdGlvXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2FzcGVjdFJhdGlvfX0se2tleTpcIndlYmdsMlwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl91c2VXZWJHTDJ9fV0pLEdMVG9vbH0oKSxHTD1uZXcgR0xUb29sO2V4cG9ydHMuZGVmYXVsdD1HTH0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKXtpZihvYmomJm9iai5fX2VzTW9kdWxlKXJldHVybiBvYmo7dmFyIG5ld09iaj17fTtpZihudWxsIT1vYmopZm9yKHZhciBrZXkgaW4gb2JqKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosa2V5KSYmKG5ld09ialtrZXldPW9ialtrZXldKTtyZXR1cm4gbmV3T2JqLmRlZmF1bHQ9b2JqLG5ld09ian1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxleHBvcnRzLnZlYzQ9ZXhwb3J0cy52ZWMzPWV4cG9ydHMudmVjMj1leHBvcnRzLnF1YXQ9ZXhwb3J0cy5tYXQ0PWV4cG9ydHMubWF0Mz1leHBvcnRzLm1hdDJkPWV4cG9ydHMubWF0Mj1leHBvcnRzLmdsTWF0cml4PXZvaWQgMDt2YXIgX2NvbW1vbj1fX3dlYnBhY2tfcmVxdWlyZV9fKDMpLGdsTWF0cml4PV9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb21tb24pLF9tYXQ9X193ZWJwYWNrX3JlcXVpcmVfXyg0MiksbWF0Mj1faW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfbWF0KSxfbWF0MmQ9X193ZWJwYWNrX3JlcXVpcmVfXyg0MyksbWF0MmQ9X2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX21hdDJkKSxfbWF0Mj1fX3dlYnBhY2tfcmVxdWlyZV9fKDIwKSxtYXQzPV9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9tYXQyKSxfbWF0Mz1fX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KSxtYXQ0PV9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9tYXQzKSxfcXVhdD1fX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KSxxdWF0PV9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9xdWF0KSxfdmVjPV9fd2VicGFja19yZXF1aXJlX18oNDYpLHZlYzI9X2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3ZlYyksX3ZlYzI9X193ZWJwYWNrX3JlcXVpcmVfXygyMSksdmVjMz1faW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdmVjMiksX3ZlYzM9X193ZWJwYWNrX3JlcXVpcmVfXygyMiksdmVjND1faW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdmVjMyk7ZXhwb3J0cy5nbE1hdHJpeD1nbE1hdHJpeCxleHBvcnRzLm1hdDI9bWF0MixleHBvcnRzLm1hdDJkPW1hdDJkLGV4cG9ydHMubWF0Mz1tYXQzLGV4cG9ydHMubWF0ND1tYXQ0LGV4cG9ydHMucXVhdD1xdWF0LGV4cG9ydHMudmVjMj12ZWMyLGV4cG9ydHMudmVjMz12ZWMzLGV4cG9ydHMudmVjND12ZWM0fSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX3R5cGVvZj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24ob2JqKXtyZXR1cm4gdHlwZW9mIG9ian06ZnVuY3Rpb24ob2JqKXtyZXR1cm4gb2JqJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJm9iai5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmb2JqIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBvYmp9LF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fCExLGRlc2NyaXB0b3IuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGRlc2NyaXB0b3ImJihkZXNjcmlwdG9yLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpfX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7cmV0dXJuIHByb3RvUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpLHN0YXRpY1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKSxDb25zdHJ1Y3Rvcn19KCksX0dMVG9vbD1fX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9HTFRvb2wyPWZ1bmN0aW9uKG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntkZWZhdWx0Om9ian19KF9HTFRvb2wpLGlzU2FtZT0oX193ZWJwYWNrX3JlcXVpcmVfXyg1MiksZnVuY3Rpb24oYXJyYXkxLGFycmF5Mil7aWYoYXJyYXkxLmxlbmd0aCE9PWFycmF5Mi5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciBpPTA7aTxhcnJheTEubGVuZ3RoO2krKylpZihhcnJheTFbaV0hPT1hcnJheTJbaV0pcmV0dXJuITE7cmV0dXJuITB9KSxhZGRMaW5lTnVtYmVycz1mdW5jdGlvbihzdHJpbmcpe2Zvcih2YXIgbGluZXM9c3RyaW5nLnNwbGl0KFwiXFxuXCIpLGk9MDtpPGxpbmVzLmxlbmd0aDtpKyspbGluZXNbaV09aSsxK1wiOiBcIitsaW5lc1tpXTtyZXR1cm4gbGluZXMuam9pbihcIlxcblwiKX0sY2xvbmVBcnJheT1mdW5jdGlvbihtQXJyYXkpe3JldHVybiBtQXJyYXkuc2xpY2U/bUFycmF5LnNsaWNlKDApOm5ldyBGbG9hdDMyQXJyYXkobUFycmF5KX0sZ2w9dm9pZCAwLGRlZmF1bHRWZXJ0ZXhTaGFkZXI9X193ZWJwYWNrX3JlcXVpcmVfXygxMSksZGVmYXVsdEZyYWdtZW50U2hhZGVyPV9fd2VicGFja19yZXF1aXJlX18oNTMpLHVuaWZvcm1NYXBwaW5nPXtmbG9hdDpcInVuaWZvcm0xZlwiLHZlYzI6XCJ1bmlmb3JtMmZ2XCIsdmVjMzpcInVuaWZvcm0zZnZcIix2ZWM0OlwidW5pZm9ybTRmdlwiLGludDpcInVuaWZvcm0xaVwiLG1hdDM6XCJ1bmlmb3JtTWF0cml4M2Z2XCIsbWF0NDpcInVuaWZvcm1NYXRyaXg0ZnZcIn0sR0xTaGFkZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBHTFNoYWRlcigpe3ZhciBzdHJWZXJ0ZXhTaGFkZXI9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOmRlZmF1bHRWZXJ0ZXhTaGFkZXIsc3RyRnJhZ21lbnRTaGFkZXI9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOmRlZmF1bHRGcmFnbWVudFNoYWRlcixtVmFyeWluZ3M9YXJndW1lbnRzWzJdO19jbGFzc0NhbGxDaGVjayh0aGlzLEdMU2hhZGVyKSxnbD1fR0xUb29sMi5kZWZhdWx0LmdsLHRoaXMucGFyYW1ldGVycz1bXSx0aGlzLnVuaWZvcm1UZXh0dXJlcz1bXSx0aGlzLl92YXJ5aW5ncz1tVmFyeWluZ3Msc3RyVmVydGV4U2hhZGVyfHwoc3RyVmVydGV4U2hhZGVyPWRlZmF1bHRWZXJ0ZXhTaGFkZXIpLHN0ckZyYWdtZW50U2hhZGVyfHwoc3RyRnJhZ21lbnRTaGFkZXI9ZGVmYXVsdFZlcnRleFNoYWRlcik7dmFyIHZzU2hhZGVyPXRoaXMuX2NyZWF0ZVNoYWRlclByb2dyYW0oc3RyVmVydGV4U2hhZGVyLCEwKSxmc1NoYWRlcj10aGlzLl9jcmVhdGVTaGFkZXJQcm9ncmFtKHN0ckZyYWdtZW50U2hhZGVyLCExKTt0aGlzLl9hdHRhY2hTaGFkZXJQcm9ncmFtKHZzU2hhZGVyLGZzU2hhZGVyKX1yZXR1cm4gX2NyZWF0ZUNsYXNzKEdMU2hhZGVyLFt7a2V5OlwiYmluZFwiLHZhbHVlOmZ1bmN0aW9uKCl7X0dMVG9vbDIuZGVmYXVsdC5zaGFkZXIhPT10aGlzJiYoZ2wudXNlUHJvZ3JhbSh0aGlzLnNoYWRlclByb2dyYW0pLF9HTFRvb2wyLmRlZmF1bHQudXNlU2hhZGVyKHRoaXMpLHRoaXMudW5pZm9ybVRleHR1cmVzPVtdKX19LHtrZXk6XCJ1bmlmb3JtXCIsdmFsdWU6ZnVuY3Rpb24obU5hbWUsbVR5cGUsbVZhbHVlKXtpZihcIm9iamVjdFwiPT09KHZvaWQgMD09PW1OYW1lP1widW5kZWZpbmVkXCI6X3R5cGVvZihtTmFtZSkpKXJldHVybiB2b2lkIHRoaXMudW5pZm9ybU9iamVjdChtTmFtZSk7Zm9yKHZhciB1bmlmb3JtVHlwZT11bmlmb3JtTWFwcGluZ1ttVHlwZV18fG1UeXBlLGhhc1VuaWZvcm09ITEsb1VuaWZvcm09dm9pZCAwLHBhcmFtZXRlckluZGV4PS0xLGk9MDtpPHRoaXMucGFyYW1ldGVycy5sZW5ndGg7aSsrKWlmKG9Vbmlmb3JtPXRoaXMucGFyYW1ldGVyc1tpXSxvVW5pZm9ybS5uYW1lPT09bU5hbWUpe2hhc1VuaWZvcm09ITAscGFyYW1ldGVySW5kZXg9aTticmVha312YXIgaXNOdW1iZXI9ITE7aWYoaGFzVW5pZm9ybT8odGhpcy5zaGFkZXJQcm9ncmFtW21OYW1lXT1vVW5pZm9ybS51bmlmb3JtTG9jLGlzTnVtYmVyPW9Vbmlmb3JtLmlzTnVtYmVyKTooaXNOdW1iZXI9XCJ1bmlmb3JtMWlcIj09PXVuaWZvcm1UeXBlfHxcInVuaWZvcm0xZlwiPT09dW5pZm9ybVR5cGUsdGhpcy5zaGFkZXJQcm9ncmFtW21OYW1lXT1nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5zaGFkZXJQcm9ncmFtLG1OYW1lKSxpc051bWJlcj90aGlzLnBhcmFtZXRlcnMucHVzaCh7bmFtZTptTmFtZSx0eXBlOnVuaWZvcm1UeXBlLHZhbHVlOm1WYWx1ZSx1bmlmb3JtTG9jOnRoaXMuc2hhZGVyUHJvZ3JhbVttTmFtZV0saXNOdW1iZXI6aXNOdW1iZXJ9KTp0aGlzLnBhcmFtZXRlcnMucHVzaCh7bmFtZTptTmFtZSx0eXBlOnVuaWZvcm1UeXBlLHZhbHVlOmNsb25lQXJyYXkobVZhbHVlKSx1bmlmb3JtTG9jOnRoaXMuc2hhZGVyUHJvZ3JhbVttTmFtZV0saXNOdW1iZXI6aXNOdW1iZXJ9KSxwYXJhbWV0ZXJJbmRleD10aGlzLnBhcmFtZXRlcnMubGVuZ3RoLTEpLHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF0udW5pZm9ybUxvYylpZigtMT09PXVuaWZvcm1UeXBlLmluZGV4T2YoXCJNYXRyaXhcIikpaWYoaXNOdW1iZXIpe3ZhciBuZWVkVXBkYXRlPXRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF0udmFsdWUhPT1tVmFsdWV8fCFoYXNVbmlmb3JtO25lZWRVcGRhdGUmJihnbFt1bmlmb3JtVHlwZV0odGhpcy5zaGFkZXJQcm9ncmFtW21OYW1lXSxtVmFsdWUpLHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF0udmFsdWU9bVZhbHVlKX1lbHNlIGlzU2FtZSh0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdLnZhbHVlLG1WYWx1ZSkmJmhhc1VuaWZvcm18fChnbFt1bmlmb3JtVHlwZV0odGhpcy5zaGFkZXJQcm9ncmFtW21OYW1lXSxtVmFsdWUpLHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF0udmFsdWU9Y2xvbmVBcnJheShtVmFsdWUpKTtlbHNlIGlzU2FtZSh0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdLnZhbHVlLG1WYWx1ZSkmJmhhc1VuaWZvcm18fChnbFt1bmlmb3JtVHlwZV0odGhpcy5zaGFkZXJQcm9ncmFtW21OYW1lXSwhMSxtVmFsdWUpLHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF0udmFsdWU9Y2xvbmVBcnJheShtVmFsdWUpKX19LHtrZXk6XCJ1bmlmb3JtT2JqZWN0XCIsdmFsdWU6ZnVuY3Rpb24obVVuaWZvcm1PYmope2Zvcih2YXIgdW5pZm9ybU5hbWUgaW4gbVVuaWZvcm1PYmope3ZhciB1bmlmb3JtVmFsdWU9bVVuaWZvcm1PYmpbdW5pZm9ybU5hbWVdLHVuaWZvcm1UeXBlPUdMU2hhZGVyLmdldFVuaWZvcm1UeXBlKHVuaWZvcm1WYWx1ZSk7aWYodW5pZm9ybVZhbHVlLmNvbmNhdCYmdW5pZm9ybVZhbHVlWzBdLmNvbmNhdCl7Zm9yKHZhciB0bXA9W10saT0wO2k8dW5pZm9ybVZhbHVlLmxlbmd0aDtpKyspdG1wPXRtcC5jb25jYXQodW5pZm9ybVZhbHVlW2ldKTt1bmlmb3JtVmFsdWU9dG1wfXRoaXMudW5pZm9ybSh1bmlmb3JtTmFtZSx1bmlmb3JtVHlwZSx1bmlmb3JtVmFsdWUpfX19LHtrZXk6XCJfY3JlYXRlU2hhZGVyUHJvZ3JhbVwiLHZhbHVlOmZ1bmN0aW9uKG1TaGFkZXJTdHIsaXNWZXJ0ZXhTaGFkZXIpe3ZhciBzaGFkZXJUeXBlPWlzVmVydGV4U2hhZGVyP19HTFRvb2wyLmRlZmF1bHQuVkVSVEVYX1NIQURFUjpfR0xUb29sMi5kZWZhdWx0LkZSQUdNRU5UX1NIQURFUixzaGFkZXI9Z2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO3JldHVybiBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLG1TaGFkZXJTdHIpLGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKSxnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLGdsLkNPTVBJTEVfU1RBVFVTKT9zaGFkZXI6KGNvbnNvbGUud2FybihcIkVycm9yIGluIFNoYWRlciA6IFwiLGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSksY29uc29sZS5sb2coYWRkTGluZU51bWJlcnMobVNoYWRlclN0cikpLG51bGwpfX0se2tleTpcIl9hdHRhY2hTaGFkZXJQcm9ncmFtXCIsdmFsdWU6ZnVuY3Rpb24obVZlcnRleFNoYWRlcixtRnJhZ21lbnRTaGFkZXIpe3RoaXMuc2hhZGVyUHJvZ3JhbT1nbC5jcmVhdGVQcm9ncmFtKCksZ2wuYXR0YWNoU2hhZGVyKHRoaXMuc2hhZGVyUHJvZ3JhbSxtVmVydGV4U2hhZGVyKSxnbC5hdHRhY2hTaGFkZXIodGhpcy5zaGFkZXJQcm9ncmFtLG1GcmFnbWVudFNoYWRlciksZ2wuZGVsZXRlU2hhZGVyKG1WZXJ0ZXhTaGFkZXIpLGdsLmRlbGV0ZVNoYWRlcihtRnJhZ21lbnRTaGFkZXIpLHRoaXMuX3ZhcnlpbmdzJiYoY29uc29sZS5sb2coXCJUcmFuc2Zvcm0gZmVlZGJhY2sgc2V0dXAgOiBcIix0aGlzLl92YXJ5aW5ncyksZ2wudHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyh0aGlzLnNoYWRlclByb2dyYW0sdGhpcy5fdmFyeWluZ3MsZ2wuU0VQQVJBVEVfQVRUUklCUykpLGdsLmxpbmtQcm9ncmFtKHRoaXMuc2hhZGVyUHJvZ3JhbSl9fV0pLEdMU2hhZGVyfSgpO0dMU2hhZGVyLmdldFVuaWZvcm1UeXBlPWZ1bmN0aW9uKG1WYWx1ZSl7dmFyIGlzQXJyYXk9ISFtVmFsdWUuY29uY2F0LGdldEFycmF5VW5pZm9ybVR5cGU9ZnVuY3Rpb24obVZhbHVlKXtyZXR1cm4gOT09PW1WYWx1ZS5sZW5ndGg/XCJ1bmlmb3JtTWF0cml4M2Z2XCI6MTY9PT1tVmFsdWUubGVuZ3RoP1widW5pZm9ybU1hdHJpeDRmdlwiOlwidmVjXCIrbVZhbHVlLmxlbmd0aH07cmV0dXJuIGlzQXJyYXk/Z2V0QXJyYXlVbmlmb3JtVHlwZShtVmFsdWVbMF0uY29uY2F0P21WYWx1ZVswXTptVmFsdWUpOlwiZmxvYXRcIn0sZXhwb3J0cy5kZWZhdWx0PUdMU2hhZGVyfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBzZXRNYXRyaXhBcnJheVR5cGUodHlwZSl7ZXhwb3J0cy5BUlJBWV9UWVBFPUFSUkFZX1RZUEU9dHlwZX1mdW5jdGlvbiB0b1JhZGlhbihhKXtyZXR1cm4gYSpkZWdyZWV9ZnVuY3Rpb24gZXF1YWxzKGEsYil7cmV0dXJuIE1hdGguYWJzKGEtYik8PUVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhKSxNYXRoLmFicyhiKSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZXhwb3J0cy5zZXRNYXRyaXhBcnJheVR5cGU9c2V0TWF0cml4QXJyYXlUeXBlLGV4cG9ydHMudG9SYWRpYW49dG9SYWRpYW4sZXhwb3J0cy5lcXVhbHM9ZXF1YWxzO3ZhciBFUFNJTE9OPWV4cG9ydHMuRVBTSUxPTj0xZS02LEFSUkFZX1RZUEU9ZXhwb3J0cy5BUlJBWV9UWVBFPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBGbG9hdDMyQXJyYXk/RmxvYXQzMkFycmF5OkFycmF5LGRlZ3JlZT0oZXhwb3J0cy5SQU5ET009TWF0aC5yYW5kb20sTWF0aC5QSS8xODApfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ITEsZGVzY3JpcHRvci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvciYmKGRlc2NyaXB0b3Iud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcil9fXJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtyZXR1cm4gcHJvdG9Qcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyksc3RhdGljUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpLENvbnN0cnVjdG9yfX0oKSxfR0xUb29sPV9fd2VicGFja19yZXF1aXJlX18oMCksX0dMVG9vbDI9ZnVuY3Rpb24ob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX0oX0dMVG9vbCksQmF0Y2g9ZnVuY3Rpb24oKXtmdW5jdGlvbiBCYXRjaChtTWVzaCxtU2hhZGVyKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxCYXRjaCksdGhpcy5fbWVzaD1tTWVzaCx0aGlzLl9zaGFkZXI9bVNoYWRlcn1yZXR1cm4gX2NyZWF0ZUNsYXNzKEJhdGNoLFt7a2V5OlwiZHJhd1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fc2hhZGVyLmJpbmQoKSxfR0xUb29sMi5kZWZhdWx0LmRyYXcodGhpcy5tZXNoKX19LHtrZXk6XCJtZXNoXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21lc2h9fSx7a2V5Olwic2hhZGVyXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NoYWRlcn19XSksQmF0Y2h9KCk7ZXhwb3J0cy5kZWZhdWx0PUJhdGNofSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntkZWZhdWx0Om9ian19ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLENvbnN0cnVjdG9yKXtpZighKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fCExLGRlc2NyaXB0b3IuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGRlc2NyaXB0b3ImJihkZXNjcmlwdG9yLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpfX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7cmV0dXJuIHByb3RvUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpLHN0YXRpY1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKSxDb25zdHJ1Y3Rvcn19KCksX0dMVG9vbD1fX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9HTFRvb2wyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dMVG9vbCksX2dsTWF0cml4PV9fd2VicGFja19yZXF1aXJlX18oMSksX2dldEF0dHJpYkxvYz1fX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSxfZ2V0QXR0cmliTG9jMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRBdHRyaWJMb2MpLGdsPXZvaWQgMCxnZXRCdWZmZXI9ZnVuY3Rpb24oYXR0cil7dmFyIGJ1ZmZlcj12b2lkIDA7cmV0dXJuIHZvaWQgMCE9PWF0dHIuYnVmZmVyP2J1ZmZlcj1hdHRyLmJ1ZmZlcjooYnVmZmVyPWdsLmNyZWF0ZUJ1ZmZlcigpLGF0dHIuYnVmZmVyPWJ1ZmZlciksYnVmZmVyfSxmb3JtQnVmZmVyPWZ1bmN0aW9uKG1EYXRhLG1OdW0pe2Zvcih2YXIgYXJ5PVtdLGk9MDtpPG1EYXRhLmxlbmd0aDtpKz1tTnVtKXtmb3IodmFyIG89W10saj0wO2o8bU51bTtqKyspby5wdXNoKG1EYXRhW2kral0pO2FyeS5wdXNoKG8pfXJldHVybiBhcnl9LE1lc2g9ZnVuY3Rpb24oKXtmdW5jdGlvbiBNZXNoKCl7dmFyIG1EcmF3aW5nVHlwZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06NCxtVXNlVmFvPSEoYXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0pfHxhcmd1bWVudHNbMV07X2NsYXNzQ2FsbENoZWNrKHRoaXMsTWVzaCksZ2w9X0dMVG9vbDIuZGVmYXVsdC5nbCx0aGlzLmRyYXdUeXBlPW1EcmF3aW5nVHlwZSx0aGlzLl9hdHRyaWJ1dGVzPVtdLHRoaXMuX251bUluc3RhbmNlPS0xLHRoaXMuX2VuYWJsZWRWZXJ0ZXhBdHRyaWJ1dGU9W10sdGhpcy5faW5kaWNlcz1bXSx0aGlzLl9mYWNlcz1bXSx0aGlzLl9idWZmZXJDaGFuZ2VkPVtdLHRoaXMuX2hhc0luZGV4QnVmZmVyQ2hhbmdlZD0hMSx0aGlzLl9oYXNWQU89ITEsdGhpcy5faXNJbnN0YW5jZWQ9ITEsdGhpcy5fZXh0VkFPPSEhX0dMVG9vbDIuZGVmYXVsdC5nbC5jcmVhdGVWZXJ0ZXhBcnJheSx0aGlzLl91c2VWQU89ISF0aGlzLl9leHRWQU8mJm1Vc2VWYW99cmV0dXJuIF9jcmVhdGVDbGFzcyhNZXNoLFt7a2V5OlwiYnVmZmVyVmVydGV4XCIsdmFsdWU6ZnVuY3Rpb24obUFycmF5VmVydGljZXMpe3ZhciBtRHJhd1R5cGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjM1MDQ0O3JldHVybiB0aGlzLmJ1ZmZlckRhdGEobUFycmF5VmVydGljZXMsXCJhVmVydGV4UG9zaXRpb25cIiwzLG1EcmF3VHlwZSksdGhpcy5ub3JtYWxzLmxlbmd0aDx0aGlzLnZlcnRpY2VzLmxlbmd0aCYmdGhpcy5idWZmZXJOb3JtYWwobUFycmF5VmVydGljZXMsbURyYXdUeXBlKSx0aGlzfX0se2tleTpcImJ1ZmZlclRleENvb3JkXCIsdmFsdWU6ZnVuY3Rpb24obUFycmF5VGV4Q29vcmRzKXt2YXIgbURyYXdUeXBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTozNTA0NDtyZXR1cm4gdGhpcy5idWZmZXJEYXRhKG1BcnJheVRleENvb3JkcyxcImFUZXh0dXJlQ29vcmRcIiwyLG1EcmF3VHlwZSksdGhpc319LHtrZXk6XCJidWZmZXJOb3JtYWxcIix2YWx1ZTpmdW5jdGlvbihtTm9ybWFscyl7dmFyIG1EcmF3VHlwZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06MzUwNDQ7cmV0dXJuIHRoaXMuYnVmZmVyRGF0YShtTm9ybWFscyxcImFOb3JtYWxcIiwzLG1EcmF3VHlwZSksdGhpc319LHtrZXk6XCJidWZmZXJJbmRleFwiLHZhbHVlOmZ1bmN0aW9uKG1BcnJheUluZGljZXMpe3ZhciBpc0R5bmFtaWM9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fZHJhd1R5cGU9aXNEeW5hbWljP2dsLkRZTkFNSUNfRFJBVzpnbC5TVEFUSUNfRFJBVyx0aGlzLl9pbmRpY2VzPW5ldyBVaW50MTZBcnJheShtQXJyYXlJbmRpY2VzKSx0aGlzLl9udW1JdGVtcz10aGlzLl9pbmRpY2VzLmxlbmd0aCx0aGlzfX0se2tleTpcImJ1ZmZlckZsYXR0ZW5EYXRhXCIsdmFsdWU6ZnVuY3Rpb24obURhdGEsbU5hbWUsbUl0ZW1TaXplKXt2YXIgZGF0YT0oYXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10mJmFyZ3VtZW50c1szXSxhcmd1bWVudHMubGVuZ3RoPjQmJnZvaWQgMCE9PWFyZ3VtZW50c1s0XSYmYXJndW1lbnRzWzRdLGZvcm1CdWZmZXIobURhdGEsbUl0ZW1TaXplKSk7cmV0dXJuIHRoaXMuYnVmZmVyRGF0YShkYXRhLG1OYW1lLG1JdGVtU2l6ZSwzNTA0NCwhMSksdGhpc319LHtrZXk6XCJidWZmZXJEYXRhXCIsdmFsdWU6ZnVuY3Rpb24obURhdGEsbU5hbWUsbUl0ZW1TaXplKXt2YXIgbURyYXdUeXBlPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTozNTA0NCxpc0luc3RhbmNlZD1hcmd1bWVudHMubGVuZ3RoPjQmJnZvaWQgMCE9PWFyZ3VtZW50c1s0XSYmYXJndW1lbnRzWzRdLGk9MCxkcmF3VHlwZT1tRHJhd1R5cGUsYnVmZmVyRGF0YT1bXTtmb3IobUl0ZW1TaXplfHwobUl0ZW1TaXplPW1EYXRhWzBdLmxlbmd0aCksdGhpcy5faXNJbnN0YW5jZWQ9aXNJbnN0YW5jZWR8fHRoaXMuX2lzSW5zdGFuY2VkLGk9MDtpPG1EYXRhLmxlbmd0aDtpKyspZm9yKHZhciBqPTA7ajxtRGF0YVtpXS5sZW5ndGg7aisrKWJ1ZmZlckRhdGEucHVzaChtRGF0YVtpXVtqXSk7dmFyIGRhdGFBcnJheT1uZXcgRmxvYXQzMkFycmF5KGJ1ZmZlckRhdGEpLGF0dHJpYnV0ZT10aGlzLmdldEF0dHJpYnV0ZShtTmFtZSk7cmV0dXJuIGF0dHJpYnV0ZT8oYXR0cmlidXRlLml0ZW1TaXplPW1JdGVtU2l6ZSxhdHRyaWJ1dGUuZGF0YUFycmF5PWRhdGFBcnJheSxhdHRyaWJ1dGUuc291cmNlPW1EYXRhKTp0aGlzLl9hdHRyaWJ1dGVzLnB1c2goe25hbWU6bU5hbWUsc291cmNlOm1EYXRhLGl0ZW1TaXplOm1JdGVtU2l6ZSxkcmF3VHlwZTpkcmF3VHlwZSxkYXRhQXJyYXk6ZGF0YUFycmF5LGlzSW5zdGFuY2VkOmlzSW5zdGFuY2VkfSksdGhpcy5fYnVmZmVyQ2hhbmdlZC5wdXNoKG1OYW1lKSx0aGlzfX0se2tleTpcImJ1ZmZlckluc3RhbmNlXCIsdmFsdWU6ZnVuY3Rpb24obURhdGEsbU5hbWUpe2lmKCFfR0xUb29sMi5kZWZhdWx0LmdsLnZlcnRleEF0dHJpYkRpdmlzb3IpcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcIkV4dGVuc2lvbiA6IEFOR0xFX2luc3RhbmNlZF9hcnJheXMgaXMgbm90IHN1cHBvcnRlZCB3aXRoIHRoaXMgZGV2aWNlICFcIik7dmFyIGl0ZW1TaXplPW1EYXRhWzBdLmxlbmd0aDt0aGlzLl9udW1JbnN0YW5jZT1tRGF0YS5sZW5ndGgsdGhpcy5idWZmZXJEYXRhKG1EYXRhLG1OYW1lLGl0ZW1TaXplLDM1MDQ0LCEwKX19LHtrZXk6XCJiaW5kXCIsdmFsdWU6ZnVuY3Rpb24obVNoYWRlclByb2dyYW0pe3RoaXMuZ2VuZXJhdGVCdWZmZXJzKG1TaGFkZXJQcm9ncmFtKSx0aGlzLmhhc1ZBTz9nbC5iaW5kVmVydGV4QXJyYXkodGhpcy52YW8pOih0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe2dsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLGF0dHJpYnV0ZS5idWZmZXIpO3ZhciBhdHRyUG9zaXRpb249YXR0cmlidXRlLmF0dHJQb3NpdGlvbjtnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJQb3NpdGlvbixhdHRyaWJ1dGUuaXRlbVNpemUsZ2wuRkxPQVQsITEsMCwwKSxhdHRyaWJ1dGUuaXNJbnN0YW5jZWQmJmdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0clBvc2l0aW9uLDEpfSksZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUix0aGlzLmlCdWZmZXIpKX19LHtrZXk6XCJnZW5lcmF0ZUJ1ZmZlcnNcIix2YWx1ZTpmdW5jdGlvbihtU2hhZGVyUHJvZ3JhbSl7dmFyIF90aGlzPXRoaXM7MCE9dGhpcy5fYnVmZmVyQ2hhbmdlZC5sZW5ndGgmJih0aGlzLl91c2VWQU8/KHRoaXMuX3Zhb3x8KHRoaXMuX3Zhbz1nbC5jcmVhdGVWZXJ0ZXhBcnJheSgpKSxnbC5iaW5kVmVydGV4QXJyYXkodGhpcy5fdmFvKSx0aGlzLl9hdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24oYXR0ck9iail7aWYoLTEhPT1fdGhpcy5fYnVmZmVyQ2hhbmdlZC5pbmRleE9mKGF0dHJPYmoubmFtZSkpe3ZhciBidWZmZXI9Z2V0QnVmZmVyKGF0dHJPYmopO2dsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLGJ1ZmZlciksZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsYXR0ck9iai5kYXRhQXJyYXksYXR0ck9iai5kcmF3VHlwZSk7dmFyIGF0dHJQb3NpdGlvbj0oMCxfZ2V0QXR0cmliTG9jMi5kZWZhdWx0KShnbCxtU2hhZGVyUHJvZ3JhbSxhdHRyT2JqLm5hbWUpO2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJQb3NpdGlvbiksZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyUG9zaXRpb24sYXR0ck9iai5pdGVtU2l6ZSxnbC5GTE9BVCwhMSwwLDApLGF0dHJPYmouYXR0clBvc2l0aW9uPWF0dHJQb3NpdGlvbixhdHRyT2JqLmlzSW5zdGFuY2VkJiZnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHJQb3NpdGlvbiwxKX19KSx0aGlzLl91cGRhdGVJbmRleEJ1ZmZlcigpLGdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKSx0aGlzLl9oYXNWQU89ITApOih0aGlzLl9hdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24oYXR0ck9iail7aWYoLTEhPT1fdGhpcy5fYnVmZmVyQ2hhbmdlZC5pbmRleE9mKGF0dHJPYmoubmFtZSkpe3ZhciBidWZmZXI9Z2V0QnVmZmVyKGF0dHJPYmopO2dsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLGJ1ZmZlciksZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsYXR0ck9iai5kYXRhQXJyYXksYXR0ck9iai5kcmF3VHlwZSk7dmFyIGF0dHJQb3NpdGlvbj0oMCxfZ2V0QXR0cmliTG9jMi5kZWZhdWx0KShnbCxtU2hhZGVyUHJvZ3JhbSxhdHRyT2JqLm5hbWUpO2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJQb3NpdGlvbiksZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyUG9zaXRpb24sYXR0ck9iai5pdGVtU2l6ZSxnbC5GTE9BVCwhMSwwLDApLGF0dHJPYmouYXR0clBvc2l0aW9uPWF0dHJQb3NpdGlvbixhdHRyT2JqLmlzSW5zdGFuY2VkJiZnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHJQb3NpdGlvbiwxKX19KSx0aGlzLl91cGRhdGVJbmRleEJ1ZmZlcigpKSx0aGlzLl9oYXNJbmRleEJ1ZmZlckNoYW5nZWQ9ITEsdGhpcy5fYnVmZmVyQ2hhbmdlZD1bXSl9fSx7a2V5OlwidW5iaW5kXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl91c2VWQU8mJmdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKSx0aGlzLl9hdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24oYXR0cmlidXRlKXthdHRyaWJ1dGUuaXNJbnN0YW5jZWQmJmdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0cmlidXRlLmF0dHJQb3NpdGlvbiwwKX0pfX0se2tleTpcIl91cGRhdGVJbmRleEJ1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5faGFzSW5kZXhCdWZmZXJDaGFuZ2VkfHwodGhpcy5pQnVmZmVyfHwodGhpcy5pQnVmZmVyPWdsLmNyZWF0ZUJ1ZmZlcigpKSxnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLHRoaXMuaUJ1ZmZlciksZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUix0aGlzLl9pbmRpY2VzLHRoaXMuX2RyYXdUeXBlKSx0aGlzLmlCdWZmZXIuaXRlbVNpemU9MSx0aGlzLmlCdWZmZXIubnVtSXRlbXM9dGhpcy5fbnVtSXRlbXMpfX0se2tleTpcImNvbXB1dGVOb3JtYWxzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdXNpbmdGYWNlTm9ybWFscz1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSYmYXJndW1lbnRzWzBdO3RoaXMuZ2VuZXJhdGVGYWNlcygpLHVzaW5nRmFjZU5vcm1hbHM/dGhpcy5fY29tcHV0ZUZhY2VOb3JtYWxzKCk6dGhpcy5fY29tcHV0ZVZlcnRleE5vcm1hbHMoKX19LHtrZXk6XCJfY29tcHV0ZUZhY2VOb3JtYWxzXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGZhY2VJbmRleD12b2lkIDAsZmFjZT12b2lkIDAsbm9ybWFscz1bXSxpPTA7aTx0aGlzLl9pbmRpY2VzLmxlbmd0aDtpKz0zKXtmYWNlSW5kZXg9aS8zLGZhY2U9dGhpcy5fZmFjZXNbZmFjZUluZGV4XTt2YXIgTj1mYWNlLm5vcm1hbDtub3JtYWxzW2ZhY2UuaW5kaWNlc1swXV09Tixub3JtYWxzW2ZhY2UuaW5kaWNlc1sxXV09Tixub3JtYWxzW2ZhY2UuaW5kaWNlc1syXV09Tn10aGlzLmJ1ZmZlck5vcm1hbChub3JtYWxzKX19LHtrZXk6XCJfY29tcHV0ZVZlcnRleE5vcm1hbHNcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgZmFjZT12b2lkIDAsc3VtTm9ybWFsPV9nbE1hdHJpeC52ZWMzLmNyZWF0ZSgpLG5vcm1hbHM9W10sdmVydGljZXM9dGhpcy52ZXJ0aWNlcyxpPTA7aTx2ZXJ0aWNlcy5sZW5ndGg7aSsrKXtfZ2xNYXRyaXgudmVjMy5zZXQoc3VtTm9ybWFsLDAsMCwwKTtmb3IodmFyIGo9MDtqPHRoaXMuX2ZhY2VzLmxlbmd0aDtqKyspZmFjZT10aGlzLl9mYWNlc1tqXSxmYWNlLmluZGljZXMuaW5kZXhPZihpKT49MCYmKHN1bU5vcm1hbFswXSs9ZmFjZS5ub3JtYWxbMF0sc3VtTm9ybWFsWzFdKz1mYWNlLm5vcm1hbFsxXSxzdW1Ob3JtYWxbMl0rPWZhY2Uubm9ybWFsWzJdKTtfZ2xNYXRyaXgudmVjMy5ub3JtYWxpemUoc3VtTm9ybWFsLHN1bU5vcm1hbCksbm9ybWFscy5wdXNoKFtzdW1Ob3JtYWxbMF0sc3VtTm9ybWFsWzFdLHN1bU5vcm1hbFsyXV0pfXRoaXMuYnVmZmVyTm9ybWFsKG5vcm1hbHMpfX0se2tleTpcImdlbmVyYXRlRmFjZXNcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgaWE9dm9pZCAwLGliPXZvaWQgMCxpYz12b2lkIDAsYT12b2lkIDAsYj12b2lkIDAsYz12b2lkIDAsdmVydGljZXM9KF9nbE1hdHJpeC52ZWMzLmNyZWF0ZSgpLF9nbE1hdHJpeC52ZWMzLmNyZWF0ZSgpLF9nbE1hdHJpeC52ZWMzLmNyZWF0ZSgpLHRoaXMudmVydGljZXMpLGk9MDtpPHRoaXMuX2luZGljZXMubGVuZ3RoO2krPTMpe2lhPXRoaXMuX2luZGljZXNbaV0saWI9dGhpcy5faW5kaWNlc1tpKzFdLGljPXRoaXMuX2luZGljZXNbaSsyXSxhPXZlcnRpY2VzW2lhXSxiPXZlcnRpY2VzW2liXSxjPXZlcnRpY2VzW2ljXTt2YXIgZmFjZT17aW5kaWNlczpbaWEsaWIsaWNdLHZlcnRpY2VzOlthLGIsY119O3RoaXMuX2ZhY2VzLnB1c2goZmFjZSl9fX0se2tleTpcImdldEF0dHJpYnV0ZVwiLHZhbHVlOmZ1bmN0aW9uKG1OYW1lKXtyZXR1cm4gdGhpcy5fYXR0cmlidXRlcy5maW5kKGZ1bmN0aW9uKGEpe3JldHVybiBhLm5hbWU9PT1tTmFtZX0pfX0se2tleTpcImdldFNvdXJjZVwiLHZhbHVlOmZ1bmN0aW9uKG1OYW1lKXt2YXIgYXR0cj10aGlzLmdldEF0dHJpYnV0ZShtTmFtZSk7cmV0dXJuIGF0dHI/YXR0ci5zb3VyY2U6W119fSx7a2V5OlwidmVydGljZXNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRTb3VyY2UoXCJhVmVydGV4UG9zaXRpb25cIil9fSx7a2V5Olwibm9ybWFsc1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFNvdXJjZShcImFOb3JtYWxcIil9fSx7a2V5OlwiY29vcmRzXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0U291cmNlKFwiYVRleHR1cmVDb29yZFwiKX19LHtrZXk6XCJpbmRpY2VzXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2luZGljZXN9fSx7a2V5OlwidmVydGV4U2l6ZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZlcnRpY2VzLmxlbmd0aH19LHtrZXk6XCJmYWNlc1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9mYWNlc319LHtrZXk6XCJhdHRyaWJ1dGVzXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXN9fSx7a2V5OlwiaGFzVkFPXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc1ZBT319LHtrZXk6XCJ2YW9cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdmFvfX0se2tleTpcIm51bUluc3RhbmNlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX251bUluc3RhbmNlfX0se2tleTpcImlzSW5zdGFuY2VkXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSW5zdGFuY2VkfX1dKSxNZXNofSgpO2V4cG9ydHMuZGVmYXVsdD1NZXNofSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ITEsZGVzY3JpcHRvci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvciYmKGRlc2NyaXB0b3Iud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcil9fXJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtyZXR1cm4gcHJvdG9Qcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyksc3RhdGljUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpLENvbnN0cnVjdG9yfX0oKSxTY2hlZHVsZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBTY2hlZHVsZXIoKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxTY2hlZHVsZXIpLHRoaXMuX2RlbGF5VGFza3M9W10sdGhpcy5fbmV4dFRhc2tzPVtdLHRoaXMuX2RlZmVyVGFza3M9W10sdGhpcy5faGlnaFRhc2tzPVtdLHRoaXMuX3VzdXJwVGFzaz1bXSx0aGlzLl9lbnRlcmZyYW1lVGFza3M9W10sdGhpcy5faWRUYWJsZT0wLHRoaXMuX3N0YXJ0VGltZT0obmV3IERhdGUpLmdldFRpbWUoKSx0aGlzLl9kZWx0YVRpbWU9MCx0aGlzLl9sb29wKCl9cmV0dXJuIF9jcmVhdGVDbGFzcyhTY2hlZHVsZXIsW3trZXk6XCJhZGRFRlwiLHZhbHVlOmZ1bmN0aW9uKGZ1bmMscGFyYW1zKXtwYXJhbXM9cGFyYW1zfHxbXTt2YXIgaWQ9dGhpcy5faWRUYWJsZTtyZXR1cm4gdGhpcy5fZW50ZXJmcmFtZVRhc2tzW2lkXT17ZnVuYzpmdW5jLHBhcmFtczpwYXJhbXN9LHRoaXMuX2lkVGFibGUrKyxpZH19LHtrZXk6XCJyZW1vdmVFRlwiLHZhbHVlOmZ1bmN0aW9uKGlkKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5fZW50ZXJmcmFtZVRhc2tzW2lkXSYmKHRoaXMuX2VudGVyZnJhbWVUYXNrc1tpZF09bnVsbCksLTF9fSx7a2V5OlwiZGVsYXlcIix2YWx1ZTpmdW5jdGlvbihmdW5jLHBhcmFtcyxfZGVsYXkpe3ZhciB0aW1lPShuZXcgRGF0ZSkuZ2V0VGltZSgpLHQ9e2Z1bmM6ZnVuYyxwYXJhbXM6cGFyYW1zLGRlbGF5Ol9kZWxheSx0aW1lOnRpbWV9O3RoaXMuX2RlbGF5VGFza3MucHVzaCh0KX19LHtrZXk6XCJkZWZlclwiLHZhbHVlOmZ1bmN0aW9uKGZ1bmMscGFyYW1zKXt2YXIgdD17ZnVuYzpmdW5jLHBhcmFtczpwYXJhbXN9O3RoaXMuX2RlZmVyVGFza3MucHVzaCh0KX19LHtrZXk6XCJuZXh0XCIsdmFsdWU6ZnVuY3Rpb24oZnVuYyxwYXJhbXMpe3ZhciB0PXtmdW5jOmZ1bmMscGFyYW1zOnBhcmFtc307dGhpcy5fbmV4dFRhc2tzLnB1c2godCl9fSx7a2V5OlwidXN1cnBcIix2YWx1ZTpmdW5jdGlvbihmdW5jLHBhcmFtcyl7dmFyIHQ9e2Z1bmM6ZnVuYyxwYXJhbXM6cGFyYW1zfTt0aGlzLl91c3VycFRhc2sucHVzaCh0KX19LHtrZXk6XCJfcHJvY2Vzc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGk9MCx0YXNrPXZvaWQgMCxpbnRlcnZhbD12b2lkIDA7Zm9yKGk9MDtpPHRoaXMuX2VudGVyZnJhbWVUYXNrcy5sZW5ndGg7aSsrKW51bGwhPT0odGFzaz10aGlzLl9lbnRlcmZyYW1lVGFza3NbaV0pJiZ2b2lkIDAhPT10YXNrJiZ0YXNrLmZ1bmModGFzay5wYXJhbXMpO2Zvcig7dGhpcy5faGlnaFRhc2tzLmxlbmd0aD4wOyl0YXNrPXRoaXMuX2hpZ2hUYXNrcy5wb3AoKSx0YXNrLmZ1bmModGFzay5wYXJhbXMpO3ZhciBzdGFydFRpbWU9KG5ldyBEYXRlKS5nZXRUaW1lKCk7Zm9yKHRoaXMuX2RlbHRhVGltZT0oc3RhcnRUaW1lLXRoaXMuX3N0YXJ0VGltZSkvMWUzLGk9MDtpPHRoaXMuX2RlbGF5VGFza3MubGVuZ3RoO2krKyl0YXNrPXRoaXMuX2RlbGF5VGFza3NbaV0sc3RhcnRUaW1lLXRhc2sudGltZT50YXNrLmRlbGF5JiYodGFzay5mdW5jKHRhc2sucGFyYW1zKSx0aGlzLl9kZWxheVRhc2tzLnNwbGljZShpLDEpKTtmb3Ioc3RhcnRUaW1lPShuZXcgRGF0ZSkuZ2V0VGltZSgpLHRoaXMuX2RlbHRhVGltZT0oc3RhcnRUaW1lLXRoaXMuX3N0YXJ0VGltZSkvMWUzLGludGVydmFsPTFlMy82MDt0aGlzLl9kZWZlclRhc2tzLmxlbmd0aD4wOyl7aWYodGFzaz10aGlzLl9kZWZlclRhc2tzLnNoaWZ0KCksISgobmV3IERhdGUpLmdldFRpbWUoKS1zdGFydFRpbWU8aW50ZXJ2YWwpKXt0aGlzLl9kZWZlclRhc2tzLnVuc2hpZnQodGFzayk7YnJlYWt9dGFzay5mdW5jKHRhc2sucGFyYW1zKX1mb3Ioc3RhcnRUaW1lPShuZXcgRGF0ZSkuZ2V0VGltZSgpLHRoaXMuX2RlbHRhVGltZT0oc3RhcnRUaW1lLXRoaXMuX3N0YXJ0VGltZSkvMWUzLGludGVydmFsPTFlMy82MDt0aGlzLl91c3VycFRhc2subGVuZ3RoPjA7KXRhc2s9dGhpcy5fdXN1cnBUYXNrLnNoaWZ0KCksKG5ldyBEYXRlKS5nZXRUaW1lKCktc3RhcnRUaW1lPGludGVydmFsJiZ0YXNrLmZ1bmModGFzay5wYXJhbXMpO3RoaXMuX2hpZ2hUYXNrcz10aGlzLl9oaWdoVGFza3MuY29uY2F0KHRoaXMuX25leHRUYXNrcyksdGhpcy5fbmV4dFRhc2tzPVtdLHRoaXMuX3VzdXJwVGFzaz1bXX19LHtrZXk6XCJfbG9vcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIF90aGlzPXRoaXM7dGhpcy5fcHJvY2VzcygpLHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtyZXR1cm4gX3RoaXMuX2xvb3AoKX0pfX0se2tleTpcImRlbHRhVGltZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9kZWx0YVRpbWV9fV0pLFNjaGVkdWxlcn0oKSxzY2hlZHVsZXI9bmV3IFNjaGVkdWxlcjtleHBvcnRzLmRlZmF1bHQ9c2NoZWR1bGVyfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX01lc2g9X193ZWJwYWNrX3JlcXVpcmVfXyg1KSxfTWVzaDI9ZnVuY3Rpb24ob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX0oX01lc2gpLEdlb209e30sbWVzaFRyaT12b2lkIDA7R2VvbS5wbGFuZT1mdW5jdGlvbih3aWR0aCxoZWlnaHQsbnVtU2VnbWVudHMpe2Zvcih2YXIgYXhpcz1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106XCJ4eVwiLGRyYXdUeXBlPWFyZ3VtZW50cy5sZW5ndGg+NCYmdm9pZCAwIT09YXJndW1lbnRzWzRdP2FyZ3VtZW50c1s0XTo0LHBvc2l0aW9ucz1bXSxjb29yZHM9W10saW5kaWNlcz1bXSxub3JtYWxzPVtdLGdhcFg9d2lkdGgvbnVtU2VnbWVudHMsZ2FwWT1oZWlnaHQvbnVtU2VnbWVudHMsZ2FwVVY9MS9udW1TZWdtZW50cyxzeD0uNSotd2lkdGgsc3k9LjUqLWhlaWdodCxpbmRleD0wLGk9MDtpPG51bVNlZ21lbnRzO2krKylmb3IodmFyIGo9MDtqPG51bVNlZ21lbnRzO2orKyl7dmFyIHR4PWdhcFgqaStzeCx0eT1nYXBZKmorc3ksdT1pL251bVNlZ21lbnRzLHY9ai9udW1TZWdtZW50cztcInh6XCI9PT1heGlzPyhwb3NpdGlvbnMucHVzaChbdHgsMCx0eStnYXBZXSkscG9zaXRpb25zLnB1c2goW3R4K2dhcFgsMCx0eStnYXBZXSkscG9zaXRpb25zLnB1c2goW3R4K2dhcFgsMCx0eV0pLHBvc2l0aW9ucy5wdXNoKFt0eCwwLHR5XSksY29vcmRzLnB1c2goW3UsMS0oditnYXBVVildKSxjb29yZHMucHVzaChbdStnYXBVViwxLSh2K2dhcFVWKV0pLGNvb3Jkcy5wdXNoKFt1K2dhcFVWLDEtdl0pLGNvb3Jkcy5wdXNoKFt1LDEtdl0pLG5vcm1hbHMucHVzaChbMCwxLDBdKSxub3JtYWxzLnB1c2goWzAsMSwwXSksbm9ybWFscy5wdXNoKFswLDEsMF0pLG5vcm1hbHMucHVzaChbMCwxLDBdKSk6XCJ5elwiPT09YXhpcz8ocG9zaXRpb25zLnB1c2goWzAsdHksdHhdKSxwb3NpdGlvbnMucHVzaChbMCx0eSx0eCtnYXBYXSkscG9zaXRpb25zLnB1c2goWzAsdHkrZ2FwWSx0eCtnYXBYXSkscG9zaXRpb25zLnB1c2goWzAsdHkrZ2FwWSx0eF0pLGNvb3Jkcy5wdXNoKFt1LHZdKSxjb29yZHMucHVzaChbdStnYXBVVix2XSksY29vcmRzLnB1c2goW3UrZ2FwVVYsditnYXBVVl0pLGNvb3Jkcy5wdXNoKFt1LHYrZ2FwVVZdKSxub3JtYWxzLnB1c2goWzEsMCwwXSksbm9ybWFscy5wdXNoKFsxLDAsMF0pLG5vcm1hbHMucHVzaChbMSwwLDBdKSxub3JtYWxzLnB1c2goWzEsMCwwXSkpOihwb3NpdGlvbnMucHVzaChbdHgsdHksMF0pLHBvc2l0aW9ucy5wdXNoKFt0eCtnYXBYLHR5LDBdKSxwb3NpdGlvbnMucHVzaChbdHgrZ2FwWCx0eStnYXBZLDBdKSxwb3NpdGlvbnMucHVzaChbdHgsdHkrZ2FwWSwwXSksY29vcmRzLnB1c2goW3Usdl0pLGNvb3Jkcy5wdXNoKFt1K2dhcFVWLHZdKSxjb29yZHMucHVzaChbdStnYXBVVix2K2dhcFVWXSksY29vcmRzLnB1c2goW3UsditnYXBVVl0pLG5vcm1hbHMucHVzaChbMCwwLDFdKSxub3JtYWxzLnB1c2goWzAsMCwxXSksbm9ybWFscy5wdXNoKFswLDAsMV0pLG5vcm1hbHMucHVzaChbMCwwLDFdKSksaW5kaWNlcy5wdXNoKDQqaW5kZXgrMCksaW5kaWNlcy5wdXNoKDQqaW5kZXgrMSksaW5kaWNlcy5wdXNoKDQqaW5kZXgrMiksaW5kaWNlcy5wdXNoKDQqaW5kZXgrMCksaW5kaWNlcy5wdXNoKDQqaW5kZXgrMiksaW5kaWNlcy5wdXNoKDQqaW5kZXgrMyksaW5kZXgrK312YXIgbWVzaD1uZXcgX01lc2gyLmRlZmF1bHQoZHJhd1R5cGUpO3JldHVybiBtZXNoLmJ1ZmZlclZlcnRleChwb3NpdGlvbnMpLG1lc2guYnVmZmVyVGV4Q29vcmQoY29vcmRzKSxtZXNoLmJ1ZmZlckluZGV4KGluZGljZXMpLG1lc2guYnVmZmVyTm9ybWFsKG5vcm1hbHMpLG1lc2h9LEdlb20uc3BoZXJlPWZ1bmN0aW9uKHNpemUsbnVtU2VnbWVudHMpe2Z1bmN0aW9uIGdldFBvc2l0aW9uKGksail7dmFyIGlzTm9ybWFsPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl0scng9aS9udW1TZWdtZW50cypNYXRoLlBJLS41Kk1hdGguUEkscnk9ai9udW1TZWdtZW50cypNYXRoLlBJKjIscj1pc05vcm1hbD8xOnNpemUscG9zPVtdO3Bvc1sxXT1NYXRoLnNpbihyeCkqcjt2YXIgdD1NYXRoLmNvcyhyeCkqcjtwb3NbMF09TWF0aC5jb3MocnkpKnQscG9zWzJdPU1hdGguc2luKHJ5KSp0O3JldHVybiBwb3NbMF09TWF0aC5mbG9vcigxZTQqcG9zWzBdKS8xZTQscG9zWzFdPU1hdGguZmxvb3IoMWU0KnBvc1sxXSkvMWU0LHBvc1syXT1NYXRoLmZsb29yKDFlNCpwb3NbMl0pLzFlNCxwb3N9Zm9yKHZhciBpc0ludmVydD1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdLGRyYXdUeXBlPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTo0LHBvc2l0aW9ucz1bXSxjb29yZHM9W10saW5kaWNlcz1bXSxub3JtYWxzPVtdLGdhcFVWPTEvbnVtU2VnbWVudHMsaW5kZXg9MCxpPTA7aTxudW1TZWdtZW50cztpKyspZm9yKHZhciBqPTA7ajxudW1TZWdtZW50cztqKyspe3Bvc2l0aW9ucy5wdXNoKGdldFBvc2l0aW9uKGksaikpLHBvc2l0aW9ucy5wdXNoKGdldFBvc2l0aW9uKGkrMSxqKSkscG9zaXRpb25zLnB1c2goZ2V0UG9zaXRpb24oaSsxLGorMSkpLHBvc2l0aW9ucy5wdXNoKGdldFBvc2l0aW9uKGksaisxKSksbm9ybWFscy5wdXNoKGdldFBvc2l0aW9uKGksaiwhMCkpLG5vcm1hbHMucHVzaChnZXRQb3NpdGlvbihpKzEsaiwhMCkpLG5vcm1hbHMucHVzaChnZXRQb3NpdGlvbihpKzEsaisxLCEwKSksbm9ybWFscy5wdXNoKGdldFBvc2l0aW9uKGksaisxLCEwKSk7dmFyIHU9ai9udW1TZWdtZW50cyx2PWkvbnVtU2VnbWVudHM7Y29vcmRzLnB1c2goWzEtdSx2XSksY29vcmRzLnB1c2goWzEtdSx2K2dhcFVWXSksY29vcmRzLnB1c2goWzEtdS1nYXBVVix2K2dhcFVWXSksY29vcmRzLnB1c2goWzEtdS1nYXBVVix2XSksaW5kaWNlcy5wdXNoKDQqaW5kZXgrMCksaW5kaWNlcy5wdXNoKDQqaW5kZXgrMSksaW5kaWNlcy5wdXNoKDQqaW5kZXgrMiksaW5kaWNlcy5wdXNoKDQqaW5kZXgrMCksaW5kaWNlcy5wdXNoKDQqaW5kZXgrMiksaW5kaWNlcy5wdXNoKDQqaW5kZXgrMyksaW5kZXgrK31pc0ludmVydCYmaW5kaWNlcy5yZXZlcnNlKCk7dmFyIG1lc2g9bmV3IF9NZXNoMi5kZWZhdWx0KGRyYXdUeXBlKTtyZXR1cm4gbWVzaC5idWZmZXJWZXJ0ZXgocG9zaXRpb25zKSxtZXNoLmJ1ZmZlclRleENvb3JkKGNvb3JkcyksbWVzaC5idWZmZXJJbmRleChpbmRpY2VzKSxtZXNoLmJ1ZmZlck5vcm1hbChub3JtYWxzKSxtZXNofSxHZW9tLmN1YmU9ZnVuY3Rpb24odyxoLGQpe3ZhciBkcmF3VHlwZT1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106NDtoPWh8fHcsZD1kfHx3O3ZhciB4PXcvMix5PWgvMix6PWQvMixwb3NpdGlvbnM9W10sY29vcmRzPVtdLGluZGljZXM9W10sbm9ybWFscz1bXSxjb3VudD0wO3Bvc2l0aW9ucy5wdXNoKFsteCx5LC16XSkscG9zaXRpb25zLnB1c2goW3gseSwtel0pLHBvc2l0aW9ucy5wdXNoKFt4LC15LC16XSkscG9zaXRpb25zLnB1c2goWy14LC15LC16XSksbm9ybWFscy5wdXNoKFswLDAsLTFdKSxub3JtYWxzLnB1c2goWzAsMCwtMV0pLG5vcm1hbHMucHVzaChbMCwwLC0xXSksbm9ybWFscy5wdXNoKFswLDAsLTFdKSxjb29yZHMucHVzaChbMCwwXSksY29vcmRzLnB1c2goWzEsMF0pLGNvb3Jkcy5wdXNoKFsxLDFdKSxjb29yZHMucHVzaChbMCwxXSksaW5kaWNlcy5wdXNoKDQqY291bnQrMCksaW5kaWNlcy5wdXNoKDQqY291bnQrMSksaW5kaWNlcy5wdXNoKDQqY291bnQrMiksaW5kaWNlcy5wdXNoKDQqY291bnQrMCksaW5kaWNlcy5wdXNoKDQqY291bnQrMiksaW5kaWNlcy5wdXNoKDQqY291bnQrMyksY291bnQrKyxwb3NpdGlvbnMucHVzaChbeCx5LC16XSkscG9zaXRpb25zLnB1c2goW3gseSx6XSkscG9zaXRpb25zLnB1c2goW3gsLXksel0pLHBvc2l0aW9ucy5wdXNoKFt4LC15LC16XSksbm9ybWFscy5wdXNoKFsxLDAsMF0pLG5vcm1hbHMucHVzaChbMSwwLDBdKSxub3JtYWxzLnB1c2goWzEsMCwwXSksbm9ybWFscy5wdXNoKFsxLDAsMF0pLGNvb3Jkcy5wdXNoKFswLDBdKSxjb29yZHMucHVzaChbMSwwXSksY29vcmRzLnB1c2goWzEsMV0pLGNvb3Jkcy5wdXNoKFswLDFdKSxpbmRpY2VzLnB1c2goNCpjb3VudCswKSxpbmRpY2VzLnB1c2goNCpjb3VudCsxKSxpbmRpY2VzLnB1c2goNCpjb3VudCsyKSxpbmRpY2VzLnB1c2goNCpjb3VudCswKSxpbmRpY2VzLnB1c2goNCpjb3VudCsyKSxpbmRpY2VzLnB1c2goNCpjb3VudCszKSxjb3VudCsrLHBvc2l0aW9ucy5wdXNoKFt4LHksel0pLHBvc2l0aW9ucy5wdXNoKFsteCx5LHpdKSxwb3NpdGlvbnMucHVzaChbLXgsLXksel0pLHBvc2l0aW9ucy5wdXNoKFt4LC15LHpdKSxub3JtYWxzLnB1c2goWzAsMCwxXSksbm9ybWFscy5wdXNoKFswLDAsMV0pLG5vcm1hbHMucHVzaChbMCwwLDFdKSxub3JtYWxzLnB1c2goWzAsMCwxXSksY29vcmRzLnB1c2goWzAsMF0pLGNvb3Jkcy5wdXNoKFsxLDBdKSxjb29yZHMucHVzaChbMSwxXSksY29vcmRzLnB1c2goWzAsMV0pLGluZGljZXMucHVzaCg0KmNvdW50KzApLGluZGljZXMucHVzaCg0KmNvdW50KzEpLGluZGljZXMucHVzaCg0KmNvdW50KzIpLGluZGljZXMucHVzaCg0KmNvdW50KzApLGluZGljZXMucHVzaCg0KmNvdW50KzIpLGluZGljZXMucHVzaCg0KmNvdW50KzMpLGNvdW50KysscG9zaXRpb25zLnB1c2goWy14LHksel0pLHBvc2l0aW9ucy5wdXNoKFsteCx5LC16XSkscG9zaXRpb25zLnB1c2goWy14LC15LC16XSkscG9zaXRpb25zLnB1c2goWy14LC15LHpdKSxub3JtYWxzLnB1c2goWy0xLDAsMF0pLG5vcm1hbHMucHVzaChbLTEsMCwwXSksbm9ybWFscy5wdXNoKFstMSwwLDBdKSxub3JtYWxzLnB1c2goWy0xLDAsMF0pLGNvb3Jkcy5wdXNoKFswLDBdKSxjb29yZHMucHVzaChbMSwwXSksY29vcmRzLnB1c2goWzEsMV0pLGNvb3Jkcy5wdXNoKFswLDFdKSxpbmRpY2VzLnB1c2goNCpjb3VudCswKSxpbmRpY2VzLnB1c2goNCpjb3VudCsxKSxpbmRpY2VzLnB1c2goNCpjb3VudCsyKSxpbmRpY2VzLnB1c2goNCpjb3VudCswKSxpbmRpY2VzLnB1c2goNCpjb3VudCsyKSxpbmRpY2VzLnB1c2goNCpjb3VudCszKSxjb3VudCsrLHBvc2l0aW9ucy5wdXNoKFt4LHksLXpdKSxwb3NpdGlvbnMucHVzaChbLXgseSwtel0pLHBvc2l0aW9ucy5wdXNoKFsteCx5LHpdKSxwb3NpdGlvbnMucHVzaChbeCx5LHpdKSxub3JtYWxzLnB1c2goWzAsMSwwXSksbm9ybWFscy5wdXNoKFswLDEsMF0pLG5vcm1hbHMucHVzaChbMCwxLDBdKSxub3JtYWxzLnB1c2goWzAsMSwwXSksY29vcmRzLnB1c2goWzAsMF0pLGNvb3Jkcy5wdXNoKFsxLDBdKSxjb29yZHMucHVzaChbMSwxXSksY29vcmRzLnB1c2goWzAsMV0pLGluZGljZXMucHVzaCg0KmNvdW50KzApLGluZGljZXMucHVzaCg0KmNvdW50KzEpLGluZGljZXMucHVzaCg0KmNvdW50KzIpLGluZGljZXMucHVzaCg0KmNvdW50KzApLGluZGljZXMucHVzaCg0KmNvdW50KzIpLGluZGljZXMucHVzaCg0KmNvdW50KzMpLGNvdW50KysscG9zaXRpb25zLnB1c2goW3gsLXksel0pLHBvc2l0aW9ucy5wdXNoKFsteCwteSx6XSkscG9zaXRpb25zLnB1c2goWy14LC15LC16XSkscG9zaXRpb25zLnB1c2goW3gsLXksLXpdKSxub3JtYWxzLnB1c2goWzAsLTEsMF0pLG5vcm1hbHMucHVzaChbMCwtMSwwXSksbm9ybWFscy5wdXNoKFswLC0xLDBdKSxub3JtYWxzLnB1c2goWzAsLTEsMF0pLGNvb3Jkcy5wdXNoKFswLDBdKSxjb29yZHMucHVzaChbMSwwXSksY29vcmRzLnB1c2goWzEsMV0pLGNvb3Jkcy5wdXNoKFswLDFdKSxpbmRpY2VzLnB1c2goNCpjb3VudCswKSxpbmRpY2VzLnB1c2goNCpjb3VudCsxKSxpbmRpY2VzLnB1c2goNCpjb3VudCsyKSxpbmRpY2VzLnB1c2goNCpjb3VudCswKSxpbmRpY2VzLnB1c2goNCpjb3VudCsyKSxpbmRpY2VzLnB1c2goNCpjb3VudCszKSxjb3VudCsrO3ZhciBtZXNoPW5ldyBfTWVzaDIuZGVmYXVsdChkcmF3VHlwZSk7cmV0dXJuIG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyksbWVzaC5idWZmZXJUZXhDb29yZChjb29yZHMpLG1lc2guYnVmZmVySW5kZXgoaW5kaWNlcyksbWVzaC5idWZmZXJOb3JtYWwobm9ybWFscyksbWVzaH0sR2VvbS5za3lib3g9ZnVuY3Rpb24oc2l6ZSl7dmFyIGRyYXdUeXBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTo0LHBvc2l0aW9ucz1bXSxjb29yZHM9W10saW5kaWNlcz1bXSxub3JtYWxzPVtdLGNvdW50PTA7cG9zaXRpb25zLnB1c2goW3NpemUsc2l6ZSwtc2l6ZV0pLHBvc2l0aW9ucy5wdXNoKFstc2l6ZSxzaXplLC1zaXplXSkscG9zaXRpb25zLnB1c2goWy1zaXplLC1zaXplLC1zaXplXSkscG9zaXRpb25zLnB1c2goW3NpemUsLXNpemUsLXNpemVdKSxub3JtYWxzLnB1c2goWzAsMCwtMV0pLG5vcm1hbHMucHVzaChbMCwwLC0xXSksbm9ybWFscy5wdXNoKFswLDAsLTFdKSxub3JtYWxzLnB1c2goWzAsMCwtMV0pLGNvb3Jkcy5wdXNoKFswLDBdKSxjb29yZHMucHVzaChbMSwwXSksY29vcmRzLnB1c2goWzEsMV0pLGNvb3Jkcy5wdXNoKFswLDFdKSxpbmRpY2VzLnB1c2goNCpjb3VudCswKSxpbmRpY2VzLnB1c2goNCpjb3VudCsxKSxpbmRpY2VzLnB1c2goNCpjb3VudCsyKSxpbmRpY2VzLnB1c2goNCpjb3VudCswKSxpbmRpY2VzLnB1c2goNCpjb3VudCsyKSxpbmRpY2VzLnB1c2goNCpjb3VudCszKSxjb3VudCsrLHBvc2l0aW9ucy5wdXNoKFtzaXplLC1zaXplLC1zaXplXSkscG9zaXRpb25zLnB1c2goW3NpemUsLXNpemUsc2l6ZV0pLHBvc2l0aW9ucy5wdXNoKFtzaXplLHNpemUsc2l6ZV0pLHBvc2l0aW9ucy5wdXNoKFtzaXplLHNpemUsLXNpemVdKSxub3JtYWxzLnB1c2goWzEsMCwwXSksbm9ybWFscy5wdXNoKFsxLDAsMF0pLG5vcm1hbHMucHVzaChbMSwwLDBdKSxub3JtYWxzLnB1c2goWzEsMCwwXSksY29vcmRzLnB1c2goWzAsMF0pLGNvb3Jkcy5wdXNoKFsxLDBdKSxjb29yZHMucHVzaChbMSwxXSksY29vcmRzLnB1c2goWzAsMV0pLGluZGljZXMucHVzaCg0KmNvdW50KzApLGluZGljZXMucHVzaCg0KmNvdW50KzEpLGluZGljZXMucHVzaCg0KmNvdW50KzIpLGluZGljZXMucHVzaCg0KmNvdW50KzApLGluZGljZXMucHVzaCg0KmNvdW50KzIpLGluZGljZXMucHVzaCg0KmNvdW50KzMpLGNvdW50KysscG9zaXRpb25zLnB1c2goWy1zaXplLHNpemUsc2l6ZV0pLHBvc2l0aW9ucy5wdXNoKFtzaXplLHNpemUsc2l6ZV0pLHBvc2l0aW9ucy5wdXNoKFtzaXplLC1zaXplLHNpemVdKSxwb3NpdGlvbnMucHVzaChbLXNpemUsLXNpemUsc2l6ZV0pLG5vcm1hbHMucHVzaChbMCwwLDFdKSxub3JtYWxzLnB1c2goWzAsMCwxXSksbm9ybWFscy5wdXNoKFswLDAsMV0pLG5vcm1hbHMucHVzaChbMCwwLDFdKSxjb29yZHMucHVzaChbMCwwXSksY29vcmRzLnB1c2goWzEsMF0pLGNvb3Jkcy5wdXNoKFsxLDFdKSxjb29yZHMucHVzaChbMCwxXSksaW5kaWNlcy5wdXNoKDQqY291bnQrMCksaW5kaWNlcy5wdXNoKDQqY291bnQrMSksaW5kaWNlcy5wdXNoKDQqY291bnQrMiksaW5kaWNlcy5wdXNoKDQqY291bnQrMCksaW5kaWNlcy5wdXNoKDQqY291bnQrMiksaW5kaWNlcy5wdXNoKDQqY291bnQrMyksY291bnQrKyxwb3NpdGlvbnMucHVzaChbLXNpemUsLXNpemUsc2l6ZV0pLHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwtc2l6ZSwtc2l6ZV0pLHBvc2l0aW9ucy5wdXNoKFstc2l6ZSxzaXplLC1zaXplXSkscG9zaXRpb25zLnB1c2goWy1zaXplLHNpemUsc2l6ZV0pLG5vcm1hbHMucHVzaChbLTEsMCwwXSksbm9ybWFscy5wdXNoKFstMSwwLDBdKSxub3JtYWxzLnB1c2goWy0xLDAsMF0pLG5vcm1hbHMucHVzaChbLTEsMCwwXSksY29vcmRzLnB1c2goWzAsMF0pLGNvb3Jkcy5wdXNoKFsxLDBdKSxjb29yZHMucHVzaChbMSwxXSksY29vcmRzLnB1c2goWzAsMV0pLGluZGljZXMucHVzaCg0KmNvdW50KzApLGluZGljZXMucHVzaCg0KmNvdW50KzEpLGluZGljZXMucHVzaCg0KmNvdW50KzIpLGluZGljZXMucHVzaCg0KmNvdW50KzApLGluZGljZXMucHVzaCg0KmNvdW50KzIpLGluZGljZXMucHVzaCg0KmNvdW50KzMpLGNvdW50KysscG9zaXRpb25zLnB1c2goW3NpemUsc2l6ZSxzaXplXSkscG9zaXRpb25zLnB1c2goWy1zaXplLHNpemUsc2l6ZV0pLHBvc2l0aW9ucy5wdXNoKFstc2l6ZSxzaXplLC1zaXplXSkscG9zaXRpb25zLnB1c2goW3NpemUsc2l6ZSwtc2l6ZV0pLG5vcm1hbHMucHVzaChbMCwxLDBdKSxub3JtYWxzLnB1c2goWzAsMSwwXSksbm9ybWFscy5wdXNoKFswLDEsMF0pLG5vcm1hbHMucHVzaChbMCwxLDBdKSxjb29yZHMucHVzaChbMCwwXSksY29vcmRzLnB1c2goWzEsMF0pLGNvb3Jkcy5wdXNoKFsxLDFdKSxjb29yZHMucHVzaChbMCwxXSksaW5kaWNlcy5wdXNoKDQqY291bnQrMCksaW5kaWNlcy5wdXNoKDQqY291bnQrMSksaW5kaWNlcy5wdXNoKDQqY291bnQrMiksaW5kaWNlcy5wdXNoKDQqY291bnQrMCksaW5kaWNlcy5wdXNoKDQqY291bnQrMiksaW5kaWNlcy5wdXNoKDQqY291bnQrMyksY291bnQrKyxwb3NpdGlvbnMucHVzaChbc2l6ZSwtc2l6ZSwtc2l6ZV0pLHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwtc2l6ZSwtc2l6ZV0pLHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwtc2l6ZSxzaXplXSkscG9zaXRpb25zLnB1c2goW3NpemUsLXNpemUsc2l6ZV0pLG5vcm1hbHMucHVzaChbMCwtMSwwXSksbm9ybWFscy5wdXNoKFswLC0xLDBdKSxub3JtYWxzLnB1c2goWzAsLTEsMF0pLG5vcm1hbHMucHVzaChbMCwtMSwwXSksY29vcmRzLnB1c2goWzAsMF0pLGNvb3Jkcy5wdXNoKFsxLDBdKSxjb29yZHMucHVzaChbMSwxXSksY29vcmRzLnB1c2goWzAsMV0pLGluZGljZXMucHVzaCg0KmNvdW50KzApLGluZGljZXMucHVzaCg0KmNvdW50KzEpLGluZGljZXMucHVzaCg0KmNvdW50KzIpLGluZGljZXMucHVzaCg0KmNvdW50KzApLGluZGljZXMucHVzaCg0KmNvdW50KzIpLGluZGljZXMucHVzaCg0KmNvdW50KzMpO3ZhciBtZXNoPW5ldyBfTWVzaDIuZGVmYXVsdChkcmF3VHlwZSk7cmV0dXJuIG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyksbWVzaC5idWZmZXJUZXhDb29yZChjb29yZHMpLG1lc2guYnVmZmVySW5kZXgoaW5kaWNlcyksbWVzaC5idWZmZXJOb3JtYWwobm9ybWFscyksbWVzaH0sR2VvbS5iaWdUcmlhbmdsZT1mdW5jdGlvbigpe2lmKCFtZXNoVHJpKXt2YXIgaW5kaWNlcz1bMiwxLDBdLHBvc2l0aW9ucz1bWy0xLC0xXSxbLTEsNF0sWzQsLTFdXTttZXNoVHJpPW5ldyBfTWVzaDIuZGVmYXVsdCxtZXNoVHJpLmJ1ZmZlckRhdGEocG9zaXRpb25zLFwiYVBvc2l0aW9uXCIsMiksbWVzaFRyaS5idWZmZXJJbmRleChpbmRpY2VzKX1yZXR1cm4gbWVzaFRyaX0sZXhwb3J0cy5kZWZhdWx0PUdlb219LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO21vZHVsZS5leHBvcnRzPXswOlwiTk9ORVwiLDE6XCJPTkVcIiwyOlwiTElORV9MT09QXCIsMzpcIkxJTkVfU1RSSVBcIiw0OlwiVFJJQU5HTEVTXCIsNTpcIlRSSUFOR0xFX1NUUklQXCIsNjpcIlRSSUFOR0xFX0ZBTlwiLDI1NjpcIkRFUFRIX0JVRkZFUl9CSVRcIiw1MTI6XCJORVZFUlwiLDUxMzpcIkxFU1NcIiw1MTQ6XCJFUVVBTFwiLDUxNTpcIkxFUVVBTFwiLDUxNjpcIkdSRUFURVJcIiw1MTc6XCJOT1RFUVVBTFwiLDUxODpcIkdFUVVBTFwiLDUxOTpcIkFMV0FZU1wiLDc2ODpcIlNSQ19DT0xPUlwiLDc2OTpcIk9ORV9NSU5VU19TUkNfQ09MT1JcIiw3NzA6XCJTUkNfQUxQSEFcIiw3NzE6XCJPTkVfTUlOVVNfU1JDX0FMUEhBXCIsNzcyOlwiRFNUX0FMUEhBXCIsNzczOlwiT05FX01JTlVTX0RTVF9BTFBIQVwiLDc3NDpcIkRTVF9DT0xPUlwiLDc3NTpcIk9ORV9NSU5VU19EU1RfQ09MT1JcIiw3NzY6XCJTUkNfQUxQSEFfU0FUVVJBVEVcIiwxMDI0OlwiU1RFTkNJTF9CVUZGRVJfQklUXCIsMTAyODpcIkZST05UXCIsMTAyOTpcIkJBQ0tcIiwxMDMyOlwiRlJPTlRfQU5EX0JBQ0tcIiwxMjgwOlwiSU5WQUxJRF9FTlVNXCIsMTI4MTpcIklOVkFMSURfVkFMVUVcIiwxMjgyOlwiSU5WQUxJRF9PUEVSQVRJT05cIiwxMjg1OlwiT1VUX09GX01FTU9SWVwiLDEyODY6XCJJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTlwiLDIzMDQ6XCJDV1wiLDIzMDU6XCJDQ1dcIiwyODQ5OlwiTElORV9XSURUSFwiLDI4ODQ6XCJDVUxMX0ZBQ0VcIiwyODg1OlwiQ1VMTF9GQUNFX01PREVcIiwyODg2OlwiRlJPTlRfRkFDRVwiLDI5Mjg6XCJERVBUSF9SQU5HRVwiLDI5Mjk6XCJERVBUSF9URVNUXCIsMjkzMDpcIkRFUFRIX1dSSVRFTUFTS1wiLDI5MzE6XCJERVBUSF9DTEVBUl9WQUxVRVwiLDI5MzI6XCJERVBUSF9GVU5DXCIsMjk2MDpcIlNURU5DSUxfVEVTVFwiLDI5NjE6XCJTVEVOQ0lMX0NMRUFSX1ZBTFVFXCIsMjk2MjpcIlNURU5DSUxfRlVOQ1wiLDI5NjM6XCJTVEVOQ0lMX1ZBTFVFX01BU0tcIiwyOTY0OlwiU1RFTkNJTF9GQUlMXCIsMjk2NTpcIlNURU5DSUxfUEFTU19ERVBUSF9GQUlMXCIsMjk2NjpcIlNURU5DSUxfUEFTU19ERVBUSF9QQVNTXCIsMjk2NzpcIlNURU5DSUxfUkVGXCIsMjk2ODpcIlNURU5DSUxfV1JJVEVNQVNLXCIsMjk3ODpcIlZJRVdQT1JUXCIsMzAyNDpcIkRJVEhFUlwiLDMwNDI6XCJCTEVORFwiLDMwODg6XCJTQ0lTU09SX0JPWFwiLDMwODk6XCJTQ0lTU09SX1RFU1RcIiwzMTA2OlwiQ09MT1JfQ0xFQVJfVkFMVUVcIiwzMTA3OlwiQ09MT1JfV1JJVEVNQVNLXCIsMzMxNzpcIlVOUEFDS19BTElHTk1FTlRcIiwzMzMzOlwiUEFDS19BTElHTk1FTlRcIiwzMzc5OlwiTUFYX1RFWFRVUkVfU0laRVwiLDMzODY6XCJNQVhfVklFV1BPUlRfRElNU1wiLDM0MDg6XCJTVUJQSVhFTF9CSVRTXCIsMzQxMDpcIlJFRF9CSVRTXCIsMzQxMTpcIkdSRUVOX0JJVFNcIiwzNDEyOlwiQkxVRV9CSVRTXCIsMzQxMzpcIkFMUEhBX0JJVFNcIiwzNDE0OlwiREVQVEhfQklUU1wiLDM0MTU6XCJTVEVOQ0lMX0JJVFNcIiwzNTUzOlwiVEVYVFVSRV8yRFwiLDQzNTI6XCJET05UX0NBUkVcIiw0MzUzOlwiRkFTVEVTVFwiLDQzNTQ6XCJOSUNFU1RcIiw1MTIwOlwiQllURVwiLDUxMjE6XCJVTlNJR05FRF9CWVRFXCIsNTEyMjpcIlNIT1JUXCIsNTEyMzpcIlVOU0lHTkVEX1NIT1JUXCIsNTEyNDpcIklOVFwiLDUxMjU6XCJVTlNJR05FRF9JTlRcIiw1MTI2OlwiRkxPQVRcIiw1Mzg2OlwiSU5WRVJUXCIsNTg5MDpcIlRFWFRVUkVcIiw2NDAxOlwiU1RFTkNJTF9JTkRFWFwiLDY0MDI6XCJERVBUSF9DT01QT05FTlRcIiw2NDAzOlwiUkVEXCIsNjQwNjpcIkFMUEhBXCIsNjQwNzpcIlJHQlwiLDY0MDg6XCJSR0JBXCIsNjQwOTpcIkxVTUlOQU5DRVwiLDY0MTA6XCJMVU1JTkFOQ0VfQUxQSEFcIiw3NjgwOlwiS0VFUFwiLDc2ODE6XCJSRVBMQUNFXCIsNzY4MjpcIklOQ1JcIiw3NjgzOlwiREVDUlwiLDc5MzY6XCJWRU5ET1JcIiw3OTM3OlwiUkVOREVSRVJcIiw3OTM4OlwiVkVSU0lPTlwiLDk3Mjg6XCJORUFSRVNUXCIsOTcyOTpcIkxJTkVBUlwiLDk5ODQ6XCJORUFSRVNUX01JUE1BUF9ORUFSRVNUXCIsOTk4NTpcIkxJTkVBUl9NSVBNQVBfTkVBUkVTVFwiLDk5ODY6XCJORUFSRVNUX01JUE1BUF9MSU5FQVJcIiw5OTg3OlwiTElORUFSX01JUE1BUF9MSU5FQVJcIiwxMDI0MDpcIlRFWFRVUkVfTUFHX0ZJTFRFUlwiLDEwMjQxOlwiVEVYVFVSRV9NSU5fRklMVEVSXCIsMTAyNDI6XCJURVhUVVJFX1dSQVBfU1wiLDEwMjQzOlwiVEVYVFVSRV9XUkFQX1RcIiwxMDQ5NzpcIlJFUEVBVFwiLDEwNzUyOlwiUE9MWUdPTl9PRkZTRVRfVU5JVFNcIiwxNjM4NDpcIkNPTE9SX0JVRkZFUl9CSVRcIiwzMjc2OTpcIkNPTlNUQU5UX0NPTE9SXCIsMzI3NzA6XCJPTkVfTUlOVVNfQ09OU1RBTlRfQ09MT1JcIiwzMjc3MTpcIkNPTlNUQU5UX0FMUEhBXCIsMzI3NzI6XCJPTkVfTUlOVVNfQ09OU1RBTlRfQUxQSEFcIiwzMjc3MzpcIkJMRU5EX0NPTE9SXCIsMzI3NzQ6XCJGVU5DX0FERFwiLDMyNzc3OlwiQkxFTkRfRVFVQVRJT05fUkdCXCIsMzI3Nzg6XCJGVU5DX1NVQlRSQUNUXCIsMzI3Nzk6XCJGVU5DX1JFVkVSU0VfU1VCVFJBQ1RcIiwzMjgxOTpcIlVOU0lHTkVEX1NIT1JUXzRfNF80XzRcIiwzMjgyMDpcIlVOU0lHTkVEX1NIT1JUXzVfNV81XzFcIiwzMjgyMzpcIlBPTFlHT05fT0ZGU0VUX0ZJTExcIiwzMjgyNDpcIlBPTFlHT05fT0ZGU0VUX0ZBQ1RPUlwiLDMyODU0OlwiUkdCQTRcIiwzMjg1NTpcIlJHQjVfQTFcIiwzMjg3MzpcIlRFWFRVUkVfQklORElOR18yRFwiLDMyOTI2OlwiU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFXCIsMzI5Mjg6XCJTQU1QTEVfQ09WRVJBR0VcIiwzMjkzNjpcIlNBTVBMRV9CVUZGRVJTXCIsMzI5Mzc6XCJTQU1QTEVTXCIsMzI5Mzg6XCJTQU1QTEVfQ09WRVJBR0VfVkFMVUVcIiwzMjkzOTpcIlNBTVBMRV9DT1ZFUkFHRV9JTlZFUlRcIiwzMjk2ODpcIkJMRU5EX0RTVF9SR0JcIiwzMjk2OTpcIkJMRU5EX1NSQ19SR0JcIiwzMjk3MDpcIkJMRU5EX0RTVF9BTFBIQVwiLDMyOTcxOlwiQkxFTkRfU1JDX0FMUEhBXCIsMzMwNzE6XCJDTEFNUF9UT19FREdFXCIsMzMxNzA6XCJHRU5FUkFURV9NSVBNQVBfSElOVFwiLDMzMTg5OlwiREVQVEhfQ09NUE9ORU5UMTZcIiwzMzMwNjpcIkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVFwiLDMzMzIxOlwiUjhcIiwzMzYzNTpcIlVOU0lHTkVEX1NIT1JUXzVfNl81XCIsMzM2NDg6XCJNSVJST1JFRF9SRVBFQVRcIiwzMzkwMTpcIkFMSUFTRURfUE9JTlRfU0laRV9SQU5HRVwiLDMzOTAyOlwiQUxJQVNFRF9MSU5FX1dJRFRIX1JBTkdFXCIsMzM5ODQ6XCJURVhUVVJFMFwiLDMzOTg1OlwiVEVYVFVSRTFcIiwzMzk4NjpcIlRFWFRVUkUyXCIsMzM5ODc6XCJURVhUVVJFM1wiLDMzOTg4OlwiVEVYVFVSRTRcIiwzMzk4OTpcIlRFWFRVUkU1XCIsMzM5OTA6XCJURVhUVVJFNlwiLDMzOTkxOlwiVEVYVFVSRTdcIiwzMzk5MjpcIlRFWFRVUkU4XCIsMzM5OTM6XCJURVhUVVJFOVwiLDMzOTk0OlwiVEVYVFVSRTEwXCIsMzM5OTU6XCJURVhUVVJFMTFcIiwzMzk5NjpcIlRFWFRVUkUxMlwiLDMzOTk3OlwiVEVYVFVSRTEzXCIsMzM5OTg6XCJURVhUVVJFMTRcIiwzMzk5OTpcIlRFWFRVUkUxNVwiLDM0ZTM6XCJURVhUVVJFMTZcIiwzNDAwMTpcIlRFWFRVUkUxN1wiLDM0MDAyOlwiVEVYVFVSRTE4XCIsMzQwMDM6XCJURVhUVVJFMTlcIiwzNDAwNDpcIlRFWFRVUkUyMFwiLDM0MDA1OlwiVEVYVFVSRTIxXCIsMzQwMDY6XCJURVhUVVJFMjJcIiwzNDAwNzpcIlRFWFRVUkUyM1wiLDM0MDA4OlwiVEVYVFVSRTI0XCIsMzQwMDk6XCJURVhUVVJFMjVcIiwzNDAxMDpcIlRFWFRVUkUyNlwiLDM0MDExOlwiVEVYVFVSRTI3XCIsMzQwMTI6XCJURVhUVVJFMjhcIiwzNDAxMzpcIlRFWFRVUkUyOVwiLDM0MDE0OlwiVEVYVFVSRTMwXCIsMzQwMTU6XCJURVhUVVJFMzFcIiwzNDAxNjpcIkFDVElWRV9URVhUVVJFXCIsMzQwMjQ6XCJNQVhfUkVOREVSQlVGRkVSX1NJWkVcIiwzNDA0MTpcIkRFUFRIX1NURU5DSUxcIiwzNDA1NTpcIklOQ1JfV1JBUFwiLDM0MDU2OlwiREVDUl9XUkFQXCIsMzQwNjc6XCJURVhUVVJFX0NVQkVfTUFQXCIsMzQwNjg6XCJURVhUVVJFX0JJTkRJTkdfQ1VCRV9NQVBcIiwzNDA2OTpcIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWFwiLDM0MDcwOlwiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YXCIsMzQwNzE6XCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1lcIiwzNDA3MjpcIlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWVwiLDM0MDczOlwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aXCIsMzQwNzQ6XCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1pcIiwzNDA3NjpcIk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkVcIiwzNDMzODpcIlZFUlRFWF9BVFRSSUJfQVJSQVlfRU5BQkxFRFwiLDM0MzM5OlwiVkVSVEVYX0FUVFJJQl9BUlJBWV9TSVpFXCIsMzQzNDA6XCJWRVJURVhfQVRUUklCX0FSUkFZX1NUUklERVwiLDM0MzQxOlwiVkVSVEVYX0FUVFJJQl9BUlJBWV9UWVBFXCIsMzQzNDI6XCJDVVJSRU5UX1ZFUlRFWF9BVFRSSUJcIiwzNDM3MzpcIlZFUlRFWF9BVFRSSUJfQVJSQVlfUE9JTlRFUlwiLDM0NDY2OlwiTlVNX0NPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTXCIsMzQ0Njc6XCJDT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUU1wiLDM0NjYwOlwiQlVGRkVSX1NJWkVcIiwzNDY2MTpcIkJVRkZFUl9VU0FHRVwiLDM0ODE2OlwiU1RFTkNJTF9CQUNLX0ZVTkNcIiwzNDgxNzpcIlNURU5DSUxfQkFDS19GQUlMXCIsMzQ4MTg6XCJTVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9GQUlMXCIsMzQ4MTk6XCJTVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9QQVNTXCIsMzQ4Nzc6XCJCTEVORF9FUVVBVElPTl9BTFBIQVwiLDM0OTIxOlwiTUFYX1ZFUlRFWF9BVFRSSUJTXCIsMzQ5MjI6XCJWRVJURVhfQVRUUklCX0FSUkFZX05PUk1BTElaRURcIiwzNDkzMDpcIk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTXCIsMzQ5NjI6XCJBUlJBWV9CVUZGRVJcIiwzNDk2MzpcIkVMRU1FTlRfQVJSQVlfQlVGRkVSXCIsMzQ5NjQ6XCJBUlJBWV9CVUZGRVJfQklORElOR1wiLDM0OTY1OlwiRUxFTUVOVF9BUlJBWV9CVUZGRVJfQklORElOR1wiLDM0OTc1OlwiVkVSVEVYX0FUVFJJQl9BUlJBWV9CVUZGRVJfQklORElOR1wiLDM1MDQwOlwiU1RSRUFNX0RSQVdcIiwzNTA0NDpcIlNUQVRJQ19EUkFXXCIsMzUwNDg6XCJEWU5BTUlDX0RSQVdcIiwzNTYzMjpcIkZSQUdNRU5UX1NIQURFUlwiLDM1NjMzOlwiVkVSVEVYX1NIQURFUlwiLDM1NjYwOlwiTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTXCIsMzU2NjE6XCJNQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUU1wiLDM1NjYzOlwiU0hBREVSX1RZUEVcIiwzNTY2NDpcIkZMT0FUX1ZFQzJcIiwzNTY2NTpcIkZMT0FUX1ZFQzNcIiwzNTY2NjpcIkZMT0FUX1ZFQzRcIiwzNTY2NzpcIklOVF9WRUMyXCIsMzU2Njg6XCJJTlRfVkVDM1wiLDM1NjY5OlwiSU5UX1ZFQzRcIiwzNTY3MDpcIkJPT0xcIiwzNTY3MTpcIkJPT0xfVkVDMlwiLDM1NjcyOlwiQk9PTF9WRUMzXCIsMzU2NzM6XCJCT09MX1ZFQzRcIiwzNTY3NDpcIkZMT0FUX01BVDJcIiwzNTY3NTpcIkZMT0FUX01BVDNcIiwzNTY3NjpcIkZMT0FUX01BVDRcIiwzNTY3ODpcIlNBTVBMRVJfMkRcIiwzNTY4MDpcIlNBTVBMRVJfQ1VCRVwiLDM1NzEyOlwiREVMRVRFX1NUQVRVU1wiLDM1NzEzOlwiQ09NUElMRV9TVEFUVVNcIiwzNTcxNDpcIkxJTktfU1RBVFVTXCIsMzU3MTU6XCJWQUxJREFURV9TVEFUVVNcIiwzNTcxNjpcIklORk9fTE9HX0xFTkdUSFwiLDM1NzE3OlwiQVRUQUNIRURfU0hBREVSU1wiLDM1NzE4OlwiQUNUSVZFX1VOSUZPUk1TXCIsMzU3MTk6XCJBQ1RJVkVfVU5JRk9STV9NQVhfTEVOR1RIXCIsMzU3MjA6XCJTSEFERVJfU09VUkNFX0xFTkdUSFwiLDM1NzIxOlwiQUNUSVZFX0FUVFJJQlVURVNcIiwzNTcyMjpcIkFDVElWRV9BVFRSSUJVVEVfTUFYX0xFTkdUSFwiLDM1NzI0OlwiU0hBRElOR19MQU5HVUFHRV9WRVJTSU9OXCIsMzU3MjU6XCJDVVJSRU5UX1BST0dSQU1cIiwzNjAwMzpcIlNURU5DSUxfQkFDS19SRUZcIiwzNjAwNDpcIlNURU5DSUxfQkFDS19WQUxVRV9NQVNLXCIsMzYwMDU6XCJTVEVOQ0lMX0JBQ0tfV1JJVEVNQVNLXCIsMzYwMDY6XCJGUkFNRUJVRkZFUl9CSU5ESU5HXCIsMzYwMDc6XCJSRU5ERVJCVUZGRVJfQklORElOR1wiLDM2MDQ4OlwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9PQkpFQ1RfVFlQRVwiLDM2MDQ5OlwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9PQkpFQ1RfTkFNRVwiLDM2MDUwOlwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0xFVkVMXCIsMzYwNTE6XCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfQ1VCRV9NQVBfRkFDRVwiLDM2MDUzOlwiRlJBTUVCVUZGRVJfQ09NUExFVEVcIiwzNjA1NDpcIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVFwiLDM2MDU1OlwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlRcIiwzNjA1NzpcIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OU1wiLDM2MDYxOlwiRlJBTUVCVUZGRVJfVU5TVVBQT1JURURcIiwzNjA2NDpcIkNPTE9SX0FUVEFDSE1FTlQwXCIsMzYwOTY6XCJERVBUSF9BVFRBQ0hNRU5UXCIsMzYxMjg6XCJTVEVOQ0lMX0FUVEFDSE1FTlRcIiwzNjE2MDpcIkZSQU1FQlVGRkVSXCIsMzYxNjE6XCJSRU5ERVJCVUZGRVJcIiwzNjE2MjpcIlJFTkRFUkJVRkZFUl9XSURUSFwiLDM2MTYzOlwiUkVOREVSQlVGRkVSX0hFSUdIVFwiLDM2MTY0OlwiUkVOREVSQlVGRkVSX0lOVEVSTkFMX0ZPUk1BVFwiLDM2MTY4OlwiU1RFTkNJTF9JTkRFWDhcIiwzNjE3NjpcIlJFTkRFUkJVRkZFUl9SRURfU0laRVwiLDM2MTc3OlwiUkVOREVSQlVGRkVSX0dSRUVOX1NJWkVcIiwzNjE3ODpcIlJFTkRFUkJVRkZFUl9CTFVFX1NJWkVcIiwzNjE3OTpcIlJFTkRFUkJVRkZFUl9BTFBIQV9TSVpFXCIsMzYxODA6XCJSRU5ERVJCVUZGRVJfREVQVEhfU0laRVwiLDM2MTgxOlwiUkVOREVSQlVGRkVSX1NURU5DSUxfU0laRVwiLDM2MTk0OlwiUkdCNTY1XCIsMzYzMzY6XCJMT1dfRkxPQVRcIiwzNjMzNzpcIk1FRElVTV9GTE9BVFwiLDM2MzM4OlwiSElHSF9GTE9BVFwiLDM2MzM5OlwiTE9XX0lOVFwiLDM2MzQwOlwiTUVESVVNX0lOVFwiLDM2MzQxOlwiSElHSF9JTlRcIiwzNjM0NjpcIlNIQURFUl9DT01QSUxFUlwiLDM2MzQ3OlwiTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlNcIiwzNjM0ODpcIk1BWF9WQVJZSU5HX1ZFQ1RPUlNcIiwzNjM0OTpcIk1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlNcIiwzNzQ0MDpcIlVOUEFDS19GTElQX1lfV0VCR0xcIiwzNzQ0MTpcIlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTFwiLDM3NDQyOlwiQ09OVEVYVF9MT1NUX1dFQkdMXCIsMzc0NDM6XCJVTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMXCIsMzc0NDQ6XCJCUk9XU0VSX0RFRkFVTFRfV0VCR0xcIn19LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ITEsZGVzY3JpcHRvci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvciYmKGRlc2NyaXB0b3Iud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcil9fXJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtyZXR1cm4gcHJvdG9Qcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyksc3RhdGljUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpLENvbnN0cnVjdG9yfX0oKSxfR0xTaGFkZXI9X193ZWJwYWNrX3JlcXVpcmVfXygyKSxfR0xTaGFkZXIyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dMU2hhZGVyKSxfRnJhbWVCdWZmZXI9X193ZWJwYWNrX3JlcXVpcmVfXygxMiksX0ZyYW1lQnVmZmVyMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GcmFtZUJ1ZmZlciksX1NoYWRlckxpYnM9X193ZWJwYWNrX3JlcXVpcmVfXygzMiksX1NoYWRlckxpYnMyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NoYWRlckxpYnMpLFBhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBQYXNzKG1Tb3VyY2Upe3ZhciBtV2lkdGg9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjAsbUhlaWdodD1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06MDthcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXSYmYXJndW1lbnRzWzNdO19jbGFzc0NhbGxDaGVjayh0aGlzLFBhc3MpLHRoaXMuc2hhZGVyPW5ldyBfR0xTaGFkZXIyLmRlZmF1bHQoX1NoYWRlckxpYnMyLmRlZmF1bHQuYmlnVHJpYW5nbGVWZXJ0LG1Tb3VyY2UpLHRoaXMuX3dpZHRoPW1XaWR0aCx0aGlzLl9oZWlnaHQ9bUhlaWdodCx0aGlzLl91bmlmb3Jtcz17fSx0aGlzLl9oYXNPd25GYm89dGhpcy5fd2lkdGg+MCYmdGhpcy5fd2lkdGg+MCx0aGlzLl91bmlmb3Jtcz17fSx0aGlzLl9oYXNPd25GYm8mJih0aGlzLl9mYm89bmV3IF9GcmFtZUJ1ZmZlcjIuZGVmYXVsdCh0aGlzLl93aWR0aCx0aGlzLmhlaWdodCxtUGFybWFzKSl9cmV0dXJuIF9jcmVhdGVDbGFzcyhQYXNzLFt7a2V5OlwidW5pZm9ybVwiLHZhbHVlOmZ1bmN0aW9uKG1OYW1lLG1WYWx1ZSl7dGhpcy5fdW5pZm9ybXNbbU5hbWVdPW1WYWx1ZX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbih0ZXh0dXJlKXt0aGlzLnNoYWRlci5iaW5kKCksdGhpcy5zaGFkZXIudW5pZm9ybShcInRleHR1cmVcIixcInVuaWZvcm0xaVwiLDApLHRleHR1cmUuYmluZCgwKSx0aGlzLnNoYWRlci51bmlmb3JtKHRoaXMuX3VuaWZvcm1zKX19LHtrZXk6XCJ3aWR0aFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl93aWR0aH19LHtrZXk6XCJoZWlnaHRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGVpZ2h0fX0se2tleTpcImZib1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9mYm99fSx7a2V5OlwiaGFzRmJvXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc093bkZib319XSksUGFzc30oKTtleHBvcnRzLmRlZmF1bHQ9UGFzc30sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPVwiLy8gc2ltcGxlQ29sb3IuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgU0lNUExFX0NPTE9SXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHZlYzMgY29sb3I7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIG9wYWNpdHkpO1xcbn1cIn0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPVwiLy8gYmFzaWMudmVydFxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgQkFTSUNfVkVSVEVYXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzMgYU5vcm1hbDtcXG5cXG51bmlmb3JtIG1hdDQgdU1vZGVsTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1Vmlld01hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVWaWV3TWF0cml4ICogdU1vZGVsTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24sIDEuMCk7XFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcbiAgICB2Tm9ybWFsID0gYU5vcm1hbDtcXG59XCJ9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ITEsZGVzY3JpcHRvci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvciYmKGRlc2NyaXB0b3Iud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcil9fXJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtyZXR1cm4gcHJvdG9Qcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyksc3RhdGljUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpLENvbnN0cnVjdG9yfX0oKSxfR0xUb29sPV9fd2VicGFja19yZXF1aXJlX18oMCksX0dMVG9vbDI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR0xUb29sKSxfR0xUZXh0dXJlPV9fd2VicGFja19yZXF1aXJlX18oMjYpLF9HTFRleHR1cmUyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dMVGV4dHVyZSksX1dlYmdsTnVtYmVyPV9fd2VicGFja19yZXF1aXJlX18oOCksX1dlYmdsTnVtYmVyMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9XZWJnbE51bWJlciksZ2w9dm9pZCAwLHdlYmdsRGVwdGhUZXh0dXJlPXZvaWQgMCxoYXNDaGVja2VkTXVsdGlSZW5kZXJTdXBwb3J0PSExLGV4dERyYXdCdWZmZXI9dm9pZCAwLGNoZWNrTXVsdGlSZW5kZXI9ZnVuY3Rpb24oKXtyZXR1cm4hIV9HTFRvb2wyLmRlZmF1bHQud2ViZ2wyfHwhIShleHREcmF3QnVmZmVyPV9HTFRvb2wyLmRlZmF1bHQuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfZHJhd19idWZmZXJzXCIpKX0sRnJhbWVCdWZmZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBGcmFtZUJ1ZmZlcihtV2lkdGgsbUhlaWdodCl7dmFyIG1QYXJhbWV0ZXJzPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp7fSxtTnVtVGFyZ2V0cz1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106MTtfY2xhc3NDYWxsQ2hlY2sodGhpcyxGcmFtZUJ1ZmZlciksZ2w9X0dMVG9vbDIuZGVmYXVsdC5nbCx3ZWJnbERlcHRoVGV4dHVyZT1fR0xUb29sMi5kZWZhdWx0LmNoZWNrRXh0ZW5zaW9uKFwiV0VCR0xfZGVwdGhfdGV4dHVyZVwiKSx0aGlzLndpZHRoPW1XaWR0aCx0aGlzLmhlaWdodD1tSGVpZ2h0LHRoaXMuX251bVRhcmdldHM9bU51bVRhcmdldHMsdGhpcy5fbXVsdGlwbGVUYXJnZXRzPW1OdW1UYXJnZXRzPjEsdGhpcy5fcGFyYW1ldGVycz1tUGFyYW1ldGVycyxoYXNDaGVja2VkTXVsdGlSZW5kZXJTdXBwb3J0fHxjaGVja011bHRpUmVuZGVyKCksdGhpcy5fbXVsdGlwbGVUYXJnZXRzJiZ0aGlzLl9jaGVja01heE51bVJlbmRlclRhcmdldCgpLHRoaXMuX2luaXQoKX1yZXR1cm4gX2NyZWF0ZUNsYXNzKEZyYW1lQnVmZmVyLFt7a2V5OlwiX2luaXRcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMuX2luaXRUZXh0dXJlcygpLHRoaXMuZnJhbWVCdWZmZXI9Z2wuY3JlYXRlRnJhbWVidWZmZXIoKSxnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsdGhpcy5mcmFtZUJ1ZmZlciksX0dMVG9vbDIuZGVmYXVsdC53ZWJnbDIpe2Zvcih2YXIgYnVmZmVycz1bXSxpPTA7aTx0aGlzLl9udW1UYXJnZXRzO2krKylnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5EUkFXX0ZSQU1FQlVGRkVSLGdsLkNPTE9SX0FUVEFDSE1FTlQwK2ksZ2wuVEVYVFVSRV8yRCx0aGlzLl90ZXh0dXJlc1tpXS50ZXh0dXJlLDApLGJ1ZmZlcnMucHVzaChnbFtcIkNPTE9SX0FUVEFDSE1FTlRcIitpXSk7Z2wuZHJhd0J1ZmZlcnMoYnVmZmVycyksZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRFJBV19GUkFNRUJVRkZFUixnbC5ERVBUSF9BVFRBQ0hNRU5ULGdsLlRFWFRVUkVfMkQsdGhpcy5nbERlcHRoVGV4dHVyZS50ZXh0dXJlLDApfWVsc2V7Zm9yKHZhciBfaT0wO19pPHRoaXMuX251bVRhcmdldHM7X2krKylnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUixnbC5DT0xPUl9BVFRBQ0hNRU5UMCtfaSxnbC5URVhUVVJFXzJELHRoaXMuX3RleHR1cmVzW19pXS50ZXh0dXJlLDApO2lmKHRoaXMuX211bHRpcGxlVGFyZ2V0cyl7Zm9yKHZhciBkcmF3QnVmZmVycz1bXSxfaTI9MDtfaTI8dGhpcy5fbnVtVGFyZ2V0cztfaTIrKylkcmF3QnVmZmVycy5wdXNoKGV4dERyYXdCdWZmZXJbXCJDT0xPUl9BVFRBQ0hNRU5UXCIrX2kyK1wiX1dFQkdMXCJdKTtleHREcmF3QnVmZmVyLmRyYXdCdWZmZXJzV0VCR0woZHJhd0J1ZmZlcnMpfXdlYmdsRGVwdGhUZXh0dXJlJiZnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUixnbC5ERVBUSF9BVFRBQ0hNRU5ULGdsLlRFWFRVUkVfMkQsdGhpcy5nbERlcHRoVGV4dHVyZS50ZXh0dXJlLDApfXZhciBGQk9zdGF0dXM9Z2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUik7RkJPc3RhdHVzIT1nbC5GUkFNRUJVRkZFUl9DT01QTEVURSYmY29uc29sZS5lcnJvcihcIkdMX0ZSQU1FQlVGRkVSX0NPTVBMRVRFIGZhaWxlZCwgQ0FOTk9UIHVzZSBGcmFtZWJ1ZmZlclwiLF9XZWJnbE51bWJlcjIuZGVmYXVsdFtGQk9zdGF0dXNdKSxnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELG51bGwpLGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLG51bGwpLGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUixudWxsKSx0aGlzLmNsZWFyKCl9fSx7a2V5OlwiX2NoZWNrTWF4TnVtUmVuZGVyVGFyZ2V0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgbWF4TnVtRHJhd0J1ZmZlcnM9X0dMVG9vbDIuZGVmYXVsdC5nbC5nZXRQYXJhbWV0ZXIoZXh0RHJhd0J1ZmZlci5NQVhfRFJBV19CVUZGRVJTX1dFQkdMKTt0aGlzLl9udW1UYXJnZXRzPm1heE51bURyYXdCdWZmZXJzJiYoY29uc29sZS5lcnJvcihcIk92ZXIgbWF4IG51bWJlciBvZiBkcmF3IGJ1ZmZlcnMgc3VwcG9ydGVkIDogXCIsbWF4TnVtRHJhd0J1ZmZlcnMpLHRoaXMuX251bVRhcmdldHM9bWF4TnVtRHJhd0J1ZmZlcnMpfX0se2tleTpcIl9pbml0VGV4dHVyZXNcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3RleHR1cmVzPVtdO2Zvcih2YXIgaT0wO2k8dGhpcy5fbnVtVGFyZ2V0cztpKyspe3ZhciBnbHQ9dGhpcy5fY3JlYXRlVGV4dHVyZSgpO3RoaXMuX3RleHR1cmVzLnB1c2goZ2x0KX1fR0xUb29sMi5kZWZhdWx0LndlYmdsMj90aGlzLmdsRGVwdGhUZXh0dXJlPXRoaXMuX2NyZWF0ZVRleHR1cmUoZ2wuREVQVEhfQ09NUE9ORU5UMTYsZ2wuVU5TSUdORURfU0hPUlQsZ2wuREVQVEhfQ09NUE9ORU5ULCEwKTp0aGlzLmdsRGVwdGhUZXh0dXJlPXRoaXMuX2NyZWF0ZVRleHR1cmUoZ2wuREVQVEhfQ09NUE9ORU5ULGdsLlVOU0lHTkVEX1NIT1JULGdsLkRFUFRIX0NPTVBPTkVOVCx7bWluRmlsdGVyOl9HTFRvb2wyLmRlZmF1bHQuTElORUFSfSl9fSx7a2V5OlwiX2NyZWF0ZVRleHR1cmVcIix2YWx1ZTpmdW5jdGlvbihtSW50ZXJuYWxmb3JtYXQsbVRleGVsVHlwZSxtRm9ybWF0KXt2YXIgbVBhcmFtZXRlcnM9YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOnt9LHBhcmFtZXRlcnM9T2JqZWN0LmFzc2lnbih7fSx0aGlzLl9wYXJhbWV0ZXJzKTttRm9ybWF0fHwobUZvcm1hdD1tSW50ZXJuYWxmb3JtYXQpLHBhcmFtZXRlcnMuaW50ZXJuYWxGb3JtYXQ9bUludGVybmFsZm9ybWF0fHxnbC5SR0JBLHBhcmFtZXRlcnMuZm9ybWF0PW1Gb3JtYXQscGFyYW1ldGVycy50eXBlPW1UZXhlbFR5cGV8fHBhcmFtZXRlcnMudHlwZXx8X0dMVG9vbDIuZGVmYXVsdC5VTlNJR05FRF9CWVRFO2Zvcih2YXIgcyBpbiBtUGFyYW1ldGVycylwYXJhbWV0ZXJzW3NdPW1QYXJhbWV0ZXJzW3NdO3JldHVybiBuZXcgX0dMVGV4dHVyZTIuZGVmYXVsdChudWxsLHBhcmFtZXRlcnMsdGhpcy53aWR0aCx0aGlzLmhlaWdodCl9fSx7a2V5OlwiYmluZFwiLHZhbHVlOmZ1bmN0aW9uKCl7KCEoYXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0pfHxhcmd1bWVudHNbMF0pJiZfR0xUb29sMi5kZWZhdWx0LnZpZXdwb3J0KDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsdGhpcy5mcmFtZUJ1ZmZlcil9fSx7a2V5OlwidW5iaW5kXCIsdmFsdWU6ZnVuY3Rpb24oKXsoIShhcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSl8fGFyZ3VtZW50c1swXSkmJl9HTFRvb2wyLmRlZmF1bHQudmlld3BvcnQoMCwwLF9HTFRvb2wyLmRlZmF1bHQud2lkdGgsX0dMVG9vbDIuZGVmYXVsdC5oZWlnaHQpLGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUixudWxsKSx0aGlzLl90ZXh0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKHRleHR1cmUpe3RleHR1cmUuZ2VuZXJhdGVNaXBtYXAoKX0pfX0se2tleTpcImNsZWFyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MCxnPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTowLGI9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOjAsYT1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106MDt0aGlzLmJpbmQoKSxfR0xUb29sMi5kZWZhdWx0LmNsZWFyKHIsZyxiLGEpLHRoaXMudW5iaW5kKCl9fSx7a2V5OlwiZ2V0VGV4dHVyZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIG1JbmRleD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MDtyZXR1cm4gdGhpcy5fdGV4dHVyZXNbbUluZGV4XX19LHtrZXk6XCJnZXREZXB0aFRleHR1cmVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdsRGVwdGhUZXh0dXJlfX0se2tleTpcInNob3dQYXJhbWV0ZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl90ZXh0dXJlc1swXS5zaG93UGFyYW1ldGVycygpfX0se2tleTpcIm1pbkZpbHRlclwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl90ZXh0dXJlc1swXS5taW5GaWx0ZXJ9LHNldDpmdW5jdGlvbihtVmFsdWUpe3RoaXMuX3RleHR1cmVzLmZvckVhY2goZnVuY3Rpb24odGV4dHVyZSl7dGV4dHVyZS5taW5GaWx0ZXI9bVZhbHVlfSl9fSx7a2V5OlwibWFnRmlsdGVyXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RleHR1cmVzWzBdLm1hZ0ZpbHRlcn0sc2V0OmZ1bmN0aW9uKG1WYWx1ZSl7dGhpcy5fdGV4dHVyZXMuZm9yRWFjaChmdW5jdGlvbih0ZXh0dXJlKXt0ZXh0dXJlLm1hZ0ZpbHRlcj1tVmFsdWV9KX19LHtrZXk6XCJ3cmFwU1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl90ZXh0dXJlc1swXS53cmFwU30sc2V0OmZ1bmN0aW9uKG1WYWx1ZSl7dGhpcy5fdGV4dHVyZXMuZm9yRWFjaChmdW5jdGlvbih0ZXh0dXJlKXt0ZXh0dXJlLndyYXBTPW1WYWx1ZX0pfX0se2tleTpcIndyYXBUXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RleHR1cmVzWzBdLndyYXBUfSxzZXQ6ZnVuY3Rpb24obVZhbHVlKXt0aGlzLl90ZXh0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKHRleHR1cmUpe3RleHR1cmUud3JhcFQ9bVZhbHVlfSl9fSx7a2V5OlwibnVtVGFyZ2V0c1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9udW1UYXJnZXRzfX1dKSxGcmFtZUJ1ZmZlcn0oKTtleHBvcnRzLmRlZmF1bHQ9RnJhbWVCdWZmZXJ9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSxDb25zdHJ1Y3Rvcil7aWYoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHwhMSxkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBkZXNjcmlwdG9yJiYoZGVzY3JpcHRvci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCxkZXNjcmlwdG9yLmtleSxkZXNjcmlwdG9yKX19cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe3JldHVybiBwcm90b1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKSxzdGF0aWNQcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyksQ29uc3RydWN0b3J9fSgpLF9zY2hlZHVsaW5nPV9fd2VicGFja19yZXF1aXJlX18oNiksX3NjaGVkdWxpbmcyPWZ1bmN0aW9uKG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntkZWZhdWx0Om9ian19KF9zY2hlZHVsaW5nKSxFYXNlTnVtYmVyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gRWFzZU51bWJlcihtVmFsdWUpe3ZhciBfdGhpcz10aGlzLG1FYXNpbmc9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOi4xO19jbGFzc0NhbGxDaGVjayh0aGlzLEVhc2VOdW1iZXIpLHRoaXMuZWFzaW5nPW1FYXNpbmcsdGhpcy5fdmFsdWU9bVZhbHVlLHRoaXMuX3RhcmdldFZhbHVlPW1WYWx1ZSx0aGlzLl9lZkluZGV4PV9zY2hlZHVsaW5nMi5kZWZhdWx0LmFkZEVGKGZ1bmN0aW9uKCl7cmV0dXJuIF90aGlzLl91cGRhdGUoKX0pfXJldHVybiBfY3JlYXRlQ2xhc3MoRWFzZU51bWJlcixbe2tleTpcIl91cGRhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2NoZWNrTGltaXQoKSx0aGlzLl92YWx1ZSs9KHRoaXMuX3RhcmdldFZhbHVlLXRoaXMuX3ZhbHVlKSp0aGlzLmVhc2luZyxNYXRoLmFicyh0aGlzLl90YXJnZXRWYWx1ZS10aGlzLl92YWx1ZSk8MWUtNCYmKHRoaXMuX3ZhbHVlPXRoaXMuX3RhcmdldFZhbHVlKX19LHtrZXk6XCJzZXRUb1wiLHZhbHVlOmZ1bmN0aW9uKG1WYWx1ZSl7dGhpcy5fdGFyZ2V0VmFsdWU9dGhpcy5fdmFsdWU9bVZhbHVlfX0se2tleTpcImFkZFwiLHZhbHVlOmZ1bmN0aW9uKG1BZGQpe3RoaXMuX3RhcmdldFZhbHVlKz1tQWRkfX0se2tleTpcImxpbWl0XCIsdmFsdWU6ZnVuY3Rpb24obU1pbixtTWF4KXtpZihtTWluPm1NYXgpcmV0dXJuIHZvaWQgdGhpcy5saW1pdChtTWF4LG1NaW4pO3RoaXMuX21pbj1tTWluLHRoaXMuX21heD1tTWF4LHRoaXMuX2NoZWNrTGltaXQoKX19LHtrZXk6XCJfY2hlY2tMaW1pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dm9pZCAwIT09dGhpcy5fbWluJiZ0aGlzLl90YXJnZXRWYWx1ZTx0aGlzLl9taW4mJih0aGlzLl90YXJnZXRWYWx1ZT10aGlzLl9taW4pLHZvaWQgMCE9PXRoaXMuX21heCYmdGhpcy5fdGFyZ2V0VmFsdWU+dGhpcy5fbWF4JiYodGhpcy5fdGFyZ2V0VmFsdWU9dGhpcy5fbWF4KX19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXtfc2NoZWR1bGluZzIuZGVmYXVsdC5yZW1vdmVFRih0aGlzLl9lZkluZGV4KX19LHtrZXk6XCJ2YWx1ZVwiLHNldDpmdW5jdGlvbihtVmFsdWUpe3RoaXMuX3RhcmdldFZhbHVlPW1WYWx1ZX0sZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3ZhbHVlfX0se2tleTpcInRhcmdldFZhbHVlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RhcmdldFZhbHVlfX1dKSxFYXNlTnVtYmVyfSgpO2V4cG9ydHMuZGVmYXVsdD1FYXNlTnVtYmVyfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ITEsZGVzY3JpcHRvci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvciYmKGRlc2NyaXB0b3Iud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcil9fXJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtyZXR1cm4gcHJvdG9Qcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyksc3RhdGljUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpLENvbnN0cnVjdG9yfX0oKSxfZ2xNYXRyaXg9X193ZWJwYWNrX3JlcXVpcmVfXygxKSxhPV9nbE1hdHJpeC52ZWMzLmNyZWF0ZSgpLGI9X2dsTWF0cml4LnZlYzMuY3JlYXRlKCksYz1fZ2xNYXRyaXgudmVjMy5jcmVhdGUoKSx0YXJnZXQ9X2dsTWF0cml4LnZlYzMuY3JlYXRlKCksZWRnZTE9X2dsTWF0cml4LnZlYzMuY3JlYXRlKCksZWRnZTI9X2dsTWF0cml4LnZlYzMuY3JlYXRlKCksbm9ybWFsPV9nbE1hdHJpeC52ZWMzLmNyZWF0ZSgpLGRpZmY9X2dsTWF0cml4LnZlYzMuY3JlYXRlKCksUmF5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gUmF5KG1PcmlnaW4sbURpcmVjdGlvbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsUmF5KSx0aGlzLm9yaWdpbj1fZ2xNYXRyaXgudmVjMy5jbG9uZShtT3JpZ2luKSx0aGlzLmRpcmVjdGlvbj1fZ2xNYXRyaXgudmVjMy5jbG9uZShtRGlyZWN0aW9uKX1yZXR1cm4gX2NyZWF0ZUNsYXNzKFJheSxbe2tleTpcImF0XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIF9nbE1hdHJpeC52ZWMzLmNvcHkodGFyZ2V0LHRoaXMuZGlyZWN0aW9uKSxfZ2xNYXRyaXgudmVjMy5zY2FsZSh0YXJnZXQsdGFyZ2V0LHQpLF9nbE1hdHJpeC52ZWMzLmFkZCh0YXJnZXQsdGFyZ2V0LHRoaXMub3JpZ2luKSx0YXJnZXR9fSx7a2V5OlwibG9va0F0XCIsdmFsdWU6ZnVuY3Rpb24obVRhcmdldCl7X2dsTWF0cml4LnZlYzMuc3ViKHRoaXMuZGlyZWN0aW9uLG1UYXJnZXQsdGhpcy5vcmlnaW4pLF9nbE1hdHJpeC52ZWMzLm5vcm1hbGl6ZSh0aGlzLm9yaWdpbix0aGlzLm9yaWdpbil9fSx7a2V5OlwiY2xvc2VzdFBvaW50VG9Qb2ludFwiLHZhbHVlOmZ1bmN0aW9uKG1Qb2ludCl7dmFyIHJlc3VsdD1fZ2xNYXRyaXgudmVjMy5jcmVhdGUoKTtfZ2xNYXRyaXgudmVjMy5zdWIobVBvaW50LHRoaXMub3JpZ2luKTt2YXIgZGlyZWN0aW9uRGlzdGFuY2U9X2dsTWF0cml4LnZlYzMuZG90KHJlc3VsdCx0aGlzLmRpcmVjdGlvbik7cmV0dXJuIGRpcmVjdGlvbkRpc3RhbmNlPDA/X2dsTWF0cml4LnZlYzMuY2xvbmUodGhpcy5vcmlnaW4pOihfZ2xNYXRyaXgudmVjMy5jb3B5KHJlc3VsdCx0aGlzLmRpcmVjdGlvbiksX2dsTWF0cml4LnZlYzMuc2NhbGUocmVzdWx0LHJlc3VsdCxkaXJlY3Rpb25EaXN0YW5jZSksX2dsTWF0cml4LnZlYzMuYWRkKHJlc3VsdCxyZXN1bHQsdGhpcy5vcmlnaW4pLHJlc3VsdCl9fSx7a2V5OlwiZGlzdGFuY2VUb1BvaW50XCIsdmFsdWU6ZnVuY3Rpb24obVBvaW50KXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQobVBvaW50KSl9fSx7a2V5OlwiZGlzdGFuY2VTcVRvUG9pbnRcIix2YWx1ZTpmdW5jdGlvbihtUG9pbnQpe3ZhciB2MT1fZ2xNYXRyaXgudmVjMy5jcmVhdGUoKTtfZ2xNYXRyaXgudmVjMy5zdWIodjEsbVBvaW50LHRoaXMub3JpZ2luKTt2YXIgZGlyZWN0aW9uRGlzdGFuY2U9X2dsTWF0cml4LnZlYzMuZG90KHYxLHRoaXMuZGlyZWN0aW9uKTtyZXR1cm4gZGlyZWN0aW9uRGlzdGFuY2U8MD9fZ2xNYXRyaXgudmVjMy5zcXVhcmVkRGlzdGFuY2UodGhpcy5vcmlnaW4sbVBvaW50KTooX2dsTWF0cml4LnZlYzMuY29weSh2MSx0aGlzLmRpcmVjdGlvbiksX2dsTWF0cml4LnZlYzMuc2NhbGUodjEsdjEsZGlyZWN0aW9uRGlzdGFuY2UpLF9nbE1hdHJpeC52ZWMzLmFkZCh2MSx2MSx0aGlzLm9yaWdpbiksX2dsTWF0cml4LnZlYzMuc3F1YXJlZERpc3RhbmNlKHYxLG1Qb2ludCkpfX0se2tleTpcImludGVyc2VjdHNTcGhlcmVcIix2YWx1ZTpmdW5jdGlvbihtQ2VudGVyLG1SYWRpdXMpe3JldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludChtQ2VudGVyKTw9bVJhZGl1c319LHtrZXk6XCJpbnRlcnNlY3RTcGhlcmVcIix2YWx1ZTpmdW5jdGlvbihtQ2VudGVyLG1SYWRpdXMpe3ZhciB2MT1fZ2xNYXRyaXgudmVjMy5jcmVhdGUoKTtfZ2xNYXRyaXgudmVjMy5zdWIodjEsbUNlbnRlcix0aGlzLm9yaWdpbik7dmFyIHRjYT1fZ2xNYXRyaXgudmVjMy5kb3QodjEsdGhpcy5kaXJlY3Rpb24pLGQyPV9nbE1hdHJpeC52ZWMzLmRvdCh2MSx2MSktdGNhKnRjYSxyYWRpdXMyPW1SYWRpdXMqbVJhZGl1cztpZihkMj5yYWRpdXMyKXJldHVybiBudWxsO3ZhciB0aGM9TWF0aC5zcXJ0KHJhZGl1czItZDIpLHQwPXRjYS10aGMsdDE9dGNhK3RoYztyZXR1cm4gdDA8MCYmdDE8MD9udWxsOnQwPDA/dGhpcy5hdCh0MSk6dGhpcy5hdCh0MCl9fSx7a2V5OlwiZGlzdGFuY2VUb1BsYW5lXCIsdmFsdWU6ZnVuY3Rpb24obVBsYW5lQ2VudGVyLG1Ob3JtYWwpe19nbE1hdHJpeC52ZWMzLmRvdChtTm9ybWFsLHRoaXMuZGlyZWN0aW9uKX19LHtrZXk6XCJpbnRlcnNlY3RUcmlhbmdsZVwiLHZhbHVlOmZ1bmN0aW9uKG1QQSxtUEIsbVBDKXt2YXIgYmFja2ZhY2VDdWxsaW5nPSEoYXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10pfHxhcmd1bWVudHNbM107X2dsTWF0cml4LnZlYzMuY29weShhLG1QQSksX2dsTWF0cml4LnZlYzMuY29weShiLG1QQiksX2dsTWF0cml4LnZlYzMuY29weShjLG1QQyksX2dsTWF0cml4LnZlYzMuc3ViKGVkZ2UxLGIsYSksX2dsTWF0cml4LnZlYzMuc3ViKGVkZ2UyLGMsYSksX2dsTWF0cml4LnZlYzMuY3Jvc3Mobm9ybWFsLGVkZ2UxLGVkZ2UyKTt2YXIgRGROPV9nbE1hdHJpeC52ZWMzLmRvdCh0aGlzLmRpcmVjdGlvbixub3JtYWwpLHNpZ249dm9pZCAwO2lmKERkTj4wKXtpZihiYWNrZmFjZUN1bGxpbmcpcmV0dXJuIG51bGw7c2lnbj0xfWVsc2V7aWYoIShEZE48MCkpcmV0dXJuIG51bGw7c2lnbj0tMSxEZE49LURkTn1fZ2xNYXRyaXgudmVjMy5zdWIoZGlmZix0aGlzLm9yaWdpbixhKSxfZ2xNYXRyaXgudmVjMy5jcm9zcyhlZGdlMixkaWZmLGVkZ2UyKTt2YXIgRGRReEUyPXNpZ24qX2dsTWF0cml4LnZlYzMuZG90KHRoaXMuZGlyZWN0aW9uLGVkZ2UyKTtpZihEZFF4RTI8MClyZXR1cm4gbnVsbDtfZ2xNYXRyaXgudmVjMy5jcm9zcyhlZGdlMSxlZGdlMSxkaWZmKTt2YXIgRGRFMXhRPXNpZ24qX2dsTWF0cml4LnZlYzMuZG90KHRoaXMuZGlyZWN0aW9uLGVkZ2UxKTtpZihEZEUxeFE8MClyZXR1cm4gbnVsbDtpZihEZFF4RTIrRGRFMXhRPkRkTilyZXR1cm4gbnVsbDt2YXIgUWRuPS1zaWduKl9nbE1hdHJpeC52ZWMzLmRvdChkaWZmLG5vcm1hbCk7cmV0dXJuIFFkbjwwP251bGw6dGhpcy5hdChRZG4vRGROKX19XSksUmF5fSgpO2V4cG9ydHMuZGVmYXVsdD1SYXl9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSxDb25zdHJ1Y3Rvcil7aWYoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHwhMSxkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBkZXNjcmlwdG9yJiYoZGVzY3JpcHRvci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCxkZXNjcmlwdG9yLmtleSxkZXNjcmlwdG9yKX19cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe3JldHVybiBwcm90b1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKSxzdGF0aWNQcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyksQ29uc3RydWN0b3J9fSgpLF9nbE1hdHJpeD1fX3dlYnBhY2tfcmVxdWlyZV9fKDEpLENhbWVyYT1mdW5jdGlvbigpe2Z1bmN0aW9uIENhbWVyYSgpe19jbGFzc0NhbGxDaGVjayh0aGlzLENhbWVyYSksdGhpcy5fbWF0cml4PV9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpLHRoaXMuX3F1YXQ9X2dsTWF0cml4LnF1YXQuY3JlYXRlKCksdGhpcy5fb3JpZW50YXRpb249X2dsTWF0cml4Lm1hdDQuY3JlYXRlKCksdGhpcy5fcHJvamVjdGlvbj1fZ2xNYXRyaXgubWF0NC5jcmVhdGUoKSx0aGlzLnBvc2l0aW9uPXZlYzMuY3JlYXRlKCl9cmV0dXJuIF9jcmVhdGVDbGFzcyhDYW1lcmEsW3trZXk6XCJsb29rQXRcIix2YWx1ZTpmdW5jdGlvbihhRXllLGFDZW50ZXIpe3ZhciBhVXA9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOlswLDEsMF07dGhpcy5fZXllPXZlYzMuY2xvbmUoYUV5ZSksdGhpcy5fY2VudGVyPXZlYzMuY2xvbmUoYUNlbnRlciksdmVjMy5jb3B5KHRoaXMucG9zaXRpb24sYUV5ZSksX2dsTWF0cml4Lm1hdDQuaWRlbnRpdHkodGhpcy5fbWF0cml4KSxfZ2xNYXRyaXgubWF0NC5sb29rQXQodGhpcy5fbWF0cml4LGFFeWUsYUNlbnRlcixhVXApfX0se2tleTpcInNldEZyb21PcmllbnRhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHgseSx6LHcpe19nbE1hdHJpeC5xdWF0LnNldCh0aGlzLl9xdWF0LHgseSx6LHcpLF9nbE1hdHJpeC5tYXQ0LmZyb21RdWF0KHRoaXMuX29yaWVudGF0aW9uLHRoaXMuX3F1YXQpLF9nbE1hdHJpeC5tYXQ0LnRyYW5zbGF0ZSh0aGlzLl9tYXRyaXgsdGhpcy5fb3JpZW50YXRpb24sdGhpcy5wb3NpdGlvbk9mZnNldCl9fSx7a2V5Olwic2V0UHJvamVjdGlvblwiLHZhbHVlOmZ1bmN0aW9uKG1Qcm9qKXt0aGlzLl9wcm9qZWN0aW9uPV9nbE1hdHJpeC5tYXQ0LmNsb25lKG1Qcm9qKX19LHtrZXk6XCJzZXRWaWV3XCIsdmFsdWU6ZnVuY3Rpb24obVZpZXcpe3RoaXMuX21hdHJpeD1fZ2xNYXRyaXgubWF0NC5jbG9uZShtVmlldyl9fSx7a2V5Olwic2V0RnJvbVZpZXdQcm9qXCIsdmFsdWU6ZnVuY3Rpb24obVZpZXcsbVByb2ope3RoaXMuc2V0VmlldyhtVmlldyksdGhpcy5zZXRQcm9qZWN0aW9uKG1Qcm9qKX19LHtrZXk6XCJtYXRyaXhcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWF0cml4fX0se2tleTpcInZpZXdNYXRyaXhcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWF0cml4fX0se2tleTpcInByb2plY3Rpb25cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcHJvamVjdGlvbn19LHtrZXk6XCJwcm9qZWN0aW9uTWF0cml4XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Byb2plY3Rpb259fSx7a2V5OlwiZXllXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2V5ZX19LHtrZXk6XCJjZW50ZXJcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY2VudGVyfX1dKSxDYW1lcmF9KCk7ZXhwb3J0cy5kZWZhdWx0PUNhbWVyYX0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7ZGVmYXVsdDpvYmp9fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSxDb25zdHJ1Y3Rvcil7aWYoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsY2FsbCl7aWYoIXNlbGYpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFjYWxsfHxcIm9iamVjdFwiIT10eXBlb2YgY2FsbCYmXCJmdW5jdGlvblwiIT10eXBlb2YgY2FsbD9zZWxmOmNhbGx9ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLHN1cGVyQ2xhc3Mpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHN1cGVyQ2xhc3MmJm51bGwhPT1zdXBlckNsYXNzKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBzdXBlckNsYXNzKTtzdWJDbGFzcy5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzJiZzdXBlckNsYXNzLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnN1YkNsYXNzLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHN1cGVyQ2xhc3MmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLHN1cGVyQ2xhc3MpOnN1YkNsYXNzLl9fcHJvdG9fXz1zdXBlckNsYXNzKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ITEsZGVzY3JpcHRvci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvciYmKGRlc2NyaXB0b3Iud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcil9fXJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtyZXR1cm4gcHJvdG9Qcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyksc3RhdGljUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpLENvbnN0cnVjdG9yfX0oKSxfQ2FtZXJhMj1fX3dlYnBhY2tfcmVxdWlyZV9fKDE1KSxfQ2FtZXJhMz1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYW1lcmEyKSxfUmF5PV9fd2VicGFja19yZXF1aXJlX18oMTQpLF9SYXkyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JheSksX2dsTWF0cml4PV9fd2VicGFja19yZXF1aXJlX18oMSksbUludmVyc2VWaWV3UHJvaj1fZ2xNYXRyaXgubWF0NC5jcmVhdGUoKSxjYW1lcmFEaXI9X2dsTWF0cml4LnZlYzMuY3JlYXRlKCksQ2FtZXJhUGVyc3BlY3RpdmU9ZnVuY3Rpb24oX0NhbWVyYSl7ZnVuY3Rpb24gQ2FtZXJhUGVyc3BlY3RpdmUoKXtyZXR1cm4gX2NsYXNzQ2FsbENoZWNrKHRoaXMsQ2FtZXJhUGVyc3BlY3RpdmUpLF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsKENhbWVyYVBlcnNwZWN0aXZlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKENhbWVyYVBlcnNwZWN0aXZlKSkuYXBwbHkodGhpcyxhcmd1bWVudHMpKX1yZXR1cm4gX2luaGVyaXRzKENhbWVyYVBlcnNwZWN0aXZlLF9DYW1lcmEpLF9jcmVhdGVDbGFzcyhDYW1lcmFQZXJzcGVjdGl2ZSxbe2tleTpcInNldFBlcnNwZWN0aXZlXCIsdmFsdWU6ZnVuY3Rpb24obUZvdixtQXNwZWN0UmF0aW8sbU5lYXIsbUZhcil7dGhpcy5fZm92PW1Gb3YsdGhpcy5fbmVhcj1tTmVhcix0aGlzLl9mYXI9bUZhcix0aGlzLl9hc3BlY3RSYXRpbz1tQXNwZWN0UmF0aW8sX2dsTWF0cml4Lm1hdDQucGVyc3BlY3RpdmUodGhpcy5fcHJvamVjdGlvbixtRm92LG1Bc3BlY3RSYXRpbyxtTmVhcixtRmFyKX19LHtrZXk6XCJzZXRBc3BlY3RSYXRpb1wiLHZhbHVlOmZ1bmN0aW9uKG1Bc3BlY3RSYXRpbyl7dGhpcy5fYXNwZWN0UmF0aW89bUFzcGVjdFJhdGlvLF9nbE1hdHJpeC5tYXQ0LnBlcnNwZWN0aXZlKHRoaXMucHJvamVjdGlvbix0aGlzLl9mb3YsbUFzcGVjdFJhdGlvLHRoaXMuX25lYXIsdGhpcy5fZmFyKX19LHtrZXk6XCJnZW5lcmF0ZVJheVwiLHZhbHVlOmZ1bmN0aW9uKG1TY3JlZW5Qb3NpdGlvbixtUmF5KXt2YXIgcHJvaj10aGlzLnByb2plY3Rpb25NYXRyaXgsdmlldz10aGlzLnZpZXdNYXRyaXg7cmV0dXJuIF9nbE1hdHJpeC5tYXQ0Lm11bHRpcGx5KG1JbnZlcnNlVmlld1Byb2oscHJvaix2aWV3KSxfZ2xNYXRyaXgubWF0NC5pbnZlcnQobUludmVyc2VWaWV3UHJvaixtSW52ZXJzZVZpZXdQcm9qKSxfZ2xNYXRyaXgudmVjMy50cmFuc2Zvcm1NYXQ0KGNhbWVyYURpcixtU2NyZWVuUG9zaXRpb24sbUludmVyc2VWaWV3UHJvaiksX2dsTWF0cml4LnZlYzMuc3ViKGNhbWVyYURpcixjYW1lcmFEaXIsdGhpcy5wb3NpdGlvbiksX2dsTWF0cml4LnZlYzMubm9ybWFsaXplKGNhbWVyYURpcixjYW1lcmFEaXIpLG1SYXk/KG1SYXkub3JpZ2luPXRoaXMucG9zaXRpb24sbVJheS5kaXJlY3Rpb249Y2FtZXJhRGlyKTptUmF5PW5ldyBfUmF5Mi5kZWZhdWx0KHRoaXMucG9zaXRpb24sY2FtZXJhRGlyKSxtUmF5fX1dKSxDYW1lcmFQZXJzcGVjdGl2ZX0oX0NhbWVyYTMuZGVmYXVsdCk7ZXhwb3J0cy5kZWZhdWx0PUNhbWVyYVBlcnNwZWN0aXZlfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ITEsZGVzY3JpcHRvci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvciYmKGRlc2NyaXB0b3Iud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcil9fXJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtyZXR1cm4gcHJvdG9Qcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyksc3RhdGljUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpLENvbnN0cnVjdG9yfX0oKSxCaW5hcnlMb2FkZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBCaW5hcnlMb2FkZXIoKXt2YXIgX3RoaXM9dGhpcyxpc0FycmF5QnVmZmVyPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF07X2NsYXNzQ2FsbENoZWNrKHRoaXMsQmluYXJ5TG9hZGVyKSx0aGlzLl9yZXE9bmV3IFhNTEh0dHBSZXF1ZXN0LHRoaXMuX3JlcS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGZ1bmN0aW9uKGUpe3JldHVybiBfdGhpcy5fb25Mb2FkZWQoZSl9KSx0aGlzLl9yZXEuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsZnVuY3Rpb24oZSl7cmV0dXJuIF90aGlzLl9vblByb2dyZXNzKGUpfSksaXNBcnJheUJ1ZmZlciYmKHRoaXMuX3JlcS5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiKX1yZXR1cm4gX2NyZWF0ZUNsYXNzKEJpbmFyeUxvYWRlcixbe2tleTpcImxvYWRcIix2YWx1ZTpmdW5jdGlvbih1cmwsY2FsbGJhY2spe2NvbnNvbGUubG9nKFwiTG9hZGluZyA6IFwiLHVybCksdGhpcy5fY2FsbGJhY2s9Y2FsbGJhY2ssdGhpcy5fcmVxLm9wZW4oXCJHRVRcIix1cmwpLHRoaXMuX3JlcS5zZW5kKCl9fSx7a2V5OlwiX29uTG9hZGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9jYWxsYmFjayh0aGlzLl9yZXEucmVzcG9uc2UpfX0se2tleTpcIl9vblByb2dyZXNzXCIsdmFsdWU6ZnVuY3Rpb24oKXt9fV0pLEJpbmFyeUxvYWRlcn0oKTtleHBvcnRzLmRlZmF1bHQ9QmluYXJ5TG9hZGVyfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9XCIvLyBiaWdUcmlhbmdsZS52ZXJ0XFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBCSUdfVFJJQU5HTEVfVkVSVEVYXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiwgMC4wLCAxLjApO1xcbiAgICB2VGV4dHVyZUNvb3JkID0gYVBvc2l0aW9uICogLjUgKyAuNTtcXG59XCJ9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1cIi8vIGNvcHkuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgQ09QWV9GUkFHTUVOVFxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleHR1cmVDb29yZCk7XFxufVwifSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBjcmVhdGUoKXt2YXIgb3V0PW5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO3JldHVybiBvdXRbMF09MSxvdXRbMV09MCxvdXRbMl09MCxvdXRbM109MCxvdXRbNF09MSxvdXRbNV09MCxvdXRbNl09MCxvdXRbN109MCxvdXRbOF09MSxvdXR9ZnVuY3Rpb24gZnJvbU1hdDQob3V0LGEpe3JldHVybiBvdXRbMF09YVswXSxvdXRbMV09YVsxXSxvdXRbMl09YVsyXSxvdXRbM109YVs0XSxvdXRbNF09YVs1XSxvdXRbNV09YVs2XSxvdXRbNl09YVs4XSxvdXRbN109YVs5XSxvdXRbOF09YVsxMF0sb3V0fWZ1bmN0aW9uIGNsb25lKGEpe3ZhciBvdXQ9bmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7cmV0dXJuIG91dFswXT1hWzBdLG91dFsxXT1hWzFdLG91dFsyXT1hWzJdLG91dFszXT1hWzNdLG91dFs0XT1hWzRdLG91dFs1XT1hWzVdLG91dFs2XT1hWzZdLG91dFs3XT1hWzddLG91dFs4XT1hWzhdLG91dH1mdW5jdGlvbiBjb3B5KG91dCxhKXtyZXR1cm4gb3V0WzBdPWFbMF0sb3V0WzFdPWFbMV0sb3V0WzJdPWFbMl0sb3V0WzNdPWFbM10sb3V0WzRdPWFbNF0sb3V0WzVdPWFbNV0sb3V0WzZdPWFbNl0sb3V0WzddPWFbN10sb3V0WzhdPWFbOF0sb3V0fWZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLG0wMSxtMDIsbTEwLG0xMSxtMTIsbTIwLG0yMSxtMjIpe3ZhciBvdXQ9bmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7cmV0dXJuIG91dFswXT1tMDAsb3V0WzFdPW0wMSxvdXRbMl09bTAyLG91dFszXT1tMTAsb3V0WzRdPW0xMSxvdXRbNV09bTEyLG91dFs2XT1tMjAsb3V0WzddPW0yMSxvdXRbOF09bTIyLG91dH1mdW5jdGlvbiBzZXQob3V0LG0wMCxtMDEsbTAyLG0xMCxtMTEsbTEyLG0yMCxtMjEsbTIyKXtyZXR1cm4gb3V0WzBdPW0wMCxvdXRbMV09bTAxLG91dFsyXT1tMDIsb3V0WzNdPW0xMCxvdXRbNF09bTExLG91dFs1XT1tMTIsb3V0WzZdPW0yMCxvdXRbN109bTIxLG91dFs4XT1tMjIsb3V0fWZ1bmN0aW9uIGlkZW50aXR5KG91dCl7cmV0dXJuIG91dFswXT0xLG91dFsxXT0wLG91dFsyXT0wLG91dFszXT0wLG91dFs0XT0xLG91dFs1XT0wLG91dFs2XT0wLG91dFs3XT0wLG91dFs4XT0xLG91dH1mdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LGEpe2lmKG91dD09PWEpe3ZhciBhMDE9YVsxXSxhMDI9YVsyXSxhMTI9YVs1XTtvdXRbMV09YVszXSxvdXRbMl09YVs2XSxvdXRbM109YTAxLG91dFs1XT1hWzddLG91dFs2XT1hMDIsb3V0WzddPWExMn1lbHNlIG91dFswXT1hWzBdLG91dFsxXT1hWzNdLG91dFsyXT1hWzZdLG91dFszXT1hWzFdLG91dFs0XT1hWzRdLG91dFs1XT1hWzddLG91dFs2XT1hWzJdLG91dFs3XT1hWzVdLG91dFs4XT1hWzhdO3JldHVybiBvdXR9ZnVuY3Rpb24gaW52ZXJ0KG91dCxhKXt2YXIgYTAwPWFbMF0sYTAxPWFbMV0sYTAyPWFbMl0sYTEwPWFbM10sYTExPWFbNF0sYTEyPWFbNV0sYTIwPWFbNl0sYTIxPWFbN10sYTIyPWFbOF0sYjAxPWEyMiphMTEtYTEyKmEyMSxiMTE9LWEyMiphMTArYTEyKmEyMCxiMjE9YTIxKmExMC1hMTEqYTIwLGRldD1hMDAqYjAxK2EwMSpiMTErYTAyKmIyMTtyZXR1cm4gZGV0PyhkZXQ9MS9kZXQsb3V0WzBdPWIwMSpkZXQsb3V0WzFdPSgtYTIyKmEwMSthMDIqYTIxKSpkZXQsb3V0WzJdPShhMTIqYTAxLWEwMiphMTEpKmRldCxvdXRbM109YjExKmRldCxvdXRbNF09KGEyMiphMDAtYTAyKmEyMCkqZGV0LG91dFs1XT0oLWExMiphMDArYTAyKmExMCkqZGV0LG91dFs2XT1iMjEqZGV0LG91dFs3XT0oLWEyMSphMDArYTAxKmEyMCkqZGV0LG91dFs4XT0oYTExKmEwMC1hMDEqYTEwKSpkZXQsb3V0KTpudWxsfWZ1bmN0aW9uIGFkam9pbnQob3V0LGEpe3ZhciBhMDA9YVswXSxhMDE9YVsxXSxhMDI9YVsyXSxhMTA9YVszXSxhMTE9YVs0XSxhMTI9YVs1XSxhMjA9YVs2XSxhMjE9YVs3XSxhMjI9YVs4XTtyZXR1cm4gb3V0WzBdPWExMSphMjItYTEyKmEyMSxvdXRbMV09YTAyKmEyMS1hMDEqYTIyLG91dFsyXT1hMDEqYTEyLWEwMiphMTEsb3V0WzNdPWExMiphMjAtYTEwKmEyMixvdXRbNF09YTAwKmEyMi1hMDIqYTIwLG91dFs1XT1hMDIqYTEwLWEwMCphMTIsb3V0WzZdPWExMCphMjEtYTExKmEyMCxvdXRbN109YTAxKmEyMC1hMDAqYTIxLG91dFs4XT1hMDAqYTExLWEwMSphMTAsb3V0fWZ1bmN0aW9uIGRldGVybWluYW50KGEpe3ZhciBhMDA9YVswXSxhMDE9YVsxXSxhMDI9YVsyXSxhMTA9YVszXSxhMTE9YVs0XSxhMTI9YVs1XSxhMjA9YVs2XSxhMjE9YVs3XSxhMjI9YVs4XTtyZXR1cm4gYTAwKihhMjIqYTExLWExMiphMjEpK2EwMSooLWEyMiphMTArYTEyKmEyMCkrYTAyKihhMjEqYTEwLWExMSphMjApfWZ1bmN0aW9uIG11bHRpcGx5KG91dCxhLGIpe3ZhciBhMDA9YVswXSxhMDE9YVsxXSxhMDI9YVsyXSxhMTA9YVszXSxhMTE9YVs0XSxhMTI9YVs1XSxhMjA9YVs2XSxhMjE9YVs3XSxhMjI9YVs4XSxiMDA9YlswXSxiMDE9YlsxXSxiMDI9YlsyXSxiMTA9YlszXSxiMTE9Yls0XSxiMTI9Yls1XSxiMjA9Yls2XSxiMjE9Yls3XSxiMjI9Yls4XTtyZXR1cm4gb3V0WzBdPWIwMCphMDArYjAxKmExMCtiMDIqYTIwLG91dFsxXT1iMDAqYTAxK2IwMSphMTErYjAyKmEyMSxvdXRbMl09YjAwKmEwMitiMDEqYTEyK2IwMiphMjIsb3V0WzNdPWIxMCphMDArYjExKmExMCtiMTIqYTIwLG91dFs0XT1iMTAqYTAxK2IxMSphMTErYjEyKmEyMSxvdXRbNV09YjEwKmEwMitiMTEqYTEyK2IxMiphMjIsb3V0WzZdPWIyMCphMDArYjIxKmExMCtiMjIqYTIwLG91dFs3XT1iMjAqYTAxK2IyMSphMTErYjIyKmEyMSxvdXRbOF09YjIwKmEwMitiMjEqYTEyK2IyMiphMjIsb3V0fWZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsYSx2KXt2YXIgYTAwPWFbMF0sYTAxPWFbMV0sYTAyPWFbMl0sYTEwPWFbM10sYTExPWFbNF0sYTEyPWFbNV0sYTIwPWFbNl0sYTIxPWFbN10sYTIyPWFbOF0seD12WzBdLHk9dlsxXTtyZXR1cm4gb3V0WzBdPWEwMCxvdXRbMV09YTAxLG91dFsyXT1hMDIsb3V0WzNdPWExMCxvdXRbNF09YTExLG91dFs1XT1hMTIsb3V0WzZdPXgqYTAwK3kqYTEwK2EyMCxvdXRbN109eCphMDEreSphMTErYTIxLG91dFs4XT14KmEwMit5KmExMithMjIsb3V0fWZ1bmN0aW9uIHJvdGF0ZShvdXQsYSxyYWQpe3ZhciBhMDA9YVswXSxhMDE9YVsxXSxhMDI9YVsyXSxhMTA9YVszXSxhMTE9YVs0XSxhMTI9YVs1XSxhMjA9YVs2XSxhMjE9YVs3XSxhMjI9YVs4XSxzPU1hdGguc2luKHJhZCksYz1NYXRoLmNvcyhyYWQpO3JldHVybiBvdXRbMF09YyphMDArcyphMTAsb3V0WzFdPWMqYTAxK3MqYTExLG91dFsyXT1jKmEwMitzKmExMixvdXRbM109YyphMTAtcyphMDAsb3V0WzRdPWMqYTExLXMqYTAxLG91dFs1XT1jKmExMi1zKmEwMixvdXRbNl09YTIwLG91dFs3XT1hMjEsb3V0WzhdPWEyMixvdXR9ZnVuY3Rpb24gc2NhbGUob3V0LGEsdil7dmFyIHg9dlswXSx5PXZbMV07cmV0dXJuIG91dFswXT14KmFbMF0sb3V0WzFdPXgqYVsxXSxvdXRbMl09eCphWzJdLG91dFszXT15KmFbM10sb3V0WzRdPXkqYVs0XSxvdXRbNV09eSphWzVdLG91dFs2XT1hWzZdLG91dFs3XT1hWzddLG91dFs4XT1hWzhdLG91dH1mdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LHYpe3JldHVybiBvdXRbMF09MSxvdXRbMV09MCxvdXRbMl09MCxvdXRbM109MCxvdXRbNF09MSxvdXRbNV09MCxvdXRbNl09dlswXSxvdXRbN109dlsxXSxvdXRbOF09MSxvdXR9ZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCxyYWQpe3ZhciBzPU1hdGguc2luKHJhZCksYz1NYXRoLmNvcyhyYWQpO3JldHVybiBvdXRbMF09YyxvdXRbMV09cyxvdXRbMl09MCxvdXRbM109LXMsb3V0WzRdPWMsb3V0WzVdPTAsb3V0WzZdPTAsb3V0WzddPTAsb3V0WzhdPTEsb3V0fWZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCx2KXtyZXR1cm4gb3V0WzBdPXZbMF0sb3V0WzFdPTAsb3V0WzJdPTAsb3V0WzNdPTAsb3V0WzRdPXZbMV0sb3V0WzVdPTAsb3V0WzZdPTAsb3V0WzddPTAsb3V0WzhdPTEsb3V0fWZ1bmN0aW9uIGZyb21NYXQyZChvdXQsYSl7cmV0dXJuIG91dFswXT1hWzBdLG91dFsxXT1hWzFdLG91dFsyXT0wLG91dFszXT1hWzJdLG91dFs0XT1hWzNdLG91dFs1XT0wLG91dFs2XT1hWzRdLG91dFs3XT1hWzVdLG91dFs4XT0xLG91dH1mdW5jdGlvbiBmcm9tUXVhdChvdXQscSl7dmFyIHg9cVswXSx5PXFbMV0sej1xWzJdLHc9cVszXSx4Mj14K3gseTI9eSt5LHoyPXoreix4eD14KngyLHl4PXkqeDIseXk9eSp5Mix6eD16KngyLHp5PXoqeTIseno9eip6Mix3eD13KngyLHd5PXcqeTIsd3o9dyp6MjtyZXR1cm4gb3V0WzBdPTEteXktenosb3V0WzNdPXl4LXd6LG91dFs2XT16eCt3eSxvdXRbMV09eXgrd3osb3V0WzRdPTEteHgtenosb3V0WzddPXp5LXd4LG91dFsyXT16eC13eSxvdXRbNV09enkrd3gsb3V0WzhdPTEteHgteXksb3V0fWZ1bmN0aW9uIG5vcm1hbEZyb21NYXQ0KG91dCxhKXt2YXIgYTAwPWFbMF0sYTAxPWFbMV0sYTAyPWFbMl0sYTAzPWFbM10sYTEwPWFbNF0sYTExPWFbNV0sYTEyPWFbNl0sYTEzPWFbN10sYTIwPWFbOF0sYTIxPWFbOV0sYTIyPWFbMTBdLGEyMz1hWzExXSxhMzA9YVsxMl0sYTMxPWFbMTNdLGEzMj1hWzE0XSxhMzM9YVsxNV0sYjAwPWEwMCphMTEtYTAxKmExMCxiMDE9YTAwKmExMi1hMDIqYTEwLGIwMj1hMDAqYTEzLWEwMyphMTAsYjAzPWEwMSphMTItYTAyKmExMSxiMDQ9YTAxKmExMy1hMDMqYTExLGIwNT1hMDIqYTEzLWEwMyphMTIsYjA2PWEyMCphMzEtYTIxKmEzMCxiMDc9YTIwKmEzMi1hMjIqYTMwLGIwOD1hMjAqYTMzLWEyMyphMzAsYjA5PWEyMSphMzItYTIyKmEzMSxiMTA9YTIxKmEzMy1hMjMqYTMxLGIxMT1hMjIqYTMzLWEyMyphMzIsZGV0PWIwMCpiMTEtYjAxKmIxMCtiMDIqYjA5K2IwMypiMDgtYjA0KmIwNytiMDUqYjA2O3JldHVybiBkZXQ/KGRldD0xL2RldCxvdXRbMF09KGExMSpiMTEtYTEyKmIxMCthMTMqYjA5KSpkZXQsb3V0WzFdPShhMTIqYjA4LWExMCpiMTEtYTEzKmIwNykqZGV0LG91dFsyXT0oYTEwKmIxMC1hMTEqYjA4K2ExMypiMDYpKmRldCxvdXRbM109KGEwMipiMTAtYTAxKmIxMS1hMDMqYjA5KSpkZXQsb3V0WzRdPShhMDAqYjExLWEwMipiMDgrYTAzKmIwNykqZGV0LG91dFs1XT0oYTAxKmIwOC1hMDAqYjEwLWEwMypiMDYpKmRldCxvdXRbNl09KGEzMSpiMDUtYTMyKmIwNCthMzMqYjAzKSpkZXQsb3V0WzddPShhMzIqYjAyLWEzMCpiMDUtYTMzKmIwMSkqZGV0LG91dFs4XT0oYTMwKmIwNC1hMzEqYjAyK2EzMypiMDApKmRldCxvdXQpOm51bGx9ZnVuY3Rpb24gcHJvamVjdGlvbihvdXQsd2lkdGgsaGVpZ2h0KXtyZXR1cm4gb3V0WzBdPTIvd2lkdGgsb3V0WzFdPTAsb3V0WzJdPTAsb3V0WzNdPTAsb3V0WzRdPS0yL2hlaWdodCxvdXRbNV09MCxvdXRbNl09LTEsb3V0WzddPTEsb3V0WzhdPTEsb3V0fWZ1bmN0aW9uIHN0cihhKXtyZXR1cm5cIm1hdDMoXCIrYVswXStcIiwgXCIrYVsxXStcIiwgXCIrYVsyXStcIiwgXCIrYVszXStcIiwgXCIrYVs0XStcIiwgXCIrYVs1XStcIiwgXCIrYVs2XStcIiwgXCIrYVs3XStcIiwgXCIrYVs4XStcIilcIn1mdW5jdGlvbiBmcm9iKGEpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwyKStNYXRoLnBvdyhhWzFdLDIpK01hdGgucG93KGFbMl0sMikrTWF0aC5wb3coYVszXSwyKStNYXRoLnBvdyhhWzRdLDIpK01hdGgucG93KGFbNV0sMikrTWF0aC5wb3coYVs2XSwyKStNYXRoLnBvdyhhWzddLDIpK01hdGgucG93KGFbOF0sMikpfWZ1bmN0aW9uIGFkZChvdXQsYSxiKXtyZXR1cm4gb3V0WzBdPWFbMF0rYlswXSxvdXRbMV09YVsxXStiWzFdLG91dFsyXT1hWzJdK2JbMl0sb3V0WzNdPWFbM10rYlszXSxvdXRbNF09YVs0XStiWzRdLG91dFs1XT1hWzVdK2JbNV0sb3V0WzZdPWFbNl0rYls2XSxvdXRbN109YVs3XStiWzddLG91dFs4XT1hWzhdK2JbOF0sb3V0fWZ1bmN0aW9uIHN1YnRyYWN0KG91dCxhLGIpe3JldHVybiBvdXRbMF09YVswXS1iWzBdLG91dFsxXT1hWzFdLWJbMV0sb3V0WzJdPWFbMl0tYlsyXSxvdXRbM109YVszXS1iWzNdLG91dFs0XT1hWzRdLWJbNF0sb3V0WzVdPWFbNV0tYls1XSxvdXRbNl09YVs2XS1iWzZdLG91dFs3XT1hWzddLWJbN10sb3V0WzhdPWFbOF0tYls4XSxvdXR9ZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LGEsYil7cmV0dXJuIG91dFswXT1hWzBdKmIsb3V0WzFdPWFbMV0qYixvdXRbMl09YVsyXSpiLG91dFszXT1hWzNdKmIsb3V0WzRdPWFbNF0qYixvdXRbNV09YVs1XSpiLG91dFs2XT1hWzZdKmIsb3V0WzddPWFbN10qYixvdXRbOF09YVs4XSpiLG91dH1mdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsYSxiLHNjYWxlKXtyZXR1cm4gb3V0WzBdPWFbMF0rYlswXSpzY2FsZSxvdXRbMV09YVsxXStiWzFdKnNjYWxlLG91dFsyXT1hWzJdK2JbMl0qc2NhbGUsb3V0WzNdPWFbM10rYlszXSpzY2FsZSxvdXRbNF09YVs0XStiWzRdKnNjYWxlLG91dFs1XT1hWzVdK2JbNV0qc2NhbGUsb3V0WzZdPWFbNl0rYls2XSpzY2FsZSxvdXRbN109YVs3XStiWzddKnNjYWxlLG91dFs4XT1hWzhdK2JbOF0qc2NhbGUsb3V0fWZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsYil7cmV0dXJuIGFbMF09PT1iWzBdJiZhWzFdPT09YlsxXSYmYVsyXT09PWJbMl0mJmFbM109PT1iWzNdJiZhWzRdPT09Yls0XSYmYVs1XT09PWJbNV0mJmFbNl09PT1iWzZdJiZhWzddPT09Yls3XSYmYVs4XT09PWJbOF19ZnVuY3Rpb24gZXF1YWxzKGEsYil7dmFyIGEwPWFbMF0sYTE9YVsxXSxhMj1hWzJdLGEzPWFbM10sYTQ9YVs0XSxhNT1hWzVdLGE2PWFbNl0sYTc9YVs3XSxhOD1hWzhdLGIwPWJbMF0sYjE9YlsxXSxiMj1iWzJdLGIzPWJbM10sYjQ9Yls0XSxiNT1iWzVdLGI2PWJbNl0sYjc9Yls3XSxiOD1iWzhdO3JldHVybiBNYXRoLmFicyhhMC1iMCk8PWdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhMCksTWF0aC5hYnMoYjApKSYmTWF0aC5hYnMoYTEtYjEpPD1nbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYTEpLE1hdGguYWJzKGIxKSkmJk1hdGguYWJzKGEyLWIyKTw9Z2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGEyKSxNYXRoLmFicyhiMikpJiZNYXRoLmFicyhhMy1iMyk8PWdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhMyksTWF0aC5hYnMoYjMpKSYmTWF0aC5hYnMoYTQtYjQpPD1nbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYTQpLE1hdGguYWJzKGI0KSkmJk1hdGguYWJzKGE1LWI1KTw9Z2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGE1KSxNYXRoLmFicyhiNSkpJiZNYXRoLmFicyhhNi1iNik8PWdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhNiksTWF0aC5hYnMoYjYpKSYmTWF0aC5hYnMoYTctYjcpPD1nbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYTcpLE1hdGguYWJzKGI3KSkmJk1hdGguYWJzKGE4LWI4KTw9Z2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGE4KSxNYXRoLmFicyhiOCkpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGV4cG9ydHMuc3ViPWV4cG9ydHMubXVsPXZvaWQgMCxleHBvcnRzLmNyZWF0ZT1jcmVhdGUsZXhwb3J0cy5mcm9tTWF0ND1mcm9tTWF0NCxleHBvcnRzLmNsb25lPWNsb25lLGV4cG9ydHMuY29weT1jb3B5LGV4cG9ydHMuZnJvbVZhbHVlcz1mcm9tVmFsdWVzLGV4cG9ydHMuc2V0PXNldCxleHBvcnRzLmlkZW50aXR5PWlkZW50aXR5LGV4cG9ydHMudHJhbnNwb3NlPXRyYW5zcG9zZSxleHBvcnRzLmludmVydD1pbnZlcnQsZXhwb3J0cy5hZGpvaW50PWFkam9pbnQsZXhwb3J0cy5kZXRlcm1pbmFudD1kZXRlcm1pbmFudCxleHBvcnRzLm11bHRpcGx5PW11bHRpcGx5LGV4cG9ydHMudHJhbnNsYXRlPXRyYW5zbGF0ZSxleHBvcnRzLnJvdGF0ZT1yb3RhdGUsZXhwb3J0cy5zY2FsZT1zY2FsZSxleHBvcnRzLmZyb21UcmFuc2xhdGlvbj1mcm9tVHJhbnNsYXRpb24sZXhwb3J0cy5mcm9tUm90YXRpb249ZnJvbVJvdGF0aW9uLGV4cG9ydHMuZnJvbVNjYWxpbmc9ZnJvbVNjYWxpbmcsZXhwb3J0cy5mcm9tTWF0MmQ9ZnJvbU1hdDJkLGV4cG9ydHMuZnJvbVF1YXQ9ZnJvbVF1YXQsZXhwb3J0cy5ub3JtYWxGcm9tTWF0ND1ub3JtYWxGcm9tTWF0NCxleHBvcnRzLnByb2plY3Rpb249cHJvamVjdGlvbixleHBvcnRzLnN0cj1zdHIsZXhwb3J0cy5mcm9iPWZyb2IsZXhwb3J0cy5hZGQ9YWRkLGV4cG9ydHMuc3VidHJhY3Q9c3VidHJhY3QsZXhwb3J0cy5tdWx0aXBseVNjYWxhcj1tdWx0aXBseVNjYWxhcixleHBvcnRzLm11bHRpcGx5U2NhbGFyQW5kQWRkPW11bHRpcGx5U2NhbGFyQW5kQWRkLGV4cG9ydHMuZXhhY3RFcXVhbHM9ZXhhY3RFcXVhbHMsZXhwb3J0cy5lcXVhbHM9ZXF1YWxzO3ZhciBfY29tbW9uPV9fd2VicGFja19yZXF1aXJlX18oMyksZ2xNYXRyaXg9ZnVuY3Rpb24ob2JqKXtpZihvYmomJm9iai5fX2VzTW9kdWxlKXJldHVybiBvYmo7dmFyIG5ld09iaj17fTtpZihudWxsIT1vYmopZm9yKHZhciBrZXkgaW4gb2JqKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosa2V5KSYmKG5ld09ialtrZXldPW9ialtrZXldKTtyZXR1cm4gbmV3T2JqLmRlZmF1bHQ9b2JqLG5ld09ian0oX2NvbW1vbik7ZXhwb3J0cy5tdWw9bXVsdGlwbHksZXhwb3J0cy5zdWI9c3VidHJhY3R9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGNyZWF0ZSgpe3ZhciBvdXQ9bmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7cmV0dXJuIG91dFswXT0wLG91dFsxXT0wLG91dFsyXT0wLG91dH1mdW5jdGlvbiBjbG9uZShhKXt2YXIgb3V0PW5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO3JldHVybiBvdXRbMF09YVswXSxvdXRbMV09YVsxXSxvdXRbMl09YVsyXSxvdXR9ZnVuY3Rpb24gbGVuZ3RoKGEpe3ZhciB4PWFbMF0seT1hWzFdLHo9YVsyXTtyZXR1cm4gTWF0aC5zcXJ0KHgqeCt5Knkreip6KX1mdW5jdGlvbiBmcm9tVmFsdWVzKHgseSx6KXt2YXIgb3V0PW5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO3JldHVybiBvdXRbMF09eCxvdXRbMV09eSxvdXRbMl09eixvdXR9ZnVuY3Rpb24gY29weShvdXQsYSl7cmV0dXJuIG91dFswXT1hWzBdLG91dFsxXT1hWzFdLG91dFsyXT1hWzJdLG91dH1mdW5jdGlvbiBzZXQob3V0LHgseSx6KXtyZXR1cm4gb3V0WzBdPXgsb3V0WzFdPXksb3V0WzJdPXosb3V0fWZ1bmN0aW9uIGFkZChvdXQsYSxiKXtyZXR1cm4gb3V0WzBdPWFbMF0rYlswXSxvdXRbMV09YVsxXStiWzFdLG91dFsyXT1hWzJdK2JbMl0sb3V0fWZ1bmN0aW9uIHN1YnRyYWN0KG91dCxhLGIpe3JldHVybiBvdXRbMF09YVswXS1iWzBdLG91dFsxXT1hWzFdLWJbMV0sb3V0WzJdPWFbMl0tYlsyXSxvdXR9ZnVuY3Rpb24gbXVsdGlwbHkob3V0LGEsYil7cmV0dXJuIG91dFswXT1hWzBdKmJbMF0sb3V0WzFdPWFbMV0qYlsxXSxvdXRbMl09YVsyXSpiWzJdLG91dH1mdW5jdGlvbiBkaXZpZGUob3V0LGEsYil7cmV0dXJuIG91dFswXT1hWzBdL2JbMF0sb3V0WzFdPWFbMV0vYlsxXSxvdXRbMl09YVsyXS9iWzJdLG91dH1mdW5jdGlvbiBjZWlsKG91dCxhKXtyZXR1cm4gb3V0WzBdPU1hdGguY2VpbChhWzBdKSxvdXRbMV09TWF0aC5jZWlsKGFbMV0pLG91dFsyXT1NYXRoLmNlaWwoYVsyXSksb3V0fWZ1bmN0aW9uIGZsb29yKG91dCxhKXtyZXR1cm4gb3V0WzBdPU1hdGguZmxvb3IoYVswXSksb3V0WzFdPU1hdGguZmxvb3IoYVsxXSksb3V0WzJdPU1hdGguZmxvb3IoYVsyXSksb3V0fWZ1bmN0aW9uIG1pbihvdXQsYSxiKXtyZXR1cm4gb3V0WzBdPU1hdGgubWluKGFbMF0sYlswXSksb3V0WzFdPU1hdGgubWluKGFbMV0sYlsxXSksb3V0WzJdPU1hdGgubWluKGFbMl0sYlsyXSksb3V0fWZ1bmN0aW9uIG1heChvdXQsYSxiKXtyZXR1cm4gb3V0WzBdPU1hdGgubWF4KGFbMF0sYlswXSksb3V0WzFdPU1hdGgubWF4KGFbMV0sYlsxXSksb3V0WzJdPU1hdGgubWF4KGFbMl0sYlsyXSksb3V0fWZ1bmN0aW9uIHJvdW5kKG91dCxhKXtyZXR1cm4gb3V0WzBdPU1hdGgucm91bmQoYVswXSksb3V0WzFdPU1hdGgucm91bmQoYVsxXSksb3V0WzJdPU1hdGgucm91bmQoYVsyXSksb3V0fWZ1bmN0aW9uIHNjYWxlKG91dCxhLGIpe3JldHVybiBvdXRbMF09YVswXSpiLG91dFsxXT1hWzFdKmIsb3V0WzJdPWFbMl0qYixvdXR9ZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LGEsYixzY2FsZSl7cmV0dXJuIG91dFswXT1hWzBdK2JbMF0qc2NhbGUsb3V0WzFdPWFbMV0rYlsxXSpzY2FsZSxvdXRbMl09YVsyXStiWzJdKnNjYWxlLG91dH1mdW5jdGlvbiBkaXN0YW5jZShhLGIpe3ZhciB4PWJbMF0tYVswXSx5PWJbMV0tYVsxXSx6PWJbMl0tYVsyXTtyZXR1cm4gTWF0aC5zcXJ0KHgqeCt5Knkreip6KX1mdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSxiKXt2YXIgeD1iWzBdLWFbMF0seT1iWzFdLWFbMV0sej1iWzJdLWFbMl07cmV0dXJuIHgqeCt5Knkreip6fWZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSl7dmFyIHg9YVswXSx5PWFbMV0sej1hWzJdO3JldHVybiB4KngreSp5K3oqen1mdW5jdGlvbiBuZWdhdGUob3V0LGEpe3JldHVybiBvdXRbMF09LWFbMF0sb3V0WzFdPS1hWzFdLG91dFsyXT0tYVsyXSxvdXR9ZnVuY3Rpb24gaW52ZXJzZShvdXQsYSl7cmV0dXJuIG91dFswXT0xL2FbMF0sb3V0WzFdPTEvYVsxXSxvdXRbMl09MS9hWzJdLG91dH1mdW5jdGlvbiBub3JtYWxpemUob3V0LGEpe3ZhciB4PWFbMF0seT1hWzFdLHo9YVsyXSxsZW49eCp4K3kqeSt6Kno7cmV0dXJuIGxlbj4wJiYobGVuPTEvTWF0aC5zcXJ0KGxlbiksb3V0WzBdPWFbMF0qbGVuLG91dFsxXT1hWzFdKmxlbixvdXRbMl09YVsyXSpsZW4pLG91dH1mdW5jdGlvbiBkb3QoYSxiKXtyZXR1cm4gYVswXSpiWzBdK2FbMV0qYlsxXSthWzJdKmJbMl19ZnVuY3Rpb24gY3Jvc3Mob3V0LGEsYil7dmFyIGF4PWFbMF0sYXk9YVsxXSxhej1hWzJdLGJ4PWJbMF0sYnk9YlsxXSxiej1iWzJdO3JldHVybiBvdXRbMF09YXkqYnotYXoqYnksb3V0WzFdPWF6KmJ4LWF4KmJ6LG91dFsyXT1heCpieS1heSpieCxvdXR9ZnVuY3Rpb24gbGVycChvdXQsYSxiLHQpe3ZhciBheD1hWzBdLGF5PWFbMV0sYXo9YVsyXTtyZXR1cm4gb3V0WzBdPWF4K3QqKGJbMF0tYXgpLG91dFsxXT1heSt0KihiWzFdLWF5KSxvdXRbMl09YXordCooYlsyXS1heiksb3V0fWZ1bmN0aW9uIGhlcm1pdGUob3V0LGEsYixjLGQsdCl7dmFyIGZhY3RvclRpbWVzMj10KnQsZmFjdG9yMT1mYWN0b3JUaW1lczIqKDIqdC0zKSsxLGZhY3RvcjI9ZmFjdG9yVGltZXMyKih0LTIpK3QsZmFjdG9yMz1mYWN0b3JUaW1lczIqKHQtMSksZmFjdG9yND1mYWN0b3JUaW1lczIqKDMtMip0KTtyZXR1cm4gb3V0WzBdPWFbMF0qZmFjdG9yMStiWzBdKmZhY3RvcjIrY1swXSpmYWN0b3IzK2RbMF0qZmFjdG9yNCxvdXRbMV09YVsxXSpmYWN0b3IxK2JbMV0qZmFjdG9yMitjWzFdKmZhY3RvcjMrZFsxXSpmYWN0b3I0LG91dFsyXT1hWzJdKmZhY3RvcjErYlsyXSpmYWN0b3IyK2NbMl0qZmFjdG9yMytkWzJdKmZhY3RvcjQsb3V0fWZ1bmN0aW9uIGJlemllcihvdXQsYSxiLGMsZCx0KXt2YXIgaW52ZXJzZUZhY3Rvcj0xLXQsaW52ZXJzZUZhY3RvclRpbWVzVHdvPWludmVyc2VGYWN0b3IqaW52ZXJzZUZhY3RvcixmYWN0b3JUaW1lczI9dCp0LGZhY3RvcjE9aW52ZXJzZUZhY3RvclRpbWVzVHdvKmludmVyc2VGYWN0b3IsZmFjdG9yMj0zKnQqaW52ZXJzZUZhY3RvclRpbWVzVHdvLGZhY3RvcjM9MypmYWN0b3JUaW1lczIqaW52ZXJzZUZhY3RvcixmYWN0b3I0PWZhY3RvclRpbWVzMip0O3JldHVybiBvdXRbMF09YVswXSpmYWN0b3IxK2JbMF0qZmFjdG9yMitjWzBdKmZhY3RvcjMrZFswXSpmYWN0b3I0LG91dFsxXT1hWzFdKmZhY3RvcjErYlsxXSpmYWN0b3IyK2NbMV0qZmFjdG9yMytkWzFdKmZhY3RvcjQsb3V0WzJdPWFbMl0qZmFjdG9yMStiWzJdKmZhY3RvcjIrY1syXSpmYWN0b3IzK2RbMl0qZmFjdG9yNCxvdXR9ZnVuY3Rpb24gcmFuZG9tKG91dCxzY2FsZSl7c2NhbGU9c2NhbGV8fDE7dmFyIHI9MipnbE1hdHJpeC5SQU5ET00oKSpNYXRoLlBJLHo9MipnbE1hdHJpeC5SQU5ET00oKS0xLHpTY2FsZT1NYXRoLnNxcnQoMS16KnopKnNjYWxlO3JldHVybiBvdXRbMF09TWF0aC5jb3MocikqelNjYWxlLG91dFsxXT1NYXRoLnNpbihyKSp6U2NhbGUsb3V0WzJdPXoqc2NhbGUsb3V0fWZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LGEsbSl7dmFyIHg9YVswXSx5PWFbMV0sej1hWzJdLHc9bVszXSp4K21bN10qeSttWzExXSp6K21bMTVdO3JldHVybiB3PXd8fDEsb3V0WzBdPShtWzBdKngrbVs0XSp5K21bOF0qeittWzEyXSkvdyxvdXRbMV09KG1bMV0qeCttWzVdKnkrbVs5XSp6K21bMTNdKS93LG91dFsyXT0obVsyXSp4K21bNl0qeSttWzEwXSp6K21bMTRdKS93LG91dH1mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCxhLG0pe3ZhciB4PWFbMF0seT1hWzFdLHo9YVsyXTtyZXR1cm4gb3V0WzBdPXgqbVswXSt5Km1bM10reiptWzZdLG91dFsxXT14Km1bMV0reSptWzRdK3oqbVs3XSxvdXRbMl09eCptWzJdK3kqbVs1XSt6Km1bOF0sb3V0fWZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LGEscSl7dmFyIHg9YVswXSx5PWFbMV0sej1hWzJdLHF4PXFbMF0scXk9cVsxXSxxej1xWzJdLHF3PXFbM10saXg9cXcqeCtxeSp6LXF6KnksaXk9cXcqeStxeip4LXF4KnosaXo9cXcqeitxeCp5LXF5KngsaXc9LXF4KngtcXkqeS1xeip6O3JldHVybiBvdXRbMF09aXgqcXcraXcqLXF4K2l5Ki1xei1peiotcXksb3V0WzFdPWl5KnF3K2l3Ki1xeStpeiotcXgtaXgqLXF6LG91dFsyXT1peipxdytpdyotcXoraXgqLXF5LWl5Ki1xeCxvdXR9ZnVuY3Rpb24gcm90YXRlWChvdXQsYSxiLGMpe3ZhciBwPVtdLHI9W107cmV0dXJuIHBbMF09YVswXS1iWzBdLHBbMV09YVsxXS1iWzFdLHBbMl09YVsyXS1iWzJdLHJbMF09cFswXSxyWzFdPXBbMV0qTWF0aC5jb3MoYyktcFsyXSpNYXRoLnNpbihjKSxyWzJdPXBbMV0qTWF0aC5zaW4oYykrcFsyXSpNYXRoLmNvcyhjKSxvdXRbMF09clswXStiWzBdLG91dFsxXT1yWzFdK2JbMV0sb3V0WzJdPXJbMl0rYlsyXSxvdXR9ZnVuY3Rpb24gcm90YXRlWShvdXQsYSxiLGMpe3ZhciBwPVtdLHI9W107cmV0dXJuIHBbMF09YVswXS1iWzBdLHBbMV09YVsxXS1iWzFdLHBbMl09YVsyXS1iWzJdLHJbMF09cFsyXSpNYXRoLnNpbihjKStwWzBdKk1hdGguY29zKGMpLHJbMV09cFsxXSxyWzJdPXBbMl0qTWF0aC5jb3MoYyktcFswXSpNYXRoLnNpbihjKSxvdXRbMF09clswXStiWzBdLG91dFsxXT1yWzFdK2JbMV0sb3V0WzJdPXJbMl0rYlsyXSxvdXR9ZnVuY3Rpb24gcm90YXRlWihvdXQsYSxiLGMpe3ZhciBwPVtdLHI9W107cmV0dXJuIHBbMF09YVswXS1iWzBdLHBbMV09YVsxXS1iWzFdLHBbMl09YVsyXS1iWzJdLHJbMF09cFswXSpNYXRoLmNvcyhjKS1wWzFdKk1hdGguc2luKGMpLHJbMV09cFswXSpNYXRoLnNpbihjKStwWzFdKk1hdGguY29zKGMpLHJbMl09cFsyXSxvdXRbMF09clswXStiWzBdLG91dFsxXT1yWzFdK2JbMV0sb3V0WzJdPXJbMl0rYlsyXSxvdXR9ZnVuY3Rpb24gYW5nbGUoYSxiKXt2YXIgdGVtcEE9ZnJvbVZhbHVlcyhhWzBdLGFbMV0sYVsyXSksdGVtcEI9ZnJvbVZhbHVlcyhiWzBdLGJbMV0sYlsyXSk7bm9ybWFsaXplKHRlbXBBLHRlbXBBKSxub3JtYWxpemUodGVtcEIsdGVtcEIpO3ZhciBjb3NpbmU9ZG90KHRlbXBBLHRlbXBCKTtyZXR1cm4gY29zaW5lPjE/MDpjb3NpbmU8LTE/TWF0aC5QSTpNYXRoLmFjb3MoY29zaW5lKX1mdW5jdGlvbiBzdHIoYSl7cmV0dXJuXCJ2ZWMzKFwiK2FbMF0rXCIsIFwiK2FbMV0rXCIsIFwiK2FbMl0rXCIpXCJ9ZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSxiKXtyZXR1cm4gYVswXT09PWJbMF0mJmFbMV09PT1iWzFdJiZhWzJdPT09YlsyXX1mdW5jdGlvbiBlcXVhbHMoYSxiKXt2YXIgYTA9YVswXSxhMT1hWzFdLGEyPWFbMl0sYjA9YlswXSxiMT1iWzFdLGIyPWJbMl07cmV0dXJuIE1hdGguYWJzKGEwLWIwKTw9Z2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGEwKSxNYXRoLmFicyhiMCkpJiZNYXRoLmFicyhhMS1iMSk8PWdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhMSksTWF0aC5hYnMoYjEpKSYmTWF0aC5hYnMoYTItYjIpPD1nbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYTIpLE1hdGguYWJzKGIyKSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZXhwb3J0cy5mb3JFYWNoPWV4cG9ydHMuc3FyTGVuPWV4cG9ydHMubGVuPWV4cG9ydHMuc3FyRGlzdD1leHBvcnRzLmRpc3Q9ZXhwb3J0cy5kaXY9ZXhwb3J0cy5tdWw9ZXhwb3J0cy5zdWI9dm9pZCAwLGV4cG9ydHMuY3JlYXRlPWNyZWF0ZSxleHBvcnRzLmNsb25lPWNsb25lLGV4cG9ydHMubGVuZ3RoPWxlbmd0aCxleHBvcnRzLmZyb21WYWx1ZXM9ZnJvbVZhbHVlcyxleHBvcnRzLmNvcHk9Y29weSxleHBvcnRzLnNldD1zZXQsZXhwb3J0cy5hZGQ9YWRkLGV4cG9ydHMuc3VidHJhY3Q9c3VidHJhY3QsZXhwb3J0cy5tdWx0aXBseT1tdWx0aXBseSxleHBvcnRzLmRpdmlkZT1kaXZpZGUsZXhwb3J0cy5jZWlsPWNlaWwsZXhwb3J0cy5mbG9vcj1mbG9vcixleHBvcnRzLm1pbj1taW4sZXhwb3J0cy5tYXg9bWF4LGV4cG9ydHMucm91bmQ9cm91bmQsZXhwb3J0cy5zY2FsZT1zY2FsZSxleHBvcnRzLnNjYWxlQW5kQWRkPXNjYWxlQW5kQWRkLGV4cG9ydHMuZGlzdGFuY2U9ZGlzdGFuY2UsZXhwb3J0cy5zcXVhcmVkRGlzdGFuY2U9c3F1YXJlZERpc3RhbmNlLGV4cG9ydHMuc3F1YXJlZExlbmd0aD1zcXVhcmVkTGVuZ3RoLGV4cG9ydHMubmVnYXRlPW5lZ2F0ZSxleHBvcnRzLmludmVyc2U9aW52ZXJzZSxleHBvcnRzLm5vcm1hbGl6ZT1ub3JtYWxpemUsZXhwb3J0cy5kb3Q9ZG90LGV4cG9ydHMuY3Jvc3M9Y3Jvc3MsZXhwb3J0cy5sZXJwPWxlcnAsZXhwb3J0cy5oZXJtaXRlPWhlcm1pdGUsZXhwb3J0cy5iZXppZXI9YmV6aWVyLGV4cG9ydHMucmFuZG9tPXJhbmRvbSxleHBvcnRzLnRyYW5zZm9ybU1hdDQ9dHJhbnNmb3JtTWF0NCxleHBvcnRzLnRyYW5zZm9ybU1hdDM9dHJhbnNmb3JtTWF0MyxleHBvcnRzLnRyYW5zZm9ybVF1YXQ9dHJhbnNmb3JtUXVhdCxleHBvcnRzLnJvdGF0ZVg9cm90YXRlWCxleHBvcnRzLnJvdGF0ZVk9cm90YXRlWSxleHBvcnRzLnJvdGF0ZVo9cm90YXRlWixleHBvcnRzLmFuZ2xlPWFuZ2xlLGV4cG9ydHMuc3RyPXN0cixleHBvcnRzLmV4YWN0RXF1YWxzPWV4YWN0RXF1YWxzLGV4cG9ydHMuZXF1YWxzPWVxdWFsczt2YXIgX2NvbW1vbj1fX3dlYnBhY2tfcmVxdWlyZV9fKDMpLGdsTWF0cml4PWZ1bmN0aW9uKG9iail7aWYob2JqJiZvYmouX19lc01vZHVsZSlyZXR1cm4gb2JqO3ZhciBuZXdPYmo9e307aWYobnVsbCE9b2JqKWZvcih2YXIga2V5IGluIG9iailPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLGtleSkmJihuZXdPYmpba2V5XT1vYmpba2V5XSk7cmV0dXJuIG5ld09iai5kZWZhdWx0PW9iaixuZXdPYmp9KF9jb21tb24pO2V4cG9ydHMuc3ViPXN1YnRyYWN0LGV4cG9ydHMubXVsPW11bHRpcGx5LGV4cG9ydHMuZGl2PWRpdmlkZSxleHBvcnRzLmRpc3Q9ZGlzdGFuY2UsZXhwb3J0cy5zcXJEaXN0PXNxdWFyZWREaXN0YW5jZSxleHBvcnRzLmxlbj1sZW5ndGgsZXhwb3J0cy5zcXJMZW49c3F1YXJlZExlbmd0aCxleHBvcnRzLmZvckVhY2g9ZnVuY3Rpb24oKXt2YXIgdmVjPWNyZWF0ZSgpO3JldHVybiBmdW5jdGlvbihhLHN0cmlkZSxvZmZzZXQsY291bnQsZm4sYXJnKXt2YXIgaT12b2lkIDAsbD12b2lkIDA7Zm9yKHN0cmlkZXx8KHN0cmlkZT0zKSxvZmZzZXR8fChvZmZzZXQ9MCksbD1jb3VudD9NYXRoLm1pbihjb3VudCpzdHJpZGUrb2Zmc2V0LGEubGVuZ3RoKTphLmxlbmd0aCxpPW9mZnNldDtpPGw7aSs9c3RyaWRlKXZlY1swXT1hW2ldLHZlY1sxXT1hW2krMV0sdmVjWzJdPWFbaSsyXSxmbih2ZWMsdmVjLGFyZyksYVtpXT12ZWNbMF0sYVtpKzFdPXZlY1sxXSxhW2krMl09dmVjWzJdO3JldHVybiBhfX0oKX0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gY3JlYXRlKCl7dmFyIG91dD1uZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtyZXR1cm4gb3V0WzBdPTAsb3V0WzFdPTAsb3V0WzJdPTAsb3V0WzNdPTAsb3V0fWZ1bmN0aW9uIGNsb25lKGEpe3ZhciBvdXQ9bmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7cmV0dXJuIG91dFswXT1hWzBdLG91dFsxXT1hWzFdLG91dFsyXT1hWzJdLG91dFszXT1hWzNdLG91dH1mdW5jdGlvbiBmcm9tVmFsdWVzKHgseSx6LHcpe3ZhciBvdXQ9bmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7cmV0dXJuIG91dFswXT14LG91dFsxXT15LG91dFsyXT16LG91dFszXT13LG91dH1mdW5jdGlvbiBjb3B5KG91dCxhKXtyZXR1cm4gb3V0WzBdPWFbMF0sb3V0WzFdPWFbMV0sb3V0WzJdPWFbMl0sb3V0WzNdPWFbM10sb3V0fWZ1bmN0aW9uIHNldChvdXQseCx5LHosdyl7cmV0dXJuIG91dFswXT14LG91dFsxXT15LG91dFsyXT16LG91dFszXT13LG91dH1mdW5jdGlvbiBhZGQob3V0LGEsYil7cmV0dXJuIG91dFswXT1hWzBdK2JbMF0sb3V0WzFdPWFbMV0rYlsxXSxvdXRbMl09YVsyXStiWzJdLG91dFszXT1hWzNdK2JbM10sb3V0fWZ1bmN0aW9uIHN1YnRyYWN0KG91dCxhLGIpe3JldHVybiBvdXRbMF09YVswXS1iWzBdLG91dFsxXT1hWzFdLWJbMV0sb3V0WzJdPWFbMl0tYlsyXSxvdXRbM109YVszXS1iWzNdLG91dH1mdW5jdGlvbiBtdWx0aXBseShvdXQsYSxiKXtyZXR1cm4gb3V0WzBdPWFbMF0qYlswXSxvdXRbMV09YVsxXSpiWzFdLG91dFsyXT1hWzJdKmJbMl0sb3V0WzNdPWFbM10qYlszXSxvdXR9ZnVuY3Rpb24gZGl2aWRlKG91dCxhLGIpe3JldHVybiBvdXRbMF09YVswXS9iWzBdLG91dFsxXT1hWzFdL2JbMV0sb3V0WzJdPWFbMl0vYlsyXSxvdXRbM109YVszXS9iWzNdLG91dH1mdW5jdGlvbiBjZWlsKG91dCxhKXtyZXR1cm4gb3V0WzBdPU1hdGguY2VpbChhWzBdKSxvdXRbMV09TWF0aC5jZWlsKGFbMV0pLG91dFsyXT1NYXRoLmNlaWwoYVsyXSksb3V0WzNdPU1hdGguY2VpbChhWzNdKSxvdXR9ZnVuY3Rpb24gZmxvb3Iob3V0LGEpe3JldHVybiBvdXRbMF09TWF0aC5mbG9vcihhWzBdKSxvdXRbMV09TWF0aC5mbG9vcihhWzFdKSxvdXRbMl09TWF0aC5mbG9vcihhWzJdKSxvdXRbM109TWF0aC5mbG9vcihhWzNdKSxvdXR9ZnVuY3Rpb24gbWluKG91dCxhLGIpe3JldHVybiBvdXRbMF09TWF0aC5taW4oYVswXSxiWzBdKSxvdXRbMV09TWF0aC5taW4oYVsxXSxiWzFdKSxvdXRbMl09TWF0aC5taW4oYVsyXSxiWzJdKSxvdXRbM109TWF0aC5taW4oYVszXSxiWzNdKSxvdXR9ZnVuY3Rpb24gbWF4KG91dCxhLGIpe3JldHVybiBvdXRbMF09TWF0aC5tYXgoYVswXSxiWzBdKSxvdXRbMV09TWF0aC5tYXgoYVsxXSxiWzFdKSxvdXRbMl09TWF0aC5tYXgoYVsyXSxiWzJdKSxvdXRbM109TWF0aC5tYXgoYVszXSxiWzNdKSxvdXR9ZnVuY3Rpb24gcm91bmQob3V0LGEpe3JldHVybiBvdXRbMF09TWF0aC5yb3VuZChhWzBdKSxvdXRbMV09TWF0aC5yb3VuZChhWzFdKSxvdXRbMl09TWF0aC5yb3VuZChhWzJdKSxvdXRbM109TWF0aC5yb3VuZChhWzNdKSxvdXR9ZnVuY3Rpb24gc2NhbGUob3V0LGEsYil7cmV0dXJuIG91dFswXT1hWzBdKmIsb3V0WzFdPWFbMV0qYixvdXRbMl09YVsyXSpiLG91dFszXT1hWzNdKmIsb3V0fWZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCxhLGIsc2NhbGUpe3JldHVybiBvdXRbMF09YVswXStiWzBdKnNjYWxlLG91dFsxXT1hWzFdK2JbMV0qc2NhbGUsb3V0WzJdPWFbMl0rYlsyXSpzY2FsZSxvdXRbM109YVszXStiWzNdKnNjYWxlLG91dH1mdW5jdGlvbiBkaXN0YW5jZShhLGIpe3ZhciB4PWJbMF0tYVswXSx5PWJbMV0tYVsxXSx6PWJbMl0tYVsyXSx3PWJbM10tYVszXTtyZXR1cm4gTWF0aC5zcXJ0KHgqeCt5Knkreip6K3cqdyl9ZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsYil7dmFyIHg9YlswXS1hWzBdLHk9YlsxXS1hWzFdLHo9YlsyXS1hWzJdLHc9YlszXS1hWzNdO3JldHVybiB4KngreSp5K3oqeit3Knd9ZnVuY3Rpb24gbGVuZ3RoKGEpe3ZhciB4PWFbMF0seT1hWzFdLHo9YVsyXSx3PWFbM107cmV0dXJuIE1hdGguc3FydCh4KngreSp5K3oqeit3KncpfWZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSl7dmFyIHg9YVswXSx5PWFbMV0sej1hWzJdLHc9YVszXTtyZXR1cm4geCp4K3kqeSt6Knordyp3fWZ1bmN0aW9uIG5lZ2F0ZShvdXQsYSl7cmV0dXJuIG91dFswXT0tYVswXSxvdXRbMV09LWFbMV0sb3V0WzJdPS1hWzJdLG91dFszXT0tYVszXSxvdXR9ZnVuY3Rpb24gaW52ZXJzZShvdXQsYSl7cmV0dXJuIG91dFswXT0xL2FbMF0sb3V0WzFdPTEvYVsxXSxvdXRbMl09MS9hWzJdLG91dFszXT0xL2FbM10sb3V0fWZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsYSl7dmFyIHg9YVswXSx5PWFbMV0sej1hWzJdLHc9YVszXSxsZW49eCp4K3kqeSt6Knordyp3O3JldHVybiBsZW4+MCYmKGxlbj0xL01hdGguc3FydChsZW4pLG91dFswXT14KmxlbixvdXRbMV09eSpsZW4sb3V0WzJdPXoqbGVuLG91dFszXT13Kmxlbiksb3V0fWZ1bmN0aW9uIGRvdChhLGIpe3JldHVybiBhWzBdKmJbMF0rYVsxXSpiWzFdK2FbMl0qYlsyXSthWzNdKmJbM119ZnVuY3Rpb24gbGVycChvdXQsYSxiLHQpe3ZhciBheD1hWzBdLGF5PWFbMV0sYXo9YVsyXSxhdz1hWzNdO3JldHVybiBvdXRbMF09YXgrdCooYlswXS1heCksb3V0WzFdPWF5K3QqKGJbMV0tYXkpLG91dFsyXT1heit0KihiWzJdLWF6KSxvdXRbM109YXcrdCooYlszXS1hdyksb3V0fWZ1bmN0aW9uIHJhbmRvbShvdXQsdmVjdG9yU2NhbGUpe3JldHVybiB2ZWN0b3JTY2FsZT12ZWN0b3JTY2FsZXx8MSxvdXRbMF09Z2xNYXRyaXguUkFORE9NKCksb3V0WzFdPWdsTWF0cml4LlJBTkRPTSgpLG91dFsyXT1nbE1hdHJpeC5SQU5ET00oKSxvdXRbM109Z2xNYXRyaXguUkFORE9NKCksbm9ybWFsaXplKG91dCxvdXQpLHNjYWxlKG91dCxvdXQsdmVjdG9yU2NhbGUpLG91dH1mdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCxhLG0pe3ZhciB4PWFbMF0seT1hWzFdLHo9YVsyXSx3PWFbM107cmV0dXJuIG91dFswXT1tWzBdKngrbVs0XSp5K21bOF0qeittWzEyXSp3LG91dFsxXT1tWzFdKngrbVs1XSp5K21bOV0qeittWzEzXSp3LG91dFsyXT1tWzJdKngrbVs2XSp5K21bMTBdKnorbVsxNF0qdyxvdXRbM109bVszXSp4K21bN10qeSttWzExXSp6K21bMTVdKncsb3V0fWZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LGEscSl7dmFyIHg9YVswXSx5PWFbMV0sej1hWzJdLHF4PXFbMF0scXk9cVsxXSxxej1xWzJdLHF3PXFbM10saXg9cXcqeCtxeSp6LXF6KnksaXk9cXcqeStxeip4LXF4KnosaXo9cXcqeitxeCp5LXF5KngsaXc9LXF4KngtcXkqeS1xeip6O3JldHVybiBvdXRbMF09aXgqcXcraXcqLXF4K2l5Ki1xei1peiotcXksb3V0WzFdPWl5KnF3K2l3Ki1xeStpeiotcXgtaXgqLXF6LG91dFsyXT1peipxdytpdyotcXoraXgqLXF5LWl5Ki1xeCxvdXRbM109YVszXSxvdXR9ZnVuY3Rpb24gc3RyKGEpe3JldHVyblwidmVjNChcIithWzBdK1wiLCBcIithWzFdK1wiLCBcIithWzJdK1wiLCBcIithWzNdK1wiKVwifWZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsYil7cmV0dXJuIGFbMF09PT1iWzBdJiZhWzFdPT09YlsxXSYmYVsyXT09PWJbMl0mJmFbM109PT1iWzNdfWZ1bmN0aW9uIGVxdWFscyhhLGIpe3ZhciBhMD1hWzBdLGExPWFbMV0sYTI9YVsyXSxhMz1hWzNdLGIwPWJbMF0sYjE9YlsxXSxiMj1iWzJdLGIzPWJbM107cmV0dXJuIE1hdGguYWJzKGEwLWIwKTw9Z2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGEwKSxNYXRoLmFicyhiMCkpJiZNYXRoLmFicyhhMS1iMSk8PWdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhMSksTWF0aC5hYnMoYjEpKSYmTWF0aC5hYnMoYTItYjIpPD1nbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYTIpLE1hdGguYWJzKGIyKSkmJk1hdGguYWJzKGEzLWIzKTw9Z2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGEzKSxNYXRoLmFicyhiMykpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGV4cG9ydHMuZm9yRWFjaD1leHBvcnRzLnNxckxlbj1leHBvcnRzLmxlbj1leHBvcnRzLnNxckRpc3Q9ZXhwb3J0cy5kaXN0PWV4cG9ydHMuZGl2PWV4cG9ydHMubXVsPWV4cG9ydHMuc3ViPXZvaWQgMCxleHBvcnRzLmNyZWF0ZT1jcmVhdGUsZXhwb3J0cy5jbG9uZT1jbG9uZSxleHBvcnRzLmZyb21WYWx1ZXM9ZnJvbVZhbHVlcyxleHBvcnRzLmNvcHk9Y29weSxleHBvcnRzLnNldD1zZXQsZXhwb3J0cy5hZGQ9YWRkLGV4cG9ydHMuc3VidHJhY3Q9c3VidHJhY3QsZXhwb3J0cy5tdWx0aXBseT1tdWx0aXBseSxleHBvcnRzLmRpdmlkZT1kaXZpZGUsZXhwb3J0cy5jZWlsPWNlaWwsZXhwb3J0cy5mbG9vcj1mbG9vcixleHBvcnRzLm1pbj1taW4sZXhwb3J0cy5tYXg9bWF4LGV4cG9ydHMucm91bmQ9cm91bmQsZXhwb3J0cy5zY2FsZT1zY2FsZSxleHBvcnRzLnNjYWxlQW5kQWRkPXNjYWxlQW5kQWRkLGV4cG9ydHMuZGlzdGFuY2U9ZGlzdGFuY2UsZXhwb3J0cy5zcXVhcmVkRGlzdGFuY2U9c3F1YXJlZERpc3RhbmNlLGV4cG9ydHMubGVuZ3RoPWxlbmd0aCxleHBvcnRzLnNxdWFyZWRMZW5ndGg9c3F1YXJlZExlbmd0aCxleHBvcnRzLm5lZ2F0ZT1uZWdhdGUsZXhwb3J0cy5pbnZlcnNlPWludmVyc2UsZXhwb3J0cy5ub3JtYWxpemU9bm9ybWFsaXplLGV4cG9ydHMuZG90PWRvdCxleHBvcnRzLmxlcnA9bGVycCxleHBvcnRzLnJhbmRvbT1yYW5kb20sZXhwb3J0cy50cmFuc2Zvcm1NYXQ0PXRyYW5zZm9ybU1hdDQsZXhwb3J0cy50cmFuc2Zvcm1RdWF0PXRyYW5zZm9ybVF1YXQsZXhwb3J0cy5zdHI9c3RyLGV4cG9ydHMuZXhhY3RFcXVhbHM9ZXhhY3RFcXVhbHMsZXhwb3J0cy5lcXVhbHM9ZXF1YWxzO3ZhciBfY29tbW9uPV9fd2VicGFja19yZXF1aXJlX18oMyksZ2xNYXRyaXg9ZnVuY3Rpb24ob2JqKXtpZihvYmomJm9iai5fX2VzTW9kdWxlKXJldHVybiBvYmo7dmFyIG5ld09iaj17fTtpZihudWxsIT1vYmopZm9yKHZhciBrZXkgaW4gb2JqKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosa2V5KSYmKG5ld09ialtrZXldPW9ialtrZXldKTtyZXR1cm4gbmV3T2JqLmRlZmF1bHQ9b2JqLG5ld09ian0oX2NvbW1vbik7ZXhwb3J0cy5zdWI9c3VidHJhY3QsZXhwb3J0cy5tdWw9bXVsdGlwbHksZXhwb3J0cy5kaXY9ZGl2aWRlLGV4cG9ydHMuZGlzdD1kaXN0YW5jZSxleHBvcnRzLnNxckRpc3Q9c3F1YXJlZERpc3RhbmNlLGV4cG9ydHMubGVuPWxlbmd0aCxleHBvcnRzLnNxckxlbj1zcXVhcmVkTGVuZ3RoLGV4cG9ydHMuZm9yRWFjaD1mdW5jdGlvbigpe3ZhciB2ZWM9Y3JlYXRlKCk7cmV0dXJuIGZ1bmN0aW9uKGEsc3RyaWRlLG9mZnNldCxjb3VudCxmbixhcmcpe3ZhciBpPXZvaWQgMCxsPXZvaWQgMDtmb3Ioc3RyaWRlfHwoc3RyaWRlPTQpLG9mZnNldHx8KG9mZnNldD0wKSxsPWNvdW50P01hdGgubWluKGNvdW50KnN0cmlkZStvZmZzZXQsYS5sZW5ndGgpOmEubGVuZ3RoLGk9b2Zmc2V0O2k8bDtpKz1zdHJpZGUpdmVjWzBdPWFbaV0sdmVjWzFdPWFbaSsxXSx2ZWNbMl09YVtpKzJdLHZlY1szXT1hW2krM10sZm4odmVjLHZlYyxhcmcpLGFbaV09dmVjWzBdLGFbaSsxXT12ZWNbMV0sYVtpKzJdPXZlY1syXSxhW2krM109dmVjWzNdO3JldHVybiBhfX0oKX0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7bW9kdWxlLmV4cG9ydHM9e0FDVElWRV9BVFRSSUJVVEVTOjM1NzIxLEFDVElWRV9BVFRSSUJVVEVfTUFYX0xFTkdUSDozNTcyMixBQ1RJVkVfVEVYVFVSRTozNDAxNixBQ1RJVkVfVU5JRk9STVM6MzU3MTgsQUNUSVZFX1VOSUZPUk1fTUFYX0xFTkdUSDozNTcxOSxBTElBU0VEX0xJTkVfV0lEVEhfUkFOR0U6MzM5MDIsQUxJQVNFRF9QT0lOVF9TSVpFX1JBTkdFOjMzOTAxLEFMUEhBOjY0MDYsQUxQSEFfQklUUzozNDEzLEFMV0FZUzo1MTksQVJSQVlfQlVGRkVSOjM0OTYyLEFSUkFZX0JVRkZFUl9CSU5ESU5HOjM0OTY0LEFUVEFDSEVEX1NIQURFUlM6MzU3MTcsQkFDSzoxMDI5LEJMRU5EOjMwNDIsQkxFTkRfQ09MT1I6MzI3NzMsQkxFTkRfRFNUX0FMUEhBOjMyOTcwLEJMRU5EX0RTVF9SR0I6MzI5NjgsQkxFTkRfRVFVQVRJT046MzI3NzcsQkxFTkRfRVFVQVRJT05fQUxQSEE6MzQ4NzcsQkxFTkRfRVFVQVRJT05fUkdCOjMyNzc3LEJMRU5EX1NSQ19BTFBIQTozMjk3MSxCTEVORF9TUkNfUkdCOjMyOTY5LEJMVUVfQklUUzozNDEyLEJPT0w6MzU2NzAsQk9PTF9WRUMyOjM1NjcxLEJPT0xfVkVDMzozNTY3MixCT09MX1ZFQzQ6MzU2NzMsQlJPV1NFUl9ERUZBVUxUX1dFQkdMOjM3NDQ0LEJVRkZFUl9TSVpFOjM0NjYwLEJVRkZFUl9VU0FHRTozNDY2MSxCWVRFOjUxMjAsQ0NXOjIzMDUsQ0xBTVBfVE9fRURHRTozMzA3MSxDT0xPUl9BVFRBQ0hNRU5UMDozNjA2NCxDT0xPUl9CVUZGRVJfQklUOjE2Mzg0LENPTE9SX0NMRUFSX1ZBTFVFOjMxMDYsQ09MT1JfV1JJVEVNQVNLOjMxMDcsQ09NUElMRV9TVEFUVVM6MzU3MTMsQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFM6MzQ0NjcsQ09OU1RBTlRfQUxQSEE6MzI3NzEsQ09OU1RBTlRfQ09MT1I6MzI3NjksQ09OVEVYVF9MT1NUX1dFQkdMOjM3NDQyLENVTExfRkFDRToyODg0LENVTExfRkFDRV9NT0RFOjI4ODUsQ1VSUkVOVF9QUk9HUkFNOjM1NzI1LENVUlJFTlRfVkVSVEVYX0FUVFJJQjozNDM0MixDVzoyMzA0LERFQ1I6NzY4MyxERUNSX1dSQVA6MzQwNTYsREVMRVRFX1NUQVRVUzozNTcxMixERVBUSF9BVFRBQ0hNRU5UOjM2MDk2LERFUFRIX0JJVFM6MzQxNCxERVBUSF9CVUZGRVJfQklUOjI1NixERVBUSF9DTEVBUl9WQUxVRToyOTMxLERFUFRIX0NPTVBPTkVOVDo2NDAyLFJFRDo2NDAzLERFUFRIX0NPTVBPTkVOVDE2OjMzMTg5LERFUFRIX0ZVTkM6MjkzMixERVBUSF9SQU5HRToyOTI4LERFUFRIX1NURU5DSUw6MzQwNDEsREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UOjMzMzA2LERFUFRIX1RFU1Q6MjkyOSxERVBUSF9XUklURU1BU0s6MjkzMCxESVRIRVI6MzAyNCxET05UX0NBUkU6NDM1MixEU1RfQUxQSEE6NzcyLERTVF9DT0xPUjo3NzQsRFlOQU1JQ19EUkFXOjM1MDQ4LEVMRU1FTlRfQVJSQVlfQlVGRkVSOjM0OTYzLEVMRU1FTlRfQVJSQVlfQlVGRkVSX0JJTkRJTkc6MzQ5NjUsRVFVQUw6NTE0LEZBU1RFU1Q6NDM1MyxGTE9BVDo1MTI2LEZMT0FUX01BVDI6MzU2NzQsRkxPQVRfTUFUMzozNTY3NSxGTE9BVF9NQVQ0OjM1Njc2LEZMT0FUX1ZFQzI6MzU2NjQsRkxPQVRfVkVDMzozNTY2NSxGTE9BVF9WRUM0OjM1NjY2LEZSQUdNRU5UX1NIQURFUjozNTYzMixGUkFNRUJVRkZFUjozNjE2MCxGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9OQU1FOjM2MDQ5LEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX1RZUEU6MzYwNDgsRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0NVQkVfTUFQX0ZBQ0U6MzYwNTEsRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0xFVkVMOjM2MDUwLEZSQU1FQlVGRkVSX0JJTkRJTkc6MzYwMDYsRlJBTUVCVUZGRVJfQ09NUExFVEU6MzYwNTMsRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UOjM2MDU0LEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUzozNjA1NyxGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVDozNjA1NSxGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDozNjA2MSxGUk9OVDoxMDI4LEZST05UX0FORF9CQUNLOjEwMzIsRlJPTlRfRkFDRToyODg2LEZVTkNfQUREOjMyNzc0LEZVTkNfUkVWRVJTRV9TVUJUUkFDVDozMjc3OSxGVU5DX1NVQlRSQUNUOjMyNzc4LEdFTkVSQVRFX01JUE1BUF9ISU5UOjMzMTcwLEdFUVVBTDo1MTgsR1JFQVRFUjo1MTYsR1JFRU5fQklUUzozNDExLEhJR0hfRkxPQVQ6MzYzMzgsSElHSF9JTlQ6MzYzNDEsSU5DUjo3NjgyLElOQ1JfV1JBUDozNDA1NSxJTkZPX0xPR19MRU5HVEg6MzU3MTYsSU5UOjUxMjQsSU5UX1ZFQzI6MzU2NjcsSU5UX1ZFQzM6MzU2NjgsSU5UX1ZFQzQ6MzU2NjksSU5WQUxJRF9FTlVNOjEyODAsSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046MTI4NixJTlZBTElEX09QRVJBVElPTjoxMjgyLElOVkFMSURfVkFMVUU6MTI4MSxJTlZFUlQ6NTM4NixLRUVQOjc2ODAsTEVRVUFMOjUxNSxMRVNTOjUxMyxMSU5FQVI6OTcyOSxMSU5FQVJfTUlQTUFQX0xJTkVBUjo5OTg3LExJTkVBUl9NSVBNQVBfTkVBUkVTVDo5OTg1LExJTkVTOjEsTElORV9MT09QOjIsTElORV9TVFJJUDozLExJTkVfV0lEVEg6Mjg0OSxMSU5LX1NUQVRVUzozNTcxNCxMT1dfRkxPQVQ6MzYzMzYsTE9XX0lOVDozNjMzOSxMVU1JTkFOQ0U6NjQwOSxMVU1JTkFOQ0VfQUxQSEE6NjQxMCxNQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUzozNTY2MSxNQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFOjM0MDc2LE1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlM6MzYzNDksTUFYX1JFTkRFUkJVRkZFUl9TSVpFOjM0MDI0LE1BWF9URVhUVVJFX0lNQUdFX1VOSVRTOjM0OTMwLE1BWF9URVhUVVJFX1NJWkU6MzM3OSxNQVhfVkFSWUlOR19WRUNUT1JTOjM2MzQ4LE1BWF9WRVJURVhfQVRUUklCUzozNDkyMSxNQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFM6MzU2NjAsTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlM6MzYzNDcsTUFYX1ZJRVdQT1JUX0RJTVM6MzM4NixNRURJVU1fRkxPQVQ6MzYzMzcsTUVESVVNX0lOVDozNjM0MCxNSVJST1JFRF9SRVBFQVQ6MzM2NDgsTkVBUkVTVDo5NzI4LE5FQVJFU1RfTUlQTUFQX0xJTkVBUjo5OTg2LE5FQVJFU1RfTUlQTUFQX05FQVJFU1Q6OTk4NCxORVZFUjo1MTIsTklDRVNUOjQzNTQsTk9ORTowLE5PVEVRVUFMOjUxNyxOT19FUlJPUjowLE5VTV9DT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUzozNDQ2NixPTkU6MSxPTkVfTUlOVVNfQ09OU1RBTlRfQUxQSEE6MzI3NzIsT05FX01JTlVTX0NPTlNUQU5UX0NPTE9SOjMyNzcwLE9ORV9NSU5VU19EU1RfQUxQSEE6NzczLE9ORV9NSU5VU19EU1RfQ09MT1I6Nzc1LE9ORV9NSU5VU19TUkNfQUxQSEE6NzcxLE9ORV9NSU5VU19TUkNfQ09MT1I6NzY5LE9VVF9PRl9NRU1PUlk6MTI4NSxQQUNLX0FMSUdOTUVOVDozMzMzLFBPSU5UUzowLFBPTFlHT05fT0ZGU0VUX0ZBQ1RPUjozMjgyNCxQT0xZR09OX09GRlNFVF9GSUxMOjMyODIzLFBPTFlHT05fT0ZGU0VUX1VOSVRTOjEwNzUyLFJFRF9CSVRTOjM0MTAsUkVOREVSQlVGRkVSOjM2MTYxLFJFTkRFUkJVRkZFUl9BTFBIQV9TSVpFOjM2MTc5LFJFTkRFUkJVRkZFUl9CSU5ESU5HOjM2MDA3LFJFTkRFUkJVRkZFUl9CTFVFX1NJWkU6MzYxNzgsUkVOREVSQlVGRkVSX0RFUFRIX1NJWkU6MzYxODAsUkVOREVSQlVGRkVSX0dSRUVOX1NJWkU6MzYxNzcsUkVOREVSQlVGRkVSX0hFSUdIVDozNjE2MyxSRU5ERVJCVUZGRVJfSU5URVJOQUxfRk9STUFUOjM2MTY0LFJFTkRFUkJVRkZFUl9SRURfU0laRTozNjE3NixSRU5ERVJCVUZGRVJfU1RFTkNJTF9TSVpFOjM2MTgxLFJFTkRFUkJVRkZFUl9XSURUSDozNjE2MixSRU5ERVJFUjo3OTM3LFJFUEVBVDoxMDQ5NyxSRVBMQUNFOjc2ODEsUkdCOjY0MDcsUkdCNV9BMTozMjg1NSxSR0I1NjU6MzYxOTQsUkdCQTo2NDA4LFJHQkE0OjMyODU0LFNBTVBMRVJfMkQ6MzU2NzgsU0FNUExFUl9DVUJFOjM1NjgwLFNBTVBMRVM6MzI5MzcsU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFOjMyOTI2LFNBTVBMRV9CVUZGRVJTOjMyOTM2LFNBTVBMRV9DT1ZFUkFHRTozMjkyOCxTQU1QTEVfQ09WRVJBR0VfSU5WRVJUOjMyOTM5LFNBTVBMRV9DT1ZFUkFHRV9WQUxVRTozMjkzOCxTQ0lTU09SX0JPWDozMDg4LFNDSVNTT1JfVEVTVDozMDg5LFNIQURFUl9DT01QSUxFUjozNjM0NixTSEFERVJfU09VUkNFX0xFTkdUSDozNTcyMCxTSEFERVJfVFlQRTozNTY2MyxTSEFESU5HX0xBTkdVQUdFX1ZFUlNJT046MzU3MjQsU0hPUlQ6NTEyMixTUkNfQUxQSEE6NzcwLFNSQ19BTFBIQV9TQVRVUkFURTo3NzYsU1JDX0NPTE9SOjc2OCxTVEFUSUNfRFJBVzozNTA0NCxTVEVOQ0lMX0FUVEFDSE1FTlQ6MzYxMjgsU1RFTkNJTF9CQUNLX0ZBSUw6MzQ4MTcsU1RFTkNJTF9CQUNLX0ZVTkM6MzQ4MTYsU1RFTkNJTF9CQUNLX1BBU1NfREVQVEhfRkFJTDozNDgxOCxTVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9QQVNTOjM0ODE5LFNURU5DSUxfQkFDS19SRUY6MzYwMDMsU1RFTkNJTF9CQUNLX1ZBTFVFX01BU0s6MzYwMDQsU1RFTkNJTF9CQUNLX1dSSVRFTUFTSzozNjAwNSxTVEVOQ0lMX0JJVFM6MzQxNSxTVEVOQ0lMX0JVRkZFUl9CSVQ6MTAyNCxTVEVOQ0lMX0NMRUFSX1ZBTFVFOjI5NjEsU1RFTkNJTF9GQUlMOjI5NjQsU1RFTkNJTF9GVU5DOjI5NjIsU1RFTkNJTF9JTkRFWDo2NDAxLFNURU5DSUxfSU5ERVg4OjM2MTY4LFNURU5DSUxfUEFTU19ERVBUSF9GQUlMOjI5NjUsU1RFTkNJTF9QQVNTX0RFUFRIX1BBU1M6Mjk2NixTVEVOQ0lMX1JFRjoyOTY3LFNURU5DSUxfVEVTVDoyOTYwLFNURU5DSUxfVkFMVUVfTUFTSzoyOTYzLFNURU5DSUxfV1JJVEVNQVNLOjI5NjgsU1RSRUFNX0RSQVc6MzUwNDAsU1VCUElYRUxfQklUUzozNDA4LFRFWFRVUkU6NTg5MCxURVhUVVJFMDozMzk4NCxURVhUVVJFMTozMzk4NSxURVhUVVJFMjozMzk4NixURVhUVVJFMzozMzk4NyxURVhUVVJFNDozMzk4OCxURVhUVVJFNTozMzk4OSxURVhUVVJFNjozMzk5MCxURVhUVVJFNzozMzk5MSxURVhUVVJFODozMzk5MixURVhUVVJFOTozMzk5MyxURVhUVVJFMTA6MzM5OTQsVEVYVFVSRTExOjMzOTk1LFRFWFRVUkUxMjozMzk5NixURVhUVVJFMTM6MzM5OTcsVEVYVFVSRTE0OjMzOTk4LFRFWFRVUkUxNTozMzk5OSxURVhUVVJFMTY6MzRlMyxURVhUVVJFMTc6MzQwMDEsVEVYVFVSRTE4OjM0MDAyLFRFWFRVUkUxOTozNDAwMyxURVhUVVJFMjA6MzQwMDQsVEVYVFVSRTIxOjM0MDA1LFRFWFRVUkUyMjozNDAwNixURVhUVVJFMjM6MzQwMDcsVEVYVFVSRTI0OjM0MDA4LFRFWFRVUkUyNTozNDAwOSxURVhUVVJFMjY6MzQwMTAsVEVYVFVSRTI3OjM0MDExLFRFWFRVUkUyODozNDAxMixURVhUVVJFMjk6MzQwMTMsVEVYVFVSRTMwOjM0MDE0LFRFWFRVUkUzMTozNDAxNSxURVhUVVJFXzJEOjM1NTMsVEVYVFVSRV9CSU5ESU5HXzJEOjMyODczLFRFWFRVUkVfQklORElOR19DVUJFX01BUDozNDA2OCxURVhUVVJFX0NVQkVfTUFQOjM0MDY3LFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWDozNDA3MCxURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1k6MzQwNzIsVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aOjM0MDc0LFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWDozNDA2OSxURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1k6MzQwNzEsVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aOjM0MDczLFRFWFRVUkVfTUFHX0ZJTFRFUjoxMDI0MCxURVhUVVJFX01JTl9GSUxURVI6MTAyNDEsVEVYVFVSRV9XUkFQX1M6MTAyNDIsVEVYVFVSRV9XUkFQX1Q6MTAyNDMsVFJJQU5HTEVTOjQsVFJJQU5HTEVfRkFOOjYsVFJJQU5HTEVfU1RSSVA6NSxVTlBBQ0tfQUxJR05NRU5UOjMzMTcsVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTDozNzQ0MyxVTlBBQ0tfRkxJUF9ZX1dFQkdMOjM3NDQwLFVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTDozNzQ0MSxVTlNJR05FRF9CWVRFOjUxMjEsVU5TSUdORURfSU5UOjUxMjUsVU5TSUdORURfU0hPUlQ6NTEyMyxVTlNJR05FRF9TSE9SVF80XzRfNF80OjMyODE5LFVOU0lHTkVEX1NIT1JUXzVfNV81XzE6MzI4MjAsVU5TSUdORURfU0hPUlRfNV82XzU6MzM2MzUsVkFMSURBVEVfU1RBVFVTOjM1NzE1LFZFTkRPUjo3OTM2LFZFUlNJT046NzkzOCxWRVJURVhfQVRUUklCX0FSUkFZX0JVRkZFUl9CSU5ESU5HOjM0OTc1LFZFUlRFWF9BVFRSSUJfQVJSQVlfRU5BQkxFRDozNDMzOCxWRVJURVhfQVRUUklCX0FSUkFZX05PUk1BTElaRUQ6MzQ5MjIsVkVSVEVYX0FUVFJJQl9BUlJBWV9QT0lOVEVSOjM0MzczLFZFUlRFWF9BVFRSSUJfQVJSQVlfU0laRTozNDMzOSxWRVJURVhfQVRUUklCX0FSUkFZX1NUUklERTozNDM0MCxWRVJURVhfQVRUUklCX0FSUkFZX1RZUEU6MzQzNDEsVkVSVEVYX1NIQURFUjozNTYzMyxWSUVXUE9SVDoyOTc4LFpFUk86MCxSODozMzMyMX19LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGV4cG9ydHMuZGVmYXVsdD1mdW5jdGlvbihnbCxzaGFkZXJQcm9ncmFtLG5hbWUpe3JldHVybiB2b2lkIDA9PT1zaGFkZXJQcm9ncmFtLmNhY2hlQXR0cmliTG9jJiYoc2hhZGVyUHJvZ3JhbS5jYWNoZUF0dHJpYkxvYz17fSksdm9pZCAwPT09c2hhZGVyUHJvZ3JhbS5jYWNoZUF0dHJpYkxvY1tuYW1lXSYmKHNoYWRlclByb2dyYW0uY2FjaGVBdHRyaWJMb2NbbmFtZV09Z2wuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSxuYW1lKSksc2hhZGVyUHJvZ3JhbS5jYWNoZUF0dHJpYkxvY1tuYW1lXX19LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpc1Bvd2VyT2ZUd28oeCl7cmV0dXJuIDAhPT14JiYhKHgmeC0xKX1mdW5jdGlvbiBpc1NvdXJjZVBvd2VyT2ZUd28ob2JqKXt2YXIgdz1vYmoud2lkdGh8fG9iai52aWRlb1dpZHRoLGg9b2JqLmhlaWdodHx8b2JqLnZpZGVvSGVpZ2h0O3JldHVybiEoIXd8fCFoKSYmKGlzUG93ZXJPZlR3byh3KSYmaXNQb3dlck9mVHdvKGgpKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ITEsZGVzY3JpcHRvci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvciYmKGRlc2NyaXB0b3Iud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcil9fXJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtyZXR1cm4gcHJvdG9Qcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyksc3RhdGljUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpLENvbnN0cnVjdG9yfX0oKSxfR0xUb29sPV9fd2VicGFja19yZXF1aXJlX18oMCksX0dMVG9vbDI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR0xUb29sKSxfV2ViZ2xOdW1iZXI9X193ZWJwYWNrX3JlcXVpcmVfXyg4KSxnbD0oX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfV2ViZ2xOdW1iZXIpLHZvaWQgMCksR0xUZXh0dXJlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gR0xUZXh0dXJlKG1Tb3VyY2Upe3ZhciBpc1RleHR1cmU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXSxtUGFyYW1ldGVycz1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e307aWYoX2NsYXNzQ2FsbENoZWNrKHRoaXMsR0xUZXh0dXJlKSxnbD1fR0xUb29sMi5kZWZhdWx0LmdsLGlzVGV4dHVyZSl0aGlzLl90ZXh0dXJlPW1Tb3VyY2U7ZWxzZXt0aGlzLl9tU291cmNlPW1Tb3VyY2UsdGhpcy5fdGV4dHVyZT1nbC5jcmVhdGVUZXh0dXJlKCksdGhpcy5faXNWaWRlbz1cIlZJREVPXCI9PT1tU291cmNlLnRhZ05hbWUsdGhpcy5fcHJlbXVsdGlwbHlBbHBoYT0hMCx0aGlzLl9tYWdGaWx0ZXI9bVBhcmFtZXRlcnMubWFnRmlsdGVyfHxnbC5MSU5FQVIsdGhpcy5fbWluRmlsdGVyPW1QYXJhbWV0ZXJzLm1pbkZpbHRlcnx8Z2wuTkVBUkVTVF9NSVBNQVBfTElORUFSLHRoaXMuX3dyYXBTPW1QYXJhbWV0ZXJzLndyYXBTfHxnbC5NSVJST1JFRF9SRVBFQVQsdGhpcy5fd3JhcFQ9bVBhcmFtZXRlcnMud3JhcFR8fGdsLk1JUlJPUkVEX1JFUEVBVDttU291cmNlLndpZHRofHxtU291cmNlLnZpZGVvV2lkdGg/aXNTb3VyY2VQb3dlck9mVHdvKG1Tb3VyY2UpfHwodGhpcy5fd3JhcFM9dGhpcy5fd3JhcFQ9Z2wuQ0xBTVBfVE9fRURHRSx0aGlzLl9taW5GaWx0ZXI9PT1nbC5ORUFSRVNUX01JUE1BUF9MSU5FQVImJih0aGlzLl9taW5GaWx0ZXI9Z2wuTElORUFSKSk6KHRoaXMuX3dyYXBTPXRoaXMuX3dyYXBUPWdsLkNMQU1QX1RPX0VER0UsdGhpcy5fbWluRmlsdGVyPT09Z2wuTkVBUkVTVF9NSVBNQVBfTElORUFSJiYodGhpcy5fbWluRmlsdGVyPWdsLkxJTkVBUikpLGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsdGhpcy5fdGV4dHVyZSksZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwhMCksbVNvdXJjZS5leHBvc3VyZT9nbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsMCxnbC5SR0JBLG1Tb3VyY2Uuc2hhcGVbMF0sbVNvdXJjZS5zaGFwZVsxXSwwLGdsLlJHQkEsZ2wuRkxPQVQsbVNvdXJjZS5kYXRhKTpnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsMCxnbC5SR0JBLGdsLlJHQkEsZ2wuVU5TSUdORURfQllURSxtU291cmNlKSxnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsZ2wuVEVYVFVSRV9NQUdfRklMVEVSLHRoaXMuX21hZ0ZpbHRlciksZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELGdsLlRFWFRVUkVfTUlOX0ZJTFRFUix0aGlzLl9taW5GaWx0ZXIpLGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCxnbC5URVhUVVJFX1dSQVBfUyx0aGlzLl93cmFwUyksZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELGdsLlRFWFRVUkVfV1JBUF9ULHRoaXMuX3dyYXBUKTt2YXIgZXh0PV9HTFRvb2wyLmRlZmF1bHQuZ2V0RXh0ZW5zaW9uKFwiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpO2lmKGV4dCl7dmFyIG1heD1nbC5nZXRQYXJhbWV0ZXIoZXh0Lk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCk7Z2wudGV4UGFyYW1ldGVyZihnbC5URVhUVVJFXzJELGV4dC5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCxtYXgpfXRoaXMuX2NhbkdlbmVyYXRlTWlwbWFwKCkmJmdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpLGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsbnVsbCl9fXJldHVybiBfY3JlYXRlQ2xhc3MoR0xUZXh0dXJlLFt7a2V5OlwiZ2VuZXJhdGVNaXBtYXBcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2NhbkdlbmVyYXRlTWlwbWFwKCkmJihnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELHRoaXMuX3RleHR1cmUpLGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpLGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsbnVsbCkpfX0se2tleTpcInVwZGF0ZVRleHR1cmVcIix2YWx1ZTpmdW5jdGlvbihtU291cmNlKXttU291cmNlJiYodGhpcy5fbVNvdXJjZT1tU291cmNlKSxnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELHRoaXMuX3RleHR1cmUpLGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsITApLGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwwLGdsLlJHQkEsZ2wuUkdCQSxnbC5VTlNJR05FRF9CWVRFLHRoaXMuX21Tb3VyY2UpLGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCxnbC5URVhUVVJFX01BR19GSUxURVIsdGhpcy5fbWFnRmlsdGVyKSxnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsZ2wuVEVYVFVSRV9NSU5fRklMVEVSLHRoaXMuX21pbkZpbHRlciksdGhpcy5fY2FuR2VuZXJhdGVNaXBtYXAoKSYmZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCksZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCxudWxsKX19LHtrZXk6XCJiaW5kXCIsdmFsdWU6ZnVuY3Rpb24oaW5kZXgpe3ZvaWQgMD09PWluZGV4JiYoaW5kZXg9MCksX0dMVG9vbDIuZGVmYXVsdC5zaGFkZXImJihnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwK2luZGV4KSxnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELHRoaXMuX3RleHR1cmUpLHRoaXMuX2JpbmRJbmRleD1pbmRleCl9fSx7a2V5OlwiX2NhbkdlbmVyYXRlTWlwbWFwXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWluRmlsdGVyPT09Z2wuTElORUFSX01JUE1BUF9ORUFSRVNUfHx0aGlzLl9taW5GaWx0ZXI9PT1nbC5ORUFSRVNUX01JUE1BUF9MSU5FQVJ8fHRoaXMuX21pbkZpbHRlcj09PWdsLkxJTkVBUl9NSVBNQVBfTElORUFSfHx0aGlzLl9taW5GaWx0ZXI9PT1nbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUfX0se2tleTpcIm1pbkZpbHRlclwiLHNldDpmdW5jdGlvbihtVmFsdWUpe2lmKG1WYWx1ZSE9PWdsLkxJTkVBUiYmbVZhbHVlIT09Z2wuTkVBUkVTVCYmbVZhbHVlIT09Z2wuTkVBUkVTVF9NSVBNQVBfTElORUFSJiZtVmFsdWUhPT1nbC5ORUFSRVNUX01JUE1BUF9MSU5FQVImJm1WYWx1ZSE9PWdsLkxJTkVBUl9NSVBNQVBfTElORUFSJiZtVmFsdWUhPT1nbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUKXJldHVybiB0aGlzO3RoaXMuX21pbkZpbHRlcj1tVmFsdWUsZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCx0aGlzLl90ZXh0dXJlKSxnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsZ2wuVEVYVFVSRV9NSU5fRklMVEVSLHRoaXMuX21pbkZpbHRlciksZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCxudWxsKX0sZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21pbkZpbHRlcn19LHtrZXk6XCJtYWdGaWx0ZXJcIixzZXQ6ZnVuY3Rpb24obVZhbHVlKXtpZihtVmFsdWUhPT1nbC5MSU5FQVImJm1WYWx1ZSE9PWdsLk5FQVJFU1QpcmV0dXJuIHRoaXM7dGhpcy5fbWFnRmlsdGVyPW1WYWx1ZSxnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELHRoaXMuX3RleHR1cmUpLGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCxnbC5URVhUVVJFX01BR19GSUxURVIsdGhpcy5fbWFnRmlsdGVyKSxnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELG51bGwpfSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWFnRmlsdGVyfX0se2tleTpcIndyYXBTXCIsc2V0OmZ1bmN0aW9uKG1WYWx1ZSl7aWYobVZhbHVlIT09Z2wuQ0xBTVBfVE9fRURHRSYmbVZhbHVlIT09Z2wuUkVQRUFUJiZtVmFsdWUhPT1nbC5NSVJST1JFRF9SRVBFQVQpcmV0dXJuIHRoaXM7dGhpcy5fd3JhcFM9bVZhbHVlLGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsdGhpcy5fdGV4dHVyZSksZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELGdsLlRFWFRVUkVfV1JBUF9TLHRoaXMuX3dyYXBTKSxnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELG51bGwpfSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd3JhcFN9fSx7a2V5Olwid3JhcFRcIixzZXQ6ZnVuY3Rpb24obVZhbHVlKXtpZihtVmFsdWUhPT1nbC5DTEFNUF9UT19FREdFJiZtVmFsdWUhPT1nbC5SRVBFQVQmJm1WYWx1ZSE9PWdsLk1JUlJPUkVEX1JFUEVBVClyZXR1cm4gdGhpczt0aGlzLl93cmFwVD1tVmFsdWUsZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCx0aGlzLl90ZXh0dXJlKSxnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsZ2wuVEVYVFVSRV9XUkFQX1QsdGhpcy5fd3JhcFQpLGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsbnVsbCl9LGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl93cmFwVH19LHtrZXk6XCJwcmVtdWx0aXBseUFscGhhXCIsc2V0OmZ1bmN0aW9uKG1WYWx1ZSl7dGhpcy5fcHJlbXVsdGlwbHlBbHBoYT1tVmFsdWUsZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCx0aGlzLl90ZXh0dXJlKSxjb25zb2xlLmxvZyhcInByZW11bHRpcGx5QWxwaGE6XCIsbVZhbHVlKSxnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsdGhpcy5fcHJlbXVsdGlwbHlBbHBoYSksZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCxudWxsKX0sZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3ByZW11bHRpcGx5QWxwaGF9fSx7a2V5OlwidGV4dHVyZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl90ZXh0dXJlfX1dKSxHTFRleHR1cmV9KCksX3doaXRlVGV4dHVyZT12b2lkIDAsX2dyZXlUZXh0dXJlPXZvaWQgMCxfYmxhY2tUZXh0dXJlPXZvaWQgMDtHTFRleHR1cmUud2hpdGVUZXh0dXJlPWZ1bmN0aW9uKCl7aWYodm9pZCAwPT09X3doaXRlVGV4dHVyZSl7dmFyIGNhbnZhcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO2NhbnZhcy53aWR0aD1jYW52YXMuaGVpZ2h0PTQ7dmFyIGN0eD1jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO2N0eC5maWxsU3R5bGU9XCIjZmZmXCIsY3R4LmZpbGxSZWN0KDAsMCw0LDQpLF93aGl0ZVRleHR1cmU9bmV3IEdMVGV4dHVyZShjYW52YXMpfXJldHVybiBfd2hpdGVUZXh0dXJlfSxHTFRleHR1cmUuZ3JleVRleHR1cmU9ZnVuY3Rpb24oKXtpZih2b2lkIDA9PT1fZ3JleVRleHR1cmUpe3ZhciBjYW52YXM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtjYW52YXMud2lkdGg9Y2FudmFzLmhlaWdodD00O3ZhciBjdHg9Y2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtjdHguZmlsbFN0eWxlPVwicmdiKDEyNywgMTI3LCAxMjcpXCIsY3R4LmZpbGxSZWN0KDAsMCw0LDQpLF9ncmV5VGV4dHVyZT1uZXcgR0xUZXh0dXJlKGNhbnZhcyl9cmV0dXJuIF9ncmV5VGV4dHVyZX0sR0xUZXh0dXJlLmJsYWNrVGV4dHVyZT1mdW5jdGlvbigpe2lmKHZvaWQgMD09PV9ibGFja1RleHR1cmUpe3ZhciBjYW52YXM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtjYW52YXMud2lkdGg9Y2FudmFzLmhlaWdodD00O3ZhciBjdHg9Y2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtjdHguZmlsbFN0eWxlPVwicmdiKDEyNywgMTI3LCAxMjcpXCIsY3R4LmZpbGxSZWN0KDAsMCw0LDQpLF9ibGFja1RleHR1cmU9bmV3IEdMVGV4dHVyZShjYW52YXMpfXJldHVybiBfYmxhY2tUZXh0dXJlfSxleHBvcnRzLmRlZmF1bHQ9R0xUZXh0dXJlfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntkZWZhdWx0Om9ian19ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLENvbnN0cnVjdG9yKXtpZighKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaXNQb3dlck9mVHdvKHgpe3JldHVybiAwIT09eCYmISh4JngtMSl9ZnVuY3Rpb24gZ2V0U291cmNlVHlwZShtU291cmNlKXt2YXIgdHlwZT1fR0xUb29sMi5kZWZhdWx0LlVOU0lHTkVEX0JZVEU7cmV0dXJuIG1Tb3VyY2UgaW5zdGFuY2VvZiBBcnJheT90eXBlPV9HTFRvb2wyLmRlZmF1bHQuVU5TSUdORURfQllURTptU291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheT90eXBlPV9HTFRvb2wyLmRlZmF1bHQuVU5TSUdORURfQllURTptU291cmNlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5P3R5cGU9X0dMVG9vbDIuZGVmYXVsdC5GTE9BVDptU291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudD90eXBlPVwiaW1hZ2VcIjptU291cmNlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQ/dHlwZT1cImNhbnZhc1wiOm1Tb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50JiYodHlwZT1cInZpZGVvXCIpLHR5cGV9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fCExLGRlc2NyaXB0b3IuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGRlc2NyaXB0b3ImJihkZXNjcmlwdG9yLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpfX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7cmV0dXJuIHByb3RvUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpLHN0YXRpY1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKSxDb25zdHJ1Y3Rvcn19KCksX2dldFRleHR1cmVQYXJhbWV0ZXJzPV9fd2VicGFja19yZXF1aXJlX18oNTQpLF9nZXRUZXh0dXJlUGFyYW1ldGVyczI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0VGV4dHVyZVBhcmFtZXRlcnMpLF9XZWJnbE51bWJlcj1fX3dlYnBhY2tfcmVxdWlyZV9fKDgpLF9XZWJnbE51bWJlcjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfV2ViZ2xOdW1iZXIpLF9HTFRvb2w9X193ZWJwYWNrX3JlcXVpcmVfXygwKSxfR0xUb29sMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HTFRvb2wpLF9zY2hlZHVsaW5nPV9fd2VicGFja19yZXF1aXJlX18oNiksX3NjaGVkdWxpbmcyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NjaGVkdWxpbmcpLGdsPXZvaWQgMCxHTFRleHR1cmU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBHTFRleHR1cmUobVNvdXJjZSl7dmFyIG1QYXJhbT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e30sX3RoaXM9dGhpcyxtV2lkdGg9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOjAsbUhlaWdodD1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106MDtfY2xhc3NDYWxsQ2hlY2sodGhpcyxHTFRleHR1cmUpLGdsPV9HTFRvb2wyLmRlZmF1bHQuZ2wsdGhpcy5fc291cmNlPW1Tb3VyY2UsdGhpcy5fZ2V0RGltZW5zaW9uKG1Tb3VyY2UsbVdpZHRoLG1IZWlnaHQpLHRoaXMuX3NvdXJjZVR5cGU9bVBhcmFtLnR5cGV8fGdldFNvdXJjZVR5cGUobVNvdXJjZSksdGhpcy5fY2hlY2tTb3VyY2UoKSx0aGlzLl90ZXhlbFR5cGU9dGhpcy5fZ2V0VGV4ZWxUeXBlKCksdGhpcy5faXNUZXh0dXJlUmVhZHk9ITAsdGhpcy5fcGFyYW1zPSgwLF9nZXRUZXh0dXJlUGFyYW1ldGVyczIuZGVmYXVsdCkobVBhcmFtLG1Tb3VyY2UsdGhpcy5fd2lkdGgsdGhpcy5faGVpZ2h0KSx0aGlzLl9jaGVja01pcG1hcCgpLHRoaXMuX2NoZWNrV3JhcHBpbmcoKSx0aGlzLl90ZXh0dXJlPWdsLmNyZWF0ZVRleHR1cmUoKSxcInZpZGVvXCI9PT10aGlzLl9zb3VyY2VUeXBlPyh0aGlzLl9pc1RleHR1cmVSZWFkeT0hMSxfc2NoZWR1bGluZzIuZGVmYXVsdC5hZGRFRihmdW5jdGlvbigpe3JldHVybiBfdGhpcy5fbG9vcCgpfSkpOnRoaXMuX3VwbG9hZFRleHR1cmUoKX1yZXR1cm4gX2NyZWF0ZUNsYXNzKEdMVGV4dHVyZSxbe2tleTpcIl9sb29wXCIsdmFsdWU6ZnVuY3Rpb24oKXs0PT10aGlzLl9zb3VyY2UucmVhZHlTdGF0ZSYmKHRoaXMuX2lzVGV4dHVyZVJlYWR5PSEwLHRoaXMuX3VwbG9hZFRleHR1cmUoKSl9fSx7a2V5OlwiX3VwbG9hZFRleHR1cmVcIix2YWx1ZTpmdW5jdGlvbigpe2lmKGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsdGhpcy5fdGV4dHVyZSksZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwhMCksdGhpcy5faXNTb3VyY2VIdG1sRWxlbWVudCgpP2dsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwwLHRoaXMuX3BhcmFtcy5pbnRlcm5hbEZvcm1hdCx0aGlzLl9wYXJhbXMuZm9ybWF0LHRoaXMuX3RleGVsVHlwZSx0aGlzLl9zb3VyY2UpOmdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwwLHRoaXMuX3BhcmFtcy5pbnRlcm5hbEZvcm1hdCx0aGlzLl93aWR0aCx0aGlzLl9oZWlnaHQsMCx0aGlzLl9wYXJhbXMuZm9ybWF0LHRoaXMuX3RleGVsVHlwZSx0aGlzLl9zb3VyY2UpLGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCxnbC5URVhUVVJFX01BR19GSUxURVIsdGhpcy5fcGFyYW1zLm1hZ0ZpbHRlciksZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELGdsLlRFWFRVUkVfTUlOX0ZJTFRFUix0aGlzLl9wYXJhbXMubWluRmlsdGVyKSxnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsZ2wuVEVYVFVSRV9XUkFQX1MsdGhpcy5fcGFyYW1zLndyYXBTKSxnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsZ2wuVEVYVFVSRV9XUkFQX1QsdGhpcy5fcGFyYW1zLndyYXBUKSxnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsdGhpcy5fcGFyYW1zLnByZW11bHRpcGx5QWxwaGEpLHRoaXMuX3BhcmFtcy5hbmlzb3Ryb3B5PjApe3ZhciBleHQ9X0dMVG9vbDIuZGVmYXVsdC5nZXRFeHRlbnNpb24oXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIik7aWYoZXh0KXt2YXIgbWF4PWdsLmdldFBhcmFtZXRlcihleHQuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKSxsZXZlbD1NYXRoLm1pbihtYXgsdGhpcy5fcGFyYW1zLmFuaXNvdHJvcHkpO2dsLnRleFBhcmFtZXRlcmYoZ2wuVEVYVFVSRV8yRCxleHQuVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsbGV2ZWwpfX10aGlzLl9nZW5lcmF0ZU1pcG1hcCYmZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCksZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCxudWxsKX19LHtrZXk6XCJiaW5kXCIsdmFsdWU6ZnVuY3Rpb24oaW5kZXgpe3ZvaWQgMD09PWluZGV4JiYoaW5kZXg9MCksX0dMVG9vbDIuZGVmYXVsdC5zaGFkZXImJihnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwK2luZGV4KSx0aGlzLl9pc1RleHR1cmVSZWFkeT9nbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELHRoaXMuX3RleHR1cmUpOmdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsR0xUZXh0dXJlLmJsYWNrVGV4dHVyZSgpLnRleHR1cmUpLHRoaXMuX2JpbmRJbmRleD1pbmRleCl9fSx7a2V5OlwidXBkYXRlVGV4dHVyZVwiLHZhbHVlOmZ1bmN0aW9uKG1Tb3VyY2Upe3RoaXMuX3NvdXJjZT1tU291cmNlLHRoaXMuX2NoZWNrU291cmNlKCksdGhpcy5fdXBsb2FkVGV4dHVyZSgpfX0se2tleTpcImdlbmVyYXRlTWlwbWFwXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9nZW5lcmF0ZU1pcG1hcCYmKGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsdGhpcy5fdGV4dHVyZSksZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCksZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCxudWxsKSl9fSx7a2V5Olwic2hvd1BhcmFtZXRlcnNcIix2YWx1ZTpmdW5jdGlvbigpe2NvbnNvbGUubG9nKFwiU291cmNlIHR5cGUgOiBcIixfV2ViZ2xOdW1iZXIyLmRlZmF1bHRbdGhpcy5fc291cmNlVHlwZV18fHRoaXMuX3NvdXJjZVR5cGUpLGNvbnNvbGUubG9nKFwiVGV4ZWwgdHlwZTpcIixfV2ViZ2xOdW1iZXIyLmRlZmF1bHRbdGhpcy50ZXhlbFR5cGVdKSxjb25zb2xlLmxvZyhcIkRpbWVuc2lvbiA6XCIsdGhpcy5fd2lkdGgsdGhpcy5faGVpZ2h0KTtmb3IodmFyIHMgaW4gdGhpcy5fcGFyYW1zKWNvbnNvbGUubG9nKHMsX1dlYmdsTnVtYmVyMi5kZWZhdWx0W3RoaXMuX3BhcmFtc1tzXV18fHRoaXMuX3BhcmFtc1tzXSk7Y29uc29sZS5sb2coXCJNaXBtYXBwaW5nIDpcIix0aGlzLl9nZW5lcmF0ZU1pcG1hcCl9fSx7a2V5OlwiX2dldERpbWVuc2lvblwiLHZhbHVlOmZ1bmN0aW9uKG1Tb3VyY2UsbVdpZHRoLG1IZWlnaHQpe21Tb3VyY2U/KHRoaXMuX3dpZHRoPW1Tb3VyY2Uud2lkdGh8fG1Tb3VyY2UudmlkZW9XaWR0aCx0aGlzLl9oZWlnaHQ9bVNvdXJjZS5oZWlnaHR8fG1Tb3VyY2UudmlkZW9XaWR0aCx0aGlzLl93aWR0aD10aGlzLl93aWR0aHx8bVdpZHRoLHRoaXMuX2hlaWdodD10aGlzLl9oZWlnaHR8fG1IZWlnaHQsdGhpcy5fd2lkdGgmJnRoaXMuX2hlaWdodHx8KHRoaXMuX3dpZHRoPXRoaXMuX2hlaWdodD1NYXRoLnNxcnQobVNvdXJjZS5sZW5ndGgvNCkpKToodGhpcy5fd2lkdGg9bVdpZHRoLHRoaXMuX2hlaWdodD1tSGVpZ2h0KX19LHtrZXk6XCJfY2hlY2tTb3VyY2VcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3NvdXJjZSYmKHRoaXMuX3NvdXJjZVR5cGU9PT1fR0xUb29sMi5kZWZhdWx0LlVOU0lHTkVEX0JZVEU/dGhpcy5fc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheXx8KHRoaXMuX3NvdXJjZT1uZXcgVWludDhBcnJheSh0aGlzLl9zb3VyY2UpKTp0aGlzLl9zb3VyY2VUeXBlPT09X0dMVG9vbDIuZGVmYXVsdC5GTE9BVCYmKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8KHRoaXMuX3NvdXJjZT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuX3NvdXJjZSkpKSl9fSx7a2V5OlwiX2dldFRleGVsVHlwZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzU291cmNlSHRtbEVsZW1lbnQoKT9fR0xUb29sMi5kZWZhdWx0LlVOU0lHTkVEX0JZVEU6X0dMVG9vbDIuZGVmYXVsdFtfV2ViZ2xOdW1iZXIyLmRlZmF1bHRbdGhpcy5fc291cmNlVHlwZV1dfHx0aGlzLl9zb3VyY2VUeXBlfX0se2tleTpcIl9jaGVja01pcG1hcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fZ2VuZXJhdGVNaXBtYXA9dGhpcy5fcGFyYW1zLm1pcG1hcCxpc1Bvd2VyT2ZUd28odGhpcy5fd2lkdGgpJiZpc1Bvd2VyT2ZUd28odGhpcy5faGVpZ2h0KXx8KHRoaXMuX2dlbmVyYXRlTWlwbWFwPSExKSwtMT09X1dlYmdsTnVtYmVyMi5kZWZhdWx0W3RoaXMuX3BhcmFtcy5taW5GaWx0ZXJdLmluZGV4T2YoXCJNSVBNQVBcIikmJih0aGlzLl9nZW5lcmF0ZU1pcG1hcD0hMSl9fSx7a2V5OlwiX2NoZWNrV3JhcHBpbmdcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2dlbmVyYXRlTWlwbWFwfHwodGhpcy5fcGFyYW1zLndyYXBTPV9HTFRvb2wyLmRlZmF1bHQuQ0xBTVBfVE9fRURHRSx0aGlzLl9wYXJhbXMud3JhcFQ9X0dMVG9vbDIuZGVmYXVsdC5DTEFNUF9UT19FREdFKX19LHtrZXk6XCJfaXNTb3VyY2VIdG1sRWxlbWVudFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuXCJpbWFnZVwiPT09dGhpcy5fc291cmNlVHlwZXx8XCJ2aWRlb1wiPT09dGhpcy5fc291cmNlVHlwZXx8XCJjYW52YXNcIj09PXRoaXMuX3NvdXJjZVR5cGV9fSx7a2V5OlwibWluRmlsdGVyXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BhcmFtcy5taW5GaWx0ZXJ9LHNldDpmdW5jdGlvbihtVmFsdWUpe3RoaXMuX3BhcmFtcy5taW5GaWx0ZXI9bVZhbHVlLHRoaXMuX2NoZWNrTWlwbWFwKCksZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCx0aGlzLl90ZXh0dXJlKSxnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsZ2wuVEVYVFVSRV9NSU5fRklMVEVSLHRoaXMuX3BhcmFtcy5taW5GaWx0ZXIpLGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsbnVsbCksdGhpcy5nZW5lcmF0ZU1pcG1hcCgpfX0se2tleTpcIm1hZ0ZpbHRlclwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wYXJhbXMubWluRmlsdGVyfSxzZXQ6ZnVuY3Rpb24obVZhbHVlKXt0aGlzLl9wYXJhbXMubWFnRmlsdGVyPW1WYWx1ZSxnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELHRoaXMuX3RleHR1cmUpLGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCxnbC5URVhUVVJFX01BR19GSUxURVIsdGhpcy5fcGFyYW1zLm1hZ0ZpbHRlciksZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCxudWxsKX19LHtrZXk6XCJ3cmFwU1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wYXJhbXMud3JhcFN9LHNldDpmdW5jdGlvbihtVmFsdWUpe3RoaXMuX3BhcmFtcy53cmFwUz1tVmFsdWUsdGhpcy5fY2hlY2tXcmFwcGluZygpLGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsdGhpcy5fdGV4dHVyZSksZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELGdsLlRFWFRVUkVfV1JBUF9TLHRoaXMuX3BhcmFtcy53cmFwUyksZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCxudWxsKX19LHtrZXk6XCJ3cmFwVFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wYXJhbXMud3JhcFR9LHNldDpmdW5jdGlvbihtVmFsdWUpe3RoaXMuX3BhcmFtcy53cmFwVD1tVmFsdWUsdGhpcy5fY2hlY2tXcmFwcGluZygpLGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsdGhpcy5fdGV4dHVyZSksZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELGdsLlRFWFRVUkVfV1JBUF9ULHRoaXMuX3BhcmFtcy53cmFwVCksZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCxudWxsKX19LHtrZXk6XCJ0ZXhlbFR5cGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdGV4ZWxUeXBlfX0se2tleTpcIndpZHRoXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3dpZHRofX0se2tleTpcImhlaWdodFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9oZWlnaHR9fSx7a2V5OlwidGV4dHVyZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl90ZXh0dXJlfX0se2tleTpcImlzVGV4dHVyZVJlYWR5XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzVGV4dHVyZVJlYWR5fX1dKSxHTFRleHR1cmV9KCksX3doaXRlVGV4dHVyZT12b2lkIDAsX2dyZXlUZXh0dXJlPXZvaWQgMCxfYmxhY2tUZXh0dXJlPXZvaWQgMDtHTFRleHR1cmUud2hpdGVUZXh0dXJlPWZ1bmN0aW9uKCl7aWYodm9pZCAwPT09X3doaXRlVGV4dHVyZSl7dmFyIGNhbnZhcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO2NhbnZhcy53aWR0aD1jYW52YXMuaGVpZ2h0PTI7dmFyIGN0eD1jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO2N0eC5maWxsU3R5bGU9XCIjZmZmXCIsY3R4LmZpbGxSZWN0KDAsMCwyLDIpLF93aGl0ZVRleHR1cmU9bmV3IEdMVGV4dHVyZShjYW52YXMpfXJldHVybiBfd2hpdGVUZXh0dXJlfSxHTFRleHR1cmUuZ3JleVRleHR1cmU9ZnVuY3Rpb24oKXtpZih2b2lkIDA9PT1fZ3JleVRleHR1cmUpe3ZhciBjYW52YXM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtjYW52YXMud2lkdGg9Y2FudmFzLmhlaWdodD0yO3ZhciBjdHg9Y2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtjdHguZmlsbFN0eWxlPVwicmdiKDEyNywgMTI3LCAxMjcpXCIsY3R4LmZpbGxSZWN0KDAsMCwyLDIpLF9ncmV5VGV4dHVyZT1uZXcgR0xUZXh0dXJlKGNhbnZhcyl9cmV0dXJuIF9ncmV5VGV4dHVyZX0sR0xUZXh0dXJlLmJsYWNrVGV4dHVyZT1mdW5jdGlvbigpe2lmKHZvaWQgMD09PV9ibGFja1RleHR1cmUpe3ZhciBjYW52YXM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtjYW52YXMud2lkdGg9Y2FudmFzLmhlaWdodD0yO3ZhciBjdHg9Y2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtjdHguZmlsbFN0eWxlPVwicmdiKDAsIDAsIDApXCIsY3R4LmZpbGxSZWN0KDAsMCwyLDIpLF9ibGFja1RleHR1cmU9bmV3IEdMVGV4dHVyZShjYW52YXMpfXJldHVybiBfYmxhY2tUZXh0dXJlfSxleHBvcnRzLmRlZmF1bHQ9R0xUZXh0dXJlfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntkZWZhdWx0Om9ian19ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLENvbnN0cnVjdG9yKXtpZighKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fCExLGRlc2NyaXB0b3IuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGRlc2NyaXB0b3ImJihkZXNjcmlwdG9yLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpfX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7cmV0dXJuIHByb3RvUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpLHN0YXRpY1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKSxDb25zdHJ1Y3Rvcn19KCksX0dMVG9vbD1fX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9HTFRvb2wyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dMVG9vbCksX3BhcnNlRGRzPV9fd2VicGFja19yZXF1aXJlX18oNTUpLF9wYXJzZURkczI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyc2VEZHMpLGdsPXZvaWQgMCxHTEN1YmVUZXh0dXJlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gR0xDdWJlVGV4dHVyZShtU291cmNlKXt2YXIgbVBhcmFtZXRlcnM9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9LGlzQ3ViZVRleHR1cmU9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXTtpZihfY2xhc3NDYWxsQ2hlY2sodGhpcyxHTEN1YmVUZXh0dXJlKSxnbD1fR0xUb29sMi5kZWZhdWx0LmdsLGlzQ3ViZVRleHR1cmUpcmV0dXJuIHZvaWQodGhpcy50ZXh0dXJlPW1Tb3VyY2UpO3ZhciBoYXNNaXBtYXBzPW1Tb3VyY2UubGVuZ3RoPjY7bVNvdXJjZVswXS5taXBtYXBDb3VudCYmKGhhc01pcG1hcHM9bVNvdXJjZVswXS5taXBtYXBDb3VudD4xKSx0aGlzLnRleHR1cmU9Z2wuY3JlYXRlVGV4dHVyZSgpLHRoaXMubWFnRmlsdGVyPW1QYXJhbWV0ZXJzLm1hZ0ZpbHRlcnx8Z2wuTElORUFSLHRoaXMubWluRmlsdGVyPW1QYXJhbWV0ZXJzLm1pbkZpbHRlcnx8Z2wuTElORUFSX01JUE1BUF9MSU5FQVIsdGhpcy53cmFwUz1tUGFyYW1ldGVycy53cmFwU3x8Z2wuQ0xBTVBfVE9fRURHRSx0aGlzLndyYXBUPW1QYXJhbWV0ZXJzLndyYXBUfHxnbC5DTEFNUF9UT19FREdFLGhhc01pcG1hcHN8fHRoaXMubWluRmlsdGVyIT1nbC5MSU5FQVJfTUlQTUFQX0xJTkVBUnx8KHRoaXMubWluRmlsdGVyPWdsLkxJTkVBUiksZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCx0aGlzLnRleHR1cmUpO3ZhciB0YXJnZXRzPVtnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YLGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSxnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1ksZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aLGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWl0sbnVtTGV2ZWxzPTEsaW5kZXg9MDtpZihudW1MZXZlbHM9bVNvdXJjZS5sZW5ndGgvNix0aGlzLm51bUxldmVscz1udW1MZXZlbHMsaGFzTWlwbWFwcylmb3IodmFyIGo9MDtqPDY7aisrKWZvcih2YXIgaT0wO2k8bnVtTGV2ZWxzO2krKylnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCExKSxpbmRleD1qKm51bUxldmVscytpLG1Tb3VyY2VbaW5kZXhdLnNoYXBlP2dsLnRleEltYWdlMkQodGFyZ2V0c1tqXSxpLGdsLlJHQkEsbVNvdXJjZVtpbmRleF0uc2hhcGVbMF0sbVNvdXJjZVtpbmRleF0uc2hhcGVbMV0sMCxnbC5SR0JBLGdsLkZMT0FULG1Tb3VyY2VbaW5kZXhdLmRhdGEpOmdsLnRleEltYWdlMkQodGFyZ2V0c1tqXSxpLGdsLlJHQkEsZ2wuUkdCQSxnbC5VTlNJR05FRF9CWVRFLG1Tb3VyY2VbaW5kZXhdKSxnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsZ2wuVEVYVFVSRV9XUkFQX1MsdGhpcy53cmFwUyksZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLGdsLlRFWFRVUkVfV1JBUF9ULHRoaXMud3JhcFQpLGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCxnbC5URVhUVVJFX01BR19GSUxURVIsdGhpcy5tYWdGaWx0ZXIpLGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCxnbC5URVhUVVJFX01JTl9GSUxURVIsdGhpcy5taW5GaWx0ZXIpO2Vsc2V7Zm9yKHZhciBfaW5kZXg9MCxfaj0wO19qPDY7X2orKylfaW5kZXg9X2oqbnVtTGV2ZWxzLGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsITEpLG1Tb3VyY2VbX2luZGV4XS5zaGFwZT9nbC50ZXhJbWFnZTJEKHRhcmdldHNbX2pdLDAsZ2wuUkdCQSxtU291cmNlW19pbmRleF0uc2hhcGVbMF0sbVNvdXJjZVtfaW5kZXhdLnNoYXBlWzFdLDAsZ2wuUkdCQSxnbC5GTE9BVCxtU291cmNlW19pbmRleF0uZGF0YSk6Z2wudGV4SW1hZ2UyRCh0YXJnZXRzW19qXSwwLGdsLlJHQkEsZ2wuUkdCQSxnbC5VTlNJR05FRF9CWVRFLG1Tb3VyY2VbX2luZGV4XSksZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLGdsLlRFWFRVUkVfV1JBUF9TLHRoaXMud3JhcFMpLGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCxnbC5URVhUVVJFX1dSQVBfVCx0aGlzLndyYXBUKSxnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsZ2wuVEVYVFVSRV9NQUdfRklMVEVSLHRoaXMubWFnRmlsdGVyKSxnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsZ2wuVEVYVFVSRV9NSU5fRklMVEVSLHRoaXMubWluRmlsdGVyKTtnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFX0NVQkVfTUFQKX1nbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLG51bGwpfXJldHVybiBfY3JlYXRlQ2xhc3MoR0xDdWJlVGV4dHVyZSxbe2tleTpcImJpbmRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBpbmRleD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MDtfR0xUb29sMi5kZWZhdWx0LnNoYWRlciYmKGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAraW5kZXgpLGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsdGhpcy50ZXh0dXJlKSxnbC51bmlmb3JtMWkoX0dMVG9vbDIuZGVmYXVsdC5zaGFkZXIudW5pZm9ybVRleHR1cmVzW2luZGV4XSxpbmRleCksdGhpcy5fYmluZEluZGV4PWluZGV4KX19LHtrZXk6XCJ1bmJpbmRcIix2YWx1ZTpmdW5jdGlvbigpe2dsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsbnVsbCl9fV0pLEdMQ3ViZVRleHR1cmV9KCk7R0xDdWJlVGV4dHVyZS5wYXJzZUREUz1mdW5jdGlvbihtQXJyYXlCdWZmZXIpe3ZhciBkZHNJbmZvcz0oMCxfcGFyc2VEZHMyLmRlZmF1bHQpKG1BcnJheUJ1ZmZlciksZmxhZ3M9ZGRzSW5mb3MuZmxhZ3MsaGVhZGVyPW5ldyBJbnQzMkFycmF5KG1BcnJheUJ1ZmZlciwwLDMxKSxtaXBtYXBDb3VudD0xOzEzMTA3MiZmbGFncyYmKG1pcG1hcENvdW50PU1hdGgubWF4KDEsaGVhZGVyWzddKSk7dmFyIHNvdXJjZXM9ZGRzSW5mb3MuaW1hZ2VzLm1hcChmdW5jdGlvbihpbWcpe3JldHVybntkYXRhOm5ldyBGbG9hdDMyQXJyYXkobUFycmF5QnVmZmVyLnNsaWNlKGltZy5vZmZzZXQsaW1nLm9mZnNldCtpbWcubGVuZ3RoKSksc2hhcGU6aW1nLnNoYXBlLG1pcG1hcENvdW50Om1pcG1hcENvdW50fX0pO3JldHVybiBuZXcgR0xDdWJlVGV4dHVyZShzb3VyY2VzKX0sZXhwb3J0cy5kZWZhdWx0PUdMQ3ViZVRleHR1cmV9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSxDb25zdHJ1Y3Rvcil7aWYoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHwhMSxkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBkZXNjcmlwdG9yJiYoZGVzY3JpcHRvci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCxkZXNjcmlwdG9yLmtleSxkZXNjcmlwdG9yKX19cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe3JldHVybiBwcm90b1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKSxzdGF0aWNQcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyksQ29uc3RydWN0b3J9fSgpLHN1cHBvcnRzQ3VzdG9tRXZlbnRzPSEwO3RyeXtkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO251bGx9Y2F0Y2goZSl7c3VwcG9ydHNDdXN0b21FdmVudHM9ITF9dmFyIEV2ZW50RGlzcGF0Y2hlcj1mdW5jdGlvbigpe2Z1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcigpe19jbGFzc0NhbGxDaGVjayh0aGlzLEV2ZW50RGlzcGF0Y2hlciksdGhpcy5fZXZlbnRMaXN0ZW5lcnM9e319cmV0dXJuIF9jcmVhdGVDbGFzcyhFdmVudERpc3BhdGNoZXIsW3trZXk6XCJhZGRFdmVudExpc3RlbmVyXCIsdmFsdWU6ZnVuY3Rpb24oYUV2ZW50VHlwZSxhRnVuY3Rpb24pe3JldHVybiBudWxsIT09dGhpcy5fZXZlbnRMaXN0ZW5lcnMmJnZvaWQgMCE9PXRoaXMuX2V2ZW50TGlzdGVuZXJzfHwodGhpcy5fZXZlbnRMaXN0ZW5lcnM9e30pLHRoaXMuX2V2ZW50TGlzdGVuZXJzW2FFdmVudFR5cGVdfHwodGhpcy5fZXZlbnRMaXN0ZW5lcnNbYUV2ZW50VHlwZV09W10pLHRoaXMuX2V2ZW50TGlzdGVuZXJzW2FFdmVudFR5cGVdLnB1c2goYUZ1bmN0aW9uKSx0aGlzfX0se2tleTpcIm9uXCIsdmFsdWU6ZnVuY3Rpb24oYUV2ZW50VHlwZSxhRnVuY3Rpb24pe3JldHVybiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoYUV2ZW50VHlwZSxhRnVuY3Rpb24pfX0se2tleTpcInJlbW92ZUV2ZW50TGlzdGVuZXJcIix2YWx1ZTpmdW5jdGlvbihhRXZlbnRUeXBlLGFGdW5jdGlvbil7bnVsbCE9PXRoaXMuX2V2ZW50TGlzdGVuZXJzJiZ2b2lkIDAhPT10aGlzLl9ldmVudExpc3RlbmVyc3x8KHRoaXMuX2V2ZW50TGlzdGVuZXJzPXt9KTt2YXIgY3VycmVudEFycmF5PXRoaXMuX2V2ZW50TGlzdGVuZXJzW2FFdmVudFR5cGVdO2lmKHZvaWQgMD09PWN1cnJlbnRBcnJheSlyZXR1cm4gdGhpcztmb3IodmFyIGN1cnJlbnRBcnJheUxlbmd0aD1jdXJyZW50QXJyYXkubGVuZ3RoLGk9MDtpPGN1cnJlbnRBcnJheUxlbmd0aDtpKyspY3VycmVudEFycmF5W2ldPT09YUZ1bmN0aW9uJiYoY3VycmVudEFycmF5LnNwbGljZShpLDEpLGktLSxjdXJyZW50QXJyYXlMZW5ndGgtLSk7cmV0dXJuIHRoaXN9fSx7a2V5Olwib2ZmXCIsdmFsdWU6ZnVuY3Rpb24oYUV2ZW50VHlwZSxhRnVuY3Rpb24pe3JldHVybiB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoYUV2ZW50VHlwZSxhRnVuY3Rpb24pfX0se2tleTpcImRpc3BhdGNoRXZlbnRcIix2YWx1ZTpmdW5jdGlvbihhRXZlbnQpe251bGwhPT10aGlzLl9ldmVudExpc3RlbmVycyYmdm9pZCAwIT09dGhpcy5fZXZlbnRMaXN0ZW5lcnN8fCh0aGlzLl9ldmVudExpc3RlbmVycz17fSk7dmFyIGV2ZW50VHlwZT1hRXZlbnQudHlwZTt0cnl7bnVsbD09PWFFdmVudC50YXJnZXQmJihhRXZlbnQudGFyZ2V0PXRoaXMpLGFFdmVudC5jdXJyZW50VGFyZ2V0PXRoaXN9Y2F0Y2godGhlRXJyb3Ipe3ZhciBuZXdFdmVudD17dHlwZTpldmVudFR5cGUsZGV0YWlsOmFFdmVudC5kZXRhaWwsZGlzcGF0Y2hlcjp0aGlzfTtyZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KX12YXIgY3VycmVudEV2ZW50TGlzdGVuZXJzPXRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50VHlwZV07aWYobnVsbCE9PWN1cnJlbnRFdmVudExpc3RlbmVycyYmdm9pZCAwIT09Y3VycmVudEV2ZW50TGlzdGVuZXJzKWZvcih2YXIgY3VycmVudEFycmF5PXRoaXMuX2NvcHlBcnJheShjdXJyZW50RXZlbnRMaXN0ZW5lcnMpLGN1cnJlbnRBcnJheUxlbmd0aD1jdXJyZW50QXJyYXkubGVuZ3RoLGk9MDtpPGN1cnJlbnRBcnJheUxlbmd0aDtpKyspe3ZhciBjdXJyZW50RnVuY3Rpb249Y3VycmVudEFycmF5W2ldO2N1cnJlbnRGdW5jdGlvbi5jYWxsKHRoaXMsYUV2ZW50KX1yZXR1cm4gdGhpc319LHtrZXk6XCJkaXNwYXRjaEN1c3RvbUV2ZW50XCIsdmFsdWU6ZnVuY3Rpb24oYUV2ZW50VHlwZSxhRGV0YWlsKXt2YXIgbmV3RXZlbnQ9dm9pZCAwO3JldHVybiBzdXBwb3J0c0N1c3RvbUV2ZW50cz8obmV3RXZlbnQ9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKSxuZXdFdmVudC5kaXNwYXRjaGVyPXRoaXMsbmV3RXZlbnQuaW5pdEN1c3RvbUV2ZW50KGFFdmVudFR5cGUsITEsITEsYURldGFpbCkpOm5ld0V2ZW50PXt0eXBlOmFFdmVudFR5cGUsZGV0YWlsOmFEZXRhaWwsZGlzcGF0Y2hlcjp0aGlzfSx0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpfX0se2tleTpcInRyaWdnZXJcIix2YWx1ZTpmdW5jdGlvbihhRXZlbnRUeXBlLGFEZXRhaWwpe3JldHVybiB0aGlzLmRpc3BhdGNoQ3VzdG9tRXZlbnQoYUV2ZW50VHlwZSxhRGV0YWlsKX19LHtrZXk6XCJfZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMuX2V2ZW50TGlzdGVuZXJzKXtmb3IodmFyIG9iamVjdE5hbWUgaW4gdGhpcy5fZXZlbnRMaXN0ZW5lcnMpaWYodGhpcy5fZXZlbnRMaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkob2JqZWN0TmFtZSkpe2Zvcih2YXIgY3VycmVudEFycmF5PXRoaXMuX2V2ZW50TGlzdGVuZXJzW29iamVjdE5hbWVdLGN1cnJlbnRBcnJheUxlbmd0aD1jdXJyZW50QXJyYXkubGVuZ3RoLGk9MDtpPGN1cnJlbnRBcnJheUxlbmd0aDtpKyspY3VycmVudEFycmF5W2ldPW51bGw7ZGVsZXRlIHRoaXMuX2V2ZW50TGlzdGVuZXJzW29iamVjdE5hbWVdfXRoaXMuX2V2ZW50TGlzdGVuZXJzPW51bGx9fX0se2tleTpcIl9jb3B5QXJyYXlcIix2YWx1ZTpmdW5jdGlvbihhQXJyYXkpe2Zvcih2YXIgY3VycmVudEFycmF5PW5ldyBBcnJheShhQXJyYXkubGVuZ3RoKSxjdXJyZW50QXJyYXlMZW5ndGg9Y3VycmVudEFycmF5Lmxlbmd0aCxpPTA7aTxjdXJyZW50QXJyYXlMZW5ndGg7aSsrKWN1cnJlbnRBcnJheVtpXT1hQXJyYXlbaV07cmV0dXJuIGN1cnJlbnRBcnJheX19XSksRXZlbnREaXNwYXRjaGVyfSgpO2V4cG9ydHMuZGVmYXVsdD1FdmVudERpc3BhdGNoZXJ9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ITEsZGVzY3JpcHRvci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvciYmKGRlc2NyaXB0b3Iud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcil9fXJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtyZXR1cm4gcHJvdG9Qcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyksc3RhdGljUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpLENvbnN0cnVjdG9yfX0oKSxfRWFzZU51bWJlcj1fX3dlYnBhY2tfcmVxdWlyZV9fKDEzKSxfRWFzZU51bWJlcjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRWFzZU51bWJlciksX3NjaGVkdWxpbmc9X193ZWJwYWNrX3JlcXVpcmVfXyg2KSxfc2NoZWR1bGluZzI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2NoZWR1bGluZyksX2dsTWF0cml4PV9fd2VicGFja19yZXF1aXJlX18oMSksZ2V0TW91c2U9ZnVuY3Rpb24obUV2ZW50LG1UYXJnZXQpe3ZhciBvPW1UYXJnZXR8fHt9O3JldHVybiBtRXZlbnQudG91Y2hlcz8oby54PW1FdmVudC50b3VjaGVzWzBdLnBhZ2VYLG8ueT1tRXZlbnQudG91Y2hlc1swXS5wYWdlWSk6KG8ueD1tRXZlbnQuY2xpZW50WCxvLnk9bUV2ZW50LmNsaWVudFkpLG99LE9yYml0YWxDb250cm9sPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gT3JiaXRhbENvbnRyb2wobVRhcmdldCl7dmFyIF90aGlzPXRoaXMsbUxpc3RlbmVyVGFyZ2V0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp3aW5kb3csbVJhZGl1cz1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06NTAwO19jbGFzc0NhbGxDaGVjayh0aGlzLE9yYml0YWxDb250cm9sKSx0aGlzLl90YXJnZXQ9bVRhcmdldCx0aGlzLl9saXN0ZW5lclRhcmdldD1tTGlzdGVuZXJUYXJnZXQsdGhpcy5fbW91c2U9e30sdGhpcy5fcHJlTW91c2U9e30sdGhpcy5jZW50ZXI9X2dsTWF0cml4LnZlYzMuY3JlYXRlKCksdGhpcy5fdXA9X2dsTWF0cml4LnZlYzMuZnJvbVZhbHVlcygwLDEsMCksdGhpcy5yYWRpdXM9bmV3IF9FYXNlTnVtYmVyMi5kZWZhdWx0KG1SYWRpdXMpLHRoaXMucG9zaXRpb249X2dsTWF0cml4LnZlYzMuZnJvbVZhbHVlcygwLDAsdGhpcy5yYWRpdXMudmFsdWUpLHRoaXMucG9zaXRpb25PZmZzZXQ9X2dsTWF0cml4LnZlYzMuY3JlYXRlKCksdGhpcy5fcng9bmV3IF9FYXNlTnVtYmVyMi5kZWZhdWx0KDApLHRoaXMuX3J4LmxpbWl0KC1NYXRoLlBJLzIsTWF0aC5QSS8yKSx0aGlzLl9yeT1uZXcgX0Vhc2VOdW1iZXIyLmRlZmF1bHQoMCksdGhpcy5fcHJlUlg9MCx0aGlzLl9wcmVSWT0wLHRoaXMuX2lzTG9ja1pvb209ITEsdGhpcy5faXNMb2NrUm90YXRpb249ITEsdGhpcy5faXNJbnZlcnQ9ITEsdGhpcy5zZW5zaXRpdml0eT0xLHRoaXMuX3doZWVsQmluZD1mdW5jdGlvbihlKXtyZXR1cm4gX3RoaXMuX29uV2hlZWwoZSl9LHRoaXMuX2Rvd25CaW5kPWZ1bmN0aW9uKGUpe3JldHVybiBfdGhpcy5fb25Eb3duKGUpfSx0aGlzLl9tb3ZlQmluZD1mdW5jdGlvbihlKXtyZXR1cm4gX3RoaXMuX29uTW92ZShlKX0sdGhpcy5fdXBCaW5kPWZ1bmN0aW9uKCl7cmV0dXJuIF90aGlzLl9vblVwKCl9LHRoaXMuY29ubmVjdCgpLF9zY2hlZHVsaW5nMi5kZWZhdWx0LmFkZEVGKGZ1bmN0aW9uKCl7cmV0dXJuIF90aGlzLl9sb29wKCl9KX1yZXR1cm4gX2NyZWF0ZUNsYXNzKE9yYml0YWxDb250cm9sLFt7a2V5OlwiY29ubmVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5kaXNjb25uZWN0KCksdGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNld2hlZWxcIix0aGlzLl93aGVlbEJpbmQpLHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Nb3VzZVNjcm9sbFwiLHRoaXMuX3doZWVsQmluZCksdGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLHRoaXMuX2Rvd25CaW5kKSx0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLHRoaXMuX2Rvd25CaW5kKSx0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsdGhpcy5fbW92ZUJpbmQpLHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIix0aGlzLl9tb3ZlQmluZCksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLHRoaXMuX3VwQmluZCksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdGhpcy5fdXBCaW5kKX19LHtrZXk6XCJkaXNjb25uZWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V3aGVlbFwiLHRoaXMuX3doZWVsQmluZCksdGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTU1vdXNlU2Nyb2xsXCIsdGhpcy5fd2hlZWxCaW5kKSx0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsdGhpcy5fZG93bkJpbmQpLHRoaXMuX2xpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsdGhpcy5fZG93bkJpbmQpLHRoaXMuX2xpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIix0aGlzLl9tb3ZlQmluZCksdGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLHRoaXMuX21vdmVCaW5kKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsdGhpcy5fdXBCaW5kKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIix0aGlzLl91cEJpbmQpfX0se2tleTpcImxvY2tcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBtVmFsdWU9IShhcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSl8fGFyZ3VtZW50c1swXTt0aGlzLl9pc0xvY2tab29tPW1WYWx1ZSx0aGlzLl9pc0xvY2tSb3RhdGlvbj1tVmFsdWUsdGhpcy5faXNNb3VzZURvd249ITF9fSx7a2V5OlwibG9ja1pvb21cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBtVmFsdWU9IShhcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSl8fGFyZ3VtZW50c1swXTt0aGlzLl9pc0xvY2tab29tPW1WYWx1ZX19LHtrZXk6XCJsb2NrUm90YXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBtVmFsdWU9IShhcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSl8fGFyZ3VtZW50c1swXTt0aGlzLl9pc0xvY2tSb3RhdGlvbj1tVmFsdWV9fSx7a2V5OlwiaW52ZXJzZUNvbnRyb2xcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBpc0ludmVydD0hKGFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdKXx8YXJndW1lbnRzWzBdO3RoaXMuX2lzSW52ZXJ0PWlzSW52ZXJ0fX0se2tleTpcIl9vbkRvd25cIix2YWx1ZTpmdW5jdGlvbihtRXZlbnQpe3RoaXMuX2lzTG9ja1JvdGF0aW9ufHwodGhpcy5faXNNb3VzZURvd249ITAsZ2V0TW91c2UobUV2ZW50LHRoaXMuX21vdXNlKSxnZXRNb3VzZShtRXZlbnQsdGhpcy5fcHJlTW91c2UpLHRoaXMuX3ByZVJYPXRoaXMuX3J4LnRhcmdldFZhbHVlLHRoaXMuX3ByZVJZPXRoaXMuX3J5LnRhcmdldFZhbHVlKX19LHtrZXk6XCJfb25Nb3ZlXCIsdmFsdWU6ZnVuY3Rpb24obUV2ZW50KXtpZighdGhpcy5faXNMb2NrUm90YXRpb24mJihnZXRNb3VzZShtRXZlbnQsdGhpcy5fbW91c2UpLG1FdmVudC50b3VjaGVzJiZtRXZlbnQucHJldmVudERlZmF1bHQoKSx0aGlzLl9pc01vdXNlRG93bikpe3ZhciBkaWZmWD0tKHRoaXMuX21vdXNlLngtdGhpcy5fcHJlTW91c2UueCk7dGhpcy5faXNJbnZlcnQmJihkaWZmWCo9LTEpLHRoaXMuX3J5LnZhbHVlPXRoaXMuX3ByZVJZLS4wMSpkaWZmWCp0aGlzLnNlbnNpdGl2aXR5O3ZhciBkaWZmWT0tKHRoaXMuX21vdXNlLnktdGhpcy5fcHJlTW91c2UueSk7dGhpcy5faXNJbnZlcnQmJihkaWZmWSo9LTEpLHRoaXMuX3J4LnZhbHVlPXRoaXMuX3ByZVJYLS4wMSpkaWZmWSp0aGlzLnNlbnNpdGl2aXR5fX19LHtrZXk6XCJfb25VcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5faXNMb2NrUm90YXRpb258fCh0aGlzLl9pc01vdXNlRG93bj0hMSl9fSx7a2V5OlwiX29uV2hlZWxcIix2YWx1ZTpmdW5jdGlvbihtRXZlbnQpe2lmKCF0aGlzLl9pc0xvY2tab29tKXt2YXIgdz1tRXZlbnQud2hlZWxEZWx0YSxkPW1FdmVudC5kZXRhaWwsdmFsdWU9MDt2YWx1ZT1kP3c/dy9kLzQwKmQ+MD8xOi0xOi1kLzM6dy8xMjAsdGhpcy5yYWRpdXMuYWRkKDIqLXZhbHVlKX19fSx7a2V5OlwiX2xvb3BcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3VwZGF0ZVBvc2l0aW9uKCksdGhpcy5fdGFyZ2V0JiZ0aGlzLl91cGRhdGVDYW1lcmEoKX19LHtrZXk6XCJfdXBkYXRlUG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucG9zaXRpb25bMV09TWF0aC5zaW4odGhpcy5fcngudmFsdWUpKnRoaXMucmFkaXVzLnZhbHVlO3ZhciB0cj1NYXRoLmNvcyh0aGlzLl9yeC52YWx1ZSkqdGhpcy5yYWRpdXMudmFsdWU7dGhpcy5wb3NpdGlvblswXT1NYXRoLmNvcyh0aGlzLl9yeS52YWx1ZSsuNSpNYXRoLlBJKSp0cix0aGlzLnBvc2l0aW9uWzJdPU1hdGguc2luKHRoaXMuX3J5LnZhbHVlKy41Kk1hdGguUEkpKnRyLF9nbE1hdHJpeC52ZWMzLmFkZCh0aGlzLnBvc2l0aW9uLHRoaXMucG9zaXRpb24sdGhpcy5wb3NpdGlvbk9mZnNldCl9fSx7a2V5OlwiX3VwZGF0ZUNhbWVyYVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fdGFyZ2V0Lmxvb2tBdCh0aGlzLnBvc2l0aW9uLHRoaXMuY2VudGVyLHRoaXMuX3VwKX19LHtrZXk6XCJyeFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yeH19LHtrZXk6XCJyeVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yeX19XSksT3JiaXRhbENvbnRyb2x9KCk7ZXhwb3J0cy5kZWZhdWx0PU9yYml0YWxDb250cm9sfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLGNhbGwpe2lmKCFzZWxmKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hY2FsbHx8XCJvYmplY3RcIiE9dHlwZW9mIGNhbGwmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGNhbGw/c2VsZjpjYWxsfWZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcyxzdXBlckNsYXNzKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBzdXBlckNsYXNzJiZudWxsIT09c3VwZXJDbGFzcyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2Ygc3VwZXJDbGFzcyk7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyYmc3VwZXJDbGFzcy5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpzdWJDbGFzcyxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxzdXBlckNsYXNzJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcyxzdXBlckNsYXNzKTpzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzcyl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fCExLGRlc2NyaXB0b3IuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGRlc2NyaXB0b3ImJihkZXNjcmlwdG9yLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpfX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7cmV0dXJuIHByb3RvUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpLHN0YXRpY1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKSxDb25zdHJ1Y3Rvcn19KCksX0NhbWVyYTI9X193ZWJwYWNrX3JlcXVpcmVfXygxNSksX0NhbWVyYTM9ZnVuY3Rpb24ob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX0oX0NhbWVyYTIpLF9nbE1hdHJpeD1fX3dlYnBhY2tfcmVxdWlyZV9fKDEpLENhbWVyYU9ydGhvPWZ1bmN0aW9uKF9DYW1lcmEpe2Z1bmN0aW9uIENhbWVyYU9ydGhvKCl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsQ2FtZXJhT3J0aG8pO3ZhciBfdGhpcz1fcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLChDYW1lcmFPcnRoby5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihDYW1lcmFPcnRobykpLmNhbGwodGhpcykpLGV5ZT1fZ2xNYXRyaXgudmVjMy5jbG9uZShbMCwwLDE1XSksY2VudGVyPV9nbE1hdHJpeC52ZWMzLmNyZWF0ZSgpLHVwPV9nbE1hdHJpeC52ZWMzLmNsb25lKFswLC0xLDBdKTtyZXR1cm4gX3RoaXMubG9va0F0KGV5ZSxjZW50ZXIsdXApLF90aGlzLm9ydGhvKDEsLTEsMSwtMSksX3RoaXN9cmV0dXJuIF9pbmhlcml0cyhDYW1lcmFPcnRobyxfQ2FtZXJhKSxfY3JlYXRlQ2xhc3MoQ2FtZXJhT3J0aG8sW3trZXk6XCJzZXRCb3VuZGFyeVwiLHZhbHVlOmZ1bmN0aW9uKGxlZnQscmlnaHQsdG9wLGJvdHRvbSl7dmFyIG5lYXI9YXJndW1lbnRzLmxlbmd0aD40JiZ2b2lkIDAhPT1hcmd1bWVudHNbNF0/YXJndW1lbnRzWzRdOi4xLGZhcj1hcmd1bWVudHMubGVuZ3RoPjUmJnZvaWQgMCE9PWFyZ3VtZW50c1s1XT9hcmd1bWVudHNbNV06MTAwO3RoaXMub3J0aG8obGVmdCxyaWdodCx0b3AsYm90dG9tLG5lYXIsZmFyKX19LHtrZXk6XCJvcnRob1wiLHZhbHVlOmZ1bmN0aW9uKGxlZnQscmlnaHQsdG9wLGJvdHRvbSl7dmFyIG5lYXI9YXJndW1lbnRzLmxlbmd0aD40JiZ2b2lkIDAhPT1hcmd1bWVudHNbNF0/YXJndW1lbnRzWzRdOi4xLGZhcj1hcmd1bWVudHMubGVuZ3RoPjUmJnZvaWQgMCE9PWFyZ3VtZW50c1s1XT9hcmd1bWVudHNbNV06MTAwO3RoaXMubGVmdD1sZWZ0LHRoaXMucmlnaHQ9cmlnaHQsdGhpcy50b3A9dG9wLHRoaXMuYm90dG9tPWJvdHRvbSxtYXQ0Lm9ydGhvKHRoaXMuX3Byb2plY3Rpb24sbGVmdCxyaWdodCx0b3AsYm90dG9tLG5lYXIsZmFyKX19XSksQ2FtZXJhT3J0aG99KF9DYW1lcmEzLmRlZmF1bHQpO2V4cG9ydHMuZGVmYXVsdD1DYW1lcmFPcnRob30sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLENvbnN0cnVjdG9yKXtpZighKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fCExLGRlc2NyaXB0b3IuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGRlc2NyaXB0b3ImJihkZXNjcmlwdG9yLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpfX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7cmV0dXJuIHByb3RvUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpLHN0YXRpY1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKSxDb25zdHJ1Y3Rvcn19KCksX2dsTWF0cml4PV9fd2VicGFja19yZXF1aXJlX18oMSksT2JqZWN0M0Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiBPYmplY3QzRCgpe19jbGFzc0NhbGxDaGVjayh0aGlzLE9iamVjdDNEKSx0aGlzLl9uZWVkVXBkYXRlPSEwLHRoaXMuX3g9MCx0aGlzLl95PTAsdGhpcy5fej0wLHRoaXMuX3N4PTEsdGhpcy5fc3k9MSx0aGlzLl9zej0xLHRoaXMuX3J4PTAsdGhpcy5fcnk9MCx0aGlzLl9yej0wLHRoaXMuX3Bvc2l0aW9uPV9nbE1hdHJpeC52ZWMzLmNyZWF0ZSgpLHRoaXMuX3NjYWxlPV9nbE1hdHJpeC52ZWMzLmZyb21WYWx1ZXMoMSwxLDEpLHRoaXMuX3JvdGF0aW9uPV9nbE1hdHJpeC52ZWMzLmNyZWF0ZSgpLHRoaXMuX21hdHJpeD1fZ2xNYXRyaXgubWF0NC5jcmVhdGUoKSx0aGlzLl9tYXRyaXhSb3RhdGlvbj1fZ2xNYXRyaXgubWF0NC5jcmVhdGUoKSx0aGlzLl9tYXRyaXhTY2FsZT1fZ2xNYXRyaXgubWF0NC5jcmVhdGUoKSx0aGlzLl9tYXRyaXhUcmFuc2xhdGlvbj1fZ2xNYXRyaXgubWF0NC5jcmVhdGUoKSx0aGlzLl9tYXRyaXhRdWF0ZXJuaW9uPV9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpLHRoaXMuX3F1YXQ9X2dsTWF0cml4LnF1YXQuY3JlYXRlKCl9cmV0dXJuIF9jcmVhdGVDbGFzcyhPYmplY3QzRCxbe2tleTpcIl91cGRhdGVcIix2YWx1ZTpmdW5jdGlvbigpe19nbE1hdHJpeC52ZWMzLnNldCh0aGlzLl9zY2FsZSx0aGlzLl9zeCx0aGlzLl9zeSx0aGlzLl9zeiksX2dsTWF0cml4LnZlYzMuc2V0KHRoaXMuX3JvdGF0aW9uLHRoaXMuX3J4LHRoaXMuX3J5LHRoaXMuX3J6KSxfZ2xNYXRyaXgudmVjMy5zZXQodGhpcy5fcG9zaXRpb24sdGhpcy5feCx0aGlzLl95LHRoaXMuX3opLF9nbE1hdHJpeC5tYXQ0LmlkZW50aXR5KHRoaXMuX21hdHJpeFRyYW5zbGF0aW9uLHRoaXMuX21hdHJpeFRyYW5zbGF0aW9uKSxfZ2xNYXRyaXgubWF0NC5pZGVudGl0eSh0aGlzLl9tYXRyaXhTY2FsZSx0aGlzLl9tYXRyaXhTY2FsZSksX2dsTWF0cml4Lm1hdDQuaWRlbnRpdHkodGhpcy5fbWF0cml4Um90YXRpb24sdGhpcy5fbWF0cml4Um90YXRpb24pLF9nbE1hdHJpeC5tYXQ0LnJvdGF0ZVgodGhpcy5fbWF0cml4Um90YXRpb24sdGhpcy5fbWF0cml4Um90YXRpb24sdGhpcy5fcngpLF9nbE1hdHJpeC5tYXQ0LnJvdGF0ZVkodGhpcy5fbWF0cml4Um90YXRpb24sdGhpcy5fbWF0cml4Um90YXRpb24sdGhpcy5fcnkpLF9nbE1hdHJpeC5tYXQ0LnJvdGF0ZVoodGhpcy5fbWF0cml4Um90YXRpb24sdGhpcy5fbWF0cml4Um90YXRpb24sdGhpcy5fcnopLF9nbE1hdHJpeC5tYXQ0LmZyb21RdWF0KHRoaXMuX21hdHJpeFF1YXRlcm5pb24sdGhpcy5fcXVhdCksX2dsTWF0cml4Lm1hdDQubXVsKHRoaXMuX21hdHJpeFJvdGF0aW9uLHRoaXMuX21hdHJpeFF1YXRlcm5pb24sdGhpcy5fbWF0cml4Um90YXRpb24pLF9nbE1hdHJpeC5tYXQ0LnNjYWxlKHRoaXMuX21hdHJpeFNjYWxlLHRoaXMuX21hdHJpeFNjYWxlLHRoaXMuX3NjYWxlKSxfZ2xNYXRyaXgubWF0NC50cmFuc2xhdGUodGhpcy5fbWF0cml4VHJhbnNsYXRpb24sdGhpcy5fbWF0cml4VHJhbnNsYXRpb24sdGhpcy5fcG9zaXRpb24pLF9nbE1hdHJpeC5tYXQ0Lm11bCh0aGlzLl9tYXRyaXgsdGhpcy5fbWF0cml4VHJhbnNsYXRpb24sdGhpcy5fbWF0cml4Um90YXRpb24pLF9nbE1hdHJpeC5tYXQ0Lm11bCh0aGlzLl9tYXRyaXgsdGhpcy5fbWF0cml4LHRoaXMuX21hdHJpeFNjYWxlKSx0aGlzLl9uZWVkVXBkYXRlPSExfX0se2tleTpcInNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb25cIix2YWx1ZTpmdW5jdGlvbihtUXVhdCl7X2dsTWF0cml4LnF1YXQuY29weSh0aGlzLl9xdWF0LG1RdWF0KSx0aGlzLl9uZWVkVXBkYXRlPSEwfX0se2tleTpcIm1hdHJpeFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9uZWVkVXBkYXRlJiZ0aGlzLl91cGRhdGUoKSx0aGlzLl9tYXRyaXh9fSx7a2V5OlwieFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl94fSxzZXQ6ZnVuY3Rpb24obVZhbHVlKXt0aGlzLl9uZWVkVXBkYXRlPSEwLHRoaXMuX3g9bVZhbHVlfX0se2tleTpcInlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5feX0sc2V0OmZ1bmN0aW9uKG1WYWx1ZSl7dGhpcy5fbmVlZFVwZGF0ZT0hMCx0aGlzLl95PW1WYWx1ZX19LHtrZXk6XCJ6XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3p9LHNldDpmdW5jdGlvbihtVmFsdWUpe3RoaXMuX25lZWRVcGRhdGU9ITAsdGhpcy5fej1tVmFsdWV9fSx7a2V5Olwic2NhbGVYXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N4fSxzZXQ6ZnVuY3Rpb24obVZhbHVlKXt0aGlzLl9uZWVkVXBkYXRlPSEwLHRoaXMuX3N4PW1WYWx1ZX19LHtrZXk6XCJzY2FsZVlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3l9LHNldDpmdW5jdGlvbihtVmFsdWUpe3RoaXMuX25lZWRVcGRhdGU9ITAsdGhpcy5fc3k9bVZhbHVlfX0se2tleTpcInNjYWxlWlwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zen0sc2V0OmZ1bmN0aW9uKG1WYWx1ZSl7dGhpcy5fbmVlZFVwZGF0ZT0hMCx0aGlzLl9zej1tVmFsdWV9fSx7a2V5Olwicm90YXRpb25YXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3J4fSxzZXQ6ZnVuY3Rpb24obVZhbHVlKXt0aGlzLl9uZWVkVXBkYXRlPSEwLHRoaXMuX3J4PW1WYWx1ZX19LHtrZXk6XCJyb3RhdGlvbllcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcnl9LHNldDpmdW5jdGlvbihtVmFsdWUpe3RoaXMuX25lZWRVcGRhdGU9ITAsdGhpcy5fcnk9bVZhbHVlfX0se2tleTpcInJvdGF0aW9uWlwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yen0sc2V0OmZ1bmN0aW9uKG1WYWx1ZSl7dGhpcy5fbmVlZFVwZGF0ZT0hMCx0aGlzLl9yej1tVmFsdWV9fV0pLE9iamVjdDNEfSgpO2V4cG9ydHMuZGVmYXVsdD1PYmplY3QzRH0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7ZGVmYXVsdDpvYmp9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBfc2ltcGxlQ29sb3I9X193ZWJwYWNrX3JlcXVpcmVfXygxMCksX3NpbXBsZUNvbG9yMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaW1wbGVDb2xvciksX2JpZ1RyaWFuZ2xlPV9fd2VicGFja19yZXF1aXJlX18oMTgpLF9iaWdUcmlhbmdsZTI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmlnVHJpYW5nbGUpLF9nZW5lcmFsPV9fd2VicGFja19yZXF1aXJlX18oMzMpLF9nZW5lcmFsMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZW5lcmFsKSxfY29weT1fX3dlYnBhY2tfcmVxdWlyZV9fKDE5KSxfY29weTI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29weSksX2Jhc2ljPV9fd2VicGFja19yZXF1aXJlX18oMTEpLF9iYXNpYzI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzaWMpLF9za3lib3g9X193ZWJwYWNrX3JlcXVpcmVfXygzNCksX3NreWJveDI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2t5Ym94KSxfc2t5Ym94Mz1fX3dlYnBhY2tfcmVxdWlyZV9fKDM1KSxfc2t5Ym94ND1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9za3lib3gzKSxTaGFkZXJMaWJzPXtzaW1wbGVDb2xvckZyYWc6X3NpbXBsZUNvbG9yMi5kZWZhdWx0LGJpZ1RyaWFuZ2xlVmVydDpfYmlnVHJpYW5nbGUyLmRlZmF1bHQsZ2VuZXJhbFZlcnQ6X2dlbmVyYWwyLmRlZmF1bHQsY29weUZyYWc6X2NvcHkyLmRlZmF1bHQsYmFzaWNWZXJ0Ol9iYXNpYzIuZGVmYXVsdCxza3lib3hWZXJ0Ol9za3lib3gyLmRlZmF1bHQsc2t5Ym94RnJhZzpfc2t5Ym94NC5kZWZhdWx0fTtleHBvcnRzLmRlZmF1bHQ9U2hhZGVyTGlic30sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPVwiLy8gZ2VuZXJhbFdpdGhOb3JtYWwudmVydFxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgR0VORVJBTF9WRVJURVhcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgdU5vcm1hbE1hdHJpeDtcXG5cXG51bmlmb3JtIHZlYzMgcG9zaXRpb247XFxudW5pZm9ybSB2ZWMzIHNjYWxlO1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFx0dmVjMyBwb3MgICAgICA9IGFWZXJ0ZXhQb3NpdGlvbiAqIHNjYWxlO1xcblxcdHBvcyAgICAgICAgICAgKz0gcG9zaXRpb247XFxuXFx0Z2xfUG9zaXRpb24gICA9IHVQcm9qZWN0aW9uTWF0cml4ICogdVZpZXdNYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KHBvcywgMS4wKTtcXG5cXHRcXG5cXHR2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG5cXHR2Tm9ybWFsICAgICAgID0gbm9ybWFsaXplKHVOb3JtYWxNYXRyaXggKiBhTm9ybWFsKTtcXG59XCJ9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1cIi8vIGJhc2ljLnZlcnRcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIFNLWUJPWF9WRVJURVhcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdlZlcnRleDtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdG1hdDQgbWF0VmlldyA9IHVWaWV3TWF0cml4O1xcblxcdG1hdFZpZXdbM11bMF0gPSAwLjA7XFxuXFx0bWF0Vmlld1szXVsxXSA9IDAuMDtcXG5cXHRtYXRWaWV3WzNdWzJdID0gMC4wO1xcblxcdFxcblxcdGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiBtYXRWaWV3ICogdU1vZGVsTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24sIDEuMCk7XFxuXFx0dlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuXFx0XFxuXFx0dlZlcnRleCA9IGFWZXJ0ZXhQb3NpdGlvbjtcXG5cXHR2Tm9ybWFsID0gYU5vcm1hbDtcXG59XCJ9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1cIi8vIGJhc2ljLmZyYWdcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIFNLWUJPWF9GUkFHTUVOVFxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxudW5pZm9ybSBzYW1wbGVyQ3ViZSB0ZXh0dXJlO1xcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2VmVydGV4O1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKHRleHR1cmUsIHZWZXJ0ZXgpO1xcbn1cIn0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLENvbnN0cnVjdG9yKXtpZighKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fCExLGRlc2NyaXB0b3IuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGRlc2NyaXB0b3ImJihkZXNjcmlwdG9yLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpfX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7cmV0dXJuIHByb3RvUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpLHN0YXRpY1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKSxDb25zdHJ1Y3Rvcn19KCksUGFzc01hY3JvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gUGFzc01hY3JvKCl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsUGFzc01hY3JvKSx0aGlzLl9wYXNzZXM9W119cmV0dXJuIF9jcmVhdGVDbGFzcyhQYXNzTWFjcm8sW3trZXk6XCJhZGRQYXNzXCIsdmFsdWU6ZnVuY3Rpb24ocGFzcyl7dGhpcy5fcGFzc2VzLnB1c2gocGFzcyl9fSx7a2V5OlwicGFzc2VzXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Bhc3Nlc319XSksUGFzc01hY3JvfSgpO2V4cG9ydHMuZGVmYXVsdD1QYXNzTWFjcm99LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSxDb25zdHJ1Y3Rvcil7aWYoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsY2FsbCl7aWYoIXNlbGYpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFjYWxsfHxcIm9iamVjdFwiIT10eXBlb2YgY2FsbCYmXCJmdW5jdGlvblwiIT10eXBlb2YgY2FsbD9zZWxmOmNhbGx9ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLHN1cGVyQ2xhc3Mpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHN1cGVyQ2xhc3MmJm51bGwhPT1zdXBlckNsYXNzKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBzdXBlckNsYXNzKTtzdWJDbGFzcy5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzJiZzdXBlckNsYXNzLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnN1YkNsYXNzLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHN1cGVyQ2xhc3MmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLHN1cGVyQ2xhc3MpOnN1YkNsYXNzLl9fcHJvdG9fXz1zdXBlckNsYXNzKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX1Bhc3NCbHVyQmFzZTI9X193ZWJwYWNrX3JlcXVpcmVfXygzOCksX1Bhc3NCbHVyQmFzZTM9ZnVuY3Rpb24ob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX0oX1Bhc3NCbHVyQmFzZTIpLFBhc3NWQmx1cj1mdW5jdGlvbihfUGFzc0JsdXJCYXNlKXtmdW5jdGlvbiBQYXNzVkJsdXIoKXt2YXIgbVF1YWxpdHk9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOjksbVdpZHRoPWFyZ3VtZW50c1sxXSxtSGVpZ2h0PWFyZ3VtZW50c1syXSxtUGFyYW1zPWFyZ3VtZW50c1szXTtyZXR1cm4gX2NsYXNzQ2FsbENoZWNrKHRoaXMsUGFzc1ZCbHVyKSxfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLChQYXNzVkJsdXIuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoUGFzc1ZCbHVyKSkuY2FsbCh0aGlzLG1RdWFsaXR5LFswLDFdLG1XaWR0aCxtSGVpZ2h0LG1QYXJhbXMpKX1yZXR1cm4gX2luaGVyaXRzKFBhc3NWQmx1cixfUGFzc0JsdXJCYXNlKSxQYXNzVkJsdXJ9KF9QYXNzQmx1ckJhc2UzLmRlZmF1bHQpO2V4cG9ydHMuZGVmYXVsdD1QYXNzVkJsdXJ9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLGNhbGwpe2lmKCFzZWxmKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hY2FsbHx8XCJvYmplY3RcIiE9dHlwZW9mIGNhbGwmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGNhbGw/c2VsZjpjYWxsfWZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcyxzdXBlckNsYXNzKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBzdXBlckNsYXNzJiZudWxsIT09c3VwZXJDbGFzcyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2Ygc3VwZXJDbGFzcyk7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyYmc3VwZXJDbGFzcy5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpzdWJDbGFzcyxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxzdXBlckNsYXNzJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcyxzdXBlckNsYXNzKTpzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzcyl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9HTFRvb2w9X193ZWJwYWNrX3JlcXVpcmVfXygwKSxfR0xUb29sMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HTFRvb2wpLF9QYXNzMj1fX3dlYnBhY2tfcmVxdWlyZV9fKDkpLF9QYXNzMz1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QYXNzMiksZnNCbHVyNT1fX3dlYnBhY2tfcmVxdWlyZV9fKDczKSxmc0JsdXI5PV9fd2VicGFja19yZXF1aXJlX18oNzQpLGZzQmx1cjEzPV9fd2VicGFja19yZXF1aXJlX18oNzUpLFBhc3NCbHVyQmFzZT1mdW5jdGlvbihfUGFzcyl7ZnVuY3Rpb24gUGFzc0JsdXJCYXNlKCl7dmFyIG1RdWFsaXR5PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTo5LG1EaXJlY3Rpb249YXJndW1lbnRzWzFdLG1XaWR0aD1hcmd1bWVudHNbMl0sbUhlaWdodD1hcmd1bWVudHNbM10sbVBhcmFtcz1hcmd1bWVudHMubGVuZ3RoPjQmJnZvaWQgMCE9PWFyZ3VtZW50c1s0XT9hcmd1bWVudHNbNF06e307X2NsYXNzQ2FsbENoZWNrKHRoaXMsUGFzc0JsdXJCYXNlKTt2YXIgZnM9dm9pZCAwO3N3aXRjaChtUXVhbGl0eSl7Y2FzZSA1OmRlZmF1bHQ6ZnM9ZnNCbHVyNTticmVhaztjYXNlIDk6ZnM9ZnNCbHVyOTticmVhaztjYXNlIDEzOmZzPWZzQmx1cjEzfXZhciBfdGhpcz1fcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLChQYXNzQmx1ckJhc2UuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoUGFzc0JsdXJCYXNlKSkuY2FsbCh0aGlzLGZzLG1XaWR0aCxtSGVpZ2h0LG1QYXJhbXMpKTtyZXR1cm4gX3RoaXMudW5pZm9ybShcInVEaXJlY3Rpb25cIixtRGlyZWN0aW9uKSxfdGhpcy51bmlmb3JtKFwidVJlc29sdXRpb25cIixbX0dMVG9vbDIuZGVmYXVsdC53aWR0aCxfR0xUb29sMi5kZWZhdWx0LmhlaWdodF0pLF90aGlzfXJldHVybiBfaW5oZXJpdHMoUGFzc0JsdXJCYXNlLF9QYXNzKSxQYXNzQmx1ckJhc2V9KF9QYXNzMy5kZWZhdWx0KTtleHBvcnRzLmRlZmF1bHQ9UGFzc0JsdXJCYXNlfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLGNhbGwpe2lmKCFzZWxmKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hY2FsbHx8XCJvYmplY3RcIiE9dHlwZW9mIGNhbGwmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGNhbGw/c2VsZjpjYWxsfWZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcyxzdXBlckNsYXNzKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBzdXBlckNsYXNzJiZudWxsIT09c3VwZXJDbGFzcyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2Ygc3VwZXJDbGFzcyk7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyYmc3VwZXJDbGFzcy5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpzdWJDbGFzcyxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxzdXBlckNsYXNzJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcyxzdXBlckNsYXNzKTpzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzcyl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9QYXNzQmx1ckJhc2UyPV9fd2VicGFja19yZXF1aXJlX18oMzgpLF9QYXNzQmx1ckJhc2UzPWZ1bmN0aW9uKG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntkZWZhdWx0Om9ian19KF9QYXNzQmx1ckJhc2UyKSxQYXNzSEJsdXI9ZnVuY3Rpb24oX1Bhc3NCbHVyQmFzZSl7ZnVuY3Rpb24gUGFzc0hCbHVyKCl7dmFyIG1RdWFsaXR5PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTo5LG1XaWR0aD1hcmd1bWVudHNbMV0sbUhlaWdodD1hcmd1bWVudHNbMl0sbVBhcmFtcz1hcmd1bWVudHNbM107cmV0dXJuIF9jbGFzc0NhbGxDaGVjayh0aGlzLFBhc3NIQmx1ciksX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywoUGFzc0hCbHVyLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKFBhc3NIQmx1cikpLmNhbGwodGhpcyxtUXVhbGl0eSxbMSwwXSxtV2lkdGgsbUhlaWdodCxtUGFyYW1zKSl9cmV0dXJuIF9pbmhlcml0cyhQYXNzSEJsdXIsX1Bhc3NCbHVyQmFzZSksUGFzc0hCbHVyfShfUGFzc0JsdXJCYXNlMy5kZWZhdWx0KTtleHBvcnRzLmRlZmF1bHQ9UGFzc0hCbHVyfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9XCIvLyBmeGFhLmZyYWdcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEZYQUFcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcbnVuaWZvcm0gdmVjMiB1UmVzb2x1dGlvbjtcXG5cXG5cXG5mbG9hdCBGWEFBX1NVQlBJWF9TSElGVCA9IDEuMC80LjA7XFxuI2RlZmluZSBGWEFBX1JFRFVDRV9NSU4gICAoMS4wLyAxMjguMClcXG4jZGVmaW5lIEZYQUFfUkVEVUNFX01VTCAgICgxLjAgLyA4LjApXFxuI2RlZmluZSBGWEFBX1NQQU5fTUFYICAgICA4LjBcXG5cXG5cXG52ZWM0IGFwcGx5RlhBQShzYW1wbGVyMkQgdGV4KSB7XFxuICAgIHZlYzQgY29sb3I7XFxuICAgIHZlYzIgZnJhZ0Nvb3JkID0gZ2xfRnJhZ0Nvb3JkLnh5O1xcbiAgICB2ZWMzIHJnYk5XID0gdGV4dHVyZTJEKHRleCwgKGZyYWdDb29yZCArIHZlYzIoLTEuMCwgLTEuMCkpICogdVJlc29sdXRpb24pLnh5ejtcXG4gICAgdmVjMyByZ2JORSA9IHRleHR1cmUyRCh0ZXgsIChmcmFnQ29vcmQgKyB2ZWMyKDEuMCwgLTEuMCkpICogdVJlc29sdXRpb24pLnh5ejtcXG4gICAgdmVjMyByZ2JTVyA9IHRleHR1cmUyRCh0ZXgsIChmcmFnQ29vcmQgKyB2ZWMyKC0xLjAsIDEuMCkpICogdVJlc29sdXRpb24pLnh5ejtcXG4gICAgdmVjMyByZ2JTRSA9IHRleHR1cmUyRCh0ZXgsIChmcmFnQ29vcmQgKyB2ZWMyKDEuMCwgMS4wKSkgKiB1UmVzb2x1dGlvbikueHl6O1xcbiAgICB2ZWMzIHJnYk0gID0gdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICAqIHVSZXNvbHV0aW9uKS54eXo7XFxuICAgIHZlYzMgbHVtYSA9IHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCk7XFxuICAgIGZsb2F0IGx1bWFOVyA9IGRvdChyZ2JOVywgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFORSA9IGRvdChyZ2JORSwgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFTVyA9IGRvdChyZ2JTVywgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFTRSA9IGRvdChyZ2JTRSwgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFNICA9IGRvdChyZ2JNLCAgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFNaW4gPSBtaW4obHVtYU0sIG1pbihtaW4obHVtYU5XLCBsdW1hTkUpLCBtaW4obHVtYVNXLCBsdW1hU0UpKSk7XFxuICAgIGZsb2F0IGx1bWFNYXggPSBtYXgobHVtYU0sIG1heChtYXgobHVtYU5XLCBsdW1hTkUpLCBtYXgobHVtYVNXLCBsdW1hU0UpKSk7XFxuXFxuICAgIHZlYzIgZGlyO1xcbiAgICBkaXIueCA9IC0oKGx1bWFOVyArIGx1bWFORSkgLSAobHVtYVNXICsgbHVtYVNFKSk7XFxuICAgIGRpci55ID0gICgobHVtYU5XICsgbHVtYVNXKSAtIChsdW1hTkUgKyBsdW1hU0UpKTtcXG5cXG4gICAgZmxvYXQgZGlyUmVkdWNlID0gbWF4KChsdW1hTlcgKyBsdW1hTkUgKyBsdW1hU1cgKyBsdW1hU0UpICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgwLjI1ICogRlhBQV9SRURVQ0VfTVVMKSwgRlhBQV9SRURVQ0VfTUlOKTtcXG5cXG4gICAgZmxvYXQgcmNwRGlyTWluID0gMS4wIC8gKG1pbihhYnMoZGlyLngpLCBhYnMoZGlyLnkpKSArIGRpclJlZHVjZSk7XFxuICAgIGRpciA9IG1pbih2ZWMyKEZYQUFfU1BBTl9NQVgsIEZYQUFfU1BBTl9NQVgpLFxcbiAgICAgICAgICAgICAgbWF4KHZlYzIoLUZYQUFfU1BBTl9NQVgsIC1GWEFBX1NQQU5fTUFYKSxcXG4gICAgICAgICAgICAgIGRpciAqIHJjcERpck1pbikpICogdVJlc29sdXRpb247XFxuXFxuICAgIHZlYzMgcmdiQSA9IDAuNSAqIChcXG4gICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIHVSZXNvbHV0aW9uICsgZGlyICogKDEuMCAvIDMuMCAtIDAuNSkpLnh5eiArXFxuICAgICAgICB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiB1UmVzb2x1dGlvbiArIGRpciAqICgyLjAgLyAzLjAgLSAwLjUpKS54eXopO1xcbiAgICB2ZWMzIHJnYkIgPSByZ2JBICogMC41ICsgMC4yNSAqIChcXG4gICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIHVSZXNvbHV0aW9uICsgZGlyICogLTAuNSkueHl6ICtcXG4gICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIHVSZXNvbHV0aW9uICsgZGlyICogMC41KS54eXopO1xcblxcbiAgICBmbG9hdCBsdW1hQiA9IGRvdChyZ2JCLCBsdW1hKTtcXG4gICAgaWYgKChsdW1hQiA8IGx1bWFNaW4pIHx8IChsdW1hQiA+IGx1bWFNYXgpKVxcbiAgICAgICAgY29sb3IgPSB2ZWM0KHJnYkEsIDEuMCk7XFxuICAgIGVsc2VcXG4gICAgICAgIGNvbG9yID0gdmVjNChyZ2JCLCAxLjApO1xcbiAgICByZXR1cm4gY29sb3I7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuIFxcdHZlYzQgY29sb3IgPSBhcHBseUZYQUEodGV4dHVyZSk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cIn0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7ZGVmYXVsdDpvYmp9fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSxDb25zdHJ1Y3Rvcil7aWYoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGV4cG9ydHMuU2hhZGVyTGlicz1leHBvcnRzLlZpZXczRD1leHBvcnRzLlZpZXc9ZXhwb3J0cy5TY2VuZT1leHBvcnRzLkJhdGNoRlhBQT1leHBvcnRzLkJhdGNoU2t5PWV4cG9ydHMuQmF0Y2hTa3lib3g9ZXhwb3J0cy5CYXRjaExpbmU9ZXhwb3J0cy5CYXRjaERvdHNQbGFuZT1leHBvcnRzLkJhdGNoQmFsbD1leHBvcnRzLkJhdGNoQXhpcz1leHBvcnRzLkJhdGNoQ29weT1leHBvcnRzLlBhc3NGeGFhPWV4cG9ydHMuUGFzc0hCbHVyPWV4cG9ydHMuUGFzc1ZCbHVyPWV4cG9ydHMuUGFzc0JsdXI9ZXhwb3J0cy5QYXNzTWFjcm89ZXhwb3J0cy5QYXNzPWV4cG9ydHMuRWZmZWN0Q29tcG9zZXI9ZXhwb3J0cy5Db2xsYWRhUGFyc2VyPWV4cG9ydHMuSERSTG9hZGVyPWV4cG9ydHMuT2JqTG9hZGVyPWV4cG9ydHMuQmluYXJ5TG9hZGVyPWV4cG9ydHMuT2JqZWN0M0Q9ZXhwb3J0cy5SYXk9ZXhwb3J0cy5DYW1lcmFDdWJlPWV4cG9ydHMuQ2FtZXJhUGVyc3BlY3RpdmU9ZXhwb3J0cy5DYW1lcmFPcnRobz1leHBvcnRzLkNhbWVyYT1leHBvcnRzLlRvdWNoRGV0ZWN0b3I9ZXhwb3J0cy5RdWF0Um90YXRpb249ZXhwb3J0cy5XZWJnbE51bWJlcj1leHBvcnRzLk9yYml0YWxDb250cm9sPWV4cG9ydHMuVHdlZW5OdW1iZXI9ZXhwb3J0cy5FYXNlTnVtYmVyPWV4cG9ydHMuRXZlbnREaXNwYXRjaGVyPWV4cG9ydHMuU2NoZWR1bGVyPWV4cG9ydHMuVHJhbnNmb3JtRmVlZGJhY2tPYmplY3Q9ZXhwb3J0cy5NdWx0aXNhbXBsZUZyYW1lQnVmZmVyPWV4cG9ydHMuQ3ViZUZyYW1lQnVmZmVyPWV4cG9ydHMuRnJhbWVCdWZmZXI9ZXhwb3J0cy5CYXRjaD1leHBvcnRzLkdlb209ZXhwb3J0cy5NZXNoPWV4cG9ydHMuR0xDdWJlVGV4dHVyZT1leHBvcnRzLkdMVGV4dHVyZU9sZD1leHBvcnRzLkdMVGV4dHVyZT1leHBvcnRzLkdMU2hhZGVyPWV4cG9ydHMuR0w9dm9pZCAwO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHwhMSxkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBkZXNjcmlwdG9yJiYoZGVzY3JpcHRvci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCxkZXNjcmlwdG9yLmtleSxkZXNjcmlwdG9yKX19cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe3JldHVybiBwcm90b1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKSxzdGF0aWNQcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyksQ29uc3RydWN0b3J9fSgpLF9nbE1hdHJpeD1fX3dlYnBhY2tfcmVxdWlyZV9fKDEpLEdMTT1mdW5jdGlvbihvYmope2lmKG9iaiYmb2JqLl9fZXNNb2R1bGUpcmV0dXJuIG9iajt2YXIgbmV3T2JqPXt9O2lmKG51bGwhPW9iailmb3IodmFyIGtleSBpbiBvYmopT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaixrZXkpJiYobmV3T2JqW2tleV09b2JqW2tleV0pO3JldHVybiBuZXdPYmouZGVmYXVsdD1vYmosbmV3T2JqfShfZ2xNYXRyaXgpLF9HTFRvb2w9X193ZWJwYWNrX3JlcXVpcmVfXygwKSxfR0xUb29sMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HTFRvb2wpLF9HTFNoYWRlcj1fX3dlYnBhY2tfcmVxdWlyZV9fKDIpLF9HTFNoYWRlcjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR0xTaGFkZXIpLF9HTFRleHR1cmU9X193ZWJwYWNrX3JlcXVpcmVfXygyNSksX0dMVGV4dHVyZTI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR0xUZXh0dXJlKSxfR0xUZXh0dXJlMz1fX3dlYnBhY2tfcmVxdWlyZV9fKDI2KSxfR0xUZXh0dXJlND1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HTFRleHR1cmUzKSxfR0xDdWJlVGV4dHVyZT1fX3dlYnBhY2tfcmVxdWlyZV9fKDI3KSxfR0xDdWJlVGV4dHVyZTI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR0xDdWJlVGV4dHVyZSksX01lc2g9X193ZWJwYWNrX3JlcXVpcmVfXyg1KSxfTWVzaDI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWVzaCksX0dlb209X193ZWJwYWNrX3JlcXVpcmVfXyg3KSxfR2VvbTI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR2VvbSksX0JhdGNoPV9fd2VicGFja19yZXF1aXJlX18oNCksX0JhdGNoMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXRjaCksX0ZyYW1lQnVmZmVyPV9fd2VicGFja19yZXF1aXJlX18oMTIpLF9GcmFtZUJ1ZmZlcjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRnJhbWVCdWZmZXIpLF9DdWJlRnJhbWVCdWZmZXI9X193ZWJwYWNrX3JlcXVpcmVfXyg1NiksX0N1YmVGcmFtZUJ1ZmZlcjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ3ViZUZyYW1lQnVmZmVyKSxfTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlcj1fX3dlYnBhY2tfcmVxdWlyZV9fKDU3KSxfTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlcjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlciksX1RyYW5zZm9ybUZlZWRiYWNrT2JqZWN0PV9fd2VicGFja19yZXF1aXJlX18oNTgpLF9UcmFuc2Zvcm1GZWVkYmFja09iamVjdDI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVHJhbnNmb3JtRmVlZGJhY2tPYmplY3QpLF9zY2hlZHVsaW5nPV9fd2VicGFja19yZXF1aXJlX18oNiksX3NjaGVkdWxpbmcyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NjaGVkdWxpbmcpLF9FdmVudERpc3BhdGNoZXI9X193ZWJwYWNrX3JlcXVpcmVfXygyOCksX0V2ZW50RGlzcGF0Y2hlcjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRXZlbnREaXNwYXRjaGVyKSxfRWFzZU51bWJlcj1fX3dlYnBhY2tfcmVxdWlyZV9fKDEzKSxfRWFzZU51bWJlcjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRWFzZU51bWJlciksX1R3ZWVuTnVtYmVyPV9fd2VicGFja19yZXF1aXJlX18oNTkpLF9Ud2Vlbk51bWJlcjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVHdlZW5OdW1iZXIpLF9PcmJpdGFsQ29udHJvbD1fX3dlYnBhY2tfcmVxdWlyZV9fKDI5KSxfT3JiaXRhbENvbnRyb2wyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX09yYml0YWxDb250cm9sKSxfUXVhdFJvdGF0aW9uPV9fd2VicGFja19yZXF1aXJlX18oNjApLF9RdWF0Um90YXRpb24yPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1F1YXRSb3RhdGlvbiksX1RvdWNoRGV0ZWN0b3I9X193ZWJwYWNrX3JlcXVpcmVfXyg2MSksX1RvdWNoRGV0ZWN0b3IyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RvdWNoRGV0ZWN0b3IpLF9XZWJnbE51bWJlcj1fX3dlYnBhY2tfcmVxdWlyZV9fKDgpLF9XZWJnbE51bWJlcjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfV2ViZ2xOdW1iZXIpLF9XZWJnbENvbnN0PV9fd2VicGFja19yZXF1aXJlX18oMjMpLF9DYW1lcmE9KF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1dlYmdsQ29uc3QpLF9fd2VicGFja19yZXF1aXJlX18oMTUpKSxfQ2FtZXJhMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYW1lcmEpLF9DYW1lcmFPcnRobz1fX3dlYnBhY2tfcmVxdWlyZV9fKDMwKSxfQ2FtZXJhT3J0aG8yPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbWVyYU9ydGhvKSxfQ2FtZXJhUGVyc3BlY3RpdmU9X193ZWJwYWNrX3JlcXVpcmVfXygxNiksX0NhbWVyYVBlcnNwZWN0aXZlMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYW1lcmFQZXJzcGVjdGl2ZSksX0NhbWVyYUN1YmU9X193ZWJwYWNrX3JlcXVpcmVfXyg2MyksX0NhbWVyYUN1YmUyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbWVyYUN1YmUpLF9SYXk9X193ZWJwYWNrX3JlcXVpcmVfXygxNCksX1JheTI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmF5KSxfT2JqZWN0M0Q9X193ZWJwYWNrX3JlcXVpcmVfXygzMSksX09iamVjdDNEMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9PYmplY3QzRCksX0JpbmFyeUxvYWRlcj1fX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSxfQmluYXJ5TG9hZGVyMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CaW5hcnlMb2FkZXIpLF9PYmpMb2FkZXI9X193ZWJwYWNrX3JlcXVpcmVfXyg2NCksX09iakxvYWRlcjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfT2JqTG9hZGVyKSxfSERSTG9hZGVyPV9fd2VicGFja19yZXF1aXJlX18oNjUpLF9IRFJMb2FkZXIyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0hEUkxvYWRlciksX0NvbGxhZGFQYXJzZXI9X193ZWJwYWNrX3JlcXVpcmVfXyg2NyksX0NvbGxhZGFQYXJzZXIyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbGxhZGFQYXJzZXIpLF9FZmZlY3RDb21wb3Nlcj1fX3dlYnBhY2tfcmVxdWlyZV9fKDcxKSxfRWZmZWN0Q29tcG9zZXIyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0VmZmVjdENvbXBvc2VyKSxfUGFzcz1fX3dlYnBhY2tfcmVxdWlyZV9fKDkpLF9QYXNzMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QYXNzKSxfUGFzc01hY3JvPV9fd2VicGFja19yZXF1aXJlX18oMzYpLF9QYXNzTWFjcm8yPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Bhc3NNYWNybyksX1Bhc3NCbHVyPV9fd2VicGFja19yZXF1aXJlX18oNzIpLF9QYXNzQmx1cjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGFzc0JsdXIpLF9QYXNzVkJsdXI9X193ZWJwYWNrX3JlcXVpcmVfXygzNyksX1Bhc3NWQmx1cjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGFzc1ZCbHVyKSxfUGFzc0hCbHVyPV9fd2VicGFja19yZXF1aXJlX18oMzkpLF9QYXNzSEJsdXIyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Bhc3NIQmx1ciksX1Bhc3NGeGFhPV9fd2VicGFja19yZXF1aXJlX18oNzYpLF9QYXNzRnhhYTI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGFzc0Z4YWEpLF9CYXRjaENvcHk9X193ZWJwYWNrX3JlcXVpcmVfXyg3NyksX0JhdGNoQ29weTI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmF0Y2hDb3B5KSxfQmF0Y2hBeGlzPV9fd2VicGFja19yZXF1aXJlX18oNzgpLF9CYXRjaEF4aXMyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JhdGNoQXhpcyksX0JhdGNoQmFsbD1fX3dlYnBhY2tfcmVxdWlyZV9fKDgxKSxfQmF0Y2hCYWxsMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXRjaEJhbGwpLF9CYXRjaERvdHNQbGFuZT1fX3dlYnBhY2tfcmVxdWlyZV9fKDgyKSxfQmF0Y2hEb3RzUGxhbmUyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JhdGNoRG90c1BsYW5lKSxfQmF0Y2hMaW5lPV9fd2VicGFja19yZXF1aXJlX18oODQpLF9CYXRjaExpbmUyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JhdGNoTGluZSksX0JhdGNoU2t5Ym94PV9fd2VicGFja19yZXF1aXJlX18oODUpLF9CYXRjaFNreWJveDI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmF0Y2hTa3lib3gpLF9CYXRjaFNreT1fX3dlYnBhY2tfcmVxdWlyZV9fKDg2KSxfQmF0Y2hTa3kyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JhdGNoU2t5KSxfQmF0Y2hGWEFBPV9fd2VicGFja19yZXF1aXJlX18oODgpLF9CYXRjaEZYQUEyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JhdGNoRlhBQSksX1NjZW5lPV9fd2VicGFja19yZXF1aXJlX18oODkpLF9TY2VuZTI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2NlbmUpLF9WaWV3PV9fd2VicGFja19yZXF1aXJlX18oOTApLF9WaWV3Mj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9WaWV3KSxfVmlldzNEPV9fd2VicGFja19yZXF1aXJlX18oOTEpLF9WaWV3M0QyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZpZXczRCksX1NoYWRlckxpYnM9X193ZWJwYWNrX3JlcXVpcmVfXygzMiksX1NoYWRlckxpYnMyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NoYWRlckxpYnMpLEFsZnJpZD1mdW5jdGlvbigpe2Z1bmN0aW9uIEFsZnJpZCgpe19jbGFzc0NhbGxDaGVjayh0aGlzLEFsZnJpZCksdGhpcy5nbG09R0xNLHRoaXMuR0w9X0dMVG9vbDIuZGVmYXVsdCx0aGlzLkdMVG9vbD1fR0xUb29sMi5kZWZhdWx0LHRoaXMuR0xTaGFkZXI9X0dMU2hhZGVyMi5kZWZhdWx0LHRoaXMuR0xUZXh0dXJlPV9HTFRleHR1cmU0LmRlZmF1bHQsdGhpcy5HTFRleHR1cmVPbGQ9X0dMVGV4dHVyZTIuZGVmYXVsdCx0aGlzLkdMQ3ViZVRleHR1cmU9X0dMQ3ViZVRleHR1cmUyLmRlZmF1bHQsdGhpcy5NZXNoPV9NZXNoMi5kZWZhdWx0LHRoaXMuR2VvbT1fR2VvbTIuZGVmYXVsdCx0aGlzLkJhdGNoPV9CYXRjaDIuZGVmYXVsdCx0aGlzLkZyYW1lQnVmZmVyPV9GcmFtZUJ1ZmZlcjIuZGVmYXVsdCx0aGlzLkN1YmVGcmFtZUJ1ZmZlcj1fQ3ViZUZyYW1lQnVmZmVyMi5kZWZhdWx0LHRoaXMuU2NoZWR1bGVyPV9zY2hlZHVsaW5nMi5kZWZhdWx0LHRoaXMuRXZlbnREaXNwYXRjaGVyPV9FdmVudERpc3BhdGNoZXIyLmRlZmF1bHQsdGhpcy5FYXNlTnVtYmVyPV9FYXNlTnVtYmVyMi5kZWZhdWx0LHRoaXMuVHdlZW5OdW1iZXI9X1R3ZWVuTnVtYmVyMi5kZWZhdWx0LHRoaXMuQ2FtZXJhPV9DYW1lcmEyLmRlZmF1bHQsdGhpcy5DYW1lcmFPcnRobz1fQ2FtZXJhT3J0aG8yLmRlZmF1bHQsdGhpcy5DYW1lcmFQZXJzcGVjdGl2ZT1fQ2FtZXJhUGVyc3BlY3RpdmUyLmRlZmF1bHQsdGhpcy5SYXk9X1JheTIuZGVmYXVsdCx0aGlzLkNhbWVyYUN1YmU9X0NhbWVyYUN1YmUyLmRlZmF1bHQsdGhpcy5PcmJpdGFsQ29udHJvbD1fT3JiaXRhbENvbnRyb2wyLmRlZmF1bHQsdGhpcy5RdWF0Um90YXRpb249X1F1YXRSb3RhdGlvbjIuZGVmYXVsdCx0aGlzLkJpbmFyeUxvYWRlcj1fQmluYXJ5TG9hZGVyMi5kZWZhdWx0LHRoaXMuT2JqTG9hZGVyPV9PYmpMb2FkZXIyLmRlZmF1bHQsdGhpcy5Db2xsYWRhUGFyc2VyPV9Db2xsYWRhUGFyc2VyMi5kZWZhdWx0LHRoaXMuSERSTG9hZGVyPV9IRFJMb2FkZXIyLmRlZmF1bHQsdGhpcy5CYXRjaENvcHk9X0JhdGNoQ29weTIuZGVmYXVsdCx0aGlzLkJhdGNoQXhpcz1fQmF0Y2hBeGlzMi5kZWZhdWx0LHRoaXMuQmF0Y2hCYWxsPV9CYXRjaEJhbGwyLmRlZmF1bHQsdGhpcy5CYXRjaEJhbGw9X0JhdGNoQmFsbDIuZGVmYXVsdCx0aGlzLkJhdGNoTGluZT1fQmF0Y2hMaW5lMi5kZWZhdWx0LHRoaXMuQmF0Y2hTa3lib3g9X0JhdGNoU2t5Ym94Mi5kZWZhdWx0LHRoaXMuQmF0Y2hTa3k9X0JhdGNoU2t5Mi5kZWZhdWx0LHRoaXMuQmF0Y2hGWEFBPV9CYXRjaEZYQUEyLmRlZmF1bHQsdGhpcy5CYXRjaERvdHNQbGFuZT1fQmF0Y2hEb3RzUGxhbmUyLmRlZmF1bHQsdGhpcy5TY2VuZT1fU2NlbmUyLmRlZmF1bHQsdGhpcy5WaWV3PV9WaWV3Mi5kZWZhdWx0LHRoaXMuVmlldzNEPV9WaWV3M0QyLmRlZmF1bHQsdGhpcy5PYmplY3QzRD1fT2JqZWN0M0QyLmRlZmF1bHQsdGhpcy5TaGFkZXJMaWJzPV9TaGFkZXJMaWJzMi5kZWZhdWx0LHRoaXMuV2ViZ2xOdW1iZXI9X1dlYmdsTnVtYmVyMi5kZWZhdWx0LHRoaXMuRWZmZWN0Q29tcG9zZXI9X0VmZmVjdENvbXBvc2VyMi5kZWZhdWx0LHRoaXMuUGFzcz1fUGFzczIuZGVmYXVsdCx0aGlzLlBhc3NNYWNybz1fUGFzc01hY3JvMi5kZWZhdWx0LHRoaXMuUGFzc0JsdXI9X1Bhc3NCbHVyMi5kZWZhdWx0LHRoaXMuUGFzc1ZCbHVyPV9QYXNzVkJsdXIyLmRlZmF1bHQsdGhpcy5QYXNzSEJsdXI9X1Bhc3NIQmx1cjIuZGVmYXVsdCx0aGlzLlBhc3NGeGFhPV9QYXNzRnhhYTIuZGVmYXVsdCx0aGlzLk11bHRpc2FtcGxlRnJhbWVCdWZmZXI9X011bHRpc2FtcGxlRnJhbWVCdWZmZXIyLmRlZmF1bHQsdGhpcy5UcmFuc2Zvcm1GZWVkYmFja09iamVjdD1fVHJhbnNmb3JtRmVlZGJhY2tPYmplY3QyLmRlZmF1bHQ7Zm9yKHZhciBzIGluIEdMTSlHTE1bc10mJih3aW5kb3dbc109R0xNW3NdKX1yZXR1cm4gX2NyZWF0ZUNsYXNzKEFsZnJpZCxbe2tleTpcImxvZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiQ2hyb21lXCIpPi0xP2NvbnNvbGUubG9nKFwiJWNsaWIgYWxmcmlkIDogVkVSU0lPTiAwLjIuMFwiLFwiYmFja2dyb3VuZDogIzE5MzQ0MTsgY29sb3I6ICNGQ0ZGRjVcIik6Y29uc29sZS5sb2coXCJsaWIgYWxmcmlkIDogVkVSU0lPTiBcIixcIjAuMi4wXCIpLGNvbnNvbGUubG9nKFwiJWNDbGFzc2VzIDogXCIsXCJjb2xvcjogIzE5MzQ0MVwiKTtmb3IodmFyIHMgaW4gdGhpcyl0aGlzW3NdJiZjb25zb2xlLmxvZyhcIiVjIC0gXCIrcyxcImNvbG9yOiAjM0U2MDZGXCIpfX1dKSxBbGZyaWR9KCksYWw9bmV3IEFsZnJpZDtleHBvcnRzLmRlZmF1bHQ9YWwsZXhwb3J0cy5HTD1fR0xUb29sMi5kZWZhdWx0LGV4cG9ydHMuR0xTaGFkZXI9X0dMU2hhZGVyMi5kZWZhdWx0LGV4cG9ydHMuR0xUZXh0dXJlPV9HTFRleHR1cmU0LmRlZmF1bHQsZXhwb3J0cy5HTFRleHR1cmVPbGQ9X0dMVGV4dHVyZTIuZGVmYXVsdCxleHBvcnRzLkdMQ3ViZVRleHR1cmU9X0dMQ3ViZVRleHR1cmUyLmRlZmF1bHQsZXhwb3J0cy5NZXNoPV9NZXNoMi5kZWZhdWx0LGV4cG9ydHMuR2VvbT1fR2VvbTIuZGVmYXVsdCxleHBvcnRzLkJhdGNoPV9CYXRjaDIuZGVmYXVsdCxleHBvcnRzLkZyYW1lQnVmZmVyPV9GcmFtZUJ1ZmZlcjIuZGVmYXVsdCxleHBvcnRzLkN1YmVGcmFtZUJ1ZmZlcj1fQ3ViZUZyYW1lQnVmZmVyMi5kZWZhdWx0LGV4cG9ydHMuTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlcj1fTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlcjIuZGVmYXVsdCxleHBvcnRzLlRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0PV9UcmFuc2Zvcm1GZWVkYmFja09iamVjdDIuZGVmYXVsdCxleHBvcnRzLlNjaGVkdWxlcj1fc2NoZWR1bGluZzIuZGVmYXVsdCxleHBvcnRzLkV2ZW50RGlzcGF0Y2hlcj1fRXZlbnREaXNwYXRjaGVyMi5kZWZhdWx0LGV4cG9ydHMuRWFzZU51bWJlcj1fRWFzZU51bWJlcjIuZGVmYXVsdCxleHBvcnRzLlR3ZWVuTnVtYmVyPV9Ud2Vlbk51bWJlcjIuZGVmYXVsdCxleHBvcnRzLk9yYml0YWxDb250cm9sPV9PcmJpdGFsQ29udHJvbDIuZGVmYXVsdCxleHBvcnRzLldlYmdsTnVtYmVyPV9XZWJnbE51bWJlcjIuZGVmYXVsdCxleHBvcnRzLlF1YXRSb3RhdGlvbj1fUXVhdFJvdGF0aW9uMi5kZWZhdWx0LGV4cG9ydHMuVG91Y2hEZXRlY3Rvcj1fVG91Y2hEZXRlY3RvcjIuZGVmYXVsdCxleHBvcnRzLkNhbWVyYT1fQ2FtZXJhMi5kZWZhdWx0LGV4cG9ydHMuQ2FtZXJhT3J0aG89X0NhbWVyYU9ydGhvMi5kZWZhdWx0LGV4cG9ydHMuQ2FtZXJhUGVyc3BlY3RpdmU9X0NhbWVyYVBlcnNwZWN0aXZlMi5kZWZhdWx0LGV4cG9ydHMuQ2FtZXJhQ3ViZT1fQ2FtZXJhQ3ViZTIuZGVmYXVsdCxleHBvcnRzLlJheT1fUmF5Mi5kZWZhdWx0LGV4cG9ydHMuT2JqZWN0M0Q9X09iamVjdDNEMi5kZWZhdWx0LGV4cG9ydHMuQmluYXJ5TG9hZGVyPV9CaW5hcnlMb2FkZXIyLmRlZmF1bHQsZXhwb3J0cy5PYmpMb2FkZXI9X09iakxvYWRlcjIuZGVmYXVsdCxleHBvcnRzLkhEUkxvYWRlcj1fSERSTG9hZGVyMi5kZWZhdWx0LGV4cG9ydHMuQ29sbGFkYVBhcnNlcj1fQ29sbGFkYVBhcnNlcjIuZGVmYXVsdCxleHBvcnRzLkVmZmVjdENvbXBvc2VyPV9FZmZlY3RDb21wb3NlcjIuZGVmYXVsdCxleHBvcnRzLlBhc3M9X1Bhc3MyLmRlZmF1bHQsZXhwb3J0cy5QYXNzTWFjcm89X1Bhc3NNYWNybzIuZGVmYXVsdCxleHBvcnRzLlBhc3NCbHVyPV9QYXNzQmx1cjIuZGVmYXVsdCxleHBvcnRzLlBhc3NWQmx1cj1fUGFzc1ZCbHVyMi5kZWZhdWx0LGV4cG9ydHMuUGFzc0hCbHVyPV9QYXNzSEJsdXIyLmRlZmF1bHQsZXhwb3J0cy5QYXNzRnhhYT1fUGFzc0Z4YWEyLmRlZmF1bHQsZXhwb3J0cy5CYXRjaENvcHk9X0JhdGNoQ29weTIuZGVmYXVsdCxleHBvcnRzLkJhdGNoQXhpcz1fQmF0Y2hBeGlzMi5kZWZhdWx0LGV4cG9ydHMuQmF0Y2hCYWxsPV9CYXRjaEJhbGwyLmRlZmF1bHQsZXhwb3J0cy5CYXRjaERvdHNQbGFuZT1fQmF0Y2hEb3RzUGxhbmUyLmRlZmF1bHQsZXhwb3J0cy5CYXRjaExpbmU9X0JhdGNoTGluZTIuZGVmYXVsdCxleHBvcnRzLkJhdGNoU2t5Ym94PV9CYXRjaFNreWJveDIuZGVmYXVsdCxleHBvcnRzLkJhdGNoU2t5PV9CYXRjaFNreTIuZGVmYXVsdCxleHBvcnRzLkJhdGNoRlhBQT1fQmF0Y2hGWEFBMi5kZWZhdWx0LGV4cG9ydHMuU2NlbmU9X1NjZW5lMi5kZWZhdWx0LGV4cG9ydHMuVmlldz1fVmlldzIuZGVmYXVsdCxleHBvcnRzLlZpZXczRD1fVmlldzNEMi5kZWZhdWx0LGV4cG9ydHMuU2hhZGVyTGlicz1fU2hhZGVyTGliczIuZGVmYXVsdH0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gY3JlYXRlKCl7dmFyIG91dD1uZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtyZXR1cm4gb3V0WzBdPTEsb3V0WzFdPTAsb3V0WzJdPTAsb3V0WzNdPTEsb3V0fWZ1bmN0aW9uIGNsb25lKGEpe3ZhciBvdXQ9bmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7cmV0dXJuIG91dFswXT1hWzBdLG91dFsxXT1hWzFdLG91dFsyXT1hWzJdLG91dFszXT1hWzNdLG91dH1mdW5jdGlvbiBjb3B5KG91dCxhKXtyZXR1cm4gb3V0WzBdPWFbMF0sb3V0WzFdPWFbMV0sb3V0WzJdPWFbMl0sb3V0WzNdPWFbM10sb3V0fWZ1bmN0aW9uIGlkZW50aXR5KG91dCl7cmV0dXJuIG91dFswXT0xLG91dFsxXT0wLG91dFsyXT0wLG91dFszXT0xLG91dH1mdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCxtMDEsbTEwLG0xMSl7dmFyIG91dD1uZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtyZXR1cm4gb3V0WzBdPW0wMCxvdXRbMV09bTAxLG91dFsyXT1tMTAsb3V0WzNdPW0xMSxvdXR9ZnVuY3Rpb24gc2V0KG91dCxtMDAsbTAxLG0xMCxtMTEpe3JldHVybiBvdXRbMF09bTAwLG91dFsxXT1tMDEsb3V0WzJdPW0xMCxvdXRbM109bTExLG91dH1mdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LGEpe2lmKG91dD09PWEpe3ZhciBhMT1hWzFdO291dFsxXT1hWzJdLG91dFsyXT1hMX1lbHNlIG91dFswXT1hWzBdLG91dFsxXT1hWzJdLG91dFsyXT1hWzFdLG91dFszXT1hWzNdO3JldHVybiBvdXR9ZnVuY3Rpb24gaW52ZXJ0KG91dCxhKXt2YXIgYTA9YVswXSxhMT1hWzFdLGEyPWFbMl0sYTM9YVszXSxkZXQ9YTAqYTMtYTIqYTE7cmV0dXJuIGRldD8oZGV0PTEvZGV0LG91dFswXT1hMypkZXQsb3V0WzFdPS1hMSpkZXQsb3V0WzJdPS1hMipkZXQsb3V0WzNdPWEwKmRldCxvdXQpOm51bGx9ZnVuY3Rpb24gYWRqb2ludChvdXQsYSl7dmFyIGEwPWFbMF07cmV0dXJuIG91dFswXT1hWzNdLG91dFsxXT0tYVsxXSxvdXRbMl09LWFbMl0sb3V0WzNdPWEwLG91dH1mdW5jdGlvbiBkZXRlcm1pbmFudChhKXtyZXR1cm4gYVswXSphWzNdLWFbMl0qYVsxXX1mdW5jdGlvbiBtdWx0aXBseShvdXQsYSxiKXt2YXIgYTA9YVswXSxhMT1hWzFdLGEyPWFbMl0sYTM9YVszXSxiMD1iWzBdLGIxPWJbMV0sYjI9YlsyXSxiMz1iWzNdO3JldHVybiBvdXRbMF09YTAqYjArYTIqYjEsb3V0WzFdPWExKmIwK2EzKmIxLG91dFsyXT1hMCpiMithMipiMyxvdXRbM109YTEqYjIrYTMqYjMsb3V0fWZ1bmN0aW9uIHJvdGF0ZShvdXQsYSxyYWQpe3ZhciBhMD1hWzBdLGExPWFbMV0sYTI9YVsyXSxhMz1hWzNdLHM9TWF0aC5zaW4ocmFkKSxjPU1hdGguY29zKHJhZCk7cmV0dXJuIG91dFswXT1hMCpjK2EyKnMsb3V0WzFdPWExKmMrYTMqcyxvdXRbMl09YTAqLXMrYTIqYyxvdXRbM109YTEqLXMrYTMqYyxvdXR9ZnVuY3Rpb24gc2NhbGUob3V0LGEsdil7dmFyIGEwPWFbMF0sYTE9YVsxXSxhMj1hWzJdLGEzPWFbM10sdjA9dlswXSx2MT12WzFdO3JldHVybiBvdXRbMF09YTAqdjAsb3V0WzFdPWExKnYwLG91dFsyXT1hMip2MSxvdXRbM109YTMqdjEsb3V0fWZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQscmFkKXt2YXIgcz1NYXRoLnNpbihyYWQpLGM9TWF0aC5jb3MocmFkKTtyZXR1cm4gb3V0WzBdPWMsb3V0WzFdPXMsb3V0WzJdPS1zLG91dFszXT1jLG91dH1mdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsdil7cmV0dXJuIG91dFswXT12WzBdLG91dFsxXT0wLG91dFsyXT0wLG91dFszXT12WzFdLG91dH1mdW5jdGlvbiBzdHIoYSl7cmV0dXJuXCJtYXQyKFwiK2FbMF0rXCIsIFwiK2FbMV0rXCIsIFwiK2FbMl0rXCIsIFwiK2FbM10rXCIpXCJ9ZnVuY3Rpb24gZnJvYihhKXtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sMikrTWF0aC5wb3coYVsxXSwyKStNYXRoLnBvdyhhWzJdLDIpK01hdGgucG93KGFbM10sMikpfWZ1bmN0aW9uIExEVShMLEQsVSxhKXtyZXR1cm4gTFsyXT1hWzJdL2FbMF0sVVswXT1hWzBdLFVbMV09YVsxXSxVWzNdPWFbM10tTFsyXSpVWzFdLFtMLEQsVV19ZnVuY3Rpb24gYWRkKG91dCxhLGIpe3JldHVybiBvdXRbMF09YVswXStiWzBdLG91dFsxXT1hWzFdK2JbMV0sb3V0WzJdPWFbMl0rYlsyXSxvdXRbM109YVszXStiWzNdLG91dH1mdW5jdGlvbiBzdWJ0cmFjdChvdXQsYSxiKXtyZXR1cm4gb3V0WzBdPWFbMF0tYlswXSxvdXRbMV09YVsxXS1iWzFdLG91dFsyXT1hWzJdLWJbMl0sb3V0WzNdPWFbM10tYlszXSxvdXR9ZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSxiKXtyZXR1cm4gYVswXT09PWJbMF0mJmFbMV09PT1iWzFdJiZhWzJdPT09YlsyXSYmYVszXT09PWJbM119ZnVuY3Rpb24gZXF1YWxzKGEsYil7dmFyIGEwPWFbMF0sYTE9YVsxXSxhMj1hWzJdLGEzPWFbM10sYjA9YlswXSxiMT1iWzFdLGIyPWJbMl0sYjM9YlszXTtyZXR1cm4gTWF0aC5hYnMoYTAtYjApPD1nbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYTApLE1hdGguYWJzKGIwKSkmJk1hdGguYWJzKGExLWIxKTw9Z2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGExKSxNYXRoLmFicyhiMSkpJiZNYXRoLmFicyhhMi1iMik8PWdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhMiksTWF0aC5hYnMoYjIpKSYmTWF0aC5hYnMoYTMtYjMpPD1nbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYTMpLE1hdGguYWJzKGIzKSl9ZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LGEsYil7cmV0dXJuIG91dFswXT1hWzBdKmIsb3V0WzFdPWFbMV0qYixvdXRbMl09YVsyXSpiLG91dFszXT1hWzNdKmIsb3V0fWZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCxhLGIsc2NhbGUpe3JldHVybiBvdXRbMF09YVswXStiWzBdKnNjYWxlLG91dFsxXT1hWzFdK2JbMV0qc2NhbGUsb3V0WzJdPWFbMl0rYlsyXSpzY2FsZSxvdXRbM109YVszXStiWzNdKnNjYWxlLG91dH1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxleHBvcnRzLnN1Yj1leHBvcnRzLm11bD12b2lkIDAsZXhwb3J0cy5jcmVhdGU9Y3JlYXRlLGV4cG9ydHMuY2xvbmU9Y2xvbmUsZXhwb3J0cy5jb3B5PWNvcHksZXhwb3J0cy5pZGVudGl0eT1pZGVudGl0eSxleHBvcnRzLmZyb21WYWx1ZXM9ZnJvbVZhbHVlcyxleHBvcnRzLnNldD1zZXQsZXhwb3J0cy50cmFuc3Bvc2U9dHJhbnNwb3NlLGV4cG9ydHMuaW52ZXJ0PWludmVydCxleHBvcnRzLmFkam9pbnQ9YWRqb2ludCxleHBvcnRzLmRldGVybWluYW50PWRldGVybWluYW50LGV4cG9ydHMubXVsdGlwbHk9bXVsdGlwbHksZXhwb3J0cy5yb3RhdGU9cm90YXRlLGV4cG9ydHMuc2NhbGU9c2NhbGUsZXhwb3J0cy5mcm9tUm90YXRpb249ZnJvbVJvdGF0aW9uLGV4cG9ydHMuZnJvbVNjYWxpbmc9ZnJvbVNjYWxpbmcsZXhwb3J0cy5zdHI9c3RyLGV4cG9ydHMuZnJvYj1mcm9iLGV4cG9ydHMuTERVPUxEVSxleHBvcnRzLmFkZD1hZGQsZXhwb3J0cy5zdWJ0cmFjdD1zdWJ0cmFjdCxleHBvcnRzLmV4YWN0RXF1YWxzPWV4YWN0RXF1YWxzLGV4cG9ydHMuZXF1YWxzPWVxdWFscyxleHBvcnRzLm11bHRpcGx5U2NhbGFyPW11bHRpcGx5U2NhbGFyLGV4cG9ydHMubXVsdGlwbHlTY2FsYXJBbmRBZGQ9bXVsdGlwbHlTY2FsYXJBbmRBZGQ7dmFyIF9jb21tb249X193ZWJwYWNrX3JlcXVpcmVfXygzKSxnbE1hdHJpeD1mdW5jdGlvbihvYmope2lmKG9iaiYmb2JqLl9fZXNNb2R1bGUpcmV0dXJuIG9iajt2YXIgbmV3T2JqPXt9O2lmKG51bGwhPW9iailmb3IodmFyIGtleSBpbiBvYmopT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaixrZXkpJiYobmV3T2JqW2tleV09b2JqW2tleV0pO3JldHVybiBuZXdPYmouZGVmYXVsdD1vYmosbmV3T2JqfShfY29tbW9uKTtleHBvcnRzLm11bD1tdWx0aXBseSxleHBvcnRzLnN1Yj1zdWJ0cmFjdH0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gY3JlYXRlKCl7dmFyIG91dD1uZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtyZXR1cm4gb3V0WzBdPTEsb3V0WzFdPTAsb3V0WzJdPTAsb3V0WzNdPTEsb3V0WzRdPTAsb3V0WzVdPTAsb3V0fWZ1bmN0aW9uIGNsb25lKGEpe3ZhciBvdXQ9bmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7cmV0dXJuIG91dFswXT1hWzBdLG91dFsxXT1hWzFdLG91dFsyXT1hWzJdLG91dFszXT1hWzNdLG91dFs0XT1hWzRdLG91dFs1XT1hWzVdLG91dH1mdW5jdGlvbiBjb3B5KG91dCxhKXtyZXR1cm4gb3V0WzBdPWFbMF0sb3V0WzFdPWFbMV0sb3V0WzJdPWFbMl0sb3V0WzNdPWFbM10sb3V0WzRdPWFbNF0sb3V0WzVdPWFbNV0sb3V0fWZ1bmN0aW9uIGlkZW50aXR5KG91dCl7cmV0dXJuIG91dFswXT0xLG91dFsxXT0wLG91dFsyXT0wLG91dFszXT0xLG91dFs0XT0wLG91dFs1XT0wLG91dH1mdW5jdGlvbiBmcm9tVmFsdWVzKGEsYixjLGQsdHgsdHkpe3ZhciBvdXQ9bmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7cmV0dXJuIG91dFswXT1hLG91dFsxXT1iLG91dFsyXT1jLG91dFszXT1kLG91dFs0XT10eCxvdXRbNV09dHksb3V0fWZ1bmN0aW9uIHNldChvdXQsYSxiLGMsZCx0eCx0eSl7cmV0dXJuIG91dFswXT1hLG91dFsxXT1iLG91dFsyXT1jLG91dFszXT1kLG91dFs0XT10eCxvdXRbNV09dHksb3V0fWZ1bmN0aW9uIGludmVydChvdXQsYSl7dmFyIGFhPWFbMF0sYWI9YVsxXSxhYz1hWzJdLGFkPWFbM10sYXR4PWFbNF0sYXR5PWFbNV0sZGV0PWFhKmFkLWFiKmFjO3JldHVybiBkZXQ/KGRldD0xL2RldCxvdXRbMF09YWQqZGV0LG91dFsxXT0tYWIqZGV0LG91dFsyXT0tYWMqZGV0LG91dFszXT1hYSpkZXQsb3V0WzRdPShhYyphdHktYWQqYXR4KSpkZXQsb3V0WzVdPShhYiphdHgtYWEqYXR5KSpkZXQsb3V0KTpudWxsfWZ1bmN0aW9uIGRldGVybWluYW50KGEpe3JldHVybiBhWzBdKmFbM10tYVsxXSphWzJdfWZ1bmN0aW9uIG11bHRpcGx5KG91dCxhLGIpe3ZhciBhMD1hWzBdLGExPWFbMV0sYTI9YVsyXSxhMz1hWzNdLGE0PWFbNF0sYTU9YVs1XSxiMD1iWzBdLGIxPWJbMV0sYjI9YlsyXSxiMz1iWzNdLGI0PWJbNF0sYjU9Yls1XTtyZXR1cm4gb3V0WzBdPWEwKmIwK2EyKmIxLG91dFsxXT1hMSpiMCthMypiMSxvdXRbMl09YTAqYjIrYTIqYjMsb3V0WzNdPWExKmIyK2EzKmIzLG91dFs0XT1hMCpiNCthMipiNSthNCxvdXRbNV09YTEqYjQrYTMqYjUrYTUsb3V0fWZ1bmN0aW9uIHJvdGF0ZShvdXQsYSxyYWQpe3ZhciBhMD1hWzBdLGExPWFbMV0sYTI9YVsyXSxhMz1hWzNdLGE0PWFbNF0sYTU9YVs1XSxzPU1hdGguc2luKHJhZCksYz1NYXRoLmNvcyhyYWQpO3JldHVybiBvdXRbMF09YTAqYythMipzLG91dFsxXT1hMSpjK2EzKnMsb3V0WzJdPWEwKi1zK2EyKmMsb3V0WzNdPWExKi1zK2EzKmMsb3V0WzRdPWE0LG91dFs1XT1hNSxvdXR9ZnVuY3Rpb24gc2NhbGUob3V0LGEsdil7dmFyIGEwPWFbMF0sYTE9YVsxXSxhMj1hWzJdLGEzPWFbM10sYTQ9YVs0XSxhNT1hWzVdLHYwPXZbMF0sdjE9dlsxXTtyZXR1cm4gb3V0WzBdPWEwKnYwLG91dFsxXT1hMSp2MCxvdXRbMl09YTIqdjEsb3V0WzNdPWEzKnYxLG91dFs0XT1hNCxvdXRbNV09YTUsb3V0fWZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsYSx2KXt2YXIgYTA9YVswXSxhMT1hWzFdLGEyPWFbMl0sYTM9YVszXSxhND1hWzRdLGE1PWFbNV0sdjA9dlswXSx2MT12WzFdO3JldHVybiBvdXRbMF09YTAsb3V0WzFdPWExLG91dFsyXT1hMixvdXRbM109YTMsb3V0WzRdPWEwKnYwK2EyKnYxK2E0LG91dFs1XT1hMSp2MCthMyp2MSthNSxvdXR9ZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCxyYWQpe3ZhciBzPU1hdGguc2luKHJhZCksYz1NYXRoLmNvcyhyYWQpO3JldHVybiBvdXRbMF09YyxvdXRbMV09cyxvdXRbMl09LXMsb3V0WzNdPWMsb3V0WzRdPTAsb3V0WzVdPTAsb3V0fWZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCx2KXtyZXR1cm4gb3V0WzBdPXZbMF0sb3V0WzFdPTAsb3V0WzJdPTAsb3V0WzNdPXZbMV0sb3V0WzRdPTAsb3V0WzVdPTAsb3V0fWZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsdil7cmV0dXJuIG91dFswXT0xLG91dFsxXT0wLG91dFsyXT0wLG91dFszXT0xLG91dFs0XT12WzBdLG91dFs1XT12WzFdLG91dH1mdW5jdGlvbiBzdHIoYSl7cmV0dXJuXCJtYXQyZChcIithWzBdK1wiLCBcIithWzFdK1wiLCBcIithWzJdK1wiLCBcIithWzNdK1wiLCBcIithWzRdK1wiLCBcIithWzVdK1wiKVwifWZ1bmN0aW9uIGZyb2IoYSl7cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhhWzBdLDIpK01hdGgucG93KGFbMV0sMikrTWF0aC5wb3coYVsyXSwyKStNYXRoLnBvdyhhWzNdLDIpK01hdGgucG93KGFbNF0sMikrTWF0aC5wb3coYVs1XSwyKSsxKX1mdW5jdGlvbiBhZGQob3V0LGEsYil7cmV0dXJuIG91dFswXT1hWzBdK2JbMF0sb3V0WzFdPWFbMV0rYlsxXSxvdXRbMl09YVsyXStiWzJdLG91dFszXT1hWzNdK2JbM10sb3V0WzRdPWFbNF0rYls0XSxvdXRbNV09YVs1XStiWzVdLG91dH1mdW5jdGlvbiBzdWJ0cmFjdChvdXQsYSxiKXtyZXR1cm4gb3V0WzBdPWFbMF0tYlswXSxvdXRbMV09YVsxXS1iWzFdLG91dFsyXT1hWzJdLWJbMl0sb3V0WzNdPWFbM10tYlszXSxvdXRbNF09YVs0XS1iWzRdLG91dFs1XT1hWzVdLWJbNV0sb3V0fWZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCxhLGIpe3JldHVybiBvdXRbMF09YVswXSpiLG91dFsxXT1hWzFdKmIsb3V0WzJdPWFbMl0qYixvdXRbM109YVszXSpiLG91dFs0XT1hWzRdKmIsb3V0WzVdPWFbNV0qYixvdXR9ZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LGEsYixzY2FsZSl7cmV0dXJuIG91dFswXT1hWzBdK2JbMF0qc2NhbGUsb3V0WzFdPWFbMV0rYlsxXSpzY2FsZSxvdXRbMl09YVsyXStiWzJdKnNjYWxlLG91dFszXT1hWzNdK2JbM10qc2NhbGUsb3V0WzRdPWFbNF0rYls0XSpzY2FsZSxvdXRbNV09YVs1XStiWzVdKnNjYWxlLG91dH1mdW5jdGlvbiBleGFjdEVxdWFscyhhLGIpe3JldHVybiBhWzBdPT09YlswXSYmYVsxXT09PWJbMV0mJmFbMl09PT1iWzJdJiZhWzNdPT09YlszXSYmYVs0XT09PWJbNF0mJmFbNV09PT1iWzVdfWZ1bmN0aW9uIGVxdWFscyhhLGIpe3ZhciBhMD1hWzBdLGExPWFbMV0sYTI9YVsyXSxhMz1hWzNdLGE0PWFbNF0sYTU9YVs1XSxiMD1iWzBdLGIxPWJbMV0sYjI9YlsyXSxiMz1iWzNdLGI0PWJbNF0sYjU9Yls1XTtyZXR1cm4gTWF0aC5hYnMoYTAtYjApPD1nbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYTApLE1hdGguYWJzKGIwKSkmJk1hdGguYWJzKGExLWIxKTw9Z2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGExKSxNYXRoLmFicyhiMSkpJiZNYXRoLmFicyhhMi1iMik8PWdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhMiksTWF0aC5hYnMoYjIpKSYmTWF0aC5hYnMoYTMtYjMpPD1nbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYTMpLE1hdGguYWJzKGIzKSkmJk1hdGguYWJzKGE0LWI0KTw9Z2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGE0KSxNYXRoLmFicyhiNCkpJiZNYXRoLmFicyhhNS1iNSk8PWdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhNSksTWF0aC5hYnMoYjUpKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxleHBvcnRzLnN1Yj1leHBvcnRzLm11bD12b2lkIDAsZXhwb3J0cy5jcmVhdGU9Y3JlYXRlLGV4cG9ydHMuY2xvbmU9Y2xvbmUsZXhwb3J0cy5jb3B5PWNvcHksZXhwb3J0cy5pZGVudGl0eT1pZGVudGl0eSxleHBvcnRzLmZyb21WYWx1ZXM9ZnJvbVZhbHVlcyxleHBvcnRzLnNldD1zZXQsZXhwb3J0cy5pbnZlcnQ9aW52ZXJ0LGV4cG9ydHMuZGV0ZXJtaW5hbnQ9ZGV0ZXJtaW5hbnQsZXhwb3J0cy5tdWx0aXBseT1tdWx0aXBseSxleHBvcnRzLnJvdGF0ZT1yb3RhdGUsZXhwb3J0cy5zY2FsZT1zY2FsZSxleHBvcnRzLnRyYW5zbGF0ZT10cmFuc2xhdGUsZXhwb3J0cy5mcm9tUm90YXRpb249ZnJvbVJvdGF0aW9uLGV4cG9ydHMuZnJvbVNjYWxpbmc9ZnJvbVNjYWxpbmcsZXhwb3J0cy5mcm9tVHJhbnNsYXRpb249ZnJvbVRyYW5zbGF0aW9uLGV4cG9ydHMuc3RyPXN0cixleHBvcnRzLmZyb2I9ZnJvYixleHBvcnRzLmFkZD1hZGQsZXhwb3J0cy5zdWJ0cmFjdD1zdWJ0cmFjdCxleHBvcnRzLm11bHRpcGx5U2NhbGFyPW11bHRpcGx5U2NhbGFyLGV4cG9ydHMubXVsdGlwbHlTY2FsYXJBbmRBZGQ9bXVsdGlwbHlTY2FsYXJBbmRBZGQsZXhwb3J0cy5leGFjdEVxdWFscz1leGFjdEVxdWFscyxleHBvcnRzLmVxdWFscz1lcXVhbHM7dmFyIF9jb21tb249X193ZWJwYWNrX3JlcXVpcmVfXygzKSxnbE1hdHJpeD1mdW5jdGlvbihvYmope2lmKG9iaiYmb2JqLl9fZXNNb2R1bGUpcmV0dXJuIG9iajt2YXIgbmV3T2JqPXt9O2lmKG51bGwhPW9iailmb3IodmFyIGtleSBpbiBvYmopT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaixrZXkpJiYobmV3T2JqW2tleV09b2JqW2tleV0pO3JldHVybiBuZXdPYmouZGVmYXVsdD1vYmosbmV3T2JqfShfY29tbW9uKTtleHBvcnRzLm11bD1tdWx0aXBseSxleHBvcnRzLnN1Yj1zdWJ0cmFjdH0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gY3JlYXRlKCl7dmFyIG91dD1uZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7cmV0dXJuIG91dFswXT0xLG91dFsxXT0wLG91dFsyXT0wLG91dFszXT0wLG91dFs0XT0wLG91dFs1XT0xLG91dFs2XT0wLG91dFs3XT0wLG91dFs4XT0wLG91dFs5XT0wLG91dFsxMF09MSxvdXRbMTFdPTAsb3V0WzEyXT0wLG91dFsxM109MCxvdXRbMTRdPTAsb3V0WzE1XT0xLG91dH1mdW5jdGlvbiBjbG9uZShhKXt2YXIgb3V0PW5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtyZXR1cm4gb3V0WzBdPWFbMF0sb3V0WzFdPWFbMV0sb3V0WzJdPWFbMl0sb3V0WzNdPWFbM10sb3V0WzRdPWFbNF0sb3V0WzVdPWFbNV0sb3V0WzZdPWFbNl0sb3V0WzddPWFbN10sb3V0WzhdPWFbOF0sb3V0WzldPWFbOV0sb3V0WzEwXT1hWzEwXSxvdXRbMTFdPWFbMTFdLG91dFsxMl09YVsxMl0sb3V0WzEzXT1hWzEzXSxvdXRbMTRdPWFbMTRdLG91dFsxNV09YVsxNV0sb3V0fWZ1bmN0aW9uIGNvcHkob3V0LGEpe3JldHVybiBvdXRbMF09YVswXSxvdXRbMV09YVsxXSxvdXRbMl09YVsyXSxvdXRbM109YVszXSxvdXRbNF09YVs0XSxvdXRbNV09YVs1XSxvdXRbNl09YVs2XSxvdXRbN109YVs3XSxvdXRbOF09YVs4XSxvdXRbOV09YVs5XSxvdXRbMTBdPWFbMTBdLG91dFsxMV09YVsxMV0sb3V0WzEyXT1hWzEyXSxvdXRbMTNdPWFbMTNdLG91dFsxNF09YVsxNF0sb3V0WzE1XT1hWzE1XSxvdXR9ZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsbTAxLG0wMixtMDMsbTEwLG0xMSxtMTIsbTEzLG0yMCxtMjEsbTIyLG0yMyxtMzAsbTMxLG0zMixtMzMpe3ZhciBvdXQ9bmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO3JldHVybiBvdXRbMF09bTAwLG91dFsxXT1tMDEsb3V0WzJdPW0wMixvdXRbM109bTAzLG91dFs0XT1tMTAsb3V0WzVdPW0xMSxvdXRbNl09bTEyLG91dFs3XT1tMTMsb3V0WzhdPW0yMCxvdXRbOV09bTIxLG91dFsxMF09bTIyLG91dFsxMV09bTIzLG91dFsxMl09bTMwLG91dFsxM109bTMxLG91dFsxNF09bTMyLG91dFsxNV09bTMzLG91dH1mdW5jdGlvbiBzZXQob3V0LG0wMCxtMDEsbTAyLG0wMyxtMTAsbTExLG0xMixtMTMsbTIwLG0yMSxtMjIsbTIzLG0zMCxtMzEsbTMyLG0zMyl7cmV0dXJuIG91dFswXT1tMDAsb3V0WzFdPW0wMSxvdXRbMl09bTAyLG91dFszXT1tMDMsb3V0WzRdPW0xMCxvdXRbNV09bTExLG91dFs2XT1tMTIsb3V0WzddPW0xMyxvdXRbOF09bTIwLG91dFs5XT1tMjEsb3V0WzEwXT1tMjIsb3V0WzExXT1tMjMsb3V0WzEyXT1tMzAsb3V0WzEzXT1tMzEsb3V0WzE0XT1tMzIsb3V0WzE1XT1tMzMsb3V0fWZ1bmN0aW9uIGlkZW50aXR5KG91dCl7cmV0dXJuIG91dFswXT0xLG91dFsxXT0wLG91dFsyXT0wLG91dFszXT0wLG91dFs0XT0wLG91dFs1XT0xLG91dFs2XT0wLG91dFs3XT0wLG91dFs4XT0wLG91dFs5XT0wLG91dFsxMF09MSxvdXRbMTFdPTAsb3V0WzEyXT0wLG91dFsxM109MCxvdXRbMTRdPTAsb3V0WzE1XT0xLG91dH1mdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LGEpe2lmKG91dD09PWEpe3ZhciBhMDE9YVsxXSxhMDI9YVsyXSxhMDM9YVszXSxhMTI9YVs2XSxhMTM9YVs3XSxhMjM9YVsxMV07b3V0WzFdPWFbNF0sb3V0WzJdPWFbOF0sb3V0WzNdPWFbMTJdLG91dFs0XT1hMDEsb3V0WzZdPWFbOV0sb3V0WzddPWFbMTNdLG91dFs4XT1hMDIsb3V0WzldPWExMixvdXRbMTFdPWFbMTRdLG91dFsxMl09YTAzLG91dFsxM109YTEzLG91dFsxNF09YTIzfWVsc2Ugb3V0WzBdPWFbMF0sb3V0WzFdPWFbNF0sb3V0WzJdPWFbOF0sb3V0WzNdPWFbMTJdLG91dFs0XT1hWzFdLG91dFs1XT1hWzVdLG91dFs2XT1hWzldLG91dFs3XT1hWzEzXSxvdXRbOF09YVsyXSxvdXRbOV09YVs2XSxvdXRbMTBdPWFbMTBdLG91dFsxMV09YVsxNF0sb3V0WzEyXT1hWzNdLG91dFsxM109YVs3XSxvdXRbMTRdPWFbMTFdLG91dFsxNV09YVsxNV07cmV0dXJuIG91dH1mdW5jdGlvbiBpbnZlcnQob3V0LGEpe3ZhciBhMDA9YVswXSxhMDE9YVsxXSxhMDI9YVsyXSxhMDM9YVszXSxhMTA9YVs0XSxhMTE9YVs1XSxhMTI9YVs2XSxhMTM9YVs3XSxhMjA9YVs4XSxhMjE9YVs5XSxhMjI9YVsxMF0sYTIzPWFbMTFdLGEzMD1hWzEyXSxhMzE9YVsxM10sYTMyPWFbMTRdLGEzMz1hWzE1XSxiMDA9YTAwKmExMS1hMDEqYTEwLGIwMT1hMDAqYTEyLWEwMiphMTAsYjAyPWEwMCphMTMtYTAzKmExMCxiMDM9YTAxKmExMi1hMDIqYTExLGIwND1hMDEqYTEzLWEwMyphMTEsYjA1PWEwMiphMTMtYTAzKmExMixiMDY9YTIwKmEzMS1hMjEqYTMwLGIwNz1hMjAqYTMyLWEyMiphMzAsYjA4PWEyMCphMzMtYTIzKmEzMCxiMDk9YTIxKmEzMi1hMjIqYTMxLGIxMD1hMjEqYTMzLWEyMyphMzEsYjExPWEyMiphMzMtYTIzKmEzMixkZXQ9YjAwKmIxMS1iMDEqYjEwK2IwMipiMDkrYjAzKmIwOC1iMDQqYjA3K2IwNSpiMDY7cmV0dXJuIGRldD8oZGV0PTEvZGV0LG91dFswXT0oYTExKmIxMS1hMTIqYjEwK2ExMypiMDkpKmRldCxvdXRbMV09KGEwMipiMTAtYTAxKmIxMS1hMDMqYjA5KSpkZXQsb3V0WzJdPShhMzEqYjA1LWEzMipiMDQrYTMzKmIwMykqZGV0LG91dFszXT0oYTIyKmIwNC1hMjEqYjA1LWEyMypiMDMpKmRldCxvdXRbNF09KGExMipiMDgtYTEwKmIxMS1hMTMqYjA3KSpkZXQsb3V0WzVdPShhMDAqYjExLWEwMipiMDgrYTAzKmIwNykqZGV0LG91dFs2XT0oYTMyKmIwMi1hMzAqYjA1LWEzMypiMDEpKmRldCxvdXRbN109KGEyMCpiMDUtYTIyKmIwMithMjMqYjAxKSpkZXQsb3V0WzhdPShhMTAqYjEwLWExMSpiMDgrYTEzKmIwNikqZGV0LG91dFs5XT0oYTAxKmIwOC1hMDAqYjEwLWEwMypiMDYpKmRldCxvdXRbMTBdPShhMzAqYjA0LWEzMSpiMDIrYTMzKmIwMCkqZGV0LG91dFsxMV09KGEyMSpiMDItYTIwKmIwNC1hMjMqYjAwKSpkZXQsb3V0WzEyXT0oYTExKmIwNy1hMTAqYjA5LWExMipiMDYpKmRldCxvdXRbMTNdPShhMDAqYjA5LWEwMSpiMDcrYTAyKmIwNikqZGV0LG91dFsxNF09KGEzMSpiMDEtYTMwKmIwMy1hMzIqYjAwKSpkZXQsb3V0WzE1XT0oYTIwKmIwMy1hMjEqYjAxK2EyMipiMDApKmRldCxvdXQpOm51bGx9ZnVuY3Rpb24gYWRqb2ludChvdXQsYSl7dmFyIGEwMD1hWzBdLGEwMT1hWzFdLGEwMj1hWzJdLGEwMz1hWzNdLGExMD1hWzRdLGExMT1hWzVdLGExMj1hWzZdLGExMz1hWzddLGEyMD1hWzhdLGEyMT1hWzldLGEyMj1hWzEwXSxhMjM9YVsxMV0sYTMwPWFbMTJdLGEzMT1hWzEzXSxhMzI9YVsxNF0sYTMzPWFbMTVdO3JldHVybiBvdXRbMF09YTExKihhMjIqYTMzLWEyMyphMzIpLWEyMSooYTEyKmEzMy1hMTMqYTMyKSthMzEqKGExMiphMjMtYTEzKmEyMiksb3V0WzFdPS0oYTAxKihhMjIqYTMzLWEyMyphMzIpLWEyMSooYTAyKmEzMy1hMDMqYTMyKSthMzEqKGEwMiphMjMtYTAzKmEyMikpLG91dFsyXT1hMDEqKGExMiphMzMtYTEzKmEzMiktYTExKihhMDIqYTMzLWEwMyphMzIpK2EzMSooYTAyKmExMy1hMDMqYTEyKSxvdXRbM109LShhMDEqKGExMiphMjMtYTEzKmEyMiktYTExKihhMDIqYTIzLWEwMyphMjIpK2EyMSooYTAyKmExMy1hMDMqYTEyKSksb3V0WzRdPS0oYTEwKihhMjIqYTMzLWEyMyphMzIpLWEyMCooYTEyKmEzMy1hMTMqYTMyKSthMzAqKGExMiphMjMtYTEzKmEyMikpLG91dFs1XT1hMDAqKGEyMiphMzMtYTIzKmEzMiktYTIwKihhMDIqYTMzLWEwMyphMzIpK2EzMCooYTAyKmEyMy1hMDMqYTIyKSxvdXRbNl09LShhMDAqKGExMiphMzMtYTEzKmEzMiktYTEwKihhMDIqYTMzLWEwMyphMzIpK2EzMCooYTAyKmExMy1hMDMqYTEyKSksb3V0WzddPWEwMCooYTEyKmEyMy1hMTMqYTIyKS1hMTAqKGEwMiphMjMtYTAzKmEyMikrYTIwKihhMDIqYTEzLWEwMyphMTIpLG91dFs4XT1hMTAqKGEyMSphMzMtYTIzKmEzMSktYTIwKihhMTEqYTMzLWExMyphMzEpK2EzMCooYTExKmEyMy1hMTMqYTIxKSxvdXRbOV09LShhMDAqKGEyMSphMzMtYTIzKmEzMSktYTIwKihhMDEqYTMzLWEwMyphMzEpK2EzMCooYTAxKmEyMy1hMDMqYTIxKSksb3V0WzEwXT1hMDAqKGExMSphMzMtYTEzKmEzMSktYTEwKihhMDEqYTMzLWEwMyphMzEpK2EzMCooYTAxKmExMy1hMDMqYTExKSxvdXRbMTFdPS0oYTAwKihhMTEqYTIzLWExMyphMjEpLWExMCooYTAxKmEyMy1hMDMqYTIxKSthMjAqKGEwMSphMTMtYTAzKmExMSkpLG91dFsxMl09LShhMTAqKGEyMSphMzItYTIyKmEzMSktYTIwKihhMTEqYTMyLWExMiphMzEpK2EzMCooYTExKmEyMi1hMTIqYTIxKSksb3V0WzEzXT1hMDAqKGEyMSphMzItYTIyKmEzMSktYTIwKihhMDEqYTMyLWEwMiphMzEpK2EzMCooYTAxKmEyMi1hMDIqYTIxKSxvdXRbMTRdPS0oYTAwKihhMTEqYTMyLWExMiphMzEpLWExMCooYTAxKmEzMi1hMDIqYTMxKSthMzAqKGEwMSphMTItYTAyKmExMSkpLG91dFsxNV09YTAwKihhMTEqYTIyLWExMiphMjEpLWExMCooYTAxKmEyMi1hMDIqYTIxKSthMjAqKGEwMSphMTItYTAyKmExMSksb3V0fWZ1bmN0aW9uIGRldGVybWluYW50KGEpe3ZhciBhMDA9YVswXSxhMDE9YVsxXSxhMDI9YVsyXSxhMDM9YVszXSxhMTA9YVs0XSxhMTE9YVs1XSxhMTI9YVs2XSxhMTM9YVs3XSxhMjA9YVs4XSxhMjE9YVs5XSxhMjI9YVsxMF0sYTIzPWFbMTFdLGEzMD1hWzEyXSxhMzE9YVsxM10sYTMyPWFbMTRdLGEzMz1hWzE1XTtyZXR1cm4oYTAwKmExMS1hMDEqYTEwKSooYTIyKmEzMy1hMjMqYTMyKS0oYTAwKmExMi1hMDIqYTEwKSooYTIxKmEzMy1hMjMqYTMxKSsoYTAwKmExMy1hMDMqYTEwKSooYTIxKmEzMi1hMjIqYTMxKSsoYTAxKmExMi1hMDIqYTExKSooYTIwKmEzMy1hMjMqYTMwKS0oYTAxKmExMy1hMDMqYTExKSooYTIwKmEzMi1hMjIqYTMwKSsoYTAyKmExMy1hMDMqYTEyKSooYTIwKmEzMS1hMjEqYTMwKX1mdW5jdGlvbiBtdWx0aXBseShvdXQsYSxiKXt2YXIgYTAwPWFbMF0sYTAxPWFbMV0sYTAyPWFbMl0sYTAzPWFbM10sYTEwPWFbNF0sYTExPWFbNV0sYTEyPWFbNl0sYTEzPWFbN10sYTIwPWFbOF0sYTIxPWFbOV0sYTIyPWFbMTBdLGEyMz1hWzExXSxhMzA9YVsxMl0sYTMxPWFbMTNdLGEzMj1hWzE0XSxhMzM9YVsxNV0sYjA9YlswXSxiMT1iWzFdLGIyPWJbMl0sYjM9YlszXTtyZXR1cm4gb3V0WzBdPWIwKmEwMCtiMSphMTArYjIqYTIwK2IzKmEzMCxvdXRbMV09YjAqYTAxK2IxKmExMStiMiphMjErYjMqYTMxLG91dFsyXT1iMCphMDIrYjEqYTEyK2IyKmEyMitiMyphMzIsb3V0WzNdPWIwKmEwMytiMSphMTMrYjIqYTIzK2IzKmEzMyxiMD1iWzRdLGIxPWJbNV0sYjI9Yls2XSxiMz1iWzddLG91dFs0XT1iMCphMDArYjEqYTEwK2IyKmEyMCtiMyphMzAsb3V0WzVdPWIwKmEwMStiMSphMTErYjIqYTIxK2IzKmEzMSxvdXRbNl09YjAqYTAyK2IxKmExMitiMiphMjIrYjMqYTMyLG91dFs3XT1iMCphMDMrYjEqYTEzK2IyKmEyMytiMyphMzMsYjA9Yls4XSxiMT1iWzldLGIyPWJbMTBdLGIzPWJbMTFdLG91dFs4XT1iMCphMDArYjEqYTEwK2IyKmEyMCtiMyphMzAsb3V0WzldPWIwKmEwMStiMSphMTErYjIqYTIxK2IzKmEzMSxvdXRbMTBdPWIwKmEwMitiMSphMTIrYjIqYTIyK2IzKmEzMixvdXRbMTFdPWIwKmEwMytiMSphMTMrYjIqYTIzK2IzKmEzMyxiMD1iWzEyXSxiMT1iWzEzXSxiMj1iWzE0XSxiMz1iWzE1XSxvdXRbMTJdPWIwKmEwMCtiMSphMTArYjIqYTIwK2IzKmEzMCxvdXRbMTNdPWIwKmEwMStiMSphMTErYjIqYTIxK2IzKmEzMSxvdXRbMTRdPWIwKmEwMitiMSphMTIrYjIqYTIyK2IzKmEzMixvdXRbMTVdPWIwKmEwMytiMSphMTMrYjIqYTIzK2IzKmEzMyxvdXR9ZnVuY3Rpb24gdHJhbnNsYXRlKG91dCxhLHYpe3ZhciB4PXZbMF0seT12WzFdLHo9dlsyXSxhMDA9dm9pZCAwLGEwMT12b2lkIDAsYTAyPXZvaWQgMCxhMDM9dm9pZCAwLGExMD12b2lkIDAsYTExPXZvaWQgMCxhMTI9dm9pZCAwLGExMz12b2lkIDAsYTIwPXZvaWQgMCxhMjE9dm9pZCAwLGEyMj12b2lkIDAsYTIzPXZvaWQgMDtyZXR1cm4gYT09PW91dD8ob3V0WzEyXT1hWzBdKngrYVs0XSp5K2FbOF0qeithWzEyXSxvdXRbMTNdPWFbMV0qeCthWzVdKnkrYVs5XSp6K2FbMTNdLG91dFsxNF09YVsyXSp4K2FbNl0qeSthWzEwXSp6K2FbMTRdLG91dFsxNV09YVszXSp4K2FbN10qeSthWzExXSp6K2FbMTVdKTooYTAwPWFbMF0sYTAxPWFbMV0sYTAyPWFbMl0sYTAzPWFbM10sYTEwPWFbNF0sYTExPWFbNV0sYTEyPWFbNl0sYTEzPWFbN10sYTIwPWFbOF0sYTIxPWFbOV0sYTIyPWFbMTBdLGEyMz1hWzExXSxvdXRbMF09YTAwLG91dFsxXT1hMDEsb3V0WzJdPWEwMixvdXRbM109YTAzLG91dFs0XT1hMTAsb3V0WzVdPWExMSxvdXRbNl09YTEyLG91dFs3XT1hMTMsb3V0WzhdPWEyMCxvdXRbOV09YTIxLG91dFsxMF09YTIyLG91dFsxMV09YTIzLG91dFsxMl09YTAwKngrYTEwKnkrYTIwKnorYVsxMl0sb3V0WzEzXT1hMDEqeCthMTEqeSthMjEqeithWzEzXSxvdXRbMTRdPWEwMip4K2ExMip5K2EyMip6K2FbMTRdLG91dFsxNV09YTAzKngrYTEzKnkrYTIzKnorYVsxNV0pLG91dH1mdW5jdGlvbiBzY2FsZShvdXQsYSx2KXt2YXIgeD12WzBdLHk9dlsxXSx6PXZbMl07cmV0dXJuIG91dFswXT1hWzBdKngsb3V0WzFdPWFbMV0qeCxvdXRbMl09YVsyXSp4LG91dFszXT1hWzNdKngsb3V0WzRdPWFbNF0qeSxvdXRbNV09YVs1XSp5LG91dFs2XT1hWzZdKnksb3V0WzddPWFbN10qeSxvdXRbOF09YVs4XSp6LG91dFs5XT1hWzldKnosb3V0WzEwXT1hWzEwXSp6LG91dFsxMV09YVsxMV0qeixvdXRbMTJdPWFbMTJdLG91dFsxM109YVsxM10sb3V0WzE0XT1hWzE0XSxvdXRbMTVdPWFbMTVdLG91dH1mdW5jdGlvbiByb3RhdGUob3V0LGEscmFkLGF4aXMpe3ZhciB4PWF4aXNbMF0seT1heGlzWzFdLHo9YXhpc1syXSxsZW49TWF0aC5zcXJ0KHgqeCt5Knkreip6KSxzPXZvaWQgMCxjPXZvaWQgMCx0PXZvaWQgMCxhMDA9dm9pZCAwLGEwMT12b2lkIDAsYTAyPXZvaWQgMCxhMDM9dm9pZCAwLGExMD12b2lkIDAsYTExPXZvaWQgMCxhMTI9dm9pZCAwLGExMz12b2lkIDAsYTIwPXZvaWQgMCxhMjE9dm9pZCAwLGEyMj12b2lkIDAsYTIzPXZvaWQgMCxiMDA9dm9pZCAwLGIwMT12b2lkIDAsYjAyPXZvaWQgMCxiMTA9dm9pZCAwLGIxMT12b2lkIDAsYjEyPXZvaWQgMCxiMjA9dm9pZCAwLGIyMT12b2lkIDAsYjIyPXZvaWQgMDtyZXR1cm4gTWF0aC5hYnMobGVuKTxnbE1hdHJpeC5FUFNJTE9OP251bGw6KGxlbj0xL2xlbix4Kj1sZW4seSo9bGVuLHoqPWxlbixzPU1hdGguc2luKHJhZCksYz1NYXRoLmNvcyhyYWQpLHQ9MS1jLGEwMD1hWzBdLGEwMT1hWzFdLGEwMj1hWzJdLGEwMz1hWzNdLGExMD1hWzRdLGExMT1hWzVdLGExMj1hWzZdLGExMz1hWzddLGEyMD1hWzhdLGEyMT1hWzldLGEyMj1hWzEwXSxhMjM9YVsxMV0sYjAwPXgqeCp0K2MsYjAxPXkqeCp0K3oqcyxiMDI9eip4KnQteSpzLGIxMD14KnkqdC16KnMsYjExPXkqeSp0K2MsYjEyPXoqeSp0K3gqcyxiMjA9eCp6KnQreSpzLGIyMT15KnoqdC14KnMsYjIyPXoqeip0K2Msb3V0WzBdPWEwMCpiMDArYTEwKmIwMSthMjAqYjAyLG91dFsxXT1hMDEqYjAwK2ExMSpiMDErYTIxKmIwMixvdXRbMl09YTAyKmIwMCthMTIqYjAxK2EyMipiMDIsb3V0WzNdPWEwMypiMDArYTEzKmIwMSthMjMqYjAyLG91dFs0XT1hMDAqYjEwK2ExMCpiMTErYTIwKmIxMixvdXRbNV09YTAxKmIxMCthMTEqYjExK2EyMSpiMTIsb3V0WzZdPWEwMipiMTArYTEyKmIxMSthMjIqYjEyLG91dFs3XT1hMDMqYjEwK2ExMypiMTErYTIzKmIxMixvdXRbOF09YTAwKmIyMCthMTAqYjIxK2EyMCpiMjIsb3V0WzldPWEwMSpiMjArYTExKmIyMSthMjEqYjIyLG91dFsxMF09YTAyKmIyMCthMTIqYjIxK2EyMipiMjIsb3V0WzExXT1hMDMqYjIwK2ExMypiMjErYTIzKmIyMixhIT09b3V0JiYob3V0WzEyXT1hWzEyXSxvdXRbMTNdPWFbMTNdLG91dFsxNF09YVsxNF0sb3V0WzE1XT1hWzE1XSksb3V0KX1mdW5jdGlvbiByb3RhdGVYKG91dCxhLHJhZCl7dmFyIHM9TWF0aC5zaW4ocmFkKSxjPU1hdGguY29zKHJhZCksYTEwPWFbNF0sYTExPWFbNV0sYTEyPWFbNl0sYTEzPWFbN10sYTIwPWFbOF0sYTIxPWFbOV0sYTIyPWFbMTBdLGEyMz1hWzExXTtyZXR1cm4gYSE9PW91dCYmKG91dFswXT1hWzBdLG91dFsxXT1hWzFdLG91dFsyXT1hWzJdLG91dFszXT1hWzNdLG91dFsxMl09YVsxMl0sb3V0WzEzXT1hWzEzXSxvdXRbMTRdPWFbMTRdLG91dFsxNV09YVsxNV0pLG91dFs0XT1hMTAqYythMjAqcyxvdXRbNV09YTExKmMrYTIxKnMsb3V0WzZdPWExMipjK2EyMipzLG91dFs3XT1hMTMqYythMjMqcyxvdXRbOF09YTIwKmMtYTEwKnMsb3V0WzldPWEyMSpjLWExMSpzLG91dFsxMF09YTIyKmMtYTEyKnMsb3V0WzExXT1hMjMqYy1hMTMqcyxvdXR9ZnVuY3Rpb24gcm90YXRlWShvdXQsYSxyYWQpe3ZhciBzPU1hdGguc2luKHJhZCksYz1NYXRoLmNvcyhyYWQpLGEwMD1hWzBdLGEwMT1hWzFdLGEwMj1hWzJdLGEwMz1hWzNdLGEyMD1hWzhdLGEyMT1hWzldLGEyMj1hWzEwXSxhMjM9YVsxMV07cmV0dXJuIGEhPT1vdXQmJihvdXRbNF09YVs0XSxvdXRbNV09YVs1XSxvdXRbNl09YVs2XSxvdXRbN109YVs3XSxvdXRbMTJdPWFbMTJdLG91dFsxM109YVsxM10sb3V0WzE0XT1hWzE0XSxvdXRbMTVdPWFbMTVdKSxvdXRbMF09YTAwKmMtYTIwKnMsb3V0WzFdPWEwMSpjLWEyMSpzLG91dFsyXT1hMDIqYy1hMjIqcyxvdXRbM109YTAzKmMtYTIzKnMsb3V0WzhdPWEwMCpzK2EyMCpjLG91dFs5XT1hMDEqcythMjEqYyxvdXRbMTBdPWEwMipzK2EyMipjLG91dFsxMV09YTAzKnMrYTIzKmMsb3V0fWZ1bmN0aW9uIHJvdGF0ZVoob3V0LGEscmFkKXt2YXIgcz1NYXRoLnNpbihyYWQpLGM9TWF0aC5jb3MocmFkKSxhMDA9YVswXSxhMDE9YVsxXSxhMDI9YVsyXSxhMDM9YVszXSxhMTA9YVs0XSxhMTE9YVs1XSxhMTI9YVs2XSxhMTM9YVs3XTtyZXR1cm4gYSE9PW91dCYmKG91dFs4XT1hWzhdLG91dFs5XT1hWzldLG91dFsxMF09YVsxMF0sb3V0WzExXT1hWzExXSxvdXRbMTJdPWFbMTJdLG91dFsxM109YVsxM10sb3V0WzE0XT1hWzE0XSxvdXRbMTVdPWFbMTVdKSxvdXRbMF09YTAwKmMrYTEwKnMsb3V0WzFdPWEwMSpjK2ExMSpzLG91dFsyXT1hMDIqYythMTIqcyxvdXRbM109YTAzKmMrYTEzKnMsb3V0WzRdPWExMCpjLWEwMCpzLG91dFs1XT1hMTEqYy1hMDEqcyxvdXRbNl09YTEyKmMtYTAyKnMsb3V0WzddPWExMypjLWEwMypzLG91dH1mdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LHYpe3JldHVybiBvdXRbMF09MSxvdXRbMV09MCxvdXRbMl09MCxvdXRbM109MCxvdXRbNF09MCxvdXRbNV09MSxvdXRbNl09MCxvdXRbN109MCxvdXRbOF09MCxvdXRbOV09MCxvdXRbMTBdPTEsb3V0WzExXT0wLG91dFsxMl09dlswXSxvdXRbMTNdPXZbMV0sb3V0WzE0XT12WzJdLG91dFsxNV09MSxvdXR9ZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LHYpe3JldHVybiBvdXRbMF09dlswXSxvdXRbMV09MCxvdXRbMl09MCxvdXRbM109MCxvdXRbNF09MCxvdXRbNV09dlsxXSxvdXRbNl09MCxvdXRbN109MCxvdXRbOF09MCxvdXRbOV09MCxvdXRbMTBdPXZbMl0sb3V0WzExXT0wLG91dFsxMl09MCxvdXRbMTNdPTAsb3V0WzE0XT0wLG91dFsxNV09MSxvdXR9ZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCxyYWQsYXhpcyl7dmFyIHg9YXhpc1swXSx5PWF4aXNbMV0sej1heGlzWzJdLGxlbj1NYXRoLnNxcnQoeCp4K3kqeSt6KnopLHM9dm9pZCAwLGM9dm9pZCAwLHQ9dm9pZCAwO3JldHVybiBNYXRoLmFicyhsZW4pPGdsTWF0cml4LkVQU0lMT04/bnVsbDoobGVuPTEvbGVuLHgqPWxlbix5Kj1sZW4seio9bGVuLHM9TWF0aC5zaW4ocmFkKSxjPU1hdGguY29zKHJhZCksdD0xLWMsb3V0WzBdPXgqeCp0K2Msb3V0WzFdPXkqeCp0K3oqcyxvdXRbMl09eip4KnQteSpzLG91dFszXT0wLG91dFs0XT14KnkqdC16KnMsb3V0WzVdPXkqeSp0K2Msb3V0WzZdPXoqeSp0K3gqcyxvdXRbN109MCxvdXRbOF09eCp6KnQreSpzLG91dFs5XT15KnoqdC14KnMsb3V0WzEwXT16KnoqdCtjLG91dFsxMV09MCxvdXRbMTJdPTAsb3V0WzEzXT0wLG91dFsxNF09MCxvdXRbMTVdPTEsb3V0KX1mdW5jdGlvbiBmcm9tWFJvdGF0aW9uKG91dCxyYWQpe3ZhciBzPU1hdGguc2luKHJhZCksYz1NYXRoLmNvcyhyYWQpO3JldHVybiBvdXRbMF09MSxvdXRbMV09MCxvdXRbMl09MCxvdXRbM109MCxvdXRbNF09MCxvdXRbNV09YyxvdXRbNl09cyxvdXRbN109MCxvdXRbOF09MCxvdXRbOV09LXMsb3V0WzEwXT1jLG91dFsxMV09MCxvdXRbMTJdPTAsb3V0WzEzXT0wLG91dFsxNF09MCxvdXRbMTVdPTEsb3V0fWZ1bmN0aW9uIGZyb21ZUm90YXRpb24ob3V0LHJhZCl7dmFyIHM9TWF0aC5zaW4ocmFkKSxjPU1hdGguY29zKHJhZCk7cmV0dXJuIG91dFswXT1jLG91dFsxXT0wLG91dFsyXT0tcyxvdXRbM109MCxvdXRbNF09MCxvdXRbNV09MSxvdXRbNl09MCxvdXRbN109MCxvdXRbOF09cyxvdXRbOV09MCxvdXRbMTBdPWMsb3V0WzExXT0wLG91dFsxMl09MCxvdXRbMTNdPTAsb3V0WzE0XT0wLG91dFsxNV09MSxvdXR9ZnVuY3Rpb24gZnJvbVpSb3RhdGlvbihvdXQscmFkKXt2YXIgcz1NYXRoLnNpbihyYWQpLGM9TWF0aC5jb3MocmFkKTtyZXR1cm4gb3V0WzBdPWMsb3V0WzFdPXMsb3V0WzJdPTAsb3V0WzNdPTAsb3V0WzRdPS1zLG91dFs1XT1jLG91dFs2XT0wLG91dFs3XT0wLG91dFs4XT0wLG91dFs5XT0wLG91dFsxMF09MSxvdXRbMTFdPTAsb3V0WzEyXT0wLG91dFsxM109MCxvdXRbMTRdPTAsb3V0WzE1XT0xLG91dH1mdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQscSx2KXt2YXIgeD1xWzBdLHk9cVsxXSx6PXFbMl0sdz1xWzNdLHgyPXgreCx5Mj15K3ksejI9eit6LHh4PXgqeDIseHk9eCp5Mix4ej14KnoyLHl5PXkqeTIseXo9eSp6Mix6ej16KnoyLHd4PXcqeDIsd3k9dyp5Mix3ej13KnoyO3JldHVybiBvdXRbMF09MS0oeXkrenopLG91dFsxXT14eSt3eixvdXRbMl09eHotd3ksb3V0WzNdPTAsb3V0WzRdPXh5LXd6LG91dFs1XT0xLSh4eCt6eiksb3V0WzZdPXl6K3d4LG91dFs3XT0wLG91dFs4XT14eit3eSxvdXRbOV09eXotd3gsb3V0WzEwXT0xLSh4eCt5eSksb3V0WzExXT0wLG91dFsxMl09dlswXSxvdXRbMTNdPXZbMV0sb3V0WzE0XT12WzJdLG91dFsxNV09MSxvdXR9ZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24ob3V0LG1hdCl7cmV0dXJuIG91dFswXT1tYXRbMTJdLG91dFsxXT1tYXRbMTNdLG91dFsyXT1tYXRbMTRdLG91dH1mdW5jdGlvbiBnZXRTY2FsaW5nKG91dCxtYXQpe3ZhciBtMTE9bWF0WzBdLG0xMj1tYXRbMV0sbTEzPW1hdFsyXSxtMjE9bWF0WzRdLG0yMj1tYXRbNV0sbTIzPW1hdFs2XSxtMzE9bWF0WzhdLG0zMj1tYXRbOV0sbTMzPW1hdFsxMF07cmV0dXJuIG91dFswXT1NYXRoLnNxcnQobTExKm0xMSttMTIqbTEyK20xMyptMTMpLG91dFsxXT1NYXRoLnNxcnQobTIxKm0yMSttMjIqbTIyK20yMyptMjMpLG91dFsyXT1NYXRoLnNxcnQobTMxKm0zMSttMzIqbTMyK20zMyptMzMpLG91dH1mdW5jdGlvbiBnZXRSb3RhdGlvbihvdXQsbWF0KXt2YXIgdHJhY2U9bWF0WzBdK21hdFs1XSttYXRbMTBdLFM9MDtyZXR1cm4gdHJhY2U+MD8oUz0yKk1hdGguc3FydCh0cmFjZSsxKSxvdXRbM109LjI1KlMsb3V0WzBdPShtYXRbNl0tbWF0WzldKS9TLG91dFsxXT0obWF0WzhdLW1hdFsyXSkvUyxvdXRbMl09KG1hdFsxXS1tYXRbNF0pL1MpOm1hdFswXT5tYXRbNV0mbWF0WzBdPm1hdFsxMF0/KFM9MipNYXRoLnNxcnQoMSttYXRbMF0tbWF0WzVdLW1hdFsxMF0pLG91dFszXT0obWF0WzZdLW1hdFs5XSkvUyxvdXRbMF09LjI1KlMsb3V0WzFdPShtYXRbMV0rbWF0WzRdKS9TLG91dFsyXT0obWF0WzhdK21hdFsyXSkvUyk6bWF0WzVdPm1hdFsxMF0/KFM9MipNYXRoLnNxcnQoMSttYXRbNV0tbWF0WzBdLW1hdFsxMF0pLG91dFszXT0obWF0WzhdLW1hdFsyXSkvUyxvdXRbMF09KG1hdFsxXSttYXRbNF0pL1Msb3V0WzFdPS4yNSpTLG91dFsyXT0obWF0WzZdK21hdFs5XSkvUyk6KFM9MipNYXRoLnNxcnQoMSttYXRbMTBdLW1hdFswXS1tYXRbNV0pLG91dFszXT0obWF0WzFdLW1hdFs0XSkvUyxvdXRbMF09KG1hdFs4XSttYXRbMl0pL1Msb3V0WzFdPShtYXRbNl0rbWF0WzldKS9TLG91dFsyXT0uMjUqUyksb3V0fWZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUob3V0LHEsdixzKXt2YXIgeD1xWzBdLHk9cVsxXSx6PXFbMl0sdz1xWzNdLHgyPXgreCx5Mj15K3ksejI9eit6LHh4PXgqeDIseHk9eCp5Mix4ej14KnoyLHl5PXkqeTIseXo9eSp6Mix6ej16KnoyLHd4PXcqeDIsd3k9dyp5Mix3ej13KnoyLHN4PXNbMF0sc3k9c1sxXSxzej1zWzJdO3JldHVybiBvdXRbMF09KDEtKHl5K3p6KSkqc3gsb3V0WzFdPSh4eSt3eikqc3gsb3V0WzJdPSh4ei13eSkqc3gsb3V0WzNdPTAsb3V0WzRdPSh4eS13eikqc3ksb3V0WzVdPSgxLSh4eCt6eikpKnN5LG91dFs2XT0oeXord3gpKnN5LG91dFs3XT0wLG91dFs4XT0oeHord3kpKnN6LG91dFs5XT0oeXotd3gpKnN6LG91dFsxMF09KDEtKHh4K3l5KSkqc3osb3V0WzExXT0wLG91dFsxMl09dlswXSxvdXRbMTNdPXZbMV0sb3V0WzE0XT12WzJdLG91dFsxNV09MSxvdXR9ZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbihvdXQscSx2LHMsbyl7dmFyIHg9cVswXSx5PXFbMV0sej1xWzJdLHc9cVszXSx4Mj14K3gseTI9eSt5LHoyPXoreix4eD14KngyLHh5PXgqeTIseHo9eCp6Mix5eT15KnkyLHl6PXkqejIseno9eip6Mix3eD13KngyLHd5PXcqeTIsd3o9dyp6MixzeD1zWzBdLHN5PXNbMV0sc3o9c1syXSxveD1vWzBdLG95PW9bMV0sb3o9b1syXTtyZXR1cm4gb3V0WzBdPSgxLSh5eSt6eikpKnN4LG91dFsxXT0oeHkrd3opKnN4LG91dFsyXT0oeHotd3kpKnN4LG91dFszXT0wLG91dFs0XT0oeHktd3opKnN5LG91dFs1XT0oMS0oeHgrenopKSpzeSxvdXRbNl09KHl6K3d4KSpzeSxvdXRbN109MCxvdXRbOF09KHh6K3d5KSpzeixvdXRbOV09KHl6LXd4KSpzeixvdXRbMTBdPSgxLSh4eCt5eSkpKnN6LG91dFsxMV09MCxvdXRbMTJdPXZbMF0rb3gtKG91dFswXSpveCtvdXRbNF0qb3krb3V0WzhdKm96KSxvdXRbMTNdPXZbMV0rb3ktKG91dFsxXSpveCtvdXRbNV0qb3krb3V0WzldKm96KSxvdXRbMTRdPXZbMl0rb3otKG91dFsyXSpveCtvdXRbNl0qb3krb3V0WzEwXSpveiksb3V0WzE1XT0xLG91dH1mdW5jdGlvbiBmcm9tUXVhdChvdXQscSl7dmFyIHg9cVswXSx5PXFbMV0sej1xWzJdLHc9cVszXSx4Mj14K3gseTI9eSt5LHoyPXoreix4eD14KngyLHl4PXkqeDIseXk9eSp5Mix6eD16KngyLHp5PXoqeTIseno9eip6Mix3eD13KngyLHd5PXcqeTIsd3o9dyp6MjtyZXR1cm4gb3V0WzBdPTEteXktenosb3V0WzFdPXl4K3d6LG91dFsyXT16eC13eSxvdXRbM109MCxvdXRbNF09eXgtd3osb3V0WzVdPTEteHgtenosb3V0WzZdPXp5K3d4LG91dFs3XT0wLG91dFs4XT16eCt3eSxvdXRbOV09enktd3gsb3V0WzEwXT0xLXh4LXl5LG91dFsxMV09MCxvdXRbMTJdPTAsb3V0WzEzXT0wLG91dFsxNF09MCxvdXRbMTVdPTEsb3V0fWZ1bmN0aW9uIGZydXN0dW0ob3V0LGxlZnQscmlnaHQsYm90dG9tLHRvcCxuZWFyLGZhcil7dmFyIHJsPTEvKHJpZ2h0LWxlZnQpLHRiPTEvKHRvcC1ib3R0b20pLG5mPTEvKG5lYXItZmFyKTtyZXR1cm4gb3V0WzBdPTIqbmVhcipybCxvdXRbMV09MCxvdXRbMl09MCxvdXRbM109MCxvdXRbNF09MCxvdXRbNV09MipuZWFyKnRiLG91dFs2XT0wLG91dFs3XT0wLG91dFs4XT0ocmlnaHQrbGVmdCkqcmwsb3V0WzldPSh0b3ArYm90dG9tKSp0YixvdXRbMTBdPShmYXIrbmVhcikqbmYsb3V0WzExXT0tMSxvdXRbMTJdPTAsb3V0WzEzXT0wLG91dFsxNF09ZmFyKm5lYXIqMipuZixvdXRbMTVdPTAsb3V0fWZ1bmN0aW9uIHBlcnNwZWN0aXZlKG91dCxmb3Z5LGFzcGVjdCxuZWFyLGZhcil7dmFyIGY9MS9NYXRoLnRhbihmb3Z5LzIpLG5mPTEvKG5lYXItZmFyKTtyZXR1cm4gb3V0WzBdPWYvYXNwZWN0LG91dFsxXT0wLG91dFsyXT0wLG91dFszXT0wLG91dFs0XT0wLG91dFs1XT1mLG91dFs2XT0wLG91dFs3XT0wLG91dFs4XT0wLG91dFs5XT0wLG91dFsxMF09KGZhcituZWFyKSpuZixvdXRbMTFdPS0xLG91dFsxMl09MCxvdXRbMTNdPTAsb3V0WzE0XT0yKmZhcipuZWFyKm5mLG91dFsxNV09MCxvdXR9ZnVuY3Rpb24gcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcob3V0LGZvdixuZWFyLGZhcil7dmFyIHVwVGFuPU1hdGgudGFuKGZvdi51cERlZ3JlZXMqTWF0aC5QSS8xODApLGRvd25UYW49TWF0aC50YW4oZm92LmRvd25EZWdyZWVzKk1hdGguUEkvMTgwKSxsZWZ0VGFuPU1hdGgudGFuKGZvdi5sZWZ0RGVncmVlcypNYXRoLlBJLzE4MCkscmlnaHRUYW49TWF0aC50YW4oZm92LnJpZ2h0RGVncmVlcypNYXRoLlBJLzE4MCkseFNjYWxlPTIvKGxlZnRUYW4rcmlnaHRUYW4pLHlTY2FsZT0yLyh1cFRhbitkb3duVGFuKTtyZXR1cm4gb3V0WzBdPXhTY2FsZSxvdXRbMV09MCxvdXRbMl09MCxvdXRbM109MCxvdXRbNF09MCxvdXRbNV09eVNjYWxlLG91dFs2XT0wLG91dFs3XT0wLG91dFs4XT0tKGxlZnRUYW4tcmlnaHRUYW4pKnhTY2FsZSouNSxvdXRbOV09KHVwVGFuLWRvd25UYW4pKnlTY2FsZSouNSxvdXRbMTBdPWZhci8obmVhci1mYXIpLG91dFsxMV09LTEsb3V0WzEyXT0wLG91dFsxM109MCxvdXRbMTRdPWZhcipuZWFyLyhuZWFyLWZhciksb3V0WzE1XT0wLG91dH1mdW5jdGlvbiBvcnRobyhvdXQsbGVmdCxyaWdodCxib3R0b20sdG9wLG5lYXIsZmFyKXt2YXIgbHI9MS8obGVmdC1yaWdodCksYnQ9MS8oYm90dG9tLXRvcCksbmY9MS8obmVhci1mYXIpO3JldHVybiBvdXRbMF09LTIqbHIsb3V0WzFdPTAsb3V0WzJdPTAsb3V0WzNdPTAsb3V0WzRdPTAsb3V0WzVdPS0yKmJ0LG91dFs2XT0wLG91dFs3XT0wLG91dFs4XT0wLG91dFs5XT0wLG91dFsxMF09MipuZixvdXRbMTFdPTAsb3V0WzEyXT0obGVmdCtyaWdodCkqbHIsb3V0WzEzXT0odG9wK2JvdHRvbSkqYnQsb3V0WzE0XT0oZmFyK25lYXIpKm5mLG91dFsxNV09MSxvdXR9ZnVuY3Rpb24gbG9va0F0KG91dCxleWUsY2VudGVyLHVwKXt2YXIgeDA9dm9pZCAwLHgxPXZvaWQgMCx4Mj12b2lkIDAseTA9dm9pZCAwLHkxPXZvaWQgMCx5Mj12b2lkIDAsejA9dm9pZCAwLHoxPXZvaWQgMCx6Mj12b2lkIDAsbGVuPXZvaWQgMCxleWV4PWV5ZVswXSxleWV5PWV5ZVsxXSxleWV6PWV5ZVsyXSx1cHg9dXBbMF0sdXB5PXVwWzFdLHVwej11cFsyXSxjZW50ZXJ4PWNlbnRlclswXSxjZW50ZXJ5PWNlbnRlclsxXSxjZW50ZXJ6PWNlbnRlclsyXTtyZXR1cm4gTWF0aC5hYnMoZXlleC1jZW50ZXJ4KTxnbE1hdHJpeC5FUFNJTE9OJiZNYXRoLmFicyhleWV5LWNlbnRlcnkpPGdsTWF0cml4LkVQU0lMT04mJk1hdGguYWJzKGV5ZXotY2VudGVyeik8Z2xNYXRyaXguRVBTSUxPTj9tYXQ0LmlkZW50aXR5KG91dCk6KHowPWV5ZXgtY2VudGVyeCx6MT1leWV5LWNlbnRlcnksejI9ZXllei1jZW50ZXJ6LGxlbj0xL01hdGguc3FydCh6MCp6MCt6MSp6MSt6Mip6MiksejAqPWxlbix6MSo9bGVuLHoyKj1sZW4seDA9dXB5KnoyLXVweip6MSx4MT11cHoqejAtdXB4KnoyLHgyPXVweCp6MS11cHkqejAsbGVuPU1hdGguc3FydCh4MCp4MCt4MSp4MSt4Mip4MiksbGVuPyhsZW49MS9sZW4seDAqPWxlbix4MSo9bGVuLHgyKj1sZW4pOih4MD0wLHgxPTAseDI9MCkseTA9ejEqeDItejIqeDEseTE9ejIqeDAtejAqeDIseTI9ejAqeDEtejEqeDAsbGVuPU1hdGguc3FydCh5MCp5MCt5MSp5MSt5Mip5MiksbGVuPyhsZW49MS9sZW4seTAqPWxlbix5MSo9bGVuLHkyKj1sZW4pOih5MD0wLHkxPTAseTI9MCksb3V0WzBdPXgwLG91dFsxXT15MCxvdXRbMl09ejAsb3V0WzNdPTAsb3V0WzRdPXgxLG91dFs1XT15MSxvdXRbNl09ejEsb3V0WzddPTAsb3V0WzhdPXgyLG91dFs5XT15MixvdXRbMTBdPXoyLG91dFsxMV09MCxvdXRbMTJdPS0oeDAqZXlleCt4MSpleWV5K3gyKmV5ZXopLG91dFsxM109LSh5MCpleWV4K3kxKmV5ZXkreTIqZXlleiksb3V0WzE0XT0tKHowKmV5ZXgrejEqZXlleSt6MipleWV6KSxvdXRbMTVdPTEsb3V0KX1mdW5jdGlvbiB0YXJnZXRUbyhvdXQsZXllLHRhcmdldCx1cCl7dmFyIGV5ZXg9ZXllWzBdLGV5ZXk9ZXllWzFdLGV5ZXo9ZXllWzJdLHVweD11cFswXSx1cHk9dXBbMV0sdXB6PXVwWzJdLHowPWV5ZXgtdGFyZ2V0WzBdLHoxPWV5ZXktdGFyZ2V0WzFdLHoyPWV5ZXotdGFyZ2V0WzJdLGxlbj16MCp6MCt6MSp6MSt6Mip6MjtsZW4+MCYmKGxlbj0xL01hdGguc3FydChsZW4pLHowKj1sZW4sejEqPWxlbix6Mio9bGVuKTt2YXIgeDA9dXB5KnoyLXVweip6MSx4MT11cHoqejAtdXB4KnoyLHgyPXVweCp6MS11cHkqejA7cmV0dXJuIG91dFswXT14MCxvdXRbMV09eDEsb3V0WzJdPXgyLG91dFszXT0wLG91dFs0XT16MSp4Mi16Mip4MSxvdXRbNV09ejIqeDAtejAqeDIsb3V0WzZdPXowKngxLXoxKngwLG91dFs3XT0wLG91dFs4XT16MCxvdXRbOV09ejEsb3V0WzEwXT16MixvdXRbMTFdPTAsb3V0WzEyXT1leWV4LG91dFsxM109ZXlleSxvdXRbMTRdPWV5ZXosb3V0WzE1XT0xLG91dH1mdW5jdGlvbiBzdHIoYSl7cmV0dXJuXCJtYXQ0KFwiK2FbMF0rXCIsIFwiK2FbMV0rXCIsIFwiK2FbMl0rXCIsIFwiK2FbM10rXCIsIFwiK2FbNF0rXCIsIFwiK2FbNV0rXCIsIFwiK2FbNl0rXCIsIFwiK2FbN10rXCIsIFwiK2FbOF0rXCIsIFwiK2FbOV0rXCIsIFwiK2FbMTBdK1wiLCBcIithWzExXStcIiwgXCIrYVsxMl0rXCIsIFwiK2FbMTNdK1wiLCBcIithWzE0XStcIiwgXCIrYVsxNV0rXCIpXCJ9ZnVuY3Rpb24gZnJvYihhKXtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sMikrTWF0aC5wb3coYVsxXSwyKStNYXRoLnBvdyhhWzJdLDIpK01hdGgucG93KGFbM10sMikrTWF0aC5wb3coYVs0XSwyKStNYXRoLnBvdyhhWzVdLDIpK01hdGgucG93KGFbNl0sMikrTWF0aC5wb3coYVs3XSwyKStNYXRoLnBvdyhhWzhdLDIpK01hdGgucG93KGFbOV0sMikrTWF0aC5wb3coYVsxMF0sMikrTWF0aC5wb3coYVsxMV0sMikrTWF0aC5wb3coYVsxMl0sMikrTWF0aC5wb3coYVsxM10sMikrTWF0aC5wb3coYVsxNF0sMikrTWF0aC5wb3coYVsxNV0sMikpfWZ1bmN0aW9uIGFkZChvdXQsYSxiKXtyZXR1cm4gb3V0WzBdPWFbMF0rYlswXSxvdXRbMV09YVsxXStiWzFdLG91dFsyXT1hWzJdK2JbMl0sb3V0WzNdPWFbM10rYlszXSxvdXRbNF09YVs0XStiWzRdLG91dFs1XT1hWzVdK2JbNV0sb3V0WzZdPWFbNl0rYls2XSxvdXRbN109YVs3XStiWzddLG91dFs4XT1hWzhdK2JbOF0sb3V0WzldPWFbOV0rYls5XSxvdXRbMTBdPWFbMTBdK2JbMTBdLG91dFsxMV09YVsxMV0rYlsxMV0sb3V0WzEyXT1hWzEyXStiWzEyXSxvdXRbMTNdPWFbMTNdK2JbMTNdLG91dFsxNF09YVsxNF0rYlsxNF0sb3V0WzE1XT1hWzE1XStiWzE1XSxvdXR9ZnVuY3Rpb24gc3VidHJhY3Qob3V0LGEsYil7cmV0dXJuIG91dFswXT1hWzBdLWJbMF0sb3V0WzFdPWFbMV0tYlsxXSxvdXRbMl09YVsyXS1iWzJdLG91dFszXT1hWzNdLWJbM10sb3V0WzRdPWFbNF0tYls0XSxvdXRbNV09YVs1XS1iWzVdLG91dFs2XT1hWzZdLWJbNl0sb3V0WzddPWFbN10tYls3XSxvdXRbOF09YVs4XS1iWzhdLG91dFs5XT1hWzldLWJbOV0sb3V0WzEwXT1hWzEwXS1iWzEwXSxvdXRbMTFdPWFbMTFdLWJbMTFdLG91dFsxMl09YVsxMl0tYlsxMl0sb3V0WzEzXT1hWzEzXS1iWzEzXSxvdXRbMTRdPWFbMTRdLWJbMTRdLG91dFsxNV09YVsxNV0tYlsxNV0sb3V0fWZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCxhLGIpe3JldHVybiBvdXRbMF09YVswXSpiLG91dFsxXT1hWzFdKmIsb3V0WzJdPWFbMl0qYixvdXRbM109YVszXSpiLG91dFs0XT1hWzRdKmIsb3V0WzVdPWFbNV0qYixvdXRbNl09YVs2XSpiLG91dFs3XT1hWzddKmIsb3V0WzhdPWFbOF0qYixvdXRbOV09YVs5XSpiLG91dFsxMF09YVsxMF0qYixvdXRbMTFdPWFbMTFdKmIsb3V0WzEyXT1hWzEyXSpiLG91dFsxM109YVsxM10qYixvdXRbMTRdPWFbMTRdKmIsb3V0WzE1XT1hWzE1XSpiLG91dH1mdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsYSxiLHNjYWxlKXtyZXR1cm4gb3V0WzBdPWFbMF0rYlswXSpzY2FsZSxvdXRbMV09YVsxXStiWzFdKnNjYWxlLG91dFsyXT1hWzJdK2JbMl0qc2NhbGUsb3V0WzNdPWFbM10rYlszXSpzY2FsZSxvdXRbNF09YVs0XStiWzRdKnNjYWxlLG91dFs1XT1hWzVdK2JbNV0qc2NhbGUsb3V0WzZdPWFbNl0rYls2XSpzY2FsZSxvdXRbN109YVs3XStiWzddKnNjYWxlLG91dFs4XT1hWzhdK2JbOF0qc2NhbGUsb3V0WzldPWFbOV0rYls5XSpzY2FsZSxvdXRbMTBdPWFbMTBdK2JbMTBdKnNjYWxlLG91dFsxMV09YVsxMV0rYlsxMV0qc2NhbGUsb3V0WzEyXT1hWzEyXStiWzEyXSpzY2FsZSxvdXRbMTNdPWFbMTNdK2JbMTNdKnNjYWxlLG91dFsxNF09YVsxNF0rYlsxNF0qc2NhbGUsb3V0WzE1XT1hWzE1XStiWzE1XSpzY2FsZSxvdXR9ZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSxiKXtyZXR1cm4gYVswXT09PWJbMF0mJmFbMV09PT1iWzFdJiZhWzJdPT09YlsyXSYmYVszXT09PWJbM10mJmFbNF09PT1iWzRdJiZhWzVdPT09Yls1XSYmYVs2XT09PWJbNl0mJmFbN109PT1iWzddJiZhWzhdPT09Yls4XSYmYVs5XT09PWJbOV0mJmFbMTBdPT09YlsxMF0mJmFbMTFdPT09YlsxMV0mJmFbMTJdPT09YlsxMl0mJmFbMTNdPT09YlsxM10mJmFbMTRdPT09YlsxNF0mJmFbMTVdPT09YlsxNV19ZnVuY3Rpb24gZXF1YWxzKGEsYil7dmFyIGEwPWFbMF0sYTE9YVsxXSxhMj1hWzJdLGEzPWFbM10sYTQ9YVs0XSxhNT1hWzVdLGE2PWFbNl0sYTc9YVs3XSxhOD1hWzhdLGE5PWFbOV0sYTEwPWFbMTBdLGExMT1hWzExXSxhMTI9YVsxMl0sYTEzPWFbMTNdLGExND1hWzE0XSxhMTU9YVsxNV0sYjA9YlswXSxiMT1iWzFdLGIyPWJbMl0sYjM9YlszXSxiND1iWzRdLGI1PWJbNV0sYjY9Yls2XSxiNz1iWzddLGI4PWJbOF0sYjk9Yls5XSxiMTA9YlsxMF0sYjExPWJbMTFdLGIxMj1iWzEyXSxiMTM9YlsxM10sYjE0PWJbMTRdLGIxNT1iWzE1XTtyZXR1cm4gTWF0aC5hYnMoYTAtYjApPD1nbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYTApLE1hdGguYWJzKGIwKSkmJk1hdGguYWJzKGExLWIxKTw9Z2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGExKSxNYXRoLmFicyhiMSkpJiZNYXRoLmFicyhhMi1iMik8PWdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhMiksTWF0aC5hYnMoYjIpKSYmTWF0aC5hYnMoYTMtYjMpPD1nbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYTMpLE1hdGguYWJzKGIzKSkmJk1hdGguYWJzKGE0LWI0KTw9Z2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGE0KSxNYXRoLmFicyhiNCkpJiZNYXRoLmFicyhhNS1iNSk8PWdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhNSksTWF0aC5hYnMoYjUpKSYmTWF0aC5hYnMoYTYtYjYpPD1nbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYTYpLE1hdGguYWJzKGI2KSkmJk1hdGguYWJzKGE3LWI3KTw9Z2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGE3KSxNYXRoLmFicyhiNykpJiZNYXRoLmFicyhhOC1iOCk8PWdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhOCksTWF0aC5hYnMoYjgpKSYmTWF0aC5hYnMoYTktYjkpPD1nbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYTkpLE1hdGguYWJzKGI5KSkmJk1hdGguYWJzKGExMC1iMTApPD1nbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYTEwKSxNYXRoLmFicyhiMTApKSYmTWF0aC5hYnMoYTExLWIxMSk8PWdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhMTEpLE1hdGguYWJzKGIxMSkpJiZNYXRoLmFicyhhMTItYjEyKTw9Z2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGExMiksTWF0aC5hYnMoYjEyKSkmJk1hdGguYWJzKGExMy1iMTMpPD1nbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYTEzKSxNYXRoLmFicyhiMTMpKSYmTWF0aC5hYnMoYTE0LWIxNCk8PWdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhMTQpLE1hdGguYWJzKGIxNCkpJiZNYXRoLmFicyhhMTUtYjE1KTw9Z2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGExNSksTWF0aC5hYnMoYjE1KSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZXhwb3J0cy5zdWI9ZXhwb3J0cy5tdWw9dm9pZCAwLGV4cG9ydHMuY3JlYXRlPWNyZWF0ZSxleHBvcnRzLmNsb25lPWNsb25lLGV4cG9ydHMuY29weT1jb3B5LGV4cG9ydHMuZnJvbVZhbHVlcz1mcm9tVmFsdWVzLGV4cG9ydHMuc2V0PXNldCxleHBvcnRzLmlkZW50aXR5PWlkZW50aXR5LGV4cG9ydHMudHJhbnNwb3NlPXRyYW5zcG9zZSxleHBvcnRzLmludmVydD1pbnZlcnQsZXhwb3J0cy5hZGpvaW50PWFkam9pbnQsZXhwb3J0cy5kZXRlcm1pbmFudD1kZXRlcm1pbmFudCxleHBvcnRzLm11bHRpcGx5PW11bHRpcGx5LGV4cG9ydHMudHJhbnNsYXRlPXRyYW5zbGF0ZSxleHBvcnRzLnNjYWxlPXNjYWxlLGV4cG9ydHMucm90YXRlPXJvdGF0ZSxleHBvcnRzLnJvdGF0ZVg9cm90YXRlWCxleHBvcnRzLnJvdGF0ZVk9cm90YXRlWSxleHBvcnRzLnJvdGF0ZVo9cm90YXRlWixleHBvcnRzLmZyb21UcmFuc2xhdGlvbj1mcm9tVHJhbnNsYXRpb24sZXhwb3J0cy5mcm9tU2NhbGluZz1mcm9tU2NhbGluZyxleHBvcnRzLmZyb21Sb3RhdGlvbj1mcm9tUm90YXRpb24sZXhwb3J0cy5mcm9tWFJvdGF0aW9uPWZyb21YUm90YXRpb24sZXhwb3J0cy5mcm9tWVJvdGF0aW9uPWZyb21ZUm90YXRpb24sZXhwb3J0cy5mcm9tWlJvdGF0aW9uPWZyb21aUm90YXRpb24sZXhwb3J0cy5mcm9tUm90YXRpb25UcmFuc2xhdGlvbj1mcm9tUm90YXRpb25UcmFuc2xhdGlvbixleHBvcnRzLmdldFRyYW5zbGF0aW9uPWdldFRyYW5zbGF0aW9uLGV4cG9ydHMuZ2V0U2NhbGluZz1nZXRTY2FsaW5nLGV4cG9ydHMuZ2V0Um90YXRpb249Z2V0Um90YXRpb24sZXhwb3J0cy5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlPWZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUsZXhwb3J0cy5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luPWZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW4sZXhwb3J0cy5mcm9tUXVhdD1mcm9tUXVhdCxleHBvcnRzLmZydXN0dW09ZnJ1c3R1bSxleHBvcnRzLnBlcnNwZWN0aXZlPXBlcnNwZWN0aXZlLGV4cG9ydHMucGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXc9cGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcsZXhwb3J0cy5vcnRobz1vcnRobyxleHBvcnRzLmxvb2tBdD1sb29rQXQsZXhwb3J0cy50YXJnZXRUbz10YXJnZXRUbyxleHBvcnRzLnN0cj1zdHIsZXhwb3J0cy5mcm9iPWZyb2IsZXhwb3J0cy5hZGQ9YWRkLGV4cG9ydHMuc3VidHJhY3Q9c3VidHJhY3QsZXhwb3J0cy5tdWx0aXBseVNjYWxhcj1tdWx0aXBseVNjYWxhcixleHBvcnRzLm11bHRpcGx5U2NhbGFyQW5kQWRkPW11bHRpcGx5U2NhbGFyQW5kQWRkLGV4cG9ydHMuZXhhY3RFcXVhbHM9ZXhhY3RFcXVhbHMsZXhwb3J0cy5lcXVhbHM9ZXF1YWxzO3ZhciBfY29tbW9uPV9fd2VicGFja19yZXF1aXJlX18oMyksZ2xNYXRyaXg9ZnVuY3Rpb24ob2JqKXtpZihvYmomJm9iai5fX2VzTW9kdWxlKXJldHVybiBvYmo7dmFyIG5ld09iaj17fTtpZihudWxsIT1vYmopZm9yKHZhciBrZXkgaW4gb2JqKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosa2V5KSYmKG5ld09ialtrZXldPW9ialtrZXldKTtyZXR1cm4gbmV3T2JqLmRlZmF1bHQ9b2JqLG5ld09ian0oX2NvbW1vbik7ZXhwb3J0cy5tdWw9bXVsdGlwbHksZXhwb3J0cy5zdWI9c3VidHJhY3R9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iail7aWYob2JqJiZvYmouX19lc01vZHVsZSlyZXR1cm4gb2JqO3ZhciBuZXdPYmo9e307aWYobnVsbCE9b2JqKWZvcih2YXIga2V5IGluIG9iailPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLGtleSkmJihuZXdPYmpba2V5XT1vYmpba2V5XSk7cmV0dXJuIG5ld09iai5kZWZhdWx0PW9iaixuZXdPYmp9ZnVuY3Rpb24gY3JlYXRlKCl7dmFyIG91dD1uZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtyZXR1cm4gb3V0WzBdPTAsb3V0WzFdPTAsb3V0WzJdPTAsb3V0WzNdPTEsb3V0fWZ1bmN0aW9uIGlkZW50aXR5KG91dCl7cmV0dXJuIG91dFswXT0wLG91dFsxXT0wLG91dFsyXT0wLG91dFszXT0xLG91dH1mdW5jdGlvbiBzZXRBeGlzQW5nbGUob3V0LGF4aXMscmFkKXtyYWQqPS41O3ZhciBzPU1hdGguc2luKHJhZCk7cmV0dXJuIG91dFswXT1zKmF4aXNbMF0sb3V0WzFdPXMqYXhpc1sxXSxvdXRbMl09cypheGlzWzJdLG91dFszXT1NYXRoLmNvcyhyYWQpLG91dH1mdW5jdGlvbiBnZXRBeGlzQW5nbGUob3V0X2F4aXMscSl7dmFyIHJhZD0yKk1hdGguYWNvcyhxWzNdKSxzPU1hdGguc2luKHJhZC8yKTtyZXR1cm4gMCE9cz8ob3V0X2F4aXNbMF09cVswXS9zLG91dF9heGlzWzFdPXFbMV0vcyxvdXRfYXhpc1syXT1xWzJdL3MpOihvdXRfYXhpc1swXT0xLG91dF9heGlzWzFdPTAsb3V0X2F4aXNbMl09MCkscmFkfWZ1bmN0aW9uIG11bHRpcGx5KG91dCxhLGIpe3ZhciBheD1hWzBdLGF5PWFbMV0sYXo9YVsyXSxhdz1hWzNdLGJ4PWJbMF0sYnk9YlsxXSxiej1iWzJdLGJ3PWJbM107cmV0dXJuIG91dFswXT1heCpidythdypieCtheSpiei1heipieSxvdXRbMV09YXkqYncrYXcqYnkrYXoqYngtYXgqYnosb3V0WzJdPWF6KmJ3K2F3KmJ6K2F4KmJ5LWF5KmJ4LG91dFszXT1hdypidy1heCpieC1heSpieS1heipieixvdXR9ZnVuY3Rpb24gcm90YXRlWChvdXQsYSxyYWQpe3JhZCo9LjU7dmFyIGF4PWFbMF0sYXk9YVsxXSxhej1hWzJdLGF3PWFbM10sYng9TWF0aC5zaW4ocmFkKSxidz1NYXRoLmNvcyhyYWQpO3JldHVybiBvdXRbMF09YXgqYncrYXcqYngsb3V0WzFdPWF5KmJ3K2F6KmJ4LG91dFsyXT1heipidy1heSpieCxvdXRbM109YXcqYnctYXgqYngsb3V0fWZ1bmN0aW9uIHJvdGF0ZVkob3V0LGEscmFkKXtyYWQqPS41O3ZhciBheD1hWzBdLGF5PWFbMV0sYXo9YVsyXSxhdz1hWzNdLGJ5PU1hdGguc2luKHJhZCksYnc9TWF0aC5jb3MocmFkKTtyZXR1cm4gb3V0WzBdPWF4KmJ3LWF6KmJ5LG91dFsxXT1heSpidythdypieSxvdXRbMl09YXoqYncrYXgqYnksb3V0WzNdPWF3KmJ3LWF5KmJ5LG91dH1mdW5jdGlvbiByb3RhdGVaKG91dCxhLHJhZCl7cmFkKj0uNTt2YXIgYXg9YVswXSxheT1hWzFdLGF6PWFbMl0sYXc9YVszXSxiej1NYXRoLnNpbihyYWQpLGJ3PU1hdGguY29zKHJhZCk7cmV0dXJuIG91dFswXT1heCpidytheSpieixvdXRbMV09YXkqYnctYXgqYnosb3V0WzJdPWF6KmJ3K2F3KmJ6LG91dFszXT1hdypidy1heipieixvdXR9ZnVuY3Rpb24gY2FsY3VsYXRlVyhvdXQsYSl7dmFyIHg9YVswXSx5PWFbMV0sej1hWzJdO3JldHVybiBvdXRbMF09eCxvdXRbMV09eSxvdXRbMl09eixvdXRbM109TWF0aC5zcXJ0KE1hdGguYWJzKDEteCp4LXkqeS16KnopKSxvdXR9ZnVuY3Rpb24gc2xlcnAob3V0LGEsYix0KXt2YXIgYXg9YVswXSxheT1hWzFdLGF6PWFbMl0sYXc9YVszXSxieD1iWzBdLGJ5PWJbMV0sYno9YlsyXSxidz1iWzNdLG9tZWdhPXZvaWQgMCxjb3NvbT12b2lkIDAsc2lub209dm9pZCAwLHNjYWxlMD12b2lkIDAsc2NhbGUxPXZvaWQgMDtyZXR1cm4gY29zb209YXgqYngrYXkqYnkrYXoqYnorYXcqYncsY29zb208MCYmKGNvc29tPS1jb3NvbSxieD0tYngsYnk9LWJ5LGJ6PS1ieixidz0tYncpLDEtY29zb20+MWUtNj8ob21lZ2E9TWF0aC5hY29zKGNvc29tKSxzaW5vbT1NYXRoLnNpbihvbWVnYSksc2NhbGUwPU1hdGguc2luKCgxLXQpKm9tZWdhKS9zaW5vbSxzY2FsZTE9TWF0aC5zaW4odCpvbWVnYSkvc2lub20pOihzY2FsZTA9MS10LHNjYWxlMT10KSxvdXRbMF09c2NhbGUwKmF4K3NjYWxlMSpieCxvdXRbMV09c2NhbGUwKmF5K3NjYWxlMSpieSxvdXRbMl09c2NhbGUwKmF6K3NjYWxlMSpieixvdXRbM109c2NhbGUwKmF3K3NjYWxlMSpidyxvdXR9ZnVuY3Rpb24gaW52ZXJ0KG91dCxhKXt2YXIgYTA9YVswXSxhMT1hWzFdLGEyPWFbMl0sYTM9YVszXSxkb3Q9YTAqYTArYTEqYTErYTIqYTIrYTMqYTMsaW52RG90PWRvdD8xL2RvdDowO3JldHVybiBvdXRbMF09LWEwKmludkRvdCxvdXRbMV09LWExKmludkRvdCxvdXRbMl09LWEyKmludkRvdCxvdXRbM109YTMqaW52RG90LG91dH1mdW5jdGlvbiBjb25qdWdhdGUob3V0LGEpe3JldHVybiBvdXRbMF09LWFbMF0sb3V0WzFdPS1hWzFdLG91dFsyXT0tYVsyXSxvdXRbM109YVszXSxvdXR9ZnVuY3Rpb24gZnJvbU1hdDMob3V0LG0pe3ZhciBmVHJhY2U9bVswXSttWzRdK21bOF0sZlJvb3Q9dm9pZCAwO2lmKGZUcmFjZT4wKWZSb290PU1hdGguc3FydChmVHJhY2UrMSksb3V0WzNdPS41KmZSb290LGZSb290PS41L2ZSb290LG91dFswXT0obVs1XS1tWzddKSpmUm9vdCxvdXRbMV09KG1bNl0tbVsyXSkqZlJvb3Qsb3V0WzJdPShtWzFdLW1bM10pKmZSb290O2Vsc2V7dmFyIGk9MDttWzRdPm1bMF0mJihpPTEpLG1bOF0+bVszKmkraV0mJihpPTIpO3ZhciBqPShpKzEpJTMsaz0oaSsyKSUzO2ZSb290PU1hdGguc3FydChtWzMqaStpXS1tWzMqaitqXS1tWzMqaytrXSsxKSxvdXRbaV09LjUqZlJvb3QsZlJvb3Q9LjUvZlJvb3Qsb3V0WzNdPShtWzMqaitrXS1tWzMqaytqXSkqZlJvb3Qsb3V0W2pdPShtWzMqaitpXSttWzMqaStqXSkqZlJvb3Qsb3V0W2tdPShtWzMqaytpXSttWzMqaStrXSkqZlJvb3R9cmV0dXJuIG91dH1mdW5jdGlvbiBmcm9tRXVsZXIob3V0LHgseSx6KXt2YXIgaGFsZlRvUmFkPS41Kk1hdGguUEkvMTgwO3gqPWhhbGZUb1JhZCx5Kj1oYWxmVG9SYWQseio9aGFsZlRvUmFkO3ZhciBzeD1NYXRoLnNpbih4KSxjeD1NYXRoLmNvcyh4KSxzeT1NYXRoLnNpbih5KSxjeT1NYXRoLmNvcyh5KSxzej1NYXRoLnNpbih6KSxjej1NYXRoLmNvcyh6KTtyZXR1cm4gb3V0WzBdPXN4KmN5KmN6LWN4KnN5KnN6LG91dFsxXT1jeCpzeSpjeitzeCpjeSpzeixvdXRbMl09Y3gqY3kqc3otc3gqc3kqY3osb3V0WzNdPWN4KmN5KmN6K3N4KnN5KnN6LG91dH1mdW5jdGlvbiBzdHIoYSl7cmV0dXJuXCJxdWF0KFwiK2FbMF0rXCIsIFwiK2FbMV0rXCIsIFwiK2FbMl0rXCIsIFwiK2FbM10rXCIpXCJ9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZXhwb3J0cy5zZXRBeGVzPWV4cG9ydHMuc3FsZXJwPWV4cG9ydHMucm90YXRpb25Ubz1leHBvcnRzLmVxdWFscz1leHBvcnRzLmV4YWN0RXF1YWxzPWV4cG9ydHMubm9ybWFsaXplPWV4cG9ydHMuc3FyTGVuPWV4cG9ydHMuc3F1YXJlZExlbmd0aD1leHBvcnRzLmxlbj1leHBvcnRzLmxlbmd0aD1leHBvcnRzLmxlcnA9ZXhwb3J0cy5kb3Q9ZXhwb3J0cy5zY2FsZT1leHBvcnRzLm11bD1leHBvcnRzLmFkZD1leHBvcnRzLnNldD1leHBvcnRzLmNvcHk9ZXhwb3J0cy5mcm9tVmFsdWVzPWV4cG9ydHMuY2xvbmU9dm9pZCAwLGV4cG9ydHMuY3JlYXRlPWNyZWF0ZSxleHBvcnRzLmlkZW50aXR5PWlkZW50aXR5LGV4cG9ydHMuc2V0QXhpc0FuZ2xlPXNldEF4aXNBbmdsZSxleHBvcnRzLmdldEF4aXNBbmdsZT1nZXRBeGlzQW5nbGUsZXhwb3J0cy5tdWx0aXBseT1tdWx0aXBseSxleHBvcnRzLnJvdGF0ZVg9cm90YXRlWCxleHBvcnRzLnJvdGF0ZVk9cm90YXRlWSxleHBvcnRzLnJvdGF0ZVo9cm90YXRlWixleHBvcnRzLmNhbGN1bGF0ZVc9Y2FsY3VsYXRlVyxleHBvcnRzLnNsZXJwPXNsZXJwLGV4cG9ydHMuaW52ZXJ0PWludmVydCxleHBvcnRzLmNvbmp1Z2F0ZT1jb25qdWdhdGUsZXhwb3J0cy5mcm9tTWF0Mz1mcm9tTWF0MyxleHBvcnRzLmZyb21FdWxlcj1mcm9tRXVsZXIsZXhwb3J0cy5zdHI9c3RyO3ZhciBfY29tbW9uPV9fd2VicGFja19yZXF1aXJlX18oMyksZ2xNYXRyaXg9X2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvbW1vbiksX21hdD1fX3dlYnBhY2tfcmVxdWlyZV9fKDIwKSxtYXQzPV9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9tYXQpLF92ZWM9X193ZWJwYWNrX3JlcXVpcmVfXygyMSksdmVjMz1faW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdmVjKSxfdmVjMj1fX3dlYnBhY2tfcmVxdWlyZV9fKDIyKSx2ZWM0PV9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF92ZWMyKSxsZW5ndGg9KGV4cG9ydHMuY2xvbmU9dmVjNC5jbG9uZSxleHBvcnRzLmZyb21WYWx1ZXM9dmVjNC5mcm9tVmFsdWVzLGV4cG9ydHMuY29weT12ZWM0LmNvcHksZXhwb3J0cy5zZXQ9dmVjNC5zZXQsZXhwb3J0cy5hZGQ9dmVjNC5hZGQsZXhwb3J0cy5tdWw9bXVsdGlwbHksZXhwb3J0cy5zY2FsZT12ZWM0LnNjYWxlLGV4cG9ydHMuZG90PXZlYzQuZG90LGV4cG9ydHMubGVycD12ZWM0LmxlcnAsZXhwb3J0cy5sZW5ndGg9dmVjNC5sZW5ndGgpLHNxdWFyZWRMZW5ndGg9KGV4cG9ydHMubGVuPWxlbmd0aCxleHBvcnRzLnNxdWFyZWRMZW5ndGg9dmVjNC5zcXVhcmVkTGVuZ3RoKSxub3JtYWxpemU9KGV4cG9ydHMuc3FyTGVuPXNxdWFyZWRMZW5ndGgsZXhwb3J0cy5ub3JtYWxpemU9dmVjNC5ub3JtYWxpemUpO2V4cG9ydHMuZXhhY3RFcXVhbHM9dmVjNC5leGFjdEVxdWFscyxleHBvcnRzLmVxdWFscz12ZWM0LmVxdWFscyxleHBvcnRzLnJvdGF0aW9uVG89ZnVuY3Rpb24oKXt2YXIgdG1wdmVjMz12ZWMzLmNyZWF0ZSgpLHhVbml0VmVjMz12ZWMzLmZyb21WYWx1ZXMoMSwwLDApLHlVbml0VmVjMz12ZWMzLmZyb21WYWx1ZXMoMCwxLDApO3JldHVybiBmdW5jdGlvbihvdXQsYSxiKXt2YXIgZG90PXZlYzMuZG90KGEsYik7cmV0dXJuIGRvdDwtLjk5OTk5OT8odmVjMy5jcm9zcyh0bXB2ZWMzLHhVbml0VmVjMyxhKSx2ZWMzLmxlbih0bXB2ZWMzKTwxZS02JiZ2ZWMzLmNyb3NzKHRtcHZlYzMseVVuaXRWZWMzLGEpLHZlYzMubm9ybWFsaXplKHRtcHZlYzMsdG1wdmVjMyksc2V0QXhpc0FuZ2xlKG91dCx0bXB2ZWMzLE1hdGguUEkpLG91dCk6ZG90Pi45OTk5OTk/KG91dFswXT0wLG91dFsxXT0wLG91dFsyXT0wLG91dFszXT0xLG91dCk6KHZlYzMuY3Jvc3ModG1wdmVjMyxhLGIpLG91dFswXT10bXB2ZWMzWzBdLG91dFsxXT10bXB2ZWMzWzFdLG91dFsyXT10bXB2ZWMzWzJdLG91dFszXT0xK2RvdCxub3JtYWxpemUob3V0LG91dCkpfX0oKSxleHBvcnRzLnNxbGVycD1mdW5jdGlvbigpe3ZhciB0ZW1wMT1jcmVhdGUoKSx0ZW1wMj1jcmVhdGUoKTtyZXR1cm4gZnVuY3Rpb24ob3V0LGEsYixjLGQsdCl7cmV0dXJuIHNsZXJwKHRlbXAxLGEsZCx0KSxzbGVycCh0ZW1wMixiLGMsdCksc2xlcnAob3V0LHRlbXAxLHRlbXAyLDIqdCooMS10KSksb3V0fX0oKSxleHBvcnRzLnNldEF4ZXM9ZnVuY3Rpb24oKXt2YXIgbWF0cj1tYXQzLmNyZWF0ZSgpO3JldHVybiBmdW5jdGlvbihvdXQsdmlldyxyaWdodCx1cCl7cmV0dXJuIG1hdHJbMF09cmlnaHRbMF0sbWF0clszXT1yaWdodFsxXSxtYXRyWzZdPXJpZ2h0WzJdLG1hdHJbMV09dXBbMF0sbWF0cls0XT11cFsxXSxtYXRyWzddPXVwWzJdLG1hdHJbMl09LXZpZXdbMF0sbWF0cls1XT0tdmlld1sxXSxtYXRyWzhdPS12aWV3WzJdLG5vcm1hbGl6ZShvdXQsZnJvbU1hdDMob3V0LG1hdHIpKX19KCl9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGNyZWF0ZSgpe3ZhciBvdXQ9bmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7cmV0dXJuIG91dFswXT0wLG91dFsxXT0wLG91dH1mdW5jdGlvbiBjbG9uZShhKXt2YXIgb3V0PW5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO3JldHVybiBvdXRbMF09YVswXSxvdXRbMV09YVsxXSxvdXR9ZnVuY3Rpb24gZnJvbVZhbHVlcyh4LHkpe3ZhciBvdXQ9bmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7cmV0dXJuIG91dFswXT14LG91dFsxXT15LG91dH1mdW5jdGlvbiBjb3B5KG91dCxhKXtyZXR1cm4gb3V0WzBdPWFbMF0sb3V0WzFdPWFbMV0sb3V0fWZ1bmN0aW9uIHNldChvdXQseCx5KXtyZXR1cm4gb3V0WzBdPXgsb3V0WzFdPXksb3V0fWZ1bmN0aW9uIGFkZChvdXQsYSxiKXtyZXR1cm4gb3V0WzBdPWFbMF0rYlswXSxvdXRbMV09YVsxXStiWzFdLG91dH1mdW5jdGlvbiBzdWJ0cmFjdChvdXQsYSxiKXtyZXR1cm4gb3V0WzBdPWFbMF0tYlswXSxvdXRbMV09YVsxXS1iWzFdLG91dH1mdW5jdGlvbiBtdWx0aXBseShvdXQsYSxiKXtyZXR1cm4gb3V0WzBdPWFbMF0qYlswXSxvdXRbMV09YVsxXSpiWzFdLG91dH1mdW5jdGlvbiBkaXZpZGUob3V0LGEsYil7cmV0dXJuIG91dFswXT1hWzBdL2JbMF0sb3V0WzFdPWFbMV0vYlsxXSxvdXR9ZnVuY3Rpb24gY2VpbChvdXQsYSl7cmV0dXJuIG91dFswXT1NYXRoLmNlaWwoYVswXSksb3V0WzFdPU1hdGguY2VpbChhWzFdKSxvdXR9ZnVuY3Rpb24gZmxvb3Iob3V0LGEpe3JldHVybiBvdXRbMF09TWF0aC5mbG9vcihhWzBdKSxvdXRbMV09TWF0aC5mbG9vcihhWzFdKSxvdXR9ZnVuY3Rpb24gbWluKG91dCxhLGIpe3JldHVybiBvdXRbMF09TWF0aC5taW4oYVswXSxiWzBdKSxvdXRbMV09TWF0aC5taW4oYVsxXSxiWzFdKSxvdXR9ZnVuY3Rpb24gbWF4KG91dCxhLGIpe3JldHVybiBvdXRbMF09TWF0aC5tYXgoYVswXSxiWzBdKSxvdXRbMV09TWF0aC5tYXgoYVsxXSxiWzFdKSxvdXR9ZnVuY3Rpb24gcm91bmQob3V0LGEpe3JldHVybiBvdXRbMF09TWF0aC5yb3VuZChhWzBdKSxvdXRbMV09TWF0aC5yb3VuZChhWzFdKSxvdXR9ZnVuY3Rpb24gc2NhbGUob3V0LGEsYil7cmV0dXJuIG91dFswXT1hWzBdKmIsb3V0WzFdPWFbMV0qYixvdXR9ZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LGEsYixzY2FsZSl7cmV0dXJuIG91dFswXT1hWzBdK2JbMF0qc2NhbGUsb3V0WzFdPWFbMV0rYlsxXSpzY2FsZSxvdXR9ZnVuY3Rpb24gZGlzdGFuY2UoYSxiKXt2YXIgeD1iWzBdLWFbMF0seT1iWzFdLWFbMV07cmV0dXJuIE1hdGguc3FydCh4KngreSp5KX1mdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSxiKXt2YXIgeD1iWzBdLWFbMF0seT1iWzFdLWFbMV07cmV0dXJuIHgqeCt5Knl9ZnVuY3Rpb24gbGVuZ3RoKGEpe3ZhciB4PWFbMF0seT1hWzFdO3JldHVybiBNYXRoLnNxcnQoeCp4K3kqeSl9ZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKXt2YXIgeD1hWzBdLHk9YVsxXTtyZXR1cm4geCp4K3kqeX1mdW5jdGlvbiBuZWdhdGUob3V0LGEpe3JldHVybiBvdXRbMF09LWFbMF0sb3V0WzFdPS1hWzFdLG91dH1mdW5jdGlvbiBpbnZlcnNlKG91dCxhKXtyZXR1cm4gb3V0WzBdPTEvYVswXSxvdXRbMV09MS9hWzFdLG91dH1mdW5jdGlvbiBub3JtYWxpemUob3V0LGEpe3ZhciB4PWFbMF0seT1hWzFdLGxlbj14KngreSp5O3JldHVybiBsZW4+MCYmKGxlbj0xL01hdGguc3FydChsZW4pLG91dFswXT1hWzBdKmxlbixvdXRbMV09YVsxXSpsZW4pLG91dH1mdW5jdGlvbiBkb3QoYSxiKXtyZXR1cm4gYVswXSpiWzBdK2FbMV0qYlsxXX1mdW5jdGlvbiBjcm9zcyhvdXQsYSxiKXt2YXIgej1hWzBdKmJbMV0tYVsxXSpiWzBdO3JldHVybiBvdXRbMF09b3V0WzFdPTAsb3V0WzJdPXosb3V0fWZ1bmN0aW9uIGxlcnAob3V0LGEsYix0KXt2YXIgYXg9YVswXSxheT1hWzFdO3JldHVybiBvdXRbMF09YXgrdCooYlswXS1heCksb3V0WzFdPWF5K3QqKGJbMV0tYXkpLG91dH1mdW5jdGlvbiByYW5kb20ob3V0LHNjYWxlKXtzY2FsZT1zY2FsZXx8MTt2YXIgcj0yKmdsTWF0cml4LlJBTkRPTSgpKk1hdGguUEk7cmV0dXJuIG91dFswXT1NYXRoLmNvcyhyKSpzY2FsZSxvdXRbMV09TWF0aC5zaW4ocikqc2NhbGUsb3V0fWZ1bmN0aW9uIHRyYW5zZm9ybU1hdDIob3V0LGEsbSl7dmFyIHg9YVswXSx5PWFbMV07cmV0dXJuIG91dFswXT1tWzBdKngrbVsyXSp5LG91dFsxXT1tWzFdKngrbVszXSp5LG91dH1mdW5jdGlvbiB0cmFuc2Zvcm1NYXQyZChvdXQsYSxtKXt2YXIgeD1hWzBdLHk9YVsxXTtyZXR1cm4gb3V0WzBdPW1bMF0qeCttWzJdKnkrbVs0XSxvdXRbMV09bVsxXSp4K21bM10qeSttWzVdLG91dH1mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCxhLG0pe3ZhciB4PWFbMF0seT1hWzFdO3JldHVybiBvdXRbMF09bVswXSp4K21bM10qeSttWzZdLG91dFsxXT1tWzFdKngrbVs0XSp5K21bN10sb3V0fWZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LGEsbSl7dmFyIHg9YVswXSx5PWFbMV07cmV0dXJuIG91dFswXT1tWzBdKngrbVs0XSp5K21bMTJdLG91dFsxXT1tWzFdKngrbVs1XSp5K21bMTNdLG91dH1mdW5jdGlvbiBzdHIoYSl7cmV0dXJuXCJ2ZWMyKFwiK2FbMF0rXCIsIFwiK2FbMV0rXCIpXCJ9ZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSxiKXtyZXR1cm4gYVswXT09PWJbMF0mJmFbMV09PT1iWzFdfWZ1bmN0aW9uIGVxdWFscyhhLGIpe3ZhciBhMD1hWzBdLGExPWFbMV0sYjA9YlswXSxiMT1iWzFdO3JldHVybiBNYXRoLmFicyhhMC1iMCk8PWdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhhMCksTWF0aC5hYnMoYjApKSYmTWF0aC5hYnMoYTEtYjEpPD1nbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYTEpLE1hdGguYWJzKGIxKSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZXhwb3J0cy5mb3JFYWNoPWV4cG9ydHMuc3FyTGVuPWV4cG9ydHMuc3FyRGlzdD1leHBvcnRzLmRpc3Q9ZXhwb3J0cy5kaXY9ZXhwb3J0cy5tdWw9ZXhwb3J0cy5zdWI9ZXhwb3J0cy5sZW49dm9pZCAwLGV4cG9ydHMuY3JlYXRlPWNyZWF0ZSxleHBvcnRzLmNsb25lPWNsb25lLGV4cG9ydHMuZnJvbVZhbHVlcz1mcm9tVmFsdWVzLGV4cG9ydHMuY29weT1jb3B5LGV4cG9ydHMuc2V0PXNldCxleHBvcnRzLmFkZD1hZGQsZXhwb3J0cy5zdWJ0cmFjdD1zdWJ0cmFjdCxleHBvcnRzLm11bHRpcGx5PW11bHRpcGx5LGV4cG9ydHMuZGl2aWRlPWRpdmlkZSxleHBvcnRzLmNlaWw9Y2VpbCxleHBvcnRzLmZsb29yPWZsb29yLGV4cG9ydHMubWluPW1pbixleHBvcnRzLm1heD1tYXgsZXhwb3J0cy5yb3VuZD1yb3VuZCxleHBvcnRzLnNjYWxlPXNjYWxlLGV4cG9ydHMuc2NhbGVBbmRBZGQ9c2NhbGVBbmRBZGQsZXhwb3J0cy5kaXN0YW5jZT1kaXN0YW5jZSxleHBvcnRzLnNxdWFyZWREaXN0YW5jZT1zcXVhcmVkRGlzdGFuY2UsZXhwb3J0cy5sZW5ndGg9bGVuZ3RoLGV4cG9ydHMuc3F1YXJlZExlbmd0aD1zcXVhcmVkTGVuZ3RoLGV4cG9ydHMubmVnYXRlPW5lZ2F0ZSxleHBvcnRzLmludmVyc2U9aW52ZXJzZSxleHBvcnRzLm5vcm1hbGl6ZT1ub3JtYWxpemUsZXhwb3J0cy5kb3Q9ZG90LGV4cG9ydHMuY3Jvc3M9Y3Jvc3MsZXhwb3J0cy5sZXJwPWxlcnAsZXhwb3J0cy5yYW5kb209cmFuZG9tLGV4cG9ydHMudHJhbnNmb3JtTWF0Mj10cmFuc2Zvcm1NYXQyLGV4cG9ydHMudHJhbnNmb3JtTWF0MmQ9dHJhbnNmb3JtTWF0MmQsZXhwb3J0cy50cmFuc2Zvcm1NYXQzPXRyYW5zZm9ybU1hdDMsZXhwb3J0cy50cmFuc2Zvcm1NYXQ0PXRyYW5zZm9ybU1hdDQsZXhwb3J0cy5zdHI9c3RyLGV4cG9ydHMuZXhhY3RFcXVhbHM9ZXhhY3RFcXVhbHMsZXhwb3J0cy5lcXVhbHM9ZXF1YWxzO3ZhciBfY29tbW9uPV9fd2VicGFja19yZXF1aXJlX18oMyksZ2xNYXRyaXg9ZnVuY3Rpb24ob2JqKXtpZihvYmomJm9iai5fX2VzTW9kdWxlKXJldHVybiBvYmo7dmFyIG5ld09iaj17fTtpZihudWxsIT1vYmopZm9yKHZhciBrZXkgaW4gb2JqKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosa2V5KSYmKG5ld09ialtrZXldPW9ialtrZXldKTtyZXR1cm4gbmV3T2JqLmRlZmF1bHQ9b2JqLG5ld09ian0oX2NvbW1vbik7ZXhwb3J0cy5sZW49bGVuZ3RoLGV4cG9ydHMuc3ViPXN1YnRyYWN0LGV4cG9ydHMubXVsPW11bHRpcGx5LGV4cG9ydHMuZGl2PWRpdmlkZSxleHBvcnRzLmRpc3Q9ZGlzdGFuY2UsZXhwb3J0cy5zcXJEaXN0PXNxdWFyZWREaXN0YW5jZSxleHBvcnRzLnNxckxlbj1zcXVhcmVkTGVuZ3RoLGV4cG9ydHMuZm9yRWFjaD1mdW5jdGlvbigpe3ZhciB2ZWM9Y3JlYXRlKCk7cmV0dXJuIGZ1bmN0aW9uKGEsc3RyaWRlLG9mZnNldCxjb3VudCxmbixhcmcpe3ZhciBpPXZvaWQgMCxsPXZvaWQgMDtmb3Ioc3RyaWRlfHwoc3RyaWRlPTIpLG9mZnNldHx8KG9mZnNldD0wKSxsPWNvdW50P01hdGgubWluKGNvdW50KnN0cmlkZStvZmZzZXQsYS5sZW5ndGgpOmEubGVuZ3RoLGk9b2Zmc2V0O2k8bDtpKz1zdHJpZGUpdmVjWzBdPWFbaV0sdmVjWzFdPWFbaSsxXSxmbih2ZWMsdmVjLGFyZyksYVtpXT12ZWNbMF0sYVtpKzFdPXZlY1sxXTtyZXR1cm4gYX19KCl9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGdldEFuZEFwcGx5RXh0ZW5zaW9uKGdsLG5hbWUpe3ZhciBleHQ9Z2wuZ2V0RXh0ZW5zaW9uKG5hbWUpO2lmKCFleHQpcmV0dXJuITE7dmFyIHN1ZmZpeD1uYW1lLnNwbGl0KFwiX1wiKVswXSxzdWZmaXhSRT1uZXcgUmVnRXhwKHN1ZmZpeCtcIiRcIik7Zm9yKHZhciBrZXkgaW4gZXh0KXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBleHRba2V5XSl7dmFyIHVuc3VmZml4ZWRLZXk9a2V5LnJlcGxhY2Uoc3VmZml4UkUsXCJcIik7a2V5LnN1YnN0cmluZyYmKGdsW3Vuc3VmZml4ZWRLZXldPWV4dFtrZXldLmJpbmQoZXh0KSl9fXJldHVybiEwfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGV4cG9ydHMuZGVmYXVsdD1nZXRBbmRBcHBseUV4dGVuc2lvbn0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7ZGVmYXVsdDpvYmp9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBfR0xUb29sPV9fd2VicGFja19yZXF1aXJlX18oMCksX0dMVG9vbDI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR0xUb29sKSxfV2ViZ2xDb25zdD1fX3dlYnBhY2tfcmVxdWlyZV9fKDIzKSxfV2ViZ2xDb25zdDI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfV2ViZ2xDb25zdCksZXhwb3NlQXR0cmlidXRlcz1mdW5jdGlvbigpe2Zvcih2YXIgcyBpbiBfV2ViZ2xDb25zdDIuZGVmYXVsdClfR0xUb29sMi5kZWZhdWx0W3NdP2NvbnNvbGUubG9nKFwiYWxyZWFkeSBleGlzdCA6IFwiLHMpOl9HTFRvb2wyLmRlZmF1bHRbc109X1dlYmdsQ29uc3QyLmRlZmF1bHRbc119O2V4cG9ydHMuZGVmYXVsdD1leHBvc2VBdHRyaWJ1dGVzfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBjaGVja0Zsb2F0KCl7cmV0dXJuIF9HTFRvb2wyLmRlZmF1bHQud2ViZ2wyP19HTFRvb2wyLmRlZmF1bHQuZ2wuRkxPQVQ6X0dMVG9vbDIuZGVmYXVsdC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdFwiKT9fR0xUb29sMi5kZWZhdWx0LmdsLkZMT0FUOihjb25zb2xlLndhcm4oXCJVU0lORyBGTE9BVCBCVVQgT0VTX3RleHR1cmVfZmxvYXQgTk9UIFNVUFBPUlRFRFwiKSxfR0xUb29sMi5kZWZhdWx0LmdsLlVOU0lHTkVEX0JZVEUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGV4cG9ydHMuZGVmYXVsdD1mdW5jdGlvbigpe3JldHVybiBoYXNDaGVja2VkfHwoX2Zsb2F0PWNoZWNrRmxvYXQoKSksX2Zsb2F0fTt2YXIgX0dMVG9vbD1fX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9HTFRvb2wyPWZ1bmN0aW9uKG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntkZWZhdWx0Om9ian19KF9HTFRvb2wpLGhhc0NoZWNrZWQ9ITEsX2Zsb2F0PXZvaWQgMH0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gY2hlY2tIYWxmRmxvYXQoKXtpZihfR0xUb29sMi5kZWZhdWx0LndlYmdsMilyZXR1cm4gX0dMVG9vbDIuZGVmYXVsdC5nbC5IQUxGX0ZMT0FUO3ZhciBleHRIYWxmRmxvYXQ9X0dMVG9vbDIuZGVmYXVsdC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpO3JldHVybiBleHRIYWxmRmxvYXQ/ZXh0SGFsZkZsb2F0LkhBTEZfRkxPQVRfT0VTOihjb25zb2xlLndhcm4oXCJVU0lORyBIQUxGIEZMT0FUIEJVVCBPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0IE5PVCBTVVBQT1JURURcIiksX0dMVG9vbDIuZGVmYXVsdC5nbC5VTlNJR05FRF9CWVRFKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxleHBvcnRzLmRlZmF1bHQ9ZnVuY3Rpb24oKXtyZXR1cm4gaGFzQ2hlY2tlZHx8KGhhbGZGbG9hdD1jaGVja0hhbGZGbG9hdCgpKSxoYWxmRmxvYXR9O3ZhciBfR0xUb29sPV9fd2VicGFja19yZXF1aXJlX18oMCksX0dMVG9vbDI9ZnVuY3Rpb24ob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX0oX0dMVG9vbCksaGFzQ2hlY2tlZD0hMSxoYWxmRmxvYXQ9dm9pZCAwfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxleHBvcnRzLmRlZmF1bHQ9W1wiRVhUX3NoYWRlcl90ZXh0dXJlX2xvZFwiLFwiRVhUX3NSR0JcIixcIkVYVF9mcmFnX2RlcHRoXCIsXCJPRVNfdGV4dHVyZV9mbG9hdFwiLFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiLFwiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXCIsXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhclwiLFwiT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXCIsXCJXRUJHTF9kZXB0aF90ZXh0dXJlXCIsXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIixcIk9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XCIsXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIsXCJXRUJHTF9kcmF3X2J1ZmZlcnNcIl19LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKHN0cmluZ3Mpe1wic3RyaW5nXCI9PXR5cGVvZiBzdHJpbmdzJiYoc3RyaW5ncz1bc3RyaW5nc10pO2Zvcih2YXIgZXhwcnM9W10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSkscGFydHM9W10saT0wO2k8c3RyaW5ncy5sZW5ndGgtMTtpKyspcGFydHMucHVzaChzdHJpbmdzW2ldLGV4cHJzW2ldfHxcIlwiKTtyZXR1cm4gcGFydHMucHVzaChzdHJpbmdzW2ldKSxwYXJ0cy5qb2luKFwiXCIpfX0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPVwiLy8gYmFzaWMuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgQkFTSUNfRlJBR01FTlRcXG5cXG5wcmVjaXNpb24gbG93cCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gZmxvYXQgdGltZTtcXG4vLyB1bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodlRleHR1cmVDb29yZCwgc2luKHRpbWUpICogLjUgKyAuNSwgMS4wKTtcXG59XCJ9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGlzUG93ZXJPZlR3byh4KXtyZXR1cm4gMCE9PXgmJiEoeCZ4LTEpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBfR0xUb29sPV9fd2VicGFja19yZXF1aXJlX18oMCksX0dMVG9vbDI9ZnVuY3Rpb24ob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX0oX0dMVG9vbCksZ2V0VGV4dHVyZVBhcmFtZXRlcnM9ZnVuY3Rpb24obVBhcmFtcyxtU291cmNlLG1XaWR0aCxtSGVpZ2h0KXtpZighbVBhcmFtcy5taW5GaWx0ZXIpe3ZhciBtaW5GaWx0ZXI9X0dMVG9vbDIuZGVmYXVsdC5MSU5FQVI7bVdpZHRoJiZtV2lkdGgmJmlzUG93ZXJPZlR3byhtV2lkdGgpJiZpc1Bvd2VyT2ZUd28obUhlaWdodCkmJihtaW5GaWx0ZXI9X0dMVG9vbDIuZGVmYXVsdC5ORUFSRVNUX01JUE1BUF9MSU5FQVIpLG1QYXJhbXMubWluRmlsdGVyPW1pbkZpbHRlcn1yZXR1cm4gbVBhcmFtcy5taXBtYXA9bVBhcmFtcy5taXBtYXB8fCEwLG1QYXJhbXMubWFnRmlsdGVyPW1QYXJhbXMubWFnRmlsdGVyfHxfR0xUb29sMi5kZWZhdWx0LkxJTkVBUixtUGFyYW1zLndyYXBTPW1QYXJhbXMud3JhcFN8fF9HTFRvb2wyLmRlZmF1bHQuQ0xBTVBfVE9fRURHRSxtUGFyYW1zLndyYXBUPW1QYXJhbXMud3JhcFR8fF9HTFRvb2wyLmRlZmF1bHQuQ0xBTVBfVE9fRURHRSxtUGFyYW1zLmludGVybmFsRm9ybWF0PW1QYXJhbXMuaW50ZXJuYWxGb3JtYXR8fF9HTFRvb2wyLmRlZmF1bHQuUkdCQSxtUGFyYW1zLmZvcm1hdD1tUGFyYW1zLmZvcm1hdHx8X0dMVG9vbDIuZGVmYXVsdC5SR0JBLG1QYXJhbXMucHJlbXVsdGlwbHlBbHBoYT1tUGFyYW1zLnByZW11bHRpcGx5QWxwaGF8fCExLG1QYXJhbXMubGV2ZWw9bVBhcmFtcy5sZXZlbHx8MCxtUGFyYW1zLmFuaXNvdHJvcHk9bVBhcmFtcy5hbmlzb3Ryb3B5fHwwLG1QYXJhbXN9O2V4cG9ydHMuZGVmYXVsdD1nZXRUZXh0dXJlUGFyYW1ldGVyc30sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGFycmF5QnVmZmVyKXt2YXIgaGVhZGVyPW5ldyBJbnQzMkFycmF5KGFycmF5QnVmZmVyLDAsaGVhZGVyTGVuZ3RoSW50KTtpZihoZWFkZXJbb2ZmX21hZ2ljXSE9PUREU19NQUdJQyl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1hZ2ljIG51bWJlciBpbiBERFMgaGVhZGVyXCIpO2lmKCFoZWFkZXJbb2ZmX3BmRmxhZ3NdJkREUEZfRk9VUkNDKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGZvcm1hdCwgbXVzdCBjb250YWluIGEgRm91ckNDIGNvZGVcIik7dmFyIGJsb2NrQnl0ZXMsZm9ybWF0LGZvdXJDQz1oZWFkZXJbb2ZmX3BmRm91ckNDXTtzd2l0Y2goZm91ckNDKXtjYXNlIEZPVVJDQ19EWFQxOmJsb2NrQnl0ZXM9OCxmb3JtYXQ9XCJkeHQxXCI7YnJlYWs7Y2FzZSBGT1VSQ0NfRFhUMzpibG9ja0J5dGVzPTE2LGZvcm1hdD1cImR4dDNcIjticmVhaztjYXNlIEZPVVJDQ19EWFQ1OmJsb2NrQnl0ZXM9MTYsZm9ybWF0PVwiZHh0NVwiO2JyZWFrO2Nhc2UgRk9VUkNDX0ZQMzJGOmZvcm1hdD1cInJnYmEzMmZcIjticmVhaztjYXNlIEZPVVJDQ19EWDEwOnZhciBkeDEwSGVhZGVyPW5ldyBVaW50MzJBcnJheShhcnJheUJ1ZmZlci5zbGljZSgxMjgsMTQ4KSk7Zm9ybWF0PWR4MTBIZWFkZXJbMF07dmFyIHJlc291cmNlRGltZW5zaW9uPWR4MTBIZWFkZXJbMV07ZHgxMEhlYWRlclsyXSxkeDEwSGVhZGVyWzNdLGR4MTBIZWFkZXJbNF07aWYocmVzb3VyY2VEaW1lbnNpb24hPT1EM0QxMF9SRVNPVVJDRV9ESU1FTlNJT05fVEVYVFVSRTJEfHxmb3JtYXQhPT1EWEdJX0ZPUk1BVF9SMzJHMzJCMzJBMzJfRkxPQVQpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgRFgxMCB0ZXh0dXJlIGZvcm1hdCBcIitmb3JtYXQpO2Zvcm1hdD1cInJnYmEzMmZcIjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIEZvdXJDQyBjb2RlOiBcIitpbnQzMlRvRm91ckNDKGZvdXJDQykpfXZhciBmbGFncz1oZWFkZXJbb2ZmX2ZsYWdzXSxtaXBtYXBDb3VudD0xO2ZsYWdzJkREU0RfTUlQTUFQQ09VTlQmJihtaXBtYXBDb3VudD1NYXRoLm1heCgxLGhlYWRlcltvZmZfbWlwbWFwQ291bnRdKSk7dmFyIGN1YmVtYXA9ITE7aGVhZGVyW29mZl9jYXBzMl0mRERTQ0FQUzJfQ1VCRU1BUCYmKGN1YmVtYXA9ITApO3ZhciBkYXRhTGVuZ3RoLHdpZHRoPWhlYWRlcltvZmZfd2lkdGhdLGhlaWdodD1oZWFkZXJbb2ZmX2hlaWdodF0sZGF0YU9mZnNldD1oZWFkZXJbb2ZmX3NpemVdKzQsdGV4V2lkdGg9d2lkdGgsdGV4SGVpZ2h0PWhlaWdodCxpbWFnZXM9W107aWYoZm91ckNDPT09Rk9VUkNDX0RYMTAmJihkYXRhT2Zmc2V0Kz0yMCksY3ViZW1hcClmb3IodmFyIGY9MDtmPDY7ZisrKXtpZihcInJnYmEzMmZcIiE9PWZvcm1hdCl0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IFJHQkEzMmYgY3ViZW1hcHMgYXJlIHN1cHBvcnRlZFwiKTt3aWR0aD10ZXhXaWR0aCxoZWlnaHQ9dGV4SGVpZ2h0O2Zvcih2YXIgcmVxdWlyZWRNaXBMZXZlbHM9TWF0aC5sb2cod2lkdGgpL01hdGgubG9nKDIpKzEsaT0wO2k8cmVxdWlyZWRNaXBMZXZlbHM7aSsrKWRhdGFMZW5ndGg9d2lkdGgqaGVpZ2h0KjE2LGltYWdlcy5wdXNoKHtvZmZzZXQ6ZGF0YU9mZnNldCxsZW5ndGg6ZGF0YUxlbmd0aCxzaGFwZTpbd2lkdGgsaGVpZ2h0XX0pLGk8bWlwbWFwQ291bnQmJihkYXRhT2Zmc2V0Kz1kYXRhTGVuZ3RoKSx3aWR0aD1NYXRoLmZsb29yKHdpZHRoLzIpLGhlaWdodD1NYXRoLmZsb29yKGhlaWdodC8yKX1lbHNlIGZvcih2YXIgaT0wO2k8bWlwbWFwQ291bnQ7aSsrKWRhdGFMZW5ndGg9TWF0aC5tYXgoNCx3aWR0aCkvNCpNYXRoLm1heCg0LGhlaWdodCkvNCpibG9ja0J5dGVzLGltYWdlcy5wdXNoKHtvZmZzZXQ6ZGF0YU9mZnNldCxsZW5ndGg6ZGF0YUxlbmd0aCxzaGFwZTpbd2lkdGgsaGVpZ2h0XX0pLGRhdGFPZmZzZXQrPWRhdGFMZW5ndGgsd2lkdGg9TWF0aC5mbG9vcih3aWR0aC8yKSxoZWlnaHQ9TWF0aC5mbG9vcihoZWlnaHQvMik7cmV0dXJue3NoYXBlOlt0ZXhXaWR0aCx0ZXhIZWlnaHRdLGltYWdlczppbWFnZXMsZm9ybWF0OmZvcm1hdCxmbGFnczpmbGFncyxjdWJlbWFwOmN1YmVtYXB9fWZ1bmN0aW9uIGZvdXJDQ1RvSW50MzIodmFsdWUpe3JldHVybiB2YWx1ZS5jaGFyQ29kZUF0KDApKyh2YWx1ZS5jaGFyQ29kZUF0KDEpPDw4KSsodmFsdWUuY2hhckNvZGVBdCgyKTw8MTYpKyh2YWx1ZS5jaGFyQ29kZUF0KDMpPDwyNCl9ZnVuY3Rpb24gaW50MzJUb0ZvdXJDQyh2YWx1ZSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1JnZhbHVlLHZhbHVlPj44JjI1NSx2YWx1ZT4+MTYmMjU1LHZhbHVlPj4yNCYyNTUpfXZhciBERFNfTUFHSUM9NTQyMzI3ODc2LEREU0RfTUlQTUFQQ09VTlQ9MTMxMDcyLEREUEZfRk9VUkNDPTQsRk9VUkNDX0RYVDE9Zm91ckNDVG9JbnQzMihcIkRYVDFcIiksRk9VUkNDX0RYVDM9Zm91ckNDVG9JbnQzMihcIkRYVDNcIiksRk9VUkNDX0RYVDU9Zm91ckNDVG9JbnQzMihcIkRYVDVcIiksRk9VUkNDX0RYMTA9Zm91ckNDVG9JbnQzMihcIkRYMTBcIiksRk9VUkNDX0ZQMzJGPTExNixERFNDQVBTMl9DVUJFTUFQPTUxMixEM0QxMF9SRVNPVVJDRV9ESU1FTlNJT05fVEVYVFVSRTJEPTMsRFhHSV9GT1JNQVRfUjMyRzMyQjMyQTMyX0ZMT0FUPTIsaGVhZGVyTGVuZ3RoSW50PTMxLG9mZl9tYWdpYz0wLG9mZl9zaXplPTEsb2ZmX2ZsYWdzPTIsb2ZmX2hlaWdodD0zLG9mZl93aWR0aD00LG9mZl9taXBtYXBDb3VudD03LG9mZl9wZkZsYWdzPTIwLG9mZl9wZkZvdXJDQz0yMSxvZmZfY2FwczI9Mjg7bW9kdWxlLmV4cG9ydHM9cGFyc2VIZWFkZXJzfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntkZWZhdWx0Om9ian19ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLENvbnN0cnVjdG9yKXtpZighKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fCExLGRlc2NyaXB0b3IuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGRlc2NyaXB0b3ImJihkZXNjcmlwdG9yLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpfX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7cmV0dXJuIHByb3RvUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpLHN0YXRpY1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKSxDb25zdHJ1Y3Rvcn19KCksX0dMVG9vbD1fX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9HTFRvb2wyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dMVG9vbCksX0dMQ3ViZVRleHR1cmU9X193ZWJwYWNrX3JlcXVpcmVfXygyNyksX0dMQ3ViZVRleHR1cmUyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dMQ3ViZVRleHR1cmUpLGdsPXZvaWQgMCxDdWJlRnJhbWVCdWZmZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBDdWJlRnJhbWVCdWZmZXIoc2l6ZSl7dmFyIG1QYXJhbWV0ZXJzPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTtfY2xhc3NDYWxsQ2hlY2sodGhpcyxDdWJlRnJhbWVCdWZmZXIpLGdsPV9HTFRvb2wyLmRlZmF1bHQuZ2wsdGhpcy5fc2l6ZT1zaXplLHRoaXMubWFnRmlsdGVyPW1QYXJhbWV0ZXJzLm1hZ0ZpbHRlcnx8Z2wuTElORUFSLHRoaXMubWluRmlsdGVyPW1QYXJhbWV0ZXJzLm1pbkZpbHRlcnx8Z2wuTElORUFSLHRoaXMud3JhcFM9bVBhcmFtZXRlcnMud3JhcFN8fGdsLkNMQU1QX1RPX0VER0UsdGhpcy53cmFwVD1tUGFyYW1ldGVycy53cmFwVHx8Z2wuQ0xBTVBfVE9fRURHRSx0aGlzLl9pbml0KCl9cmV0dXJuIF9jcmVhdGVDbGFzcyhDdWJlRnJhbWVCdWZmZXIsW3trZXk6XCJfaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50ZXh0dXJlPWdsLmNyZWF0ZVRleHR1cmUoKSx0aGlzLmdsVGV4dHVyZT1uZXcgX0dMQ3ViZVRleHR1cmUyLmRlZmF1bHQodGhpcy50ZXh0dXJlLHt9LCEwKSxnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLHRoaXMudGV4dHVyZSksZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLGdsLlRFWFRVUkVfTUFHX0ZJTFRFUix0aGlzLm1hZ0ZpbHRlciksZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLGdsLlRFWFRVUkVfTUlOX0ZJTFRFUix0aGlzLm1pbkZpbHRlciksZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLGdsLlRFWFRVUkVfV1JBUF9TLHRoaXMud3JhcFMpLGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCxnbC5URVhUVVJFX1dSQVBfVCx0aGlzLndyYXBUKTtmb3IodmFyIHRhcmdldHM9W2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCxnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1gsZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZLGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWSxnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1osZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aXSxpPTA7aTx0YXJnZXRzLmxlbmd0aDtpKyspZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwhMSksZ2wudGV4SW1hZ2UyRCh0YXJnZXRzW2ldLDAsZ2wuUkdCQSx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0LDAsZ2wuUkdCQSxnbC5GTE9BVCxudWxsKTt0aGlzLl9mcmFtZUJ1ZmZlcnM9W107Zm9yKHZhciBfaT0wO19pPHRhcmdldHMubGVuZ3RoO19pKyspe3ZhciBmcmFtZUJ1ZmZlcj1nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO2dsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUixmcmFtZUJ1ZmZlciksZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsZ2wuQ09MT1JfQVRUQUNITUVOVDAsdGFyZ2V0c1tfaV0sdGhpcy50ZXh0dXJlLDApO3ZhciBzdGF0dXM9Z2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUik7c3RhdHVzIT09Z2wuRlJBTUVCVUZGRVJfQ09NUExFVEUmJmNvbnNvbGUubG9nKFwiJ2dsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoKSByZXR1cm5lZCAnXCIrc3RhdHVzKSx0aGlzLl9mcmFtZUJ1ZmZlcnMucHVzaChmcmFtZUJ1ZmZlcil9Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLG51bGwpLGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLG51bGwpLGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsbnVsbCl9fSx7a2V5OlwiYmluZFwiLHZhbHVlOmZ1bmN0aW9uKG1UYXJnZXRJbmRleCl7X0dMVG9vbDIuZGVmYXVsdC52aWV3cG9ydCgwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLHRoaXMuX2ZyYW1lQnVmZmVyc1ttVGFyZ2V0SW5kZXhdKX19LHtrZXk6XCJ1bmJpbmRcIix2YWx1ZTpmdW5jdGlvbigpe2dsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUixudWxsKSxfR0xUb29sMi5kZWZhdWx0LnZpZXdwb3J0KDAsMCxfR0xUb29sMi5kZWZhdWx0LndpZHRoLF9HTFRvb2wyLmRlZmF1bHQuaGVpZ2h0KX19LHtrZXk6XCJnZXRUZXh0dXJlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nbFRleHR1cmV9fSx7a2V5Olwid2lkdGhcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2l6ZX19LHtrZXk6XCJoZWlnaHRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2l6ZX19XSksQ3ViZUZyYW1lQnVmZmVyfSgpO2V4cG9ydHMuZGVmYXVsdD1DdWJlRnJhbWVCdWZmZXJ9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpc1Bvd2VyT2ZUd28oeCl7cmV0dXJuIDAhPT14JiYhKHgmeC0xKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ITEsZGVzY3JpcHRvci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvciYmKGRlc2NyaXB0b3Iud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcil9fXJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtyZXR1cm4gcHJvdG9Qcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyksc3RhdGljUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpLENvbnN0cnVjdG9yfX0oKSxfR0xUb29sPV9fd2VicGFja19yZXF1aXJlX18oMCksX0dMVG9vbDI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR0xUb29sKSxfR0xUZXh0dXJlPV9fd2VicGFja19yZXF1aXJlX18oMjUpLF9HTFRleHR1cmUyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dMVGV4dHVyZSksZ2w9dm9pZCAwLE11bHRpc2FtcGxlRnJhbWVCdWZmZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBNdWx0aXNhbXBsZUZyYW1lQnVmZmVyKG1XaWR0aCxtSGVpZ2h0KXt2YXIgbVBhcmFtZXRlcnM9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnt9O19jbGFzc0NhbGxDaGVjayh0aGlzLE11bHRpc2FtcGxlRnJhbWVCdWZmZXIpLGdsPV9HTFRvb2wyLmRlZmF1bHQuZ2wsdGhpcy53aWR0aD1tV2lkdGgsdGhpcy5oZWlnaHQ9bUhlaWdodCx0aGlzLm1hZ0ZpbHRlcj1tUGFyYW1ldGVycy5tYWdGaWx0ZXJ8fGdsLkxJTkVBUix0aGlzLm1pbkZpbHRlcj1tUGFyYW1ldGVycy5taW5GaWx0ZXJ8fGdsLkxJTkVBUix0aGlzLndyYXBTPW1QYXJhbWV0ZXJzLndyYXBTfHxnbC5DTEFNUF9UT19FREdFLHRoaXMud3JhcFQ9bVBhcmFtZXRlcnMud3JhcFR8fGdsLkNMQU1QX1RPX0VER0UsdGhpcy51c2VEZXB0aD1tUGFyYW1ldGVycy51c2VEZXB0aHx8ITAsdGhpcy51c2VTdGVuY2lsPW1QYXJhbWV0ZXJzLnVzZVN0ZW5jaWx8fCExLHRoaXMudGV4ZWxUeXBlPW1QYXJhbWV0ZXJzLnR5cGUsdGhpcy5fbnVtU2FtcGxlPW1QYXJhbWV0ZXJzLm51bVNhbXBsZXx8OCxpc1Bvd2VyT2ZUd28odGhpcy53aWR0aCkmJmlzUG93ZXJPZlR3byh0aGlzLmhlaWdodCl8fCh0aGlzLndyYXBTPXRoaXMud3JhcFQ9Z2wuQ0xBTVBfVE9fRURHRSx0aGlzLm1pbkZpbHRlcj09PWdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCYmKHRoaXMubWluRmlsdGVyPWdsLkxJTkVBUikpLHRoaXMuX2luaXQoKX1yZXR1cm4gX2NyZWF0ZUNsYXNzKE11bHRpc2FtcGxlRnJhbWVCdWZmZXIsW3trZXk6XCJfaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHRleGVsVHlwZT1nbC5VTlNJR05FRF9CWVRFO3RoaXMudGV4ZWxUeXBlJiYodGV4ZWxUeXBlPXRoaXMudGV4ZWxUeXBlKSx0aGlzLnRleGVsVHlwZT10ZXhlbFR5cGUsdGhpcy5mcmFtZUJ1ZmZlcj1nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpLHRoaXMuZnJhbWVCdWZmZXJDb2xvcj1nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpLHRoaXMucmVuZGVyQnVmZmVyQ29sb3I9Z2wuY3JlYXRlUmVuZGVyYnVmZmVyKCksdGhpcy5yZW5kZXJCdWZmZXJEZXB0aD1nbC5jcmVhdGVSZW5kZXJidWZmZXIoKSx0aGlzLmdsVGV4dHVyZT10aGlzLl9jcmVhdGVUZXh0dXJlKCksdGhpcy5nbERlcHRoVGV4dHVyZT10aGlzLl9jcmVhdGVUZXh0dXJlKGdsLkRFUFRIX0NPTVBPTkVOVDE2LGdsLlVOU0lHTkVEX1NIT1JULGdsLkRFUFRIX0NPTVBPTkVOVCwhMCksZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsdGhpcy5yZW5kZXJCdWZmZXJDb2xvciksZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKGdsLlJFTkRFUkJVRkZFUix0aGlzLl9udW1TYW1wbGUsZ2wuUkdCQTgsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsdGhpcy5yZW5kZXJCdWZmZXJEZXB0aCksZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKGdsLlJFTkRFUkJVRkZFUix0aGlzLl9udW1TYW1wbGUsZ2wuREVQVEhfQ09NUE9ORU5UMTYsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLHRoaXMuZnJhbWVCdWZmZXIpLGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLGdsLkNPTE9SX0FUVEFDSE1FTlQwLGdsLlJFTkRFUkJVRkZFUix0aGlzLnJlbmRlckJ1ZmZlckNvbG9yKSxnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUixnbC5ERVBUSF9BVFRBQ0hNRU5ULGdsLlJFTkRFUkJVRkZFUix0aGlzLnJlbmRlckJ1ZmZlckRlcHRoKSxnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsbnVsbCksZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLHRoaXMuZnJhbWVCdWZmZXJDb2xvciksZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsZ2wuQ09MT1JfQVRUQUNITUVOVDAsZ2wuVEVYVFVSRV8yRCx0aGlzLmdsVGV4dHVyZS50ZXh0dXJlLDApLGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUixudWxsKX19LHtrZXk6XCJfY3JlYXRlVGV4dHVyZVwiLHZhbHVlOmZ1bmN0aW9uKG1JbnRlcm5hbGZvcm1hdCxtVGV4ZWxUeXBlLG1Gb3JtYXQpe3ZhciBmb3JjZU5lYXJlc3Q9YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10mJmFyZ3VtZW50c1szXTt2b2lkIDA9PT1tSW50ZXJuYWxmb3JtYXQmJihtSW50ZXJuYWxmb3JtYXQ9Z2wuUkdCQSksdm9pZCAwPT09bVRleGVsVHlwZSYmKG1UZXhlbFR5cGU9dGhpcy50ZXhlbFR5cGUpLG1Gb3JtYXR8fChtRm9ybWF0PW1JbnRlcm5hbGZvcm1hdCk7dmFyIHQ9Z2wuY3JlYXRlVGV4dHVyZSgpLGdsdD1uZXcgX0dMVGV4dHVyZTIuZGVmYXVsdCh0LCEwKSxtYWdGaWx0ZXI9Zm9yY2VOZWFyZXN0P19HTFRvb2wyLmRlZmF1bHQuTkVBUkVTVDp0aGlzLm1hZ0ZpbHRlcixtaW5GaWx0ZXI9Zm9yY2VOZWFyZXN0P19HTFRvb2wyLmRlZmF1bHQuTkVBUkVTVDp0aGlzLm1pbkZpbHRlcjtyZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCx0KSxnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsZ2wuVEVYVFVSRV9NQUdfRklMVEVSLG1hZ0ZpbHRlciksZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELGdsLlRFWFRVUkVfTUlOX0ZJTFRFUixtaW5GaWx0ZXIpLGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCxnbC5URVhUVVJFX1dSQVBfUyx0aGlzLndyYXBTKSxnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsZ2wuVEVYVFVSRV9XUkFQX1QsdGhpcy53cmFwVCksZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELDAsbUludGVybmFsZm9ybWF0LHRoaXMud2lkdGgsdGhpcy5oZWlnaHQsMCxtRm9ybWF0LG1UZXhlbFR5cGUsbnVsbCksZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCxudWxsKSxnbHR9fSx7a2V5OlwiYmluZFwiLHZhbHVlOmZ1bmN0aW9uKCl7KCEoYXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0pfHxhcmd1bWVudHNbMF0pJiZfR0xUb29sMi5kZWZhdWx0LnZpZXdwb3J0KDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsdGhpcy5mcmFtZUJ1ZmZlcil9fSx7a2V5OlwidW5iaW5kXCIsdmFsdWU6ZnVuY3Rpb24oKXsoIShhcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSl8fGFyZ3VtZW50c1swXSkmJl9HTFRvb2wyLmRlZmF1bHQudmlld3BvcnQoMCwwLF9HTFRvb2wyLmRlZmF1bHQud2lkdGgsX0dMVG9vbDIuZGVmYXVsdC5oZWlnaHQpO3ZhciB3aWR0aD10aGlzLndpZHRoLGhlaWdodD10aGlzLmhlaWdodDtnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsbnVsbCksZ2wuYmluZEZyYW1lYnVmZmVyKGdsLlJFQURfRlJBTUVCVUZGRVIsdGhpcy5mcmFtZUJ1ZmZlciksZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkRSQVdfRlJBTUVCVUZGRVIsdGhpcy5mcmFtZUJ1ZmZlckNvbG9yKSxnbC5jbGVhckJ1ZmZlcmZ2KGdsLkNPTE9SLDAsWzAsMCwwLDBdKSxnbC5ibGl0RnJhbWVidWZmZXIoMCwwLHdpZHRoLGhlaWdodCwwLDAsd2lkdGgsaGVpZ2h0LGdsLkNPTE9SX0JVRkZFUl9CSVQsX0dMVG9vbDIuZGVmYXVsdC5ORUFSRVNUKSxnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsbnVsbCl9fSx7a2V5OlwiZ2V0VGV4dHVyZVwiLHZhbHVlOmZ1bmN0aW9uKCl7YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5nbFRleHR1cmV9fSx7a2V5OlwiZ2V0RGVwdGhUZXh0dXJlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nbERlcHRoVGV4dHVyZX19XSksTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlcn0oKTtleHBvcnRzLmRlZmF1bHQ9TXVsdGlzYW1wbGVGcmFtZUJ1ZmZlcn0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7ZGVmYXVsdDpvYmp9fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSxDb25zdHJ1Y3Rvcil7aWYoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHwhMSxkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBkZXNjcmlwdG9yJiYoZGVzY3JpcHRvci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCxkZXNjcmlwdG9yLmtleSxkZXNjcmlwdG9yKX19cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe3JldHVybiBwcm90b1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKSxzdGF0aWNQcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyksQ29uc3RydWN0b3J9fSgpLF9HTFRvb2w9X193ZWJwYWNrX3JlcXVpcmVfXygwKSxfR0xUb29sMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HTFRvb2wpLF9HTFNoYWRlcj1fX3dlYnBhY2tfcmVxdWlyZV9fKDIpLF9HTFNoYWRlcjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR0xTaGFkZXIpLF9NZXNoPV9fd2VicGFja19yZXF1aXJlX18oNSksX01lc2gyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01lc2gpLGdsPXZvaWQgMCxUcmFuc2Zvcm1GZWVkYmFja09iamVjdD1mdW5jdGlvbigpe2Z1bmN0aW9uIFRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0KHN0clZlcnRleFNoYWRlcixzdHJGcmFnbWVudFNoYWRlcil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsVHJhbnNmb3JtRmVlZGJhY2tPYmplY3QpLGdsPV9HTFRvb2wyLmRlZmF1bHQuZ2wsdGhpcy5fdnM9c3RyVmVydGV4U2hhZGVyLHRoaXMuX2ZzPXN0ckZyYWdtZW50U2hhZGVyLHRoaXMuX2luaXQoKX1yZXR1cm4gX2NyZWF0ZUNsYXNzKFRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0LFt7a2V5OlwiX2luaXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX21lc2hDdXJyZW50PW5ldyBfTWVzaDIuZGVmYXVsdCx0aGlzLl9tZXNoVGFyZ2V0PW5ldyBfTWVzaDIuZGVmYXVsdCx0aGlzLl9udW1Qb2ludHM9LTEsdGhpcy5fdmFyeWluZ3M9W10sdGhpcy50cmFuc2Zvcm1GZWVkYmFjaz1nbC5jcmVhdGVUcmFuc2Zvcm1GZWVkYmFjaygpfX0se2tleTpcImJ1ZmZlckRhdGFcIix2YWx1ZTpmdW5jdGlvbihtRGF0YSxtTmFtZSxtVmFyeWluZ05hbWUpe3ZhciBpc1RyYW5zZm9ybUZlZWRiYWNrPSEhbVZhcnlpbmdOYW1lO2NvbnNvbGUubG9nKFwiaXMgVHJhbnNmb3JtIGZlZWRiYWNrID9cIixtTmFtZSxpc1RyYW5zZm9ybUZlZWRiYWNrKSx0aGlzLl9tZXNoQ3VycmVudC5idWZmZXJEYXRhKG1EYXRhLG1OYW1lLG51bGwsZ2wuU1RSRUFNX0NPUFksITEpLHRoaXMuX21lc2hUYXJnZXQuYnVmZmVyRGF0YShtRGF0YSxtTmFtZSxudWxsLGdsLlNUUkVBTV9DT1BZLCExKSxpc1RyYW5zZm9ybUZlZWRiYWNrJiYodGhpcy5fdmFyeWluZ3MucHVzaChtVmFyeWluZ05hbWUpLHRoaXMuX251bVBvaW50czwwJiYodGhpcy5fbnVtUG9pbnRzPW1EYXRhLmxlbmd0aCkpfX0se2tleTpcImJ1ZmZlckluZGV4XCIsdmFsdWU6ZnVuY3Rpb24obUFycmF5SW5kaWNlcyl7dGhpcy5fbWVzaEN1cnJlbnQuYnVmZmVySW5kZXgobUFycmF5SW5kaWNlcyksdGhpcy5fbWVzaFRhcmdldC5idWZmZXJJbmRleChtQXJyYXlJbmRpY2VzKX19LHtrZXk6XCJ1bmlmb3JtXCIsdmFsdWU6ZnVuY3Rpb24obU5hbWUsbVR5cGUsbVZhbHVlKXt0aGlzLnNoYWRlciYmdGhpcy5zaGFkZXIudW5pZm9ybShtTmFtZSxtVHlwZSxtVmFsdWUpfX0se2tleTpcImdlbmVyYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnNoYWRlcj1uZXcgX0dMU2hhZGVyMi5kZWZhdWx0KHRoaXMuX3ZzLHRoaXMuX2ZzLHRoaXMuX3ZhcnlpbmdzKX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2hhZGVyfHx0aGlzLmdlbmVyYXRlKCksdGhpcy5zaGFkZXIuYmluZCgpLF9HTFRvb2wyLmRlZmF1bHQuZHJhd1RyYW5zZm9ybUZlZWRiYWNrKHRoaXMpLHRoaXMuX3N3YXAoKX19LHtrZXk6XCJfc3dhcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHRtcD10aGlzLl9tZXNoQ3VycmVudDt0aGlzLl9tZXNoQ3VycmVudD10aGlzLl9tZXNoVGFyZ2V0LHRoaXMuX21lc2hUYXJnZXQ9dG1wfX0se2tleTpcIm51bVBvaW50c1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9udW1Qb2ludHN9fSx7a2V5OlwibWVzaEN1cnJlbnRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWVzaEN1cnJlbnR9fSx7a2V5OlwibWVzaFRhcmdldFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tZXNoVGFyZ2V0fX0se2tleTpcIm1lc2hTb3VyY2VcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWVzaEN1cnJlbnR9fSx7a2V5OlwibWVzaERlc3RpbmF0aW9uXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21lc2hUYXJnZXR9fV0pLFRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0fSgpO2V4cG9ydHMuZGVmYXVsdD1UcmFuc2Zvcm1GZWVkYmFja09iamVjdH0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLENvbnN0cnVjdG9yKXtpZighKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gZ2V0RnVuYyhtRWFzaW5nKXtzd2l0Y2gobUVhc2luZyl7ZGVmYXVsdDpjYXNlXCJsaW5lYXJcIjpyZXR1cm4gRWFzaW5nLkxpbmVhci5Ob25lO2Nhc2VcImV4cEluXCI6cmV0dXJuIEVhc2luZy5FeHBvbmVudGlhbC5JbjtjYXNlXCJleHBPdXRcIjpyZXR1cm4gRWFzaW5nLkV4cG9uZW50aWFsLk91dDtjYXNlXCJleHBJbk91dFwiOnJldHVybiBFYXNpbmcuRXhwb25lbnRpYWwuSW5PdXQ7Y2FzZVwiY3ViaWNJblwiOnJldHVybiBFYXNpbmcuQ3ViaWMuSW47Y2FzZVwiY3ViaWNPdXRcIjpyZXR1cm4gRWFzaW5nLkN1YmljLk91dDtjYXNlXCJjdWJpY0luT3V0XCI6cmV0dXJuIEVhc2luZy5DdWJpYy5Jbk91dDtjYXNlXCJxdWFydGljSW5cIjpyZXR1cm4gRWFzaW5nLlF1YXJ0aWMuSW47Y2FzZVwicXVhcnRpY091dFwiOnJldHVybiBFYXNpbmcuUXVhcnRpYy5PdXQ7Y2FzZVwicXVhcnRpY0luT3V0XCI6cmV0dXJuIEVhc2luZy5RdWFydGljLkluT3V0O2Nhc2VcInF1aW50aWNJblwiOnJldHVybiBFYXNpbmcuUXVpbnRpYy5JbjtjYXNlXCJxdWludGljT3V0XCI6cmV0dXJuIEVhc2luZy5RdWludGljLk91dDtjYXNlXCJxdWludGljSW5PdXRcIjpyZXR1cm4gRWFzaW5nLlF1aW50aWMuSW5PdXQ7Y2FzZVwic2ludXNvaWRhbEluXCI6cmV0dXJuIEVhc2luZy5TaW51c29pZGFsLkluO2Nhc2VcInNpbnVzb2lkYWxPdXRcIjpyZXR1cm4gRWFzaW5nLlNpbnVzb2lkYWwuT3V0O2Nhc2VcInNpbnVzb2lkYWxJbk91dFwiOnJldHVybiBFYXNpbmcuU2ludXNvaWRhbC5Jbk91dDtjYXNlXCJjaXJjdWxhckluXCI6cmV0dXJuIEVhc2luZy5DaXJjdWxhci5JbjtjYXNlXCJjaXJjdWxhck91dFwiOnJldHVybiBFYXNpbmcuQ2lyY3VsYXIuT3V0O2Nhc2VcImNpcmN1bGFySW5PdXRcIjpyZXR1cm4gRWFzaW5nLkNpcmN1bGFyLkluT3V0O2Nhc2VcImVsYXN0aWNJblwiOnJldHVybiBFYXNpbmcuRWxhc3RpYy5JbjtjYXNlXCJlbGFzdGljT3V0XCI6cmV0dXJuIEVhc2luZy5FbGFzdGljLk91dDtjYXNlXCJlbGFzdGljSW5PdXRcIjpyZXR1cm4gRWFzaW5nLkVsYXN0aWMuSW5PdXQ7Y2FzZVwiYmFja0luXCI6cmV0dXJuIEVhc2luZy5CYWNrLkluO2Nhc2VcImJhY2tPdXRcIjpyZXR1cm4gRWFzaW5nLkJhY2suT3V0O2Nhc2VcImJhY2tJbk91dFwiOnJldHVybiBFYXNpbmcuQmFjay5Jbk91dDtjYXNlXCJib3VuY2VJblwiOnJldHVybiBFYXNpbmcuQm91bmNlLmluO2Nhc2VcImJvdW5jZU91dFwiOnJldHVybiBFYXNpbmcuQm91bmNlLm91dDtjYXNlXCJib3VuY2VJbk91dFwiOnJldHVybiBFYXNpbmcuQm91bmNlLmluT3V0fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ITEsZGVzY3JpcHRvci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvciYmKGRlc2NyaXB0b3Iud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcil9fXJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtyZXR1cm4gcHJvdG9Qcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyksc3RhdGljUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpLENvbnN0cnVjdG9yfX0oKSxfc2NoZWR1bGluZz1fX3dlYnBhY2tfcmVxdWlyZV9fKDYpLF9zY2hlZHVsaW5nMj1mdW5jdGlvbihvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7ZGVmYXVsdDpvYmp9fShfc2NoZWR1bGluZyksRWFzaW5nPXtMaW5lYXI6e05vbmU6ZnVuY3Rpb24oayl7cmV0dXJuIGt9fSxRdWFkcmF0aWM6e0luOmZ1bmN0aW9uKGspe3JldHVybiBrKmt9LE91dDpmdW5jdGlvbihrKXtyZXR1cm4gayooMi1rKX0sSW5PdXQ6ZnVuY3Rpb24oayl7cmV0dXJuKGsqPTIpPDE/LjUqayprOi0uNSooLS1rKihrLTIpLTEpfX0sQ3ViaWM6e0luOmZ1bmN0aW9uKGspe3JldHVybiBrKmsqa30sT3V0OmZ1bmN0aW9uKGspe3JldHVybi0tayprKmsrMX0sSW5PdXQ6ZnVuY3Rpb24oayl7cmV0dXJuKGsqPTIpPDE/LjUqayprKms6LjUqKChrLT0yKSprKmsrMil9fSxRdWFydGljOntJbjpmdW5jdGlvbihrKXtyZXR1cm4gayprKmsqa30sT3V0OmZ1bmN0aW9uKGspe3JldHVybiAxLSAtLWsqayprKmt9LEluT3V0OmZ1bmN0aW9uKGspe3JldHVybihrKj0yKTwxPy41KmsqayprKms6LS41Kigoay09MikqayprKmstMil9fSxRdWludGljOntJbjpmdW5jdGlvbihrKXtyZXR1cm4gayprKmsqayprfSxPdXQ6ZnVuY3Rpb24oayl7cmV0dXJuLS1rKmsqayprKmsrMX0sSW5PdXQ6ZnVuY3Rpb24oayl7cmV0dXJuKGsqPTIpPDE/LjUqayprKmsqayprOi41Kigoay09MikqayprKmsqaysyKX19LFNpbnVzb2lkYWw6e0luOmZ1bmN0aW9uKGspe3JldHVybiAxLU1hdGguY29zKGsqTWF0aC5QSS8yKX0sT3V0OmZ1bmN0aW9uKGspe3JldHVybiBNYXRoLnNpbihrKk1hdGguUEkvMil9LEluT3V0OmZ1bmN0aW9uKGspe3JldHVybi41KigxLU1hdGguY29zKE1hdGguUEkqaykpfX0sRXhwb25lbnRpYWw6e0luOmZ1bmN0aW9uKGspe3JldHVybiAwPT09az8wOk1hdGgucG93KDEwMjQsay0xKX0sT3V0OmZ1bmN0aW9uKGspe3JldHVybiAxPT09az8xOjEtTWF0aC5wb3coMiwtMTAqayl9LEluT3V0OmZ1bmN0aW9uKGspe3JldHVybiAwPT09az8wOjE9PT1rPzE6KGsqPTIpPDE/LjUqTWF0aC5wb3coMTAyNCxrLTEpOi41KigyLU1hdGgucG93KDIsLTEwKihrLTEpKSl9fSxDaXJjdWxhcjp7SW46ZnVuY3Rpb24oayl7cmV0dXJuIDEtTWF0aC5zcXJ0KDEtayprKX0sT3V0OmZ1bmN0aW9uKGspe3JldHVybiBNYXRoLnNxcnQoMS0gLS1rKmspfSxJbk91dDpmdW5jdGlvbihrKXtyZXR1cm4oayo9Mik8MT8tLjUqKE1hdGguc3FydCgxLWsqayktMSk6LjUqKE1hdGguc3FydCgxLShrLT0yKSprKSsxKX19LEVsYXN0aWM6e0luOmZ1bmN0aW9uKGspe3ZhciBzPXZvaWQgMCxhPS4xO3JldHVybiAwPT09az8wOjE9PT1rPzE6KCFhfHxhPDE/KGE9MSxzPS4xKTpzPS40Kk1hdGguYXNpbigxL2EpLygyKk1hdGguUEkpLC1hKk1hdGgucG93KDIsMTAqKGstPTEpKSpNYXRoLnNpbigoay1zKSooMipNYXRoLlBJKS8uNCkpfSxPdXQ6ZnVuY3Rpb24oayl7dmFyIHM9dm9pZCAwLGE9LjE7cmV0dXJuIDA9PT1rPzA6MT09PWs/MTooIWF8fGE8MT8oYT0xLHM9LjEpOnM9LjQqTWF0aC5hc2luKDEvYSkvKDIqTWF0aC5QSSksYSpNYXRoLnBvdygyLC0xMCprKSpNYXRoLnNpbigoay1zKSooMipNYXRoLlBJKS8uNCkrMSl9LEluT3V0OmZ1bmN0aW9uKGspe3ZhciBzPXZvaWQgMCxhPS4xO3JldHVybiAwPT09az8wOjE9PT1rPzE6KCFhfHxhPDE/KGE9MSxzPS4xKTpzPS40Kk1hdGguYXNpbigxL2EpLygyKk1hdGguUEkpLChrKj0yKTwxP2EqTWF0aC5wb3coMiwxMCooay09MSkpKk1hdGguc2luKChrLXMpKigyKk1hdGguUEkpLy40KSotLjU6YSpNYXRoLnBvdygyLC0xMCooay09MSkpKk1hdGguc2luKChrLXMpKigyKk1hdGguUEkpLy40KSouNSsxKX19LEJhY2s6e0luOmZ1bmN0aW9uKGspe3ZhciBzPTEuNzAxNTg7cmV0dXJuIGsqayooKHMrMSkqay1zKX0sT3V0OmZ1bmN0aW9uKGspe3ZhciBzPTEuNzAxNTg7cmV0dXJuLS1rKmsqKChzKzEpKmsrcykrMX0sSW5PdXQ6ZnVuY3Rpb24oayl7dmFyIHM9Mi41OTQ5MDk1O3JldHVybihrKj0yKTwxP2sqayooKHMrMSkqay1zKSouNTouNSooKGstPTIpKmsqKChzKzEpKmsrcykrMil9fSxCb3VuY2U6e2luOmZ1bmN0aW9uKGspe3JldHVybiAxLUVhc2luZy5Cb3VuY2Uub3V0KDEtayl9LG91dDpmdW5jdGlvbihrKXtyZXR1cm4gazwxLzIuNzU/Ny41NjI1KmsqazprPDIvMi43NT83LjU2MjUqKGstPTEuNS8yLjc1KSprKy43NTprPDIuNS8yLjc1PzcuNTYyNSooay09Mi4yNS8yLjc1KSprKy45Mzc1OjcuNTYyNSooay09Mi42MjUvMi43NSkqaysuOTg0Mzc1fSxpbk91dDpmdW5jdGlvbihrKXtyZXR1cm4gazwuNT8uNSpFYXNpbmcuQm91bmNlLmluKDIqayk6LjUqRWFzaW5nLkJvdW5jZS5vdXQoMiprLTEpKy41fX19LFR3ZWVuTnVtYmVyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gVHdlZW5OdW1iZXIobVZhbHVlKXt2YXIgX3RoaXM9dGhpcyxtRWFzaW5nPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpcImV4cE91dFwiLG1TcGVlZD1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06LjAxO19jbGFzc0NhbGxDaGVjayh0aGlzLFR3ZWVuTnVtYmVyKSx0aGlzLl92YWx1ZT1tVmFsdWUsdGhpcy5fc3RhcnRWYWx1ZT1tVmFsdWUsdGhpcy5fdGFyZ2V0VmFsdWU9bVZhbHVlLHRoaXMuX2NvdW50ZXI9MSx0aGlzLnNwZWVkPW1TcGVlZCx0aGlzLmVhc2luZz1tRWFzaW5nLHRoaXMuX25lZWRVcGRhdGU9ITAsdGhpcy5fZWZJbmRleD1fc2NoZWR1bGluZzIuZGVmYXVsdC5hZGRFRihmdW5jdGlvbigpe3JldHVybiBfdGhpcy5fdXBkYXRlKCl9KX1yZXR1cm4gX2NyZWF0ZUNsYXNzKFR3ZWVuTnVtYmVyLFt7a2V5OlwiX3VwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIG5ld0NvdW50ZXI9dGhpcy5fY291bnRlcit0aGlzLnNwZWVkO2lmKG5ld0NvdW50ZXI+MSYmKG5ld0NvdW50ZXI9MSksdGhpcy5fY291bnRlcj09PW5ld0NvdW50ZXIpcmV0dXJuIHZvaWQodGhpcy5fbmVlZFVwZGF0ZT0hMSk7dGhpcy5fY291bnRlcj1uZXdDb3VudGVyLHRoaXMuX25lZWRVcGRhdGU9ITB9fSx7a2V5OlwibGltaXRcIix2YWx1ZTpmdW5jdGlvbihtTWluLG1NYXgpe2lmKG1NaW4+bU1heClyZXR1cm4gdm9pZCB0aGlzLmxpbWl0KG1NYXgsbU1pbik7dGhpcy5fbWluPW1NaW4sdGhpcy5fbWF4PW1NYXgsdGhpcy5fY2hlY2tMaW1pdCgpfX0se2tleTpcInNldFRvXCIsdmFsdWU6ZnVuY3Rpb24obVZhbHVlKXt0aGlzLl92YWx1ZT1tVmFsdWUsdGhpcy5fdGFyZ2V0VmFsdWU9bVZhbHVlLHRoaXMuX2NvdW50ZXI9MX19LHtrZXk6XCJfY2hlY2tMaW1pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dm9pZCAwIT09dGhpcy5fbWluJiZ0aGlzLl90YXJnZXRWYWx1ZTx0aGlzLl9taW4mJih0aGlzLl90YXJnZXRWYWx1ZT10aGlzLl9taW4pLHZvaWQgMCE9PXRoaXMuX21heCYmdGhpcy5fdGFyZ2V0VmFsdWU+dGhpcy5fbWF4JiYodGhpcy5fdGFyZ2V0VmFsdWU9dGhpcy5fbWF4KX19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXtfc2NoZWR1bGluZzIuZGVmYXVsdC5yZW1vdmVFRih0aGlzLl9lZkluZGV4KX19LHtrZXk6XCJ2YWx1ZVwiLHNldDpmdW5jdGlvbihtVmFsdWUpe3RoaXMuX3N0YXJ0VmFsdWU9dGhpcy5fdmFsdWUsdGhpcy5fdGFyZ2V0VmFsdWU9bVZhbHVlLHRoaXMuX2NoZWNrTGltaXQoKSx0aGlzLl9jb3VudGVyPTB9LGdldDpmdW5jdGlvbigpe2lmKHRoaXMuX25lZWRVcGRhdGUpe3ZhciBmPWdldEZ1bmModGhpcy5lYXNpbmcpLHA9Zih0aGlzLl9jb3VudGVyKTt0aGlzLl92YWx1ZT10aGlzLl9zdGFydFZhbHVlK3AqKHRoaXMuX3RhcmdldFZhbHVlLXRoaXMuX3N0YXJ0VmFsdWUpLHRoaXMuX25lZWRVcGRhdGU9ITF9cmV0dXJuIHRoaXMuX3ZhbHVlfX0se2tleTpcInRhcmdldFZhbHVlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RhcmdldFZhbHVlfX1dKSxUd2Vlbk51bWJlcn0oKTtleHBvcnRzLmRlZmF1bHQ9VHdlZW5OdW1iZXJ9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ITEsZGVzY3JpcHRvci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvciYmKGRlc2NyaXB0b3Iud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcil9fXJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtyZXR1cm4gcHJvdG9Qcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyksc3RhdGljUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpLENvbnN0cnVjdG9yfX0oKSxfZ2xNYXRyaXg9X193ZWJwYWNrX3JlcXVpcmVfXygxKSxfZ2xNYXRyaXgyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsTWF0cml4KSxfRWFzZU51bWJlcj1fX3dlYnBhY2tfcmVxdWlyZV9fKDEzKSxfRWFzZU51bWJlcjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRWFzZU51bWJlciksX3NjaGVkdWxpbmc9X193ZWJwYWNrX3JlcXVpcmVfXyg2KSxfc2NoZWR1bGluZzI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2NoZWR1bGluZyksZ2V0TW91c2U9ZnVuY3Rpb24obUV2ZW50LG1UYXJnZXQpe3ZhciBvPW1UYXJnZXR8fHt9O3JldHVybiBtRXZlbnQudG91Y2hlcz8oby54PW1FdmVudC50b3VjaGVzWzBdLnBhZ2VYLG8ueT1tRXZlbnQudG91Y2hlc1swXS5wYWdlWSk6KG8ueD1tRXZlbnQuY2xpZW50WCxvLnk9bUV2ZW50LmNsaWVudFkpLG99LFF1YXRSb3RhdGlvbj1mdW5jdGlvbigpe2Z1bmN0aW9uIFF1YXRSb3RhdGlvbihtVGFyZ2V0KXt2YXIgX3RoaXM9dGhpcyxtTGlzdGVuZXJUYXJnZXQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOndpbmRvdyxtRWFzaW5nPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTouMTtfY2xhc3NDYWxsQ2hlY2sodGhpcyxRdWF0Um90YXRpb24pLHRoaXMuX3RhcmdldD1tVGFyZ2V0LHRoaXMuX2xpc3RlbmVyVGFyZ2V0PW1MaXN0ZW5lclRhcmdldCx0aGlzLm1hdHJpeD1fZ2xNYXRyaXgyLmRlZmF1bHQubWF0NC5jcmVhdGUoKSx0aGlzLm09X2dsTWF0cml4Mi5kZWZhdWx0Lm1hdDQuY3JlYXRlKCksdGhpcy5fdlpheGlzPV9nbE1hdHJpeDIuZGVmYXVsdC52ZWMzLmNsb25lKFswLDAsMF0pLHRoaXMuX3pBeGlzPV9nbE1hdHJpeDIuZGVmYXVsdC52ZWMzLmNsb25lKFswLDAsMV0pLHRoaXMucHJlTW91c2U9e3g6MCx5OjB9LHRoaXMubW91c2U9e3g6MCx5OjB9LHRoaXMuX2lzTW91c2VEb3duPSExLHRoaXMuX3JvdGF0aW9uPV9nbE1hdHJpeDIuZGVmYXVsdC5xdWF0LmNyZWF0ZSgpLHRoaXMudGVtcFJvdGF0aW9uPV9nbE1hdHJpeDIuZGVmYXVsdC5xdWF0LmNyZWF0ZSgpLHRoaXMuX3JvdGF0ZVpNYXJnaW49MCx0aGlzLl9vZmZzZXQ9LjAwNCx0aGlzLl9zbGVycD0tMSx0aGlzLl9pc0xvY2tlZD0hMSx0aGlzLl9kaWZmWD1uZXcgX0Vhc2VOdW1iZXIyLmRlZmF1bHQoMCxtRWFzaW5nKSx0aGlzLl9kaWZmWT1uZXcgX0Vhc2VOdW1iZXIyLmRlZmF1bHQoMCxtRWFzaW5nKSx0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsZnVuY3Rpb24oZSl7cmV0dXJuIF90aGlzLl9vbkRvd24oZSl9KSx0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLGZ1bmN0aW9uKGUpe3JldHVybiBfdGhpcy5fb25Eb3duKGUpfSksdGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLGZ1bmN0aW9uKGUpe3JldHVybiBfdGhpcy5fb25Nb3ZlKGUpfSksdGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLGZ1bmN0aW9uKGUpe3JldHVybiBfdGhpcy5fb25Nb3ZlKGUpfSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLGZ1bmN0aW9uKCl7cmV0dXJuIF90aGlzLl9vblVwKCl9KSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIixmdW5jdGlvbigpe3JldHVybiBfdGhpcy5fb25VcCgpfSksX3NjaGVkdWxpbmcyLmRlZmF1bHQuYWRkRUYoZnVuY3Rpb24oKXtyZXR1cm4gX3RoaXMuX2xvb3AoKX0pfXJldHVybiBfY3JlYXRlQ2xhc3MoUXVhdFJvdGF0aW9uLFt7a2V5OlwiaW52ZXJzZUNvbnRyb2xcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBpc0ludmVydD0hKGFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdKXx8YXJndW1lbnRzWzBdO3RoaXMuX2lzSW52ZXJ0PWlzSW52ZXJ0fX0se2tleTpcImxvY2tcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBtVmFsdWU9IShhcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSl8fGFyZ3VtZW50c1swXTt0aGlzLl9pc0xvY2tlZD1tVmFsdWV9fSx7a2V5Olwic2V0Q2FtZXJhUG9zXCIsdmFsdWU6ZnVuY3Rpb24obVF1YXQpe3ZhciBzcGVlZD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06LjE7aWYodGhpcy5lYXNpbmc9c3BlZWQsISh0aGlzLl9zbGVycD4wKSl7dmFyIHRlbXBSb3RhdGlvbj1fZ2xNYXRyaXgyLmRlZmF1bHQucXVhdC5jbG9uZSh0aGlzLl9yb3RhdGlvbik7dGhpcy5fdXBkYXRlUm90YXRpb24odGVtcFJvdGF0aW9uKSx0aGlzLl9yb3RhdGlvbj1fZ2xNYXRyaXgyLmRlZmF1bHQucXVhdC5jbG9uZSh0ZW1wUm90YXRpb24pLHRoaXMuX2N1cnJEaWZmWD10aGlzLmRpZmZYPTAsdGhpcy5fY3VyckRpZmZZPXRoaXMuZGlmZlk9MCx0aGlzLl9pc01vdXNlRG93bj0hMSx0aGlzLl9pc1JvdGF0ZVo9MCx0aGlzLl90YXJnZXRRdWF0PV9nbE1hdHJpeDIuZGVmYXVsdC5xdWF0LmNsb25lKG1RdWF0KSx0aGlzLl9zbGVycD0xfX19LHtrZXk6XCJyZXNldFF1YXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3JvdGF0aW9uPV9nbE1hdHJpeDIuZGVmYXVsdC5xdWF0LmNsb25lKFswLDAsMSwwXSksdGhpcy50ZW1wUm90YXRpb249X2dsTWF0cml4Mi5kZWZhdWx0LnF1YXQuY2xvbmUoWzAsMCwwLDBdKSx0aGlzLl90YXJnZXRRdWF0PXZvaWQgMCx0aGlzLl9zbGVycD0tMX19LHtrZXk6XCJfb25Eb3duXCIsdmFsdWU6ZnVuY3Rpb24obUV2ZW50KXtpZighdGhpcy5faXNMb2NrZWQpe3ZhciBtb3VzZT1nZXRNb3VzZShtRXZlbnQpLHRlbXBSb3RhdGlvbj1fZ2xNYXRyaXgyLmRlZmF1bHQucXVhdC5jbG9uZSh0aGlzLl9yb3RhdGlvbik7dGhpcy5fdXBkYXRlUm90YXRpb24odGVtcFJvdGF0aW9uKSx0aGlzLl9yb3RhdGlvbj10ZW1wUm90YXRpb24sdGhpcy5faXNNb3VzZURvd249ITAsdGhpcy5faXNSb3RhdGVaPTAsdGhpcy5wcmVNb3VzZT17eDptb3VzZS54LHk6bW91c2UueX0sbW91c2UueTx0aGlzLl9yb3RhdGVaTWFyZ2lufHxtb3VzZS55PndpbmRvdy5pbm5lckhlaWdodC10aGlzLl9yb3RhdGVaTWFyZ2luP3RoaXMuX2lzUm90YXRlWj0xOihtb3VzZS54PHRoaXMuX3JvdGF0ZVpNYXJnaW58fG1vdXNlLng+d2luZG93LmlubmVyV2lkdGgtdGhpcy5fcm90YXRlWk1hcmdpbikmJih0aGlzLl9pc1JvdGF0ZVo9MiksdGhpcy5fZGlmZlguc2V0VG8oMCksdGhpcy5fZGlmZlkuc2V0VG8oMCl9fX0se2tleTpcIl9vbk1vdmVcIix2YWx1ZTpmdW5jdGlvbihtRXZlbnQpe3RoaXMuX2lzTG9ja2VkfHxnZXRNb3VzZShtRXZlbnQsdGhpcy5tb3VzZSl9fSx7a2V5OlwiX29uVXBcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2lzTG9ja2VkfHwodGhpcy5faXNNb3VzZURvd249ITEpfX0se2tleTpcIl91cGRhdGVSb3RhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKG1UZW1wUm90YXRpb24pe3RoaXMuX2lzTW91c2VEb3duJiYhdGhpcy5faXNMb2NrZWQmJih0aGlzLl9kaWZmWC52YWx1ZT0tKHRoaXMubW91c2UueC10aGlzLnByZU1vdXNlLngpLHRoaXMuX2RpZmZZLnZhbHVlPXRoaXMubW91c2UueS10aGlzLnByZU1vdXNlLnksdGhpcy5faXNJbnZlcnQmJih0aGlzLl9kaWZmWC52YWx1ZT0tdGhpcy5fZGlmZlgudGFyZ2V0VmFsdWUsdGhpcy5fZGlmZlkudmFsdWU9LXRoaXMuX2RpZmZZLnRhcmdldFZhbHVlKSk7dmFyIGFuZ2xlPXZvaWQgMCxfcXVhdD12b2lkIDA7aWYodGhpcy5faXNSb3RhdGVaPjApMT09PXRoaXMuX2lzUm90YXRlWj8oYW5nbGU9LXRoaXMuX2RpZmZYLnZhbHVlKnRoaXMuX29mZnNldCxhbmdsZSo9dGhpcy5wcmVNb3VzZS55PHRoaXMuX3JvdGF0ZVpNYXJnaW4/LTE6MSxfcXVhdD1fZ2xNYXRyaXgyLmRlZmF1bHQucXVhdC5jbG9uZShbMCwwLE1hdGguc2luKGFuZ2xlKSxNYXRoLmNvcyhhbmdsZSldKSxfZ2xNYXRyaXgyLmRlZmF1bHQucXVhdC5tdWx0aXBseShfcXVhdCxtVGVtcFJvdGF0aW9uLF9xdWF0KSk6KGFuZ2xlPS10aGlzLl9kaWZmWS52YWx1ZSp0aGlzLl9vZmZzZXQsYW5nbGUqPXRoaXMucHJlTW91c2UueDx0aGlzLl9yb3RhdGVaTWFyZ2luPzE6LTEsX3F1YXQ9X2dsTWF0cml4Mi5kZWZhdWx0LnF1YXQuY2xvbmUoWzAsMCxNYXRoLnNpbihhbmdsZSksTWF0aC5jb3MoYW5nbGUpXSksX2dsTWF0cml4Mi5kZWZhdWx0LnF1YXQubXVsdGlwbHkoX3F1YXQsbVRlbXBSb3RhdGlvbixfcXVhdCkpO2Vsc2V7dmFyIHY9X2dsTWF0cml4Mi5kZWZhdWx0LnZlYzMuY2xvbmUoW3RoaXMuX2RpZmZYLnZhbHVlLHRoaXMuX2RpZmZZLnZhbHVlLDBdKSxheGlzPV9nbE1hdHJpeDIuZGVmYXVsdC52ZWMzLmNyZWF0ZSgpO19nbE1hdHJpeDIuZGVmYXVsdC52ZWMzLmNyb3NzKGF4aXMsdix0aGlzLl96QXhpcyksX2dsTWF0cml4Mi5kZWZhdWx0LnZlYzMubm9ybWFsaXplKGF4aXMsYXhpcyksYW5nbGU9X2dsTWF0cml4Mi5kZWZhdWx0LnZlYzMubGVuZ3RoKHYpKnRoaXMuX29mZnNldCxfcXVhdD1fZ2xNYXRyaXgyLmRlZmF1bHQucXVhdC5jbG9uZShbTWF0aC5zaW4oYW5nbGUpKmF4aXNbMF0sTWF0aC5zaW4oYW5nbGUpKmF4aXNbMV0sTWF0aC5zaW4oYW5nbGUpKmF4aXNbMl0sTWF0aC5jb3MoYW5nbGUpXSksX2dsTWF0cml4Mi5kZWZhdWx0LnF1YXQubXVsdGlwbHkobVRlbXBSb3RhdGlvbixfcXVhdCxtVGVtcFJvdGF0aW9uKX19fSx7a2V5OlwiX2xvb3BcIix2YWx1ZTpmdW5jdGlvbigpe19nbE1hdHJpeDIuZGVmYXVsdC5tYXQ0LmlkZW50aXR5KHRoaXMubSksdm9pZCAwPT09dGhpcy5fdGFyZ2V0UXVhdD8oX2dsTWF0cml4Mi5kZWZhdWx0LnF1YXQuc2V0KHRoaXMudGVtcFJvdGF0aW9uLHRoaXMuX3JvdGF0aW9uWzBdLHRoaXMuX3JvdGF0aW9uWzFdLHRoaXMuX3JvdGF0aW9uWzJdLHRoaXMuX3JvdGF0aW9uWzNdKSx0aGlzLl91cGRhdGVSb3RhdGlvbih0aGlzLnRlbXBSb3RhdGlvbikpOih0aGlzLl9zbGVycCs9LjEqKDAtdGhpcy5fc2xlcnApLHRoaXMuX3NsZXJwPDVlLTQ/KF9nbE1hdHJpeDIuZGVmYXVsdC5xdWF0LmNvcHkodGhpcy5fcm90YXRpb24sdGhpcy5fdGFyZ2V0UXVhdCksX2dsTWF0cml4Mi5kZWZhdWx0LnF1YXQuY29weSh0aGlzLnRlbXBSb3RhdGlvbix0aGlzLl90YXJnZXRRdWF0KSx0aGlzLl90YXJnZXRRdWF0PXZvaWQgMCx0aGlzLl9kaWZmWC5zZXRUbygwKSx0aGlzLl9kaWZmWS5zZXRUbygwKSx0aGlzLl9zbGVycD0tMSk6KF9nbE1hdHJpeDIuZGVmYXVsdC5xdWF0LnNldCh0aGlzLnRlbXBSb3RhdGlvbiwwLDAsMCwwKSxfZ2xNYXRyaXgyLmRlZmF1bHQucXVhdC5zbGVycCh0aGlzLnRlbXBSb3RhdGlvbix0aGlzLl90YXJnZXRRdWF0LHRoaXMuX3JvdGF0aW9uLHRoaXMuX3NsZXJwKSkpLF9nbE1hdHJpeDIuZGVmYXVsdC52ZWMzLnRyYW5zZm9ybVF1YXQodGhpcy5fdlpheGlzLHRoaXMuX3ZaYXhpcyx0aGlzLnRlbXBSb3RhdGlvbiksX2dsTWF0cml4Mi5kZWZhdWx0Lm1hdDQuZnJvbVF1YXQodGhpcy5tYXRyaXgsdGhpcy50ZW1wUm90YXRpb24pfX0se2tleTpcImVhc2luZ1wiLHNldDpmdW5jdGlvbihtVmFsdWUpe3RoaXMuX2RpZmZYLmVhc2luZz1tVmFsdWUsdGhpcy5fZGlmZlkuZWFzaW5nPW1WYWx1ZX0sZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2RpZmZYLmVhc2luZ319XSksUXVhdFJvdGF0aW9ufSgpO2V4cG9ydHMuZGVmYXVsdD1RdWF0Um90YXRpb259LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLGNhbGwpe2lmKCFzZWxmKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hY2FsbHx8XCJvYmplY3RcIiE9dHlwZW9mIGNhbGwmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGNhbGw/c2VsZjpjYWxsfWZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcyxzdXBlckNsYXNzKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBzdXBlckNsYXNzJiZudWxsIT09c3VwZXJDbGFzcyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2Ygc3VwZXJDbGFzcyk7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyYmc3VwZXJDbGFzcy5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpzdWJDbGFzcyxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxzdXBlckNsYXNzJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcyxzdXBlckNsYXNzKTpzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzcyl9ZnVuY3Rpb24gZGlzdGFuY2UoYSxiKXt2YXIgZHg9YS54LWIueCxkeT1hLnktYi55O3JldHVybiBNYXRoLnNxcnQoZHgqZHgrZHkqZHkpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHwhMSxkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBkZXNjcmlwdG9yJiYoZGVzY3JpcHRvci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCxkZXNjcmlwdG9yLmtleSxkZXNjcmlwdG9yKX19cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe3JldHVybiBwcm90b1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKSxzdGF0aWNQcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyksQ29uc3RydWN0b3J9fSgpLF9HTFRvb2w9X193ZWJwYWNrX3JlcXVpcmVfXygwKSxfR0xUb29sMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HTFRvb2wpLF9FdmVudERpc3BhdGNoZXIyPV9fd2VicGFja19yZXF1aXJlX18oMjgpLF9FdmVudERpc3BhdGNoZXIzPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0V2ZW50RGlzcGF0Y2hlcjIpLF9SYXk9X193ZWJwYWNrX3JlcXVpcmVfXygxNCksX1JheTI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmF5KSxfZ2V0TW91c2U9X193ZWJwYWNrX3JlcXVpcmVfXyg2MiksX2dldE1vdXNlMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRNb3VzZSksVG91Y2hEZXRlY3Rvcj1mdW5jdGlvbihfRXZlbnREaXNwYXRjaGVyKXtmdW5jdGlvbiBUb3VjaERldGVjdG9yKG1NZXNoLG1DYW1lcmEpe3ZhciBtU2tpcE1vdmVDaGVjaz1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdLG1MaXN0ZW5lclRhcmdldD1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106d2luZG93O19jbGFzc0NhbGxDaGVjayh0aGlzLFRvdWNoRGV0ZWN0b3IpO3ZhciBfdGhpcz1fcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLChUb3VjaERldGVjdG9yLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKFRvdWNoRGV0ZWN0b3IpKS5jYWxsKHRoaXMpKTtyZXR1cm4gX3RoaXMuX21lc2g9bU1lc2gsX3RoaXMuX21lc2guZ2VuZXJhdGVGYWNlcygpLF90aGlzLl9jYW1lcmE9bUNhbWVyYSxfdGhpcy5mYWNlVmVydGljZXM9bU1lc2guZmFjZXMubWFwKGZ1bmN0aW9uKGZhY2Upe3JldHVybiBmYWNlLnZlcnRpY2VzfSksX3RoaXMuY2xpY2tUb2xlcmFuY2U9OCxfdGhpcy5fcmF5PW5ldyBfUmF5Mi5kZWZhdWx0KFswLDAsMF0sWzAsMCwtMV0pLF90aGlzLl9oaXQ9dmVjMy5mcm9tVmFsdWVzKC05OTksLTk5OSwtOTk5KSxfdGhpcy5fbGFzdFBvcyxfdGhpcy5fZmlyc3RQb3MsX3RoaXMubXR4TW9kZWw9bWF0NC5jcmVhdGUoKSxfdGhpcy5fbGlzdGVuZXJUYXJnZXQ9bUxpc3RlbmVyVGFyZ2V0LF90aGlzLl9za2lwcGluZ01vdmU9bVNraXBNb3ZlQ2hlY2ssX3RoaXMuX29uTW92ZUJpbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIF90aGlzLl9vbk1vdmUoZSl9LF90aGlzLl9vbkRvd25CaW5kPWZ1bmN0aW9uKGUpe3JldHVybiBfdGhpcy5fb25Eb3duKGUpfSxfdGhpcy5fb25VcEJpbmQ9ZnVuY3Rpb24oKXtyZXR1cm4gX3RoaXMuX29uVXAoKX0sX3RoaXMuY29ubmVjdCgpLF90aGlzfXJldHVybiBfaW5oZXJpdHMoVG91Y2hEZXRlY3RvcixfRXZlbnREaXNwYXRjaGVyKSxfY3JlYXRlQ2xhc3MoVG91Y2hEZXRlY3Rvcixbe2tleTpcImNvbm5lY3RcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIix0aGlzLl9vbkRvd25CaW5kKSx0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsdGhpcy5fb25Nb3ZlQmluZCksdGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIix0aGlzLl9vblVwQmluZCl9fSx7a2V5OlwiZGlzY29ubmVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLHRoaXMuX29uRG93bkJpbmQpLHRoaXMuX2xpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIix0aGlzLl9vbk1vdmVCaW5kKSx0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHRoaXMuX29uVXBCaW5kKX19LHtrZXk6XCJfY2hlY2tIaXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBfdGhpczI9dGhpcyxtVHlwZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06XCJvbkhpdFwiLGNhbWVyYT10aGlzLl9jYW1lcmE7aWYoY2FtZXJhKXt2YXIgbXg9dGhpcy5fbGFzdFBvcy54L19HTFRvb2wyLmRlZmF1bHQud2lkdGgqMi0xLG15PS10aGlzLl9sYXN0UG9zLnkvX0dMVG9vbDIuZGVmYXVsdC5oZWlnaHQqMisxO2NhbWVyYS5nZW5lcmF0ZVJheShbbXgsbXksMF0sdGhpcy5fcmF5KTtmb3IodmFyIGhpdD12b2lkIDAsdjA9dmVjMy5jcmVhdGUoKSx2MT12ZWMzLmNyZWF0ZSgpLHYyPXZlYzMuY3JlYXRlKCksZGlzdD0wLGdldFZlY3Rvcj1mdW5jdGlvbih2LHRhcmdldCl7dmVjMy50cmFuc2Zvcm1NYXQ0KHRhcmdldCx2LF90aGlzMi5tdHhNb2RlbCl9LGk9MDtpPHRoaXMuZmFjZVZlcnRpY2VzLmxlbmd0aDtpKyspe3ZhciB2ZXJ0aWNlcz10aGlzLmZhY2VWZXJ0aWNlc1tpXTtnZXRWZWN0b3IodmVydGljZXNbMF0sdjApLGdldFZlY3Rvcih2ZXJ0aWNlc1sxXSx2MSksZ2V0VmVjdG9yKHZlcnRpY2VzWzJdLHYyKTt2YXIgdD10aGlzLl9yYXkuaW50ZXJzZWN0VHJpYW5nbGUodjAsdjEsdjIpO2lmKHQpaWYoaGl0KXt2YXIgZGlzdFRvQ2FtPXZlYzMuZGlzdCh0LGNhbWVyYS5wb3NpdGlvbik7ZGlzdFRvQ2FtPGRpc3QmJihoaXQ9dmVjMy5jbG9uZSh0KSxkaXN0PWRpc3RUb0NhbSl9ZWxzZSBoaXQ9dmVjMy5jbG9uZSh0KSxkaXN0PXZlYzMuZGlzdChoaXQsY2FtZXJhLnBvc2l0aW9uKX1oaXQ/KHRoaXMuX2hpdD12ZWMzLmNsb25lKGhpdCksdGhpcy5kaXNwYXRjaEN1c3RvbUV2ZW50KG1UeXBlLHtoaXQ6aGl0fSkpOnRoaXMuZGlzcGF0Y2hDdXN0b21FdmVudChcIm9uVXBcIil9fX0se2tleTpcIl9vbkRvd25cIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLl9maXJzdFBvcz0oMCxfZ2V0TW91c2UyLmRlZmF1bHQpKGUpLHRoaXMuX2xhc3RQb3M9KDAsX2dldE1vdXNlMi5kZWZhdWx0KShlKSx0aGlzLl9jaGVja0hpdChcIm9uRG93blwiKX19LHtrZXk6XCJfb25Nb3ZlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fbGFzdFBvcz0oMCxfZ2V0TW91c2UyLmRlZmF1bHQpKGUpLHRoaXMuX3NraXBwaW5nTW92ZXx8dGhpcy5fY2hlY2tIaXQoKX19LHtrZXk6XCJfb25VcFwiLHZhbHVlOmZ1bmN0aW9uKCl7ZGlzdGFuY2UodGhpcy5fZmlyc3RQb3MsdGhpcy5fbGFzdFBvcyk8dGhpcy5jbGlja1RvbGVyYW5jZSYmdGhpcy5fY2hlY2tIaXQoKX19XSksVG91Y2hEZXRlY3Rvcn0oX0V2ZW50RGlzcGF0Y2hlcjMuZGVmYXVsdCk7ZXhwb3J0cy5kZWZhdWx0PVRvdWNoRGV0ZWN0b3J9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGV4cG9ydHMuZGVmYXVsdD1mdW5jdGlvbihlKXt2YXIgeD12b2lkIDAseT12b2lkIDA7cmV0dXJuIGUudG91Y2hlcz8oeD1lLnRvdWNoZXNbMF0ucGFnZVgseT1lLnRvdWNoZXNbMF0ucGFnZVkpOih4PWUuY2xpZW50WCx5PWUuY2xpZW50WSkse3g6eCx5Onl9fX0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLENvbnN0cnVjdG9yKXtpZighKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZixjYWxsKXtpZighc2VsZil0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWNhbGx8fFwib2JqZWN0XCIhPXR5cGVvZiBjYWxsJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBjYWxsP3NlbGY6Y2FsbH1mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3Msc3VwZXJDbGFzcyl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygc3VwZXJDbGFzcyYmbnVsbCE9PXN1cGVyQ2xhc3MpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHN1cGVyQ2xhc3MpO3N1YkNsYXNzLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MmJnN1cGVyQ2xhc3MucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6c3ViQ2xhc3MsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksc3VwZXJDbGFzcyYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3Msc3VwZXJDbGFzcyk6c3ViQ2xhc3MuX19wcm90b19fPXN1cGVyQ2xhc3MpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHwhMSxkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBkZXNjcmlwdG9yJiYoZGVzY3JpcHRvci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCxkZXNjcmlwdG9yLmtleSxkZXNjcmlwdG9yKX19cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe3JldHVybiBwcm90b1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKSxzdGF0aWNQcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyksQ29uc3RydWN0b3J9fSgpLF9DYW1lcmFQZXJzcGVjdGl2ZTI9X193ZWJwYWNrX3JlcXVpcmVfXygxNiksX0NhbWVyYVBlcnNwZWN0aXZlMz1mdW5jdGlvbihvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7ZGVmYXVsdDpvYmp9fShfQ2FtZXJhUGVyc3BlY3RpdmUyKSxfZ2xNYXRyaXg9X193ZWJwYWNrX3JlcXVpcmVfXygxKSxDQU1FUkFfU0VUVElOR1M9W1tfZ2xNYXRyaXgudmVjMy5mcm9tVmFsdWVzKDAsMCwwKSxfZ2xNYXRyaXgudmVjMy5mcm9tVmFsdWVzKDEsMCwwKSxfZ2xNYXRyaXgudmVjMy5mcm9tVmFsdWVzKDAsLTEsMCldLFtfZ2xNYXRyaXgudmVjMy5mcm9tVmFsdWVzKDAsMCwwKSxfZ2xNYXRyaXgudmVjMy5mcm9tVmFsdWVzKC0xLDAsMCksX2dsTWF0cml4LnZlYzMuZnJvbVZhbHVlcygwLC0xLDApXSxbX2dsTWF0cml4LnZlYzMuZnJvbVZhbHVlcygwLDAsMCksX2dsTWF0cml4LnZlYzMuZnJvbVZhbHVlcygwLDEsMCksX2dsTWF0cml4LnZlYzMuZnJvbVZhbHVlcygwLDAsMSldLFtfZ2xNYXRyaXgudmVjMy5mcm9tVmFsdWVzKDAsMCwwKSxfZ2xNYXRyaXgudmVjMy5mcm9tVmFsdWVzKDAsLTEsMCksX2dsTWF0cml4LnZlYzMuZnJvbVZhbHVlcygwLDAsLTEpXSxbX2dsTWF0cml4LnZlYzMuZnJvbVZhbHVlcygwLDAsMCksX2dsTWF0cml4LnZlYzMuZnJvbVZhbHVlcygwLDAsMSksX2dsTWF0cml4LnZlYzMuZnJvbVZhbHVlcygwLC0xLDApXSxbX2dsTWF0cml4LnZlYzMuZnJvbVZhbHVlcygwLDAsMCksX2dsTWF0cml4LnZlYzMuZnJvbVZhbHVlcygwLDAsLTEpLF9nbE1hdHJpeC52ZWMzLmZyb21WYWx1ZXMoMCwtMSwwKV1dLENhbWVyYUN1YmU9ZnVuY3Rpb24oX0NhbWVyYVBlcnNwZWN0aXZlKXtmdW5jdGlvbiBDYW1lcmFDdWJlKCl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsQ2FtZXJhQ3ViZSk7dmFyIF90aGlzPV9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsKENhbWVyYUN1YmUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2FtZXJhQ3ViZSkpLmNhbGwodGhpcykpO3JldHVybiBfdGhpcy5zZXRQZXJzcGVjdGl2ZShNYXRoLlBJLzIsMSwuMSwxZTMpLF90aGlzfXJldHVybiBfaW5oZXJpdHMoQ2FtZXJhQ3ViZSxfQ2FtZXJhUGVyc3BlY3RpdmUpLF9jcmVhdGVDbGFzcyhDYW1lcmFDdWJlLFt7a2V5OlwiZmFjZVwiLHZhbHVlOmZ1bmN0aW9uKG1JbmRleCl7dmFyIG89Q0FNRVJBX1NFVFRJTkdTW21JbmRleF07dGhpcy5sb29rQXQob1swXSxvWzFdLG9bMl0pfX1dKSxDYW1lcmFDdWJlfShfQ2FtZXJhUGVyc3BlY3RpdmUzLmRlZmF1bHQpO2V4cG9ydHMuZGVmYXVsdD1DYW1lcmFDdWJlfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntkZWZhdWx0Om9ian19ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLENvbnN0cnVjdG9yKXtpZighKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZixjYWxsKXtpZighc2VsZil0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWNhbGx8fFwib2JqZWN0XCIhPXR5cGVvZiBjYWxsJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBjYWxsP3NlbGY6Y2FsbH1mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3Msc3VwZXJDbGFzcyl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygc3VwZXJDbGFzcyYmbnVsbCE9PXN1cGVyQ2xhc3MpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHN1cGVyQ2xhc3MpO3N1YkNsYXNzLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MmJnN1cGVyQ2xhc3MucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6c3ViQ2xhc3MsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksc3VwZXJDbGFzcyYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3Msc3VwZXJDbGFzcyk6c3ViQ2xhc3MuX19wcm90b19fPXN1cGVyQ2xhc3MpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHwhMSxkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBkZXNjcmlwdG9yJiYoZGVzY3JpcHRvci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCxkZXNjcmlwdG9yLmtleSxkZXNjcmlwdG9yKX19cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe3JldHVybiBwcm90b1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKSxzdGF0aWNQcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyksQ29uc3RydWN0b3J9fSgpLF9nZXQ9ZnVuY3Rpb24gZ2V0KG9iamVjdCxwcm9wZXJ0eSxyZWNlaXZlcil7bnVsbD09PW9iamVjdCYmKG9iamVjdD1GdW5jdGlvbi5wcm90b3R5cGUpO3ZhciBkZXNjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LHByb3BlcnR5KTtpZih2b2lkIDA9PT1kZXNjKXt2YXIgcGFyZW50PU9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpO3JldHVybiBudWxsPT09cGFyZW50P3ZvaWQgMDpnZXQocGFyZW50LHByb3BlcnR5LHJlY2VpdmVyKX1pZihcInZhbHVlXCJpbiBkZXNjKXJldHVybiBkZXNjLnZhbHVlO3ZhciBnZXR0ZXI9ZGVzYy5nZXQ7aWYodm9pZCAwIT09Z2V0dGVyKXJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcil9LF9CaW5hcnlMb2FkZXIyPV9fd2VicGFja19yZXF1aXJlX18oMTcpLF9CaW5hcnlMb2FkZXIzPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JpbmFyeUxvYWRlcjIpLF9NZXNoPV9fd2VicGFja19yZXF1aXJlX18oNSksX01lc2gyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01lc2gpLE9iakxvYWRlcj1mdW5jdGlvbihfQmluYXJ5TG9hZGVyKXtmdW5jdGlvbiBPYmpMb2FkZXIoKXtyZXR1cm4gX2NsYXNzQ2FsbENoZWNrKHRoaXMsT2JqTG9hZGVyKSxfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLChPYmpMb2FkZXIuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqTG9hZGVyKSkuYXBwbHkodGhpcyxhcmd1bWVudHMpKX1yZXR1cm4gX2luaGVyaXRzKE9iakxvYWRlcixfQmluYXJ5TG9hZGVyKSxfY3JlYXRlQ2xhc3MoT2JqTG9hZGVyLFt7a2V5OlwibG9hZFwiLHZhbHVlOmZ1bmN0aW9uKHVybCxjYWxsYmFjayl7dmFyIGRyYXdUeXBlPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTo0O3RoaXMuX2RyYXdUeXBlPWRyYXdUeXBlLF9nZXQoT2JqTG9hZGVyLnByb3RvdHlwZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmpMb2FkZXIucHJvdG90eXBlKSxcImxvYWRcIix0aGlzKS5jYWxsKHRoaXMsdXJsLGNhbGxiYWNrKX19LHtrZXk6XCJfb25Mb2FkZWRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucGFyc2VPYmoodGhpcy5fcmVxLnJlc3BvbnNlKX19LHtrZXk6XCJwYXJzZU9ialwiLHZhbHVlOmZ1bmN0aW9uKG9ialN0cil7ZnVuY3Rpb24gcGFyc2VWZXJ0ZXhJbmRleCh2YWx1ZSl7dmFyIGluZGV4PXBhcnNlSW50KHZhbHVlKTtyZXR1cm4gMyooaW5kZXg+PTA/aW5kZXgtMTppbmRleCt2ZXJ0aWNlcy5sZW5ndGgvMyl9ZnVuY3Rpb24gcGFyc2VOb3JtYWxJbmRleCh2YWx1ZSl7dmFyIGluZGV4PXBhcnNlSW50KHZhbHVlKTtyZXR1cm4gMyooaW5kZXg+PTA/aW5kZXgtMTppbmRleCtub3JtYWxzLmxlbmd0aC8zKX1mdW5jdGlvbiBwYXJzZVVWSW5kZXgodmFsdWUpe3ZhciBpbmRleD1wYXJzZUludCh2YWx1ZSk7cmV0dXJuIDIqKGluZGV4Pj0wP2luZGV4LTE6aW5kZXgrdXZzLmxlbmd0aC8yKX1mdW5jdGlvbiBhZGRWZXJ0ZXgoYSxiLGMpe3Bvc2l0aW9ucy5wdXNoKFt2ZXJ0aWNlc1thXSx2ZXJ0aWNlc1thKzFdLHZlcnRpY2VzW2ErMl1dKSxwb3NpdGlvbnMucHVzaChbdmVydGljZXNbYl0sdmVydGljZXNbYisxXSx2ZXJ0aWNlc1tiKzJdXSkscG9zaXRpb25zLnB1c2goW3ZlcnRpY2VzW2NdLHZlcnRpY2VzW2MrMV0sdmVydGljZXNbYysyXV0pLGluZGljZXMucHVzaCgzKmNvdW50KzApLGluZGljZXMucHVzaCgzKmNvdW50KzEpLGluZGljZXMucHVzaCgzKmNvdW50KzIpLGNvdW50Kyt9ZnVuY3Rpb24gYWRkVVYoYSxiLGMpe2Nvb3Jkcy5wdXNoKFt1dnNbYV0sdXZzW2ErMV1dKSxjb29yZHMucHVzaChbdXZzW2JdLHV2c1tiKzFdXSksY29vcmRzLnB1c2goW3V2c1tjXSx1dnNbYysxXV0pfWZ1bmN0aW9uIGFkZE5vcm1hbChhLGIsYyl7ZmluYWxOb3JtYWxzLnB1c2goW25vcm1hbHNbYV0sbm9ybWFsc1thKzFdLG5vcm1hbHNbYSsyXV0pLGZpbmFsTm9ybWFscy5wdXNoKFtub3JtYWxzW2JdLG5vcm1hbHNbYisxXSxub3JtYWxzW2IrMl1dKSxmaW5hbE5vcm1hbHMucHVzaChbbm9ybWFsc1tjXSxub3JtYWxzW2MrMV0sbm9ybWFsc1tjKzJdXSl9ZnVuY3Rpb24gYWRkRmFjZShhLGIsYyxkLHVhLHViLHVjLHVkLG5hLG5iLG5jLG5kKXt2YXIgaWE9cGFyc2VWZXJ0ZXhJbmRleChhKSxpYj1wYXJzZVZlcnRleEluZGV4KGIpLGljPXBhcnNlVmVydGV4SW5kZXgoYyksaWQ9dm9pZCAwO3ZvaWQgMD09PWQ/YWRkVmVydGV4KGlhLGliLGljKTooaWQ9cGFyc2VWZXJ0ZXhJbmRleChkKSxhZGRWZXJ0ZXgoaWEsaWIsaWQpLGFkZFZlcnRleChpYixpYyxpZCkpLHZvaWQgMCE9PXVhJiYoaWE9cGFyc2VVVkluZGV4KHVhKSxpYj1wYXJzZVVWSW5kZXgodWIpLGljPXBhcnNlVVZJbmRleCh1Yyksdm9pZCAwPT09ZD9hZGRVVihpYSxpYixpYyk6KGlkPXBhcnNlVVZJbmRleCh1ZCksYWRkVVYoaWEsaWIsaWQpLGFkZFVWKGliLGljLGlkKSkpLHZvaWQgMCE9PW5hJiYoaWE9cGFyc2VOb3JtYWxJbmRleChuYSksaWI9cGFyc2VOb3JtYWxJbmRleChuYiksaWM9cGFyc2VOb3JtYWxJbmRleChuYyksdm9pZCAwPT09ZD9hZGROb3JtYWwoaWEsaWIsaWMpOihpZD1wYXJzZU5vcm1hbEluZGV4KG5kKSxhZGROb3JtYWwoaWEsaWIsaWQpLGFkZE5vcm1hbChpYixpYyxpZCkpKX1mb3IodmFyIGxpbmVzPW9ialN0ci5zcGxpdChcIlxcblwiKSxwb3NpdGlvbnM9W10sY29vcmRzPVtdLGZpbmFsTm9ybWFscz1bXSx2ZXJ0aWNlcz1bXSxub3JtYWxzPVtdLHV2cz1bXSxpbmRpY2VzPVtdLGNvdW50PTAscmVzdWx0PXZvaWQgMCx2ZXJ0ZXhQYXR0ZXJuPS92KCArW1xcZHxcXC58XFwrfFxcLXxlfEVdKykoICtbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKSggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspLyxub3JtYWxQYXR0ZXJuPS92biggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspKCArW1xcZHxcXC58XFwrfFxcLXxlfEVdKykoICtbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKS8sdXZQYXR0ZXJuPS92dCggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspKCArW1xcZHxcXC58XFwrfFxcLXxlfEVdKykvLGZhY2VQYXR0ZXJuMT0vZiggKy0/XFxkKykoICstP1xcZCspKCArLT9cXGQrKSggKy0/XFxkKyk/LyxmYWNlUGF0dGVybjI9L2YoICsoLT9cXGQrKVxcLygtP1xcZCspKSggKygtP1xcZCspXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcLygtP1xcZCspKT8vLGZhY2VQYXR0ZXJuMz0vZiggKygtP1xcZCspXFwvKC0/XFxkKylcXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcLygtP1xcZCspXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC8oLT9cXGQrKVxcLygtP1xcZCspKSggKygtP1xcZCspXFwvKC0/XFxkKylcXC8oLT9cXGQrKSk/LyxmYWNlUGF0dGVybjQ9L2YoICsoLT9cXGQrKVxcL1xcLygtP1xcZCspKSggKygtP1xcZCspXFwvXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC9cXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcL1xcLygtP1xcZCspKT8vLGk9MDtpPGxpbmVzLmxlbmd0aDtpKyspe3ZhciBsaW5lPWxpbmVzW2ldO2xpbmU9bGluZS50cmltKCksMCE9PWxpbmUubGVuZ3RoJiZcIiNcIiE9PWxpbmUuY2hhckF0KDApJiYobnVsbCE9PShyZXN1bHQ9dmVydGV4UGF0dGVybi5leGVjKGxpbmUpKT92ZXJ0aWNlcy5wdXNoKHBhcnNlRmxvYXQocmVzdWx0WzFdKSxwYXJzZUZsb2F0KHJlc3VsdFsyXSkscGFyc2VGbG9hdChyZXN1bHRbM10pKTpudWxsIT09KHJlc3VsdD1ub3JtYWxQYXR0ZXJuLmV4ZWMobGluZSkpP25vcm1hbHMucHVzaChwYXJzZUZsb2F0KHJlc3VsdFsxXSkscGFyc2VGbG9hdChyZXN1bHRbMl0pLHBhcnNlRmxvYXQocmVzdWx0WzNdKSk6bnVsbCE9PShyZXN1bHQ9dXZQYXR0ZXJuLmV4ZWMobGluZSkpP3V2cy5wdXNoKHBhcnNlRmxvYXQocmVzdWx0WzFdKSxwYXJzZUZsb2F0KHJlc3VsdFsyXSkpOm51bGwhPT0ocmVzdWx0PWZhY2VQYXR0ZXJuMS5leGVjKGxpbmUpKT9hZGRGYWNlKHJlc3VsdFsxXSxyZXN1bHRbMl0scmVzdWx0WzNdLHJlc3VsdFs0XSk6bnVsbCE9PShyZXN1bHQ9ZmFjZVBhdHRlcm4yLmV4ZWMobGluZSkpP2FkZEZhY2UocmVzdWx0WzJdLHJlc3VsdFs1XSxyZXN1bHRbOF0scmVzdWx0WzExXSxyZXN1bHRbM10scmVzdWx0WzZdLHJlc3VsdFs5XSxyZXN1bHRbMTJdKTpudWxsIT09KHJlc3VsdD1mYWNlUGF0dGVybjMuZXhlYyhsaW5lKSk/YWRkRmFjZShyZXN1bHRbMl0scmVzdWx0WzZdLHJlc3VsdFsxMF0scmVzdWx0WzE0XSxyZXN1bHRbM10scmVzdWx0WzddLHJlc3VsdFsxMV0scmVzdWx0WzE1XSxyZXN1bHRbNF0scmVzdWx0WzhdLHJlc3VsdFsxMl0scmVzdWx0WzE2XSk6bnVsbCE9PShyZXN1bHQ9ZmFjZVBhdHRlcm40LmV4ZWMobGluZSkpJiZhZGRGYWNlKHJlc3VsdFsyXSxyZXN1bHRbNV0scmVzdWx0WzhdLHJlc3VsdFsxMV0sdm9pZCAwLHZvaWQgMCx2b2lkIDAsdm9pZCAwLHJlc3VsdFszXSxyZXN1bHRbNl0scmVzdWx0WzldLHJlc3VsdFsxMl0pKX1yZXR1cm4gdGhpcy5fZ2VuZXJhdGVNZXNoZXMoe3Bvc2l0aW9uczpwb3NpdGlvbnMsY29vcmRzOmNvb3Jkcyxub3JtYWxzOmZpbmFsTm9ybWFscyxpbmRpY2VzOmluZGljZXN9KX19LHtrZXk6XCJfZ2VuZXJhdGVNZXNoZXNcIix2YWx1ZTpmdW5jdGlvbihvKXt2YXIgaGFzTm9ybWFscz1vLm5vcm1hbHMubGVuZ3RoPjAsaGFzVVZzPW8uY29vcmRzLmxlbmd0aD4wLG1lc2g9dm9pZCAwO2lmKG8ucG9zaXRpb25zLmxlbmd0aD42NTUzNSl7dmFyIG1lc2hlcz1bXSxsYXN0SW5kZXg9MCxvQ29weT17fTtmb3Iob0NvcHkucG9zaXRpb25zPW8ucG9zaXRpb25zLmNvbmNhdCgpLG9Db3B5LmNvb3Jkcz1vLmNvb3Jkcy5jb25jYXQoKSxvQ29weS5pbmRpY2VzPW8uaW5kaWNlcy5jb25jYXQoKSxvQ29weS5ub3JtYWxzPW8ubm9ybWFscy5jb25jYXQoKTtvLmluZGljZXMubGVuZ3RoPjA7KXtmb3IodmFyIHNsaWNlTnVtPU1hdGgubWluKDY1NTM1LG8ucG9zaXRpb25zLmxlbmd0aCksaW5kaWNlcz1vLmluZGljZXMuc3BsaWNlKDAsc2xpY2VOdW0pLHBvc2l0aW9ucz1bXSxjb29yZHM9W10sbm9ybWFscz1bXSxpbmRleD12b2lkIDAsdG1wSW5kZXg9MCxpPTA7aTxpbmRpY2VzLmxlbmd0aDtpKyspaW5kaWNlc1tpXT50bXBJbmRleCYmKHRtcEluZGV4PWluZGljZXNbaV0pLGluZGV4PWluZGljZXNbaV0scG9zaXRpb25zLnB1c2gob0NvcHkucG9zaXRpb25zW2luZGV4XSksaGFzVVZzJiZjb29yZHMucHVzaChvQ29weS5jb29yZHNbaW5kZXhdKSxoYXNOb3JtYWxzJiZub3JtYWxzLnB1c2gob0NvcHkubm9ybWFsc1tpbmRleF0pLGluZGljZXNbaV0tPWxhc3RJbmRleDtsYXN0SW5kZXg9dG1wSW5kZXgrMSxtZXNoPW5ldyBfTWVzaDIuZGVmYXVsdCh0aGlzLl9kcmF3VHlwZSksbWVzaC5idWZmZXJWZXJ0ZXgocG9zaXRpb25zKSxoYXNVVnMmJm1lc2guYnVmZmVyVGV4Q29vcmQoY29vcmRzKSxtZXNoLmJ1ZmZlckluZGV4KGluZGljZXMpLGhhc05vcm1hbHMmJm1lc2guYnVmZmVyTm9ybWFsKG5vcm1hbHMpLG1lc2hlcy5wdXNoKG1lc2gpfXJldHVybiB0aGlzLl9jYWxsYmFjayYmdGhpcy5fY2FsbGJhY2sobWVzaGVzLG9Db3B5KSxtZXNoZXN9cmV0dXJuIG1lc2g9bmV3IF9NZXNoMi5kZWZhdWx0KHRoaXMuX2RyYXdUeXBlKSxtZXNoLmJ1ZmZlclZlcnRleChvLnBvc2l0aW9ucyksaGFzVVZzJiZtZXNoLmJ1ZmZlclRleENvb3JkKG8uY29vcmRzKSxtZXNoLmJ1ZmZlckluZGV4KG8uaW5kaWNlcyksaGFzTm9ybWFscyYmbWVzaC5idWZmZXJOb3JtYWwoby5ub3JtYWxzKSx0aGlzLl9jYWxsYmFjayYmdGhpcy5fY2FsbGJhY2sobWVzaCxvKSxtZXNofX1dKSxPYmpMb2FkZXJ9KF9CaW5hcnlMb2FkZXIzLmRlZmF1bHQpO09iakxvYWRlci5wYXJzZT1mdW5jdGlvbihvYmpTdHIpe3JldHVybihuZXcgT2JqTG9hZGVyKS5wYXJzZU9iaihvYmpTdHIpfSxleHBvcnRzLmRlZmF1bHQ9T2JqTG9hZGVyfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntkZWZhdWx0Om9ian19ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLENvbnN0cnVjdG9yKXtpZighKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZixjYWxsKXtpZighc2VsZil0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWNhbGx8fFwib2JqZWN0XCIhPXR5cGVvZiBjYWxsJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBjYWxsP3NlbGY6Y2FsbH1mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3Msc3VwZXJDbGFzcyl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygc3VwZXJDbGFzcyYmbnVsbCE9PXN1cGVyQ2xhc3MpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHN1cGVyQ2xhc3MpO3N1YkNsYXNzLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MmJnN1cGVyQ2xhc3MucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6c3ViQ2xhc3MsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksc3VwZXJDbGFzcyYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3Msc3VwZXJDbGFzcyk6c3ViQ2xhc3MuX19wcm90b19fPXN1cGVyQ2xhc3MpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHwhMSxkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBkZXNjcmlwdG9yJiYoZGVzY3JpcHRvci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCxkZXNjcmlwdG9yLmtleSxkZXNjcmlwdG9yKX19cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe3JldHVybiBwcm90b1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKSxzdGF0aWNQcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyksQ29uc3RydWN0b3J9fSgpLF9CaW5hcnlMb2FkZXIyPV9fd2VicGFja19yZXF1aXJlX18oMTcpLF9CaW5hcnlMb2FkZXIzPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JpbmFyeUxvYWRlcjIpLF9IRFJQYXJzZXI9X193ZWJwYWNrX3JlcXVpcmVfXyg2NiksX0hEUlBhcnNlcjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSERSUGFyc2VyKSxIRFJMb2FkZXI9ZnVuY3Rpb24oX0JpbmFyeUxvYWRlcil7ZnVuY3Rpb24gSERSTG9hZGVyKCl7cmV0dXJuIF9jbGFzc0NhbGxDaGVjayh0aGlzLEhEUkxvYWRlciksX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywoSERSTG9hZGVyLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKEhEUkxvYWRlcikpLmNhbGwodGhpcywhMCkpfXJldHVybiBfaW5oZXJpdHMoSERSTG9hZGVyLF9CaW5hcnlMb2FkZXIpLF9jcmVhdGVDbGFzcyhIRFJMb2FkZXIsW3trZXk6XCJwYXJzZVwiLHZhbHVlOmZ1bmN0aW9uKG1BcnJheUJ1ZmZlcil7cmV0dXJuKDAsX0hEUlBhcnNlcjIuZGVmYXVsdCkobUFycmF5QnVmZmVyKX19LHtrZXk6XCJfb25Mb2FkZWRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBvPXRoaXMucGFyc2UodGhpcy5fcmVxLnJlc3BvbnNlKTt0aGlzLl9jYWxsYmFjayYmdGhpcy5fY2FsbGJhY2sobyl9fV0pLEhEUkxvYWRlcn0oX0JpbmFyeUxvYWRlcjMuZGVmYXVsdCk7SERSTG9hZGVyLnBhcnNlPWZ1bmN0aW9uKG1BcnJheUJ1ZmZlcil7cmV0dXJuKDAsX0hEUlBhcnNlcjIuZGVmYXVsdCkobUFycmF5QnVmZmVyKX0sZXhwb3J0cy5kZWZhdWx0PUhEUkxvYWRlcn0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcmVhZFBpeGVsc1Jhd1JMRShidWZmZXIsZGF0YSxvZmZzZXQsZmlsZU9mZnNldCxzY2FubGluZVdpZHRoLG51bVNjYW5saW5lcyl7ZnVuY3Rpb24gcmVhZEJ1ZihidWYpe3ZhciBieXRlc1JlYWQ9MDtkb3tidWZbYnl0ZXNSZWFkKytdPWJ1ZmZlcltmaWxlT2Zmc2V0XX13aGlsZSgrK2ZpbGVPZmZzZXQ8YnVmZmVyTGVuZ3RoJiZieXRlc1JlYWQ8YnVmLmxlbmd0aCk7cmV0dXJuIGJ5dGVzUmVhZH1mdW5jdGlvbiByZWFkQnVmT2Zmc2V0KGJ1ZixvZmZzZXQsbGVuZ3RoKXt2YXIgYnl0ZXNSZWFkPTA7ZG97YnVmW29mZnNldCtieXRlc1JlYWQrK109YnVmZmVyW2ZpbGVPZmZzZXRdfXdoaWxlKCsrZmlsZU9mZnNldDxidWZmZXJMZW5ndGgmJmJ5dGVzUmVhZDxsZW5ndGgpO3JldHVybiBieXRlc1JlYWR9Zm9yKHZhciByZ2JlPW5ldyBBcnJheSg0KSxzY2FubGluZUJ1ZmZlcj1udWxsLHB0cj12b2lkIDAscHRyRW5kPXZvaWQgMCxjb3VudD12b2lkIDAsYnVmPW5ldyBBcnJheSgyKSxidWZmZXJMZW5ndGg9YnVmZmVyLmxlbmd0aDtudW1TY2FubGluZXM+MDspe2lmKHJlYWRCdWYocmdiZSk8cmdiZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcmVhZGluZyBieXRlczogZXhwZWN0ZWQgXCIrcmdiZS5sZW5ndGgpO2lmKDIhPT1yZ2JlWzBdfHwyIT09cmdiZVsxXXx8MCE9KDEyOCZyZ2JlWzJdKSlyZXR1cm4gZGF0YVtvZmZzZXQrK109cmdiZVswXSxkYXRhW29mZnNldCsrXT1yZ2JlWzFdLGRhdGFbb2Zmc2V0KytdPXJnYmVbMl0sZGF0YVtvZmZzZXQrK109cmdiZVszXSx2b2lkIGZ1bmN0aW9uKGJ1ZmZlcixkYXRhLG9mZnNldCxudW1waXhlbHMpe3ZhciBudW1FeHBlY3RlZD00Km51bXBpeGVscyxudW1SZWFkPXJlYWRCdWZPZmZzZXQoZGF0YSxvZmZzZXQsbnVtRXhwZWN0ZWQpO2lmKG51bVJlYWQ8bnVtRXhwZWN0ZWQpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcmVhZGluZyByYXcgcGl4ZWxzOiBnb3QgXCIrbnVtUmVhZCtcIiBieXRlcywgZXhwZWN0ZWQgXCIrbnVtRXhwZWN0ZWQpfSgwLGRhdGEsb2Zmc2V0LHNjYW5saW5lV2lkdGgqbnVtU2NhbmxpbmVzLTEpO2lmKCgoMjU1JnJnYmVbMl0pPDw4fDI1NSZyZ2JlWzNdKSE9PXNjYW5saW5lV2lkdGgpdGhyb3cgbmV3IEVycm9yKFwiV3Jvbmcgc2NhbmxpbmUgd2lkdGggXCIrKCgyNTUmcmdiZVsyXSk8PDh8MjU1JnJnYmVbM10pK1wiLCBleHBlY3RlZCBcIitzY2FubGluZVdpZHRoKTtudWxsPT09c2NhbmxpbmVCdWZmZXImJihzY2FubGluZUJ1ZmZlcj1uZXcgQXJyYXkoNCpzY2FubGluZVdpZHRoKSkscHRyPTA7Zm9yKHZhciBpPTA7aTw0O2krKylmb3IocHRyRW5kPShpKzEpKnNjYW5saW5lV2lkdGg7cHRyPHB0ckVuZDspe2lmKHJlYWRCdWYoYnVmKTxidWYubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkVycm9yIHJlYWRpbmcgMi1ieXRlIGJ1ZmZlclwiKTtpZigoMjU1JmJ1ZlswXSk+MTI4KXtpZigwPT09KGNvdW50PSgyNTUmYnVmWzBdKS0xMjgpfHxjb3VudD5wdHJFbmQtcHRyKXRocm93IG5ldyBFcnJvcihcIkJhZCBzY2FubGluZSBkYXRhXCIpO2Zvcig7Y291bnQtLSA+MDspc2NhbmxpbmVCdWZmZXJbcHRyKytdPWJ1ZlsxXX1lbHNle2lmKDA9PT0oY291bnQ9MjU1JmJ1ZlswXSl8fGNvdW50PnB0ckVuZC1wdHIpdGhyb3cgbmV3IEVycm9yKFwiQmFkIHNjYW5saW5lIGRhdGFcIik7aWYoc2NhbmxpbmVCdWZmZXJbcHRyKytdPWJ1ZlsxXSwtLWNvdW50PjApe2lmKHJlYWRCdWZPZmZzZXQoc2NhbmxpbmVCdWZmZXIscHRyLGNvdW50KTxjb3VudCl0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciByZWFkaW5nIG5vbi1ydW4gZGF0YVwiKTtwdHIrPWNvdW50fX19Zm9yKHZhciBfaT0wO19pPHNjYW5saW5lV2lkdGg7X2krKylkYXRhW29mZnNldCswXT1zY2FubGluZUJ1ZmZlcltfaV0sZGF0YVtvZmZzZXQrMV09c2NhbmxpbmVCdWZmZXJbX2krc2NhbmxpbmVXaWR0aF0sZGF0YVtvZmZzZXQrMl09c2NhbmxpbmVCdWZmZXJbX2krMipzY2FubGluZVdpZHRoXSxkYXRhW29mZnNldCszXT1zY2FubGluZUJ1ZmZlcltfaSszKnNjYW5saW5lV2lkdGhdLG9mZnNldCs9NDtudW1TY2FubGluZXMtLX19ZnVuY3Rpb24gcGFyc2VIZHIoYnVmZmVyKXtidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmKGJ1ZmZlcj1uZXcgVWludDhBcnJheShidWZmZXIpKTtmb3IodmFyIGZpbGVPZmZzZXQ9MCxidWZmZXJMZW5ndGg9YnVmZmVyLmxlbmd0aCxORVdfTElORT0xMCx3aWR0aD0wLGhlaWdodD0wLGV4cG9zdXJlPTEscmxlPSExLGk9MDtpPDIwO2krKyl7dmFyIGxpbmU9ZnVuY3Rpb24oKXt2YXIgYnVmPVwiXCI7ZG97dmFyIGI9YnVmZmVyW2ZpbGVPZmZzZXRdO2lmKGI9PT1ORVdfTElORSl7KytmaWxlT2Zmc2V0O2JyZWFrfWJ1Zis9U3RyaW5nLmZyb21DaGFyQ29kZShiKX13aGlsZSgrK2ZpbGVPZmZzZXQ8YnVmZmVyTGVuZ3RoKTtyZXR1cm4gYnVmfSgpLG1hdGNoPXZvaWQgMDtpZihtYXRjaD1saW5lLm1hdGNoKHJhZGlhbmNlUGF0dGVybikpO2Vsc2UgaWYobWF0Y2g9bGluZS5tYXRjaChmb3JtYXRQYXR0ZXJuKSlybGU9ITA7ZWxzZSBpZihtYXRjaD1saW5lLm1hdGNoKGV4cG9zdXJlUGF0dGVybikpZXhwb3N1cmU9TnVtYmVyKG1hdGNoWzFdKTtlbHNlIGlmKG1hdGNoPWxpbmUubWF0Y2goY29tbWVudFBhdHRlcm4pKTtlbHNlIGlmKG1hdGNoPWxpbmUubWF0Y2god2lkdGhIZWlnaHRQYXR0ZXJuKSl7aGVpZ2h0PU51bWJlcihtYXRjaFsxXSksd2lkdGg9TnVtYmVyKG1hdGNoWzJdKTticmVha319aWYoIXJsZSl0aHJvdyBuZXcgRXJyb3IoXCJGaWxlIGlzIG5vdCBydW4gbGVuZ3RoIGVuY29kZWQhXCIpO3ZhciBkYXRhPW5ldyBVaW50OEFycmF5KHdpZHRoKmhlaWdodCo0KTtyZWFkUGl4ZWxzUmF3UkxFKGJ1ZmZlcixkYXRhLDAsZmlsZU9mZnNldCx3aWR0aCxoZWlnaHQpO2Zvcih2YXIgZmxvYXREYXRhPW5ldyBGbG9hdDMyQXJyYXkod2lkdGgqaGVpZ2h0KjQpLG9mZnNldD0wO29mZnNldDxkYXRhLmxlbmd0aDtvZmZzZXQrPTQpe3ZhciByPWRhdGFbb2Zmc2V0KzBdLzI1NSxnPWRhdGFbb2Zmc2V0KzFdLzI1NSxiPWRhdGFbb2Zmc2V0KzJdLzI1NSxlPWRhdGFbb2Zmc2V0KzNdLGY9TWF0aC5wb3coMixlLTEyOCk7cio9ZixnKj1mLGIqPWY7dmFyIGZsb2F0T2Zmc2V0PW9mZnNldDtmbG9hdERhdGFbZmxvYXRPZmZzZXQrMF09cixmbG9hdERhdGFbZmxvYXRPZmZzZXQrMV09ZyxmbG9hdERhdGFbZmxvYXRPZmZzZXQrMl09YixmbG9hdERhdGFbZmxvYXRPZmZzZXQrM109MX1yZXR1cm57c2hhcGU6W3dpZHRoLGhlaWdodF0sZXhwb3N1cmU6ZXhwb3N1cmUsZ2FtbWE6MSxkYXRhOmZsb2F0RGF0YX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHJhZGlhbmNlUGF0dGVybj1cIiNcXFxcP1JBRElBTkNFXCIsY29tbWVudFBhdHRlcm49XCIjLipcIixleHBvc3VyZVBhdHRlcm49XCJFWFBPU1VSRT1cXFxccyooWzAtOV0qWy5dWzAtOV0qKVwiLGZvcm1hdFBhdHRlcm49XCJGT1JNQVQ9MzItYml0X3JsZV9yZ2JlXCIsd2lkdGhIZWlnaHRQYXR0ZXJuPVwiLVkgKFswLTldKykgXFxcXCtYIChbMC05XSspXCI7ZXhwb3J0cy5kZWZhdWx0PXBhcnNlSGRyfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntkZWZhdWx0Om9ian19T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9jb2xsYWRhUGFyc2VyPV9fd2VicGFja19yZXF1aXJlX18oNjgpLF9jb2xsYWRhUGFyc2VyMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb2xsYWRhUGFyc2VyKSxfTWVzaD1fX3dlYnBhY2tfcmVxdWlyZV9fKDUpLF9NZXNoMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZXNoKSxnZW5lcmF0ZU1lc2g9ZnVuY3Rpb24obWVzaGVzKXt2YXIgY2FjaGVzPXt9O21lc2hlcy5mb3JFYWNoKGZ1bmN0aW9uKG1lc2gpe3ZhciBfbWVzaCRtZXNoPW1lc2gubWVzaCx2ZXJ0aWNlcz1fbWVzaCRtZXNoLnZlcnRpY2VzLG5vcm1hbHM9X21lc2gkbWVzaC5ub3JtYWxzLGNvb3Jkcz1fbWVzaCRtZXNoLmNvb3Jkcyx0cmlhbmdsZXM9X21lc2gkbWVzaC50cmlhbmdsZXMsbmFtZT1fbWVzaCRtZXNoLm5hbWU7aWYoIWNhY2hlc1tuYW1lXSl7dmFyIGdsTWVzaD0obmV3IF9NZXNoMi5kZWZhdWx0KS5idWZmZXJGbGF0dGVuRGF0YSh2ZXJ0aWNlcyxcImFWZXJ0ZXhQb3NpdGlvblwiLDMpLmJ1ZmZlckZsYXR0ZW5EYXRhKGNvb3JkcyxcImFUZXh0dXJlQ29vcmRcIiwyKS5idWZmZXJGbGF0dGVuRGF0YShub3JtYWxzLFwiYU5vcm1hbFwiLDMpLmJ1ZmZlckluZGV4KHRyaWFuZ2xlcyk7Y2FjaGVzW25hbWVdPWdsTWVzaH1tZXNoLmdsTWVzaD1jYWNoZXNbbmFtZV19KX0scGFyc2U9ZnVuY3Rpb24obURhdGEpe3ZhciBtZXNoZXM9X2NvbGxhZGFQYXJzZXIyLmRlZmF1bHQucGFyc2UobURhdGEpO3JldHVybiBnZW5lcmF0ZU1lc2gobWVzaGVzKSxtZXNoZXN9LGxvYWQ9ZnVuY3Rpb24obVBhdGgsbUNhbGxiYWNrKXtfY29sbGFkYVBhcnNlcjIuZGVmYXVsdC5sb2FkKG1QYXRoLGZ1bmN0aW9uKG1lc2hlcyl7Z2VuZXJhdGVNZXNoKG1lc2hlcyksbUNhbGxiYWNrKG1lc2hlcyl9KX0sQ29sbGFkYVBhcnNlcj17cGFyc2U6cGFyc2UsbG9hZDpsb2FkfTtleHBvcnRzLmRlZmF1bHQ9Q29sbGFkYVBhcnNlcn0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9Db2xsYWRhPV9fd2VicGFja19yZXF1aXJlX18oNjkpLF9Db2xsYWRhMj1mdW5jdGlvbihvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7ZGVmYXVsdDpvYmp9fShfQ29sbGFkYSksX2dsTWF0cml4PV9fd2VicGFja19yZXF1aXJlX18oMSkscGFyc2VEYXRhPWZ1bmN0aW9uKG1EYXRhKXtmdW5jdGlvbiBnZXRNYXRlcmlhbChpZCl7dmFyIG1hdD12b2lkIDA7Zm9yKHZhciBfcyBpbiBtYXRlcmlhbHMpX3M9PT1pZCYmKG1hdD1tYXRlcmlhbHNbX3NdKTt2YXIgb01hdGVyaWFsPXt9O3JldHVybiBtYXQuZGlmZnVzZSYmKG9NYXRlcmlhbC5kaWZmdXNlQ29sb3I9bWF0LmRpZmZ1c2UpLG9NYXRlcmlhbC5kaWZmdXNlQ29sb3I9bWF0LmRpZmZ1c2V8fFswLDAsMF0sb01hdGVyaWFsLnNoaW5pbmVzcz1tYXQuc2hpbmluZXNzfHwwLG1hdC50ZXh0dXJlcyYmKG1hdC50ZXh0dXJlcy5kaWZmdXNlJiYob01hdGVyaWFsLmRpZmZ1c2VNYXBJRD1tYXQudGV4dHVyZXMuZGlmZnVzZS5tYXBfaWQpLG1hdC50ZXh0dXJlcy5ub3JtYWwmJihvTWF0ZXJpYWwubm9ybWFsTWFwSUQ9bWF0LnRleHR1cmVzLm5vcm1hbC5tYXBfaWQpKSxvTWF0ZXJpYWx9ZnVuY3Rpb24gd2Fsayhub2RlLG10eFBhcmVudCl7dmFyIG09X2dsTWF0cml4Lm1hdDQuY3JlYXRlKCk7aWYobm9kZS5tb2RlbD9fZ2xNYXRyaXgubWF0NC5tdWx0aXBseShtLG10eFBhcmVudCxub2RlLm1vZGVsKTpfZ2xNYXRyaXgubWF0NC5jb3B5KG0sbXR4UGFyZW50KSxub2RlLmNoaWxkcmVuLmxlbmd0aD4wJiZub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpe3dhbGsoY2hpbGQsbSl9KSxub2RlLm1lc2gpe3ZhciBfb01lc2g9e307X29NZXNoLm1vZGVsTWF0cml4PW0sX29NZXNoLm1lc2g9bWVzaGVzW25vZGUubWVzaF0sX29NZXNoLmlkPW5vZGUuaWQsX29NZXNoLm5hbWU9bm9kZS5uYW1lLF9vTWVzaC5tYXRlcmlhbD1nZXRNYXRlcmlhbChub2RlLm1hdGVyaWFsKSxtZXNoT2Jqcy5wdXNoKF9vTWVzaCl9fXZhciBtYXRlcmlhbHM9bURhdGEubWF0ZXJpYWxzLG1lc2hlcz1tRGF0YS5tZXNoZXMsbWVzaE9ianM9W10sYWxsTWVzaGVzPVtdO2Zvcih2YXIgcyBpbiBtZXNoZXMpe3ZhciBvTWVzaD1tZXNoZXNbc10sdmVydGljZXM9b01lc2gudmVydGljZXMsbm9ybWFscz1vTWVzaC5ub3JtYWxzLGNvb3Jkcz1vTWVzaC5jb29yZHMsdHJpYW5nbGVzPW9NZXNoLnRyaWFuZ2xlcyxidWZmZXJzPXt2ZXJ0aWNlczp2ZXJ0aWNlcyxub3JtYWxzOm5vcm1hbHMsY29vcmRzOmNvb3Jkcyx0cmlhbmdsZXM6dHJpYW5nbGVzfTthbGxNZXNoZXMucHVzaCh7aWQ6cyxidWZmZXJzOmJ1ZmZlcnN9KX12YXIgbXR4PV9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpO3JldHVybiB3YWxrKG1EYXRhLnJvb3QsbXR4KSxtZXNoT2Jqc30scGFyc2U9ZnVuY3Rpb24obUZpbGUpe3ZhciBvPV9Db2xsYWRhMi5kZWZhdWx0LnBhcnNlKG1GaWxlKTtyZXR1cm4gcGFyc2VEYXRhKG8pfSxsb2FkPWZ1bmN0aW9uKG1QYXRoLG1DYWxsQmFjayl7X0NvbGxhZGEyLmRlZmF1bHQubG9hZChtUGF0aCxmdW5jdGlvbihtRGF0YSl7bUNhbGxCYWNrKHBhcnNlRGF0YShtRGF0YSkpfSl9LENvbGxhZGFQYXJzZXI9e2xvYWQ6bG9hZCxwYXJzZTpwYXJzZX07ZXhwb3J0cy5kZWZhdWx0PUNvbGxhZGFQYXJzZXIsbW9kdWxlLmV4cG9ydHM9ZXhwb3J0cy5kZWZhdWx0fSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjsoZnVuY3Rpb24oZ2xvYmFsKXtmdW5jdGlvbiByZXF1ZXN0KHVybCxjYWxsYmFjayl7dmFyIHJlcT1uZXcgWE1MSHR0cFJlcXVlc3Q7cmVxLm9ubG9hZD1mdW5jdGlvbigpe3RoaXMucmVzcG9uc2U7MjAwPT10aGlzLnN0YXR1cyYmY2FsbGJhY2smJmNhbGxiYWNrKHRoaXMucmVzcG9uc2UpfSxyZXEub3BlbihcImdldFwiLHVybCwhMCkscmVxLnNlbmQoKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX2dsTWF0cml4PV9fd2VicGFja19yZXF1aXJlX18oMSksaXNXb3JrZXI9dm9pZCAwPT09Z2xvYmFsLmRvY3VtZW50LERFRzJSQUQ9MipNYXRoLlBJLzM2MCx0ZW1wX21hdDQ9bnVsbCx0ZW1wX3ZlYzI9bnVsbCx0ZW1wX3ZlYzM9bnVsbCx0ZW1wX3ZlYzQ9bnVsbCx0ZW1wX3F1YXQ9bnVsbCxDb2xsYWRhPXtsaWJzUGF0aDpcIi4vXCIsd29ya2VyUGF0aDpcIi4vXCIsbm9fZmxpcDohMCx1c2VfdHJhbnNmZXJhYmxlczohMCxvbmVycm9yOm51bGwsdmVyYm9zZTohMSxjb25maWc6e2ZvcmNlUGFyc2VyOiExfSxpbml0OmZ1bmN0aW9uKGNvbmZpZyl7Y29uZmlnPWNvbmZpZ3x8e307Zm9yKHZhciBpIGluIGNvbmZpZyl0aGlzW2ldPWNvbmZpZ1tpXTtpZih0aGlzLmNvbmZpZz1jb25maWcsaXNXb3JrZXIpdHJ5e2ltcG9ydFNjcmlwdHModGhpcy5saWJzUGF0aCtcImdsLW1hdHJpeC1taW4uanNcIix0aGlzLmxpYnNQYXRoK1widGlueXhtbC5qc1wiKX1jYXRjaChlcnIpe0NvbGxhZGEudGhyb3dFeGNlcHRpb24oQ29sbGFkYS5MSUJNSVNTSU5HX0VSUk9SKX10ZW1wX21hdDQ9X2dsTWF0cml4Lm1hdDQuY3JlYXRlKCksdGVtcF92ZWMyPXZlYzMuY3JlYXRlKCksdGVtcF92ZWMzPXZlYzMuY3JlYXRlKCksdGVtcF92ZWM0PXZlYzMuY3JlYXRlKCksdGVtcF9xdWF0PV9nbE1hdHJpeC5xdWF0LmNyZWF0ZSgpLGlzV29ya2VyJiZjb25zb2xlLmxvZyhcIkNvbGxhZGEgd29ya2VyIHJlYWR5XCIpfSxsb2FkOmZ1bmN0aW9uKHVybCxjYWxsYmFjayl7cmVxdWVzdCh1cmwsZnVuY3Rpb24oZGF0YSl7Y2FsbGJhY2soZGF0YT9Db2xsYWRhLnBhcnNlKGRhdGEpOm51bGwpfSl9LF94bWxyb290Om51bGwsX25vZGVzX2J5X2lkOm51bGwsX3RyYW5zZmVyYWJsZXM6bnVsbCxfY29udHJvbGxlcnNfZm91bmQ6bnVsbCxfZ2VvbWV0cmllc19mb3VuZDpudWxsLHNhZmVTdHJpbmc6ZnVuY3Rpb24oc3RyKXtyZXR1cm4gc3RyP3RoaXMuY29udmVydElEP3RoaXMuY29udmVydElEKHN0cik6c3RyLnJlcGxhY2UoLyAvZyxcIl9cIik6XCJcIn0sTElCTUlTU0lOR19FUlJPUjpcIkxpYnJhcmllcyBsb2FkaW5nIGVycm9yLCB3aGVuIHVzaW5nIHdvcmtlcnMgcmVtZW1iZXIgdG8gcGFzcyB0aGUgVVJMIHRvIHRoZSB0aW55eG1sLmpzIGluIHRoZSBvcHRpb25zLmxpYnNQYXRoXCIsTk9YTUxQQVJTRVJfRVJST1I6XCJUaW55WE1MIG5vdCBmb3VuZCwgd2hlbiB1c2luZyB3b3JrZXJzIHJlbWVtYmVyIHRvIHBhc3MgdGhlIFVSTCB0byB0aGUgdGlueXhtbC5qcyBpbiB0aGUgb3B0aW9ucy5saWJzUGF0aCAoV29ya2VycyBkbyBub3QgYWxsb3cgdG8gYWNjZXNzIHRoZSBuYXRpdmUgWE1MIERPTVBhcnNlcilcIix0aHJvd0V4Y2VwdGlvbjpmdW5jdGlvbihtc2cpe3Rocm93IGlzV29ya2VyP3NlbGYucG9zdE1lc3NhZ2Uoe2FjdGlvbjpcImV4Y2VwdGlvblwiLG1zZzptc2d9KTpDb2xsYWRhLm9uZXJyb3ImJkNvbGxhZGEub25lcnJvcihtc2cpLG1zZ30sZ2V0RmlsZW5hbWU6ZnVuY3Rpb24oZmlsZW5hbWUpe3ZhciBwb3M9ZmlsZW5hbWUubGFzdEluZGV4T2YoXCJcXFxcXCIpO3JldHVybi0xIT1wb3MmJihmaWxlbmFtZT1maWxlbmFtZS5zdWJzdHIocG9zKzEpKSxwb3M9ZmlsZW5hbWUubGFzdEluZGV4T2YoXCIvXCIpLC0xIT1wb3MmJihmaWxlbmFtZT1maWxlbmFtZS5zdWJzdHIocG9zKzEpKSxmaWxlbmFtZX0sbGFzdF9uYW1lOjAsZ2VuZXJhdGVOYW1lOmZ1bmN0aW9uKHYpe3Y9dnx8XCJuYW1lX1wiO3ZhciBuYW1lPXYrdGhpcy5sYXN0X25hbWU7cmV0dXJuIHRoaXMubGFzdF9uYW1lKyssbmFtZX0scGFyc2U6ZnVuY3Rpb24oZGF0YSxvcHRpb25zLGZpbGVuYW1lKXtvcHRpb25zPW9wdGlvbnN8fHt9LGZpbGVuYW1lPWZpbGVuYW1lfHxcIl9kYWVfXCIrRGF0ZS5ub3coKStcIi5kYWVcIjt2YXIgeG1scGFyc2VyPW51bGwscm9vdD1udWxsO2lmKHRoaXMuX3RyYW5zZmVyYWJsZXM9W10sdGhpcy52ZXJib3NlJiZjb25zb2xlLmxvZyhcIiAtIFhNTCBwYXJzaW5nLi4uXCIpLGdsb2JhbC5ET01QYXJzZXImJiF0aGlzLmNvbmZpZy5mb3JjZVBhcnNlcil4bWxwYXJzZXI9bmV3IERPTVBhcnNlcixyb290PXhtbHBhcnNlci5wYXJzZUZyb21TdHJpbmcoZGF0YSxcInRleHQveG1sXCIpLHRoaXMudmVyYm9zZSYmY29uc29sZS5sb2coXCIgLSBYTUwgcGFyc2VkXCIpO2Vsc2V7aWYoIWdsb2JhbC5ET01JbXBsZW1lbnRhdGlvbilyZXR1cm4gQ29sbGFkYS50aHJvd0V4Y2VwdGlvbihDb2xsYWRhLk5PWE1MUEFSU0VSX0VSUk9SKTt0cnl7eG1scGFyc2VyPW5ldyBET01JbXBsZW1lbnRhdGlvbn1jYXRjaChlcnIpe3JldHVybiBDb2xsYWRhLnRocm93RXhjZXB0aW9uKENvbGxhZGEuTk9YTUxQQVJTRVJfRVJST1IpfXJvb3Q9eG1scGFyc2VyLmxvYWRYTUwoZGF0YSksdGhpcy52ZXJib3NlJiZjb25zb2xlLmxvZyhcIiAtIFhNTCBwYXJzZWRcIik7Zm9yKHZhciBieV9pZHM9cm9vdC5fbm9kZXNfYnlfaWQ9e30saT0wLGw9cm9vdC5hbGwubGVuZ3RoO2k8bDsrK2kpe3ZhciBub2RlPXJvb3QuYWxsW2ldO2J5X2lkc1tub2RlLmlkXT1ub2RlLG5vZGUuZ2V0QXR0cmlidXRlKFwic2lkXCIpJiYoYnlfaWRzW25vZGUuZ2V0QXR0cmlidXRlKFwic2lkXCIpXT1ub2RlKX10aGlzLmV4dHJhX2Z1bmN0aW9uc3x8KHRoaXMuZXh0cmFfZnVuY3Rpb25zPSEwLERPTURvY3VtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yPURPTUVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3I9ZnVuY3Rpb24oc2VsZWN0b3Ipe2Zvcih2YXIgdGFncz1zZWxlY3Rvci5zcGxpdChcIiBcIiksY3VycmVudF9lbGVtZW50PXRoaXM7dGFncy5sZW5ndGg7KXt2YXIgY3VycmVudD10YWdzLnNoaWZ0KCksdG9rZW5zPWN1cnJlbnQuc3BsaXQoXCIjXCIpLHRhZ25hbWU9dG9rZW5zWzBdLGlkPXRva2Vuc1sxXSxlbGVtZW50cz10YWduYW1lP2N1cnJlbnRfZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWduYW1lKTpjdXJyZW50X2VsZW1lbnQuY2hpbGROb2RlcztpZihpZCl7Zm9yKHZhciBpPTA7aTxlbGVtZW50cy5sZW5ndGg7aSsrKWlmKGVsZW1lbnRzLml0ZW0oaSkuZ2V0QXR0cmlidXRlKFwiaWRcIik9PWlkKXtpZigwPT10YWdzLmxlbmd0aClyZXR1cm4gZWxlbWVudHMuaXRlbShpKTtjdXJyZW50X2VsZW1lbnQ9ZWxlbWVudHMuaXRlbShpKTticmVha319ZWxzZXtpZigwPT10YWdzLmxlbmd0aClyZXR1cm4gZWxlbWVudHMuaXRlbSgwKTtjdXJyZW50X2VsZW1lbnQ9ZWxlbWVudHMuaXRlbSgwKX19cmV0dXJuIG51bGx9LERPTURvY3VtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsPURPTUVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGw9ZnVuY3Rpb24oc2VsZWN0b3Ipe2Z1bmN0aW9uIGlubmVyKHJvb3QsdGFncyl7aWYodGFncyl7dmFyIGN1cnJlbnQ9dGFncy5zaGlmdCgpLGVsZW1lbnRzPXJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoY3VycmVudCk7aWYoMCE9dGFncy5sZW5ndGgpZm9yKHZhciBpPTA7aTxlbGVtZW50cy5sZW5ndGg7aSsrKWlubmVyKGVsZW1lbnRzLml0ZW0oaSksdGFncy5jb25jYXQoKSk7ZWxzZSBmb3IodmFyIGk9MDtpPGVsZW1lbnRzLmxlbmd0aDtpKyspcmVzdWx0LnB1c2goZWxlbWVudHMuaXRlbShpKSl9fXZhciB0YWdzPXNlbGVjdG9yLnNwbGl0KFwiIFwiKTtpZigxPT10YWdzLmxlbmd0aClyZXR1cm4gdGhpcy5nZXRFbGVtZW50c0J5VGFnTmFtZShzZWxlY3Rvcik7dmFyIHJlc3VsdD1bXTtpbm5lcih0aGlzLHRhZ3MpO3ZhciBsaXN0PW5ldyBET01Ob2RlTGlzdCh0aGlzLmRvY3VtZW50RWxlbWVudCk7cmV0dXJuIGxpc3QuX25vZGVzPXJlc3VsdCxsaXN0Lmxlbmd0aD1yZXN1bHQubGVuZ3RoLGxpc3R9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShET01FbGVtZW50LnByb3RvdHlwZSxcInRleHRDb250ZW50XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldENoaWxkTm9kZXMoKS5pdGVtKDApLnRvU3RyaW5nKCl9LHNldDpmdW5jdGlvbigpe319KSl9dGhpcy5feG1scm9vdD1yb290O3ZhciB4bWxjb2xsYWRhPXJvb3QucXVlcnlTZWxlY3RvcihcIkNPTExBREFcIik7eG1sY29sbGFkYSYmKHRoaXMuX2N1cnJlbnRfREFFX3ZlcnNpb249eG1sY29sbGFkYS5nZXRBdHRyaWJ1dGUoXCJ2ZXJzaW9uXCIpLGNvbnNvbGUubG9nKFwiREFFIFZlcnNpb246XCIrdGhpcy5fY3VycmVudF9EQUVfdmVyc2lvbikpO3ZhciB4bWx2aXN1YWxfc2NlbmU9cm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInZpc3VhbF9zY2VuZVwiKS5pdGVtKDApO2lmKCF4bWx2aXN1YWxfc2NlbmUpdGhyb3dcInZpc3VhbF9zY2VuZSBYTUwgbm9kZSBub3QgZm91bmQgaW4gREFFXCI7dGhpcy5fbm9kZXNfYnlfaWQ9e30sdGhpcy5fY29udHJvbGxlcnNfZm91bmQ9e30sdGhpcy5fZ2VvbWV0cmllc19mb3VuZD17fTt2YXIgc2NlbmU9e29iamVjdF90eXBlOlwiU2NlbmVUcmVlXCIsbGlnaHQ6bnVsbCxtYXRlcmlhbHM6e30sbWVzaGVzOnt9LHJlc291cmNlczp7fSxyb290OntjaGlsZHJlbjpbXX0sZXh0ZXJuYWxfZmlsZXM6e319LHhtbGFzc2V0PXJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhc3NldFwiKVswXTt4bWxhc3NldCYmKHNjZW5lLm1ldGFkYXRhPXRoaXMucmVhZEFzc2V0KHhtbGFzc2V0KSk7Zm9yKHZhciB4bWxub2Rlcz14bWx2aXN1YWxfc2NlbmUuY2hpbGROb2RlcyxpPTA7aTx4bWxub2Rlcy5sZW5ndGg7aSsrKWlmKFwibm9kZVwiPT14bWxub2Rlcy5pdGVtKGkpLmxvY2FsTmFtZSl7dmFyIG5vZGU9dGhpcy5yZWFkTm9kZVRyZWUoeG1sbm9kZXMuaXRlbShpKSxzY2VuZSwwLCExKTtub2RlJiZzY2VuZS5yb290LmNoaWxkcmVuLnB1c2gobm9kZSl9Zm9yKHZhciBpPTA7aTx4bWxub2Rlcy5sZW5ndGg7aSsrKVwibm9kZVwiPT14bWxub2Rlcy5pdGVtKGkpLmxvY2FsTmFtZSYmdGhpcy5yZWFkTm9kZUluZm8oeG1sbm9kZXMuaXRlbShpKSxzY2VuZSwwLCExKTt0aGlzLnJlYWRMaWJyYXJ5Q29udHJvbGxlcnMoc2NlbmUpO3ZhciBhbmltYXRpb25zPXRoaXMucmVhZEFuaW1hdGlvbnMocm9vdCxzY2VuZSk7aWYoYW5pbWF0aW9ucyl7dmFyIGFuaW1hdGlvbnNfbmFtZT1cIiNhbmltYXRpb25zX1wiK2ZpbGVuYW1lLnN1YnN0cigwLGZpbGVuYW1lLmluZGV4T2YoXCIuXCIpKTtzY2VuZS5yZXNvdXJjZXNbYW5pbWF0aW9uc19uYW1lXT1hbmltYXRpb25zLHNjZW5lLnJvb3QuYW5pbWF0aW9ucz1hbmltYXRpb25zX25hbWV9cmV0dXJuIHNjZW5lLmltYWdlcz10aGlzLnJlYWRJbWFnZXMocm9vdCksdGhpcy5fbm9kZXNfYnlfaWQ9e30sdGhpcy5fY29udHJvbGxlcnNfZm91bmQ9e30sdGhpcy5fZ2VvbWV0cmllc19mb3VuZD17fSx0aGlzLl94bWxyb290PW51bGwsc2NlbmV9LHJlYWRBc3NldDpmdW5jdGlvbih4bWxhc3NldCl7Zm9yKHZhciBtZXRhZGF0YT17fSxpPTA7aTx4bWxhc3NldC5jaGlsZE5vZGVzLmxlbmd0aDtpKyspe3ZhciB4bWxjaGlsZD14bWxhc3NldC5jaGlsZE5vZGVzLml0ZW0oaSk7aWYoMT09eG1sY2hpbGQubm9kZVR5cGUpc3dpdGNoKHhtbGNoaWxkLmxvY2FsTmFtZSl7Y2FzZVwiY29udHJpYnV0b3JcIjp2YXIgdG9vbD14bWxjaGlsZC5xdWVyeVNlbGVjdG9yKFwiYXV0aG9yaW5nX3Rvb2xcIik7dG9vbCYmKG1ldGFkYXRhLmF1dGhvcmluZ190b29sPXRvb2wudGV4dENvbnRleHQpO2JyZWFrO2Nhc2VcInVuaXRcIjptZXRhZGF0YS51bml0PXhtbGNoaWxkLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7YnJlYWs7ZGVmYXVsdDptZXRhZGF0YVt4bWxjaGlsZC5sb2NhbE5hbWVdPXhtbGNoaWxkLnRleHRDb250ZW50fX1yZXR1cm4gbWV0YWRhdGF9LHJlYWROb2RlVHJlZTpmdW5jdGlvbih4bWxub2RlLHNjZW5lLGxldmVsLGZsaXApe3ZhciBub2RlX2lkPXRoaXMuc2FmZVN0cmluZyh4bWxub2RlLmdldEF0dHJpYnV0ZShcImlkXCIpKSxub2RlX3NpZD10aGlzLnNhZmVTdHJpbmcoeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJzaWRcIikpO2lmKCFub2RlX2lkJiYhbm9kZV9zaWQpcmV0dXJuIG51bGw7dmFyIG5vZGU9e2lkOm5vZGVfc2lkfHxub2RlX2lkLGNoaWxkcmVuOltdLF9kZXB0aDpsZXZlbH0sbm9kZV90eXBlPXhtbG5vZGUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtub2RlX3R5cGUmJihub2RlLnR5cGU9bm9kZV90eXBlKTt2YXIgbm9kZV9uYW1lPXhtbG5vZGUuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtub2RlX25hbWUmJihub2RlLm5hbWU9bm9kZV9uYW1lKSx0aGlzLl9ub2Rlc19ieV9pZFtub2RlLmlkXT1ub2RlLG5vZGVfaWQmJih0aGlzLl9ub2Rlc19ieV9pZFtub2RlX2lkXT1ub2RlKSxub2RlX3NpZCYmKHRoaXMuX25vZGVzX2J5X2lkW25vZGVfc2lkXT1ub2RlKSxub2RlLm1vZGVsPXRoaXMucmVhZFRyYW5zZm9ybSh4bWxub2RlLGxldmVsLGZsaXApO2Zvcih2YXIgaT0wO2k8eG1sbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtpKyspe3ZhciB4bWxjaGlsZD14bWxub2RlLmNoaWxkTm9kZXMuaXRlbShpKTtpZigxPT14bWxjaGlsZC5ub2RlVHlwZSlpZihcIm5vZGVcIiE9eG1sY2hpbGQubG9jYWxOYW1lKTtlbHNle3ZhciBjaGlsZF9ub2RlPXRoaXMucmVhZE5vZGVUcmVlKHhtbGNoaWxkLHNjZW5lLGxldmVsKzEsZmxpcCk7Y2hpbGRfbm9kZSYmbm9kZS5jaGlsZHJlbi5wdXNoKGNoaWxkX25vZGUpfX1yZXR1cm4gbm9kZX0scmVhZE5vZGVJbmZvOmZ1bmN0aW9uKHhtbG5vZGUsc2NlbmUsbGV2ZWwsZmxpcCxwYXJlbnQpe3ZhciBub2RlLG5vZGVfaWQ9dGhpcy5zYWZlU3RyaW5nKHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwiaWRcIikpLG5vZGVfc2lkPXRoaXMuc2FmZVN0cmluZyh4bWxub2RlLmdldEF0dHJpYnV0ZShcInNpZFwiKSk7aWYobm9kZV9pZHx8bm9kZV9zaWQpbm9kZT10aGlzLl9ub2Rlc19ieV9pZFtub2RlX2lkfHxub2RlX3NpZF07ZWxzZXtpZighcGFyZW50KXJldHVybiBudWxsO25vZGU9dGhpcy5fbm9kZXNfYnlfaWRbcGFyZW50LmlkfHxwYXJlbnQuc2lkXX1pZighbm9kZSlyZXR1cm4gY29uc29sZS53YXJuKFwiQ29sbGFkYTogTm9kZSBub3QgZm91bmQgYnkgaWQ6IFwiKyhub2RlX2lkfHxub2RlX3NpZCkpLG51bGw7Zm9yKHZhciBpPTA7aTx4bWxub2RlLmNoaWxkTm9kZXMubGVuZ3RoO2krKyl7dmFyIHhtbGNoaWxkPXhtbG5vZGUuY2hpbGROb2Rlcy5pdGVtKGkpO2lmKDE9PXhtbGNoaWxkLm5vZGVUeXBlKWlmKFwibm9kZVwiIT14bWxjaGlsZC5sb2NhbE5hbWUpe2lmKFwiaW5zdGFuY2VfZ2VvbWV0cnlcIj09eG1sY2hpbGQubG9jYWxOYW1lKXt2YXIgdXJsPXhtbGNoaWxkLmdldEF0dHJpYnV0ZShcInVybFwiKSxtZXNoX2lkPXVybC50b1N0cmluZygpLnN1YnN0cigxKTtpZihub2RlLm1lc2g9bWVzaF9pZCwhc2NlbmUubWVzaGVzW3VybF0pe3ZhciBtZXNoX2RhdGE9dGhpcy5yZWFkR2VvbWV0cnkodXJsLGZsaXApO21lc2hfZGF0YSYmKG1lc2hfZGF0YS5uYW1lPW1lc2hfaWQsc2NlbmUubWVzaGVzW21lc2hfaWRdPW1lc2hfZGF0YSl9dmFyIHhtbG1hdGVyaWFscz14bWxjaGlsZC5xdWVyeVNlbGVjdG9yQWxsKFwiaW5zdGFuY2VfbWF0ZXJpYWxcIik7aWYoeG1sbWF0ZXJpYWxzKWZvcih2YXIgaU1hdD0wO2lNYXQ8eG1sbWF0ZXJpYWxzLmxlbmd0aDsrK2lNYXQpe3ZhciB4bWxtYXRlcmlhbD14bWxtYXRlcmlhbHMuaXRlbShpTWF0KTtpZih4bWxtYXRlcmlhbCl7dmFyIG1hdG5hbWU9eG1sbWF0ZXJpYWwuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpLnRvU3RyaW5nKCkuc3Vic3RyKDEpO2lmKCFzY2VuZS5tYXRlcmlhbHNbbWF0bmFtZV0pe3ZhciBtYXRlcmlhbD10aGlzLnJlYWRNYXRlcmlhbChtYXRuYW1lKTttYXRlcmlhbCYmKG1hdGVyaWFsLmlkPW1hdG5hbWUsc2NlbmUubWF0ZXJpYWxzW21hdGVyaWFsLmlkXT1tYXRlcmlhbCl9MD09aU1hdD9ub2RlLm1hdGVyaWFsPW1hdG5hbWU6KG5vZGUubWF0ZXJpYWxzfHwobm9kZS5tYXRlcmlhbHM9W10pLG5vZGUubWF0ZXJpYWxzLnB1c2gobWF0bmFtZSkpfWVsc2UgY29uc29sZS53YXJuKFwiaW5zdGFuY2VfbWF0ZXJpYWwgbm90IGZvdW5kOiBcIitpKX19aWYoXCJpbnN0YW5jZV9jb250cm9sbGVyXCI9PXhtbGNoaWxkLmxvY2FsTmFtZSl7dmFyIHVybD14bWxjaGlsZC5nZXRBdHRyaWJ1dGUoXCJ1cmxcIikseG1sY29udHJvbGxlcj10aGlzLl94bWxyb290LnF1ZXJ5U2VsZWN0b3IoXCJjb250cm9sbGVyXCIrdXJsKTtpZih4bWxjb250cm9sbGVyKXt2YXIgbWVzaF9kYXRhPXRoaXMucmVhZENvbnRyb2xsZXIoeG1sY29udHJvbGxlcixmbGlwLHNjZW5lKSx4bWxiaW5kX21hdGVyaWFsPXhtbGNoaWxkLnF1ZXJ5U2VsZWN0b3IoXCJiaW5kX21hdGVyaWFsXCIpO2lmKHhtbGJpbmRfbWF0ZXJpYWwpZm9yKHZhciB4bWx0ZWNobmlxdWVzPXhtbGJpbmRfbWF0ZXJpYWwucXVlcnlTZWxlY3RvckFsbChcInRlY2huaXF1ZV9jb21tb25cIiksaVRlYz0wO2lUZWM8eG1sdGVjaG5pcXVlcy5sZW5ndGg7aVRlYysrKWZvcih2YXIgeG1sdGVjaG5pcXVlPXhtbHRlY2huaXF1ZXMuaXRlbShpVGVjKSx4bWxpbnN0YW5jZV9tYXRlcmlhbHM9eG1sdGVjaG5pcXVlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnN0YW5jZV9tYXRlcmlhbFwiKSxpTWF0PTA7aU1hdDx4bWxpbnN0YW5jZV9tYXRlcmlhbHMubGVuZ3RoO2lNYXQrKyl7dmFyIHhtbGluc3RhbmNlX21hdGVyaWFsPXhtbGluc3RhbmNlX21hdGVyaWFscy5pdGVtKGlNYXQpO2lmKHhtbGluc3RhbmNlX21hdGVyaWFsKXt2YXIgbWF0bmFtZT14bWxpbnN0YW5jZV9tYXRlcmlhbC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIikudG9TdHJpbmcoKS5zdWJzdHIoMSk7aWYoIXNjZW5lLm1hdGVyaWFsc1ttYXRuYW1lXSl7dmFyIG1hdGVyaWFsPXRoaXMucmVhZE1hdGVyaWFsKG1hdG5hbWUpO21hdGVyaWFsJiYobWF0ZXJpYWwuaWQ9bWF0bmFtZSxzY2VuZS5tYXRlcmlhbHNbbWF0ZXJpYWwuaWRdPW1hdGVyaWFsKX0wPT1pTWF0P25vZGUubWF0ZXJpYWw9bWF0bmFtZToobm9kZS5tYXRlcmlhbHN8fChub2RlLm1hdGVyaWFscz1bXSksbm9kZS5tYXRlcmlhbHMucHVzaChtYXRuYW1lKSl9ZWxzZSBjb25zb2xlLndhcm4oXCJpbnN0YW5jZV9tYXRlcmlhbCBmb3IgY29udHJvbGxlciBub3QgZm91bmQ6IFwiK3htbGluc3RhbmNlX21hdGVyaWFsKX1pZihtZXNoX2RhdGEpe3ZhciBtZXNoPW1lc2hfZGF0YTtcIm1vcnBoXCI9PW1lc2hfZGF0YS50eXBlJiYobWVzaD1tZXNoX2RhdGEubWVzaCxub2RlLm1vcnBoX3RhcmdldHM9bWVzaF9kYXRhLm1vcnBoX3RhcmdldHMpLG1lc2gubmFtZT11cmwudG9TdHJpbmcoKSxub2RlLm1lc2g9dXJsLnRvU3RyaW5nKCksc2NlbmUubWVzaGVzW3VybF09bWVzaH19fWlmKFwiaW5zdGFuY2VfbGlnaHRcIj09eG1sY2hpbGQubG9jYWxOYW1lKXt2YXIgdXJsPXhtbGNoaWxkLmdldEF0dHJpYnV0ZShcInVybFwiKTt0aGlzLnJlYWRMaWdodChub2RlLHVybCl9aWYoXCJpbnN0YW5jZV9jYW1lcmFcIj09eG1sY2hpbGQubG9jYWxOYW1lKXt2YXIgdXJsPXhtbGNoaWxkLmdldEF0dHJpYnV0ZShcInVybFwiKTt0aGlzLnJlYWRDYW1lcmEobm9kZSx1cmwpfX1lbHNlIHRoaXMucmVhZE5vZGVJbmZvKHhtbGNoaWxkLHNjZW5lLGxldmVsKzEsZmxpcCx4bWxub2RlKX19LG1hdGVyaWFsX3RyYW5zbGF0ZV90YWJsZTp7fSxsaWdodF90cmFuc2xhdGVfdGFibGU6e3BvaW50Olwib21uaVwiLGRpcmVjdGlvbmFsOlwiZGlyZWN0aW9uYWxcIixzcG90Olwic3BvdFwifSxjYW1lcmFfdHJhbnNsYXRlX3RhYmxlOnt4Zm92OlwiZm92XCIsYXNwZWN0X3JhdGlvOlwiYXNwZWN0XCIsem5lYXI6XCJuZWFyXCIsemZhcjpcImZhclwifSxxdWVyeVNlbGVjdG9yQW5kSWQ6ZnVuY3Rpb24ocm9vdCxzZWxlY3RvcixpZCl7Zm9yKHZhciBub2Rlcz1yb290LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLGk9MDtpPG5vZGVzLmxlbmd0aDtpKyspe3ZhciBhdHRyX2lkPW5vZGVzLml0ZW0oaSkuZ2V0QXR0cmlidXRlKFwiaWRcIik7aWYoYXR0cl9pZCYmKGF0dHJfaWQ9YXR0cl9pZC50b1N0cmluZygpKT09aWQpcmV0dXJuIG5vZGVzLml0ZW0oaSl9cmV0dXJuIG51bGx9LGdldEZpcnN0Q2hpbGRFbGVtZW50OmZ1bmN0aW9uKHJvb3QsbG9jYWxOYW1lKXtmb3IodmFyIGM9cm9vdC5jaGlsZE5vZGVzLGk9MDtpPGMubGVuZ3RoOysraSl7dmFyIGl0ZW09Yy5pdGVtKGkpO2lmKGl0ZW0ubG9jYWxOYW1lJiYhbG9jYWxOYW1lfHxsb2NhbE5hbWUmJmxvY2FsTmFtZT09aXRlbS5sb2NhbE5hbWUpcmV0dXJuIGl0ZW19cmV0dXJuIG51bGx9LHJlYWRNYXRlcmlhbDpmdW5jdGlvbih1cmwpe3ZhciB4bWxtYXRlcmlhbD10aGlzLnF1ZXJ5U2VsZWN0b3JBbmRJZCh0aGlzLl94bWxyb290LFwibGlicmFyeV9tYXRlcmlhbHMgbWF0ZXJpYWxcIix1cmwpO2lmKCF4bWxtYXRlcmlhbClyZXR1cm4gbnVsbDt2YXIgeG1sZWZmZWN0PXhtbG1hdGVyaWFsLnF1ZXJ5U2VsZWN0b3IoXCJpbnN0YW5jZV9lZmZlY3RcIik7aWYoIXhtbGVmZmVjdClyZXR1cm4gbnVsbDt2YXIgZWZmZWN0X3VybD14bWxlZmZlY3QuZ2V0QXR0cmlidXRlKFwidXJsXCIpLnN1YnN0cigxKSx4bWxlZmZlY3RzPXRoaXMucXVlcnlTZWxlY3RvckFuZElkKHRoaXMuX3htbHJvb3QsXCJsaWJyYXJ5X2VmZmVjdHMgZWZmZWN0XCIsZWZmZWN0X3VybCk7aWYoIXhtbGVmZmVjdHMpcmV0dXJuIG51bGw7dmFyIHhtbHRlY2huaXF1ZT14bWxlZmZlY3RzLnF1ZXJ5U2VsZWN0b3IoXCJ0ZWNobmlxdWVcIik7aWYoIXhtbHRlY2huaXF1ZSlyZXR1cm4gbnVsbDtmb3IodmFyIHhtbG5ld3BhcmFtcz14bWxlZmZlY3RzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJuZXdwYXJhbVwiKSxuZXdwYXJhbXM9e30saT0wO2k8eG1sbmV3cGFyYW1zLmxlbmd0aDtpKyspe3ZhciBwYXJlbnQsaW5pdF9mcm9tPXhtbG5ld3BhcmFtc1tpXS5xdWVyeVNlbGVjdG9yKFwiaW5pdF9mcm9tXCIpO2lmKGluaXRfZnJvbSlwYXJlbnQ9aW5pdF9mcm9tLmlubmVySFRNTDtlbHNle3BhcmVudD14bWxuZXdwYXJhbXNbaV0ucXVlcnlTZWxlY3RvcihcInNvdXJjZVwiKS5pbm5lckhUTUx9bmV3cGFyYW1zW3htbG5ld3BhcmFtc1tpXS5nZXRBdHRyaWJ1dGUoXCJzaWRcIildPXtwYXJlbnQ6cGFyZW50fX12YXIgbWF0ZXJpYWw9e30saW1hZ2VzPXRoaXMucmVhZEltYWdlcyh0aGlzLl94bWxyb290KSx4bWxwaG9uZz14bWx0ZWNobmlxdWUucXVlcnlTZWxlY3RvcihcInBob25nXCIpO2lmKHhtbHBob25nfHwoeG1scGhvbmc9eG1sdGVjaG5pcXVlLnF1ZXJ5U2VsZWN0b3IoXCJibGlublwiKSkseG1scGhvbmd8fCh4bWxwaG9uZz14bWx0ZWNobmlxdWUucXVlcnlTZWxlY3RvcihcImxhbWJlcnRcIikpLCF4bWxwaG9uZylyZXR1cm4gbnVsbDtmb3IodmFyIGk9MDtpPHhtbHBob25nLmNoaWxkTm9kZXMubGVuZ3RoOysraSl7dmFyIHhtbHBhcmFtPXhtbHBob25nLmNoaWxkTm9kZXMuaXRlbShpKTtpZih4bWxwYXJhbS5sb2NhbE5hbWUpe3ZhciBwYXJhbV9uYW1lPXhtbHBhcmFtLmxvY2FsTmFtZS50b1N0cmluZygpO3RoaXMubWF0ZXJpYWxfdHJhbnNsYXRlX3RhYmxlW3BhcmFtX25hbWVdJiYocGFyYW1fbmFtZT10aGlzLm1hdGVyaWFsX3RyYW5zbGF0ZV90YWJsZVtwYXJhbV9uYW1lXSk7dmFyIHhtbHBhcmFtX3ZhbHVlPXRoaXMuZ2V0Rmlyc3RDaGlsZEVsZW1lbnQoeG1scGFyYW0pO2lmKHhtbHBhcmFtX3ZhbHVlKWlmKFwiY29sb3JcIiE9eG1scGFyYW1fdmFsdWUubG9jYWxOYW1lLnRvU3RyaW5nKCkpaWYoXCJmbG9hdFwiIT14bWxwYXJhbV92YWx1ZS5sb2NhbE5hbWUudG9TdHJpbmcoKSl7aWYoXCJ0ZXh0dXJlXCI9PXhtbHBhcmFtX3ZhbHVlLmxvY2FsTmFtZS50b1N0cmluZygpKXttYXRlcmlhbC50ZXh0dXJlc3x8KG1hdGVyaWFsLnRleHR1cmVzPXt9KTt2YXIgbWFwX2lkPXhtbHBhcmFtX3ZhbHVlLmdldEF0dHJpYnV0ZShcInRleHR1cmVcIik7aWYoIW1hcF9pZCljb250aW51ZTstMT09PW1hcF9pZC5pbmRleE9mKFwiLlwiKSYmKG1hcF9pZD10aGlzLmdldFBhcmVudFBhcmFtKG5ld3BhcmFtcyxtYXBfaWQpLGltYWdlc1ttYXBfaWRdJiYobWFwX2lkPWltYWdlc1ttYXBfaWRdLnBhdGgpKTt2YXIgbWFwX2luZm89e21hcF9pZDptYXBfaWR9LHV2cz14bWxwYXJhbV92YWx1ZS5nZXRBdHRyaWJ1dGUoXCJ0ZXhjb29yZFwiKTttYXBfaW5mby51dnM9dXZzLG1hdGVyaWFsLnRleHR1cmVzW3BhcmFtX25hbWVdPW1hcF9pbmZvfX1lbHNlIG1hdGVyaWFsW3BhcmFtX25hbWVdPXRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWxwYXJhbV92YWx1ZSlbMF07ZWxzZXt2YXIgdmFsdWU9dGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbHBhcmFtX3ZhbHVlKTtcIlJHQl9aRVJPXCI9PXhtbHBhcmFtLmdldEF0dHJpYnV0ZShcIm9wYXF1ZVwiKT9tYXRlcmlhbFtwYXJhbV9uYW1lXT12YWx1ZS5zdWJhcnJheSgwLDQpOm1hdGVyaWFsW3BhcmFtX25hbWVdPXZhbHVlLnN1YmFycmF5KDAsMyl9fX1yZXR1cm4gbWF0ZXJpYWwub2JqZWN0X3R5cGU9XCJNYXRlcmlhbFwiLG1hdGVyaWFsfSxnZXRQYXJlbnRQYXJhbTpmdW5jdGlvbihuZXdwYXJhbXMscGFyYW0pe3JldHVybiBuZXdwYXJhbXNbcGFyYW1dJiZuZXdwYXJhbXNbcGFyYW1dLnBhcmVudD90aGlzLmdldFBhcmVudFBhcmFtKG5ld3BhcmFtcyxuZXdwYXJhbXNbcGFyYW1dLnBhcmVudCk6cGFyYW19LHJlYWRMaWdodDpmdW5jdGlvbihub2RlLHVybCl7ZnVuY3Rpb24gcGFyc2VfcGFyYW1zKGxpZ2h0LHhtbCl7Zm9yKHZhciBpPTA7aTx4bWwuY2hpbGROb2Rlcy5sZW5ndGg7aSsrKXt2YXIgY2hpbGQ9eG1sLmNoaWxkTm9kZXMuaXRlbShpKTtpZihjaGlsZCYmMT09Y2hpbGQubm9kZVR5cGUpc3dpdGNoKGNoaWxkLmxvY2FsTmFtZSl7Y2FzZVwiY29sb3JcIjpsaWdodC5jb2xvcj1Db2xsYWRhLnJlYWRDb250ZW50QXNGbG9hdHMoY2hpbGQpO2JyZWFrO2Nhc2VcImZhbGxvZmZfYW5nbGVcIjpsaWdodC5hbmdsZV9lbmQ9Q29sbGFkYS5yZWFkQ29udGVudEFzRmxvYXRzKGNoaWxkKVswXSxsaWdodC5hbmdsZT1saWdodC5hbmdsZV9lbmQtMTB9fX12YXIgbGlnaHQ9e30seG1sbm9kZT1udWxsO2lmKHVybC5sZW5ndGg+MSl4bWxub2RlPXRoaXMuX3htbHJvb3QucXVlcnlTZWxlY3RvcihcImxpYnJhcnlfbGlnaHRzIFwiK3VybCk7ZWxzZXt2YXIgeG1sbGlibGlnaHRzPXRoaXMuX3htbHJvb3QucXVlcnlTZWxlY3RvcihcImxpYnJhcnlfbGlnaHRzXCIpO3htbG5vZGU9dGhpcy5nZXRGaXJzdENoaWxkRWxlbWVudCh4bWxsaWJsaWdodHMsXCJsaWdodFwiKX1pZigheG1sbm9kZSlyZXR1cm4gbnVsbDt2YXIgY2hpbGRyZW49W10seG1sPXhtbG5vZGUucXVlcnlTZWxlY3RvcihcInRlY2huaXF1ZV9jb21tb25cIik7aWYoeG1sKWZvcih2YXIgaT0wO2k8eG1sLmNoaWxkTm9kZXMubGVuZ3RoO2krKykxPT14bWwuY2hpbGROb2Rlcy5pdGVtKGkpLm5vZGVUeXBlJiZjaGlsZHJlbi5wdXNoKHhtbC5jaGlsZE5vZGVzLml0ZW0oaSkpO2Zvcih2YXIgeG1scz14bWxub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJ0ZWNobmlxdWVcIiksaT0wO2k8eG1scy5sZW5ndGg7aSsrKWZvcih2YXIgeG1sMj14bWxzLml0ZW0oaSksaj0wO2o8eG1sMi5jaGlsZE5vZGVzLmxlbmd0aDtqKyspMT09eG1sMi5jaGlsZE5vZGVzLml0ZW0oaikubm9kZVR5cGUmJmNoaWxkcmVuLnB1c2goeG1sMi5jaGlsZE5vZGVzLml0ZW0oaikpO2Zvcih2YXIgaT0wO2k8Y2hpbGRyZW4ubGVuZ3RoO2krKyl7dmFyIHhtbD1jaGlsZHJlbltpXTtzd2l0Y2goeG1sLmxvY2FsTmFtZSl7Y2FzZVwicG9pbnRcIjpjYXNlXCJkaXJlY3Rpb25hbFwiOmNhc2VcInNwb3RcIjpsaWdodC50eXBlPXRoaXMubGlnaHRfdHJhbnNsYXRlX3RhYmxlW3htbC5sb2NhbE5hbWVdLHBhcnNlX3BhcmFtcyhsaWdodCx4bWwpO2JyZWFrO2Nhc2VcImludGVuc2l0eVwiOmxpZ2h0LmludGVuc2l0eT10aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKVswXX19aWYobm9kZS5tb2RlbCl7bGlnaHQucG9zaXRpb249W25vZGUubW9kZWxbMTJdLG5vZGUubW9kZWxbMTNdLG5vZGUubW9kZWxbMTRdXTt2YXIgZm9yd2FyZD1bLW5vZGUubW9kZWxbOF0sLW5vZGUubW9kZWxbOV0sLW5vZGUubW9kZWxbMTBdXTtsaWdodC50YXJnZXQ9W2xpZ2h0LnBvc2l0aW9uWzBdK2ZvcndhcmRbMF0sbGlnaHQucG9zaXRpb25bMV0rZm9yd2FyZFsxXSxsaWdodC5wb3NpdGlvblsyXStmb3J3YXJkWzJdXX1lbHNlIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCByZWFkIGxpZ2h0IHBvc2l0aW9uIGZvciBsaWdodDogXCIrbm9kZS5uYW1lK1wiLiBTZXR0aW5nIGRlZmF1bHRzLlwiKSxsaWdodC5wb3NpdGlvbj1bMCwwLDBdLGxpZ2h0LnRhcmdldD1bMCwtMSwwXTtub2RlLmxpZ2h0PWxpZ2h0fSxyZWFkQ2FtZXJhOmZ1bmN0aW9uKG5vZGUsdXJsKXt2YXIgY2FtZXJhPXt9LHhtbG5vZGU9dGhpcy5feG1scm9vdC5xdWVyeVNlbGVjdG9yKFwibGlicmFyeV9jYW1lcmFzIFwiK3VybCk7aWYoIXhtbG5vZGUpcmV0dXJuIG51bGw7dmFyIGNoaWxkcmVuPVtdLHhtbD14bWxub2RlLnF1ZXJ5U2VsZWN0b3IoXCJ0ZWNobmlxdWVfY29tbW9uXCIpO2lmKHhtbClmb3IodmFyIGk9MDtpPHhtbC5jaGlsZE5vZGVzLmxlbmd0aDtpKyspMT09eG1sLmNoaWxkTm9kZXMuaXRlbShpKS5ub2RlVHlwZSYmY2hpbGRyZW4ucHVzaCh4bWwuY2hpbGROb2Rlcy5pdGVtKGkpKTtmb3IodmFyIGk9MDtpPGNoaWxkcmVuLmxlbmd0aDtpKyspe3ZhciB0YWc9Y2hpbGRyZW5baV07IWZ1bmN0aW9uKGNhbWVyYSx4bWwpe2Zvcih2YXIgaT0wO2k8eG1sLmNoaWxkTm9kZXMubGVuZ3RoO2krKyl7dmFyIGNoaWxkPXhtbC5jaGlsZE5vZGVzLml0ZW0oaSk7Y2hpbGQmJjE9PWNoaWxkLm5vZGVUeXBlJiYoY2FtZXJhW0NvbGxhZGEuY2FtZXJhX3RyYW5zbGF0ZV90YWJsZVtjaGlsZC5sb2NhbE5hbWVdfHxjaGlsZC5sb2NhbE5hbWVdPXBhcnNlRmxvYXQoY2hpbGQudGV4dENvbnRlbnQpKX19KGNhbWVyYSx0YWcpfWNhbWVyYS55Zm92JiYhY2FtZXJhLmZvdiYmKGNhbWVyYS5hc3BlY3Q/Y2FtZXJhLmZvdj1jYW1lcmEueWZvdipjYW1lcmEuYXNwZWN0OmNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBjb252ZXJ0IGNhbWVyYSB5Zm92IHRvIHhmb3YgYmVjYXVzZSBhc3BlY3QgcmF0aW8gbm90IHNldFwiKSksbm9kZS5jYW1lcmE9Y2FtZXJhfSxyZWFkVHJhbnNmb3JtOmZ1bmN0aW9uKHhtbG5vZGUsbGV2ZWwsZmxpcCl7Zm9yKHZhciBtYXRyaXg9X2dsTWF0cml4Lm1hdDQuY3JlYXRlKCksdGVtcD1fZ2xNYXRyaXgubWF0NC5jcmVhdGUoKSx0bXBxPV9nbE1hdHJpeC5xdWF0LmNyZWF0ZSgpLGk9MDtpPHhtbG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7aSsrKXt2YXIgeG1sPXhtbG5vZGUuY2hpbGROb2Rlcy5pdGVtKGkpO2lmKHhtbCYmMT09eG1sLm5vZGVUeXBlKXtpZihcIm1hdHJpeFwiPT14bWwubG9jYWxOYW1lKXt2YXIgbWF0cml4PXRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWwpO3JldHVybiB0aGlzLnRyYW5zZm9ybU1hdHJpeChtYXRyaXgsMD09bGV2ZWwpLG1hdHJpeH1pZihcInRyYW5zbGF0ZVwiIT14bWwubG9jYWxOYW1lKWlmKFwicm90YXRlXCIhPXhtbC5sb2NhbE5hbWUpe2lmKFwic2NhbGVcIj09eG1sLmxvY2FsTmFtZSl7dmFyIHZhbHVlcz10aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKTtpZihmbGlwKXt2YXIgdG1wPXZhbHVlc1sxXTt2YWx1ZXNbMV09dmFsdWVzWzJdLHZhbHVlc1syXT0tdG1wfV9nbE1hdHJpeC5tYXQ0LnNjYWxlKG1hdHJpeCxtYXRyaXgsdmFsdWVzKX19ZWxzZXt2YXIgdmFsdWVzPXRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWwpO2lmKDQ9PXZhbHVlcy5sZW5ndGgpe3ZhciBpZD14bWwuZ2V0QXR0cmlidXRlKFwic2lkXCIpO2lmKFwiam9pbnRPcmllbnRYXCI9PWlkJiYodmFsdWVzWzNdKz05MCwhMCksZmxpcCl7dmFyIHRtcD12YWx1ZXNbMV07dmFsdWVzWzFdPXZhbHVlc1syXSx2YWx1ZXNbMl09LXRtcH0wIT12YWx1ZXNbM10mJihfZ2xNYXRyaXgucXVhdC5zZXRBeGlzQW5nbGUodG1wcSx2YWx1ZXMuc3ViYXJyYXkoMCwzKSx2YWx1ZXNbM10qREVHMlJBRCksX2dsTWF0cml4Lm1hdDQuZnJvbVF1YXQodGVtcCx0bXBxKSxfZ2xNYXRyaXgubWF0NC5tdWx0aXBseShtYXRyaXgsbWF0cml4LHRlbXApKX19ZWxzZXt2YXIgdmFsdWVzPXRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWwpO2lmKGZsaXAmJmxldmVsPjApe3ZhciB0bXA9dmFsdWVzWzFdO3ZhbHVlc1sxXT12YWx1ZXNbMl0sdmFsdWVzWzJdPS10bXB9X2dsTWF0cml4Lm1hdDQudHJhbnNsYXRlKG1hdHJpeCxtYXRyaXgsdmFsdWVzKX19fXJldHVybiBtYXRyaXh9LHJlYWRUcmFuc2Zvcm0yOmZ1bmN0aW9uKHhtbG5vZGUsbGV2ZWwsZmxpcCl7Zm9yKHZhciBtYXRyaXg9X2dsTWF0cml4Lm1hdDQuY3JlYXRlKCkscm90YXRpb249X2dsTWF0cml4LnF1YXQuY3JlYXRlKCksdG1wbWF0cml4PV9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpLHRtcHE9X2dsTWF0cml4LnF1YXQuY3JlYXRlKCksdHJhbnNsYXRlPXZlYzMuY3JlYXRlKCksc2NhbGU9dmVjMy5mcm9tVmFsdWVzKDEsMSwxKSxpPTA7aTx4bWxub2RlLmNoaWxkTm9kZXMubGVuZ3RoO2krKyl7dmFyIHhtbD14bWxub2RlLmNoaWxkTm9kZXMuaXRlbShpKTtpZihcIm1hdHJpeFwiPT14bWwubG9jYWxOYW1lKXt2YXIgbWF0cml4PXRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWwpO3JldHVybiB0aGlzLnRyYW5zZm9ybU1hdHJpeChtYXRyaXgsMD09bGV2ZWwpLG1hdHJpeH1pZihcInRyYW5zbGF0ZVwiIT14bWwubG9jYWxOYW1lKWlmKFwicm90YXRlXCIhPXhtbC5sb2NhbE5hbWUpe2lmKFwic2NhbGVcIj09eG1sLmxvY2FsTmFtZSl7dmFyIHZhbHVlcz10aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKTtpZihmbGlwKXt2YXIgdG1wPXZhbHVlc1sxXTt2YWx1ZXNbMV09dmFsdWVzWzJdLHZhbHVlc1syXT0tdG1wfXNjYWxlLnNldCh2YWx1ZXMpfX1lbHNle3ZhciB2YWx1ZXM9dGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbCk7aWYoND09dmFsdWVzLmxlbmd0aCl7dmFyIGlkPXhtbC5nZXRBdHRyaWJ1dGUoXCJzaWRcIik7aWYoXCJqb2ludE9yaWVudFhcIj09aWQmJih2YWx1ZXNbM10rPTkwLCEwKSxmbGlwKXt2YXIgdG1wPXZhbHVlc1sxXTt2YWx1ZXNbMV09dmFsdWVzWzJdLHZhbHVlc1syXT0tdG1wfTAhPXZhbHVlc1szXSYmKF9nbE1hdHJpeC5xdWF0LnNldEF4aXNBbmdsZSh0bXBxLHZhbHVlcy5zdWJhcnJheSgwLDMpLHZhbHVlc1szXSpERUcyUkFEKSxfZ2xNYXRyaXgucXVhdC5tdWx0aXBseShyb3RhdGlvbixyb3RhdGlvbix0bXBxKSl9fWVsc2V7dmFyIHZhbHVlcz10aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKTt0cmFuc2xhdGUuc2V0KHZhbHVlcyl9fWlmKGZsaXAmJmxldmVsPjApe3ZhciB0bXA9dHJhbnNsYXRlWzFdO3RyYW5zbGF0ZVsxXT10cmFuc2xhdGVbMl0sdHJhbnNsYXRlWzJdPS10bXB9cmV0dXJuIF9nbE1hdHJpeC5tYXQ0LnRyYW5zbGF0ZShtYXRyaXgsbWF0cml4LHRyYW5zbGF0ZSksX2dsTWF0cml4Lm1hdDQuZnJvbVF1YXQodG1wbWF0cml4LHJvdGF0aW9uKSxfZ2xNYXRyaXgubWF0NC5tdWx0aXBseShtYXRyaXgsbWF0cml4LHRtcG1hdHJpeCksX2dsTWF0cml4Lm1hdDQuc2NhbGUobWF0cml4LG1hdHJpeCxzY2FsZSksbWF0cml4fSxyZWFkR2VvbWV0cnk6ZnVuY3Rpb24oaWQsZmxpcCxzY2VuZSl7aWYodm9pZCAwIT09dGhpcy5fZ2VvbWV0cmllc19mb3VuZFtpZF0pcmV0dXJuIHRoaXMuX2dlb21ldHJpZXNfZm91bmRbaWRdO3ZhciB4bWxnZW9tZXRyeT10aGlzLl94bWxyb290LmdldEVsZW1lbnRCeUlkKGlkLnN1YnN0cigxKSk7aWYoIXhtbGdlb21ldHJ5KXJldHVybiBjb25zb2xlLndhcm4oXCJyZWFkR2VvbWV0cnk6IGdlb21ldHJ5IG5vdCBmb3VuZDogXCIraWQpLHRoaXMuX2dlb21ldHJpZXNfZm91bmRbaWRdPW51bGwsbnVsbDtpZihcImNvbnRyb2xsZXJcIj09eG1sZ2VvbWV0cnkubG9jYWxOYW1lKXt2YXIgZ2VvbWV0cnk9dGhpcy5yZWFkQ29udHJvbGxlcih4bWxnZW9tZXRyeSxmbGlwLHNjZW5lKTtyZXR1cm4gdGhpcy5fZ2VvbWV0cmllc19mb3VuZFtpZF09Z2VvbWV0cnksZ2VvbWV0cnl9aWYoXCJnZW9tZXRyeVwiIT14bWxnZW9tZXRyeS5sb2NhbE5hbWUpcmV0dXJuIGNvbnNvbGUud2FybihcInJlYWRHZW9tZXRyeTogdGFnIHNob3VsZCBiZSBnZW9tZXRyeSwgaW5zdGVhZCBpdCB3YXMgZm91bmQ6IFwiK3htbGdlb21ldHJ5LmxvY2FsTmFtZSksdGhpcy5fZ2VvbWV0cmllc19mb3VuZFtpZF09bnVsbCxudWxsO3ZhciB4bWxtZXNoPXhtbGdlb21ldHJ5LnF1ZXJ5U2VsZWN0b3IoXCJtZXNoXCIpO2lmKCF4bWxtZXNoKXJldHVybiBjb25zb2xlLndhcm4oXCJyZWFkR2VvbWV0cnk6IG1lc2ggbm90IGZvdW5kIGluIGdlb21ldHJ5OiBcIitpZCksdGhpcy5fZ2VvbWV0cmllc19mb3VuZFtpZF09bnVsbCxudWxsO2Zvcih2YXIgc291cmNlcz17fSx4bWxzb3VyY2VzPXhtbG1lc2gucXVlcnlTZWxlY3RvckFsbChcInNvdXJjZVwiKSxpPTA7aTx4bWxzb3VyY2VzLmxlbmd0aDtpKyspe3ZhciB4bWxzb3VyY2U9eG1sc291cmNlcy5pdGVtKGkpO2lmKHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKXt2YXIgZmxvYXRfYXJyYXk9eG1sc291cmNlLnF1ZXJ5U2VsZWN0b3IoXCJmbG9hdF9hcnJheVwiKTtpZihmbG9hdF9hcnJheSl7dmFyIGZsb2F0cz10aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoZmxvYXRfYXJyYXkpLHhtbGFjY2Vzc29yPXhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwiYWNjZXNzb3JcIiksc3RyaWRlPXBhcnNlSW50KHhtbGFjY2Vzc29yLmdldEF0dHJpYnV0ZShcInN0cmlkZVwiKSk7c291cmNlc1t4bWxzb3VyY2UuZ2V0QXR0cmlidXRlKFwiaWRcIildPXtzdHJpZGU6c3RyaWRlLGRhdGE6ZmxvYXRzfX19fXZhciB4bWx2ZXJ0aWNlcz14bWxtZXNoLnF1ZXJ5U2VsZWN0b3IoXCJ2ZXJ0aWNlcyBpbnB1dFwiKSx2ZXJ0aWNlc19zb3VyY2U9c291cmNlc1t4bWx2ZXJ0aWNlcy5nZXRBdHRyaWJ1dGUoXCJzb3VyY2VcIikuc3Vic3RyKDEpXTtzb3VyY2VzW3htbG1lc2gucXVlcnlTZWxlY3RvcihcInZlcnRpY2VzXCIpLmdldEF0dHJpYnV0ZShcImlkXCIpXT12ZXJ0aWNlc19zb3VyY2U7dmFyIG1lc2g9bnVsbCx4bWxwb2x5Z29ucz14bWxtZXNoLnF1ZXJ5U2VsZWN0b3IoXCJwb2x5Z29uc1wiKTtpZih4bWxwb2x5Z29ucyYmKG1lc2g9dGhpcy5yZWFkVHJpYW5nbGVzKHhtbHBvbHlnb25zLHNvdXJjZXMpKSwhbWVzaCl7dmFyIHhtbHRyaWFuZ2xlcz14bWxtZXNoLnF1ZXJ5U2VsZWN0b3JBbGwoXCJ0cmlhbmdsZXNcIik7eG1sdHJpYW5nbGVzJiZ4bWx0cmlhbmdsZXMubGVuZ3RoJiYobWVzaD10aGlzLnJlYWRUcmlhbmdsZXMoeG1sdHJpYW5nbGVzLHNvdXJjZXMpKX1pZighbWVzaCl7dmFyIHhtbHBvbHlsaXN0PXhtbG1lc2gucXVlcnlTZWxlY3RvcihcInBvbHlsaXN0XCIpO3htbHBvbHlsaXN0JiYobWVzaD10aGlzLnJlYWRQb2x5bGlzdCh4bWxwb2x5bGlzdCxzb3VyY2VzKSl9aWYoIW1lc2gpe3ZhciB4bWxsaW5lc3RyaXA9eG1sbWVzaC5xdWVyeVNlbGVjdG9yKFwibGluZXN0cmlwc1wiKTt4bWxsaW5lc3RyaXAmJihtZXNoPXRoaXMucmVhZExpbmVTdHJpcChzb3VyY2VzLHhtbGxpbmVzdHJpcCkpfWlmKCFtZXNoKXJldHVybiBjb25zb2xlLmxvZyhcIm5vIHBvbHlnb25zIG9yIHRyaWFuZ2xlcyBpbiBtZXNoOiBcIitpZCksdGhpcy5fZ2VvbWV0cmllc19mb3VuZFtpZF09bnVsbCxudWxsO2lmKGZsaXAmJiF0aGlzLm5vX2ZsaXApe2Zvcih2YXIgdG1wPTAsYXJyYXk9bWVzaC52ZXJ0aWNlcyxpPTAsbD1hcnJheS5sZW5ndGg7aTxsO2krPTMpdG1wPWFycmF5W2krMV0sYXJyYXlbaSsxXT1hcnJheVtpKzJdLGFycmF5W2krMl09LXRtcDthcnJheT1tZXNoLm5vcm1hbHM7Zm9yKHZhciBpPTAsbD1hcnJheS5sZW5ndGg7aTxsO2krPTMpdG1wPWFycmF5W2krMV0sYXJyYXlbaSsxXT1hcnJheVtpKzJdLGFycmF5W2krMl09LXRtcH1pZihpc1dvcmtlciYmdGhpcy51c2VfdHJhbnNmZXJhYmxlcylmb3IodmFyIGkgaW4gbWVzaCl7dmFyIGRhdGE9bWVzaFtpXTtkYXRhJiZkYXRhLmJ1ZmZlciYmZGF0YS5sZW5ndGg+MTAwJiZ0aGlzLl90cmFuc2ZlcmFibGVzLnB1c2goZGF0YS5idWZmZXIpfXJldHVybiBtZXNoLmZpbGVuYW1lPWlkLG1lc2gub2JqZWN0X3R5cGU9XCJNZXNoXCIsdGhpcy5fZ2VvbWV0cmllc19mb3VuZFtpZF09bWVzaCxtZXNofSxyZWFkVHJpYW5nbGVzOmZ1bmN0aW9uKHhtbHRyaWFuZ2xlcyxzb3VyY2VzKXtmb3IodmFyIGdyb3Vwcz1bXSxidWZmZXJzPVtdLGxhc3RfaW5kZXg9MCxmYWNlbWFwPXt9LHZlcnRleF9yZW1hcD1bXSxpbmRpY2VzQXJyYXk9W10sbGFzdF9zdGFydD0wLG1hdGVyaWFsX25hbWU9XCJcIix0cmlzPTA7dHJpczx4bWx0cmlhbmdsZXMubGVuZ3RoO3RyaXMrKyl7dmFyIHhtbF9zaGFwZV9yb290PXhtbHRyaWFuZ2xlcy5pdGVtKHRyaXMpLHRyaWFuZ2xlcz1cInRyaWFuZ2xlc1wiPT14bWxfc2hhcGVfcm9vdC5sb2NhbE5hbWU7bWF0ZXJpYWxfbmFtZT14bWxfc2hhcGVfcm9vdC5nZXRBdHRyaWJ1dGUoXCJtYXRlcmlhbFwiKSwwPT10cmlzJiYoYnVmZmVycz10aGlzLnJlYWRTaGFwZUlucHV0cyh4bWxfc2hhcGVfcm9vdCxzb3VyY2VzKSk7Zm9yKHZhciB4bWxwcz14bWxfc2hhcGVfcm9vdC5xdWVyeVNlbGVjdG9yQWxsKFwicFwiKSxpPShidWZmZXJzLmxlbmd0aCwwKTtpPHhtbHBzLmxlbmd0aDtpKyspe3ZhciB4bWxwPXhtbHBzLml0ZW0oaSk7aWYoIXhtbHB8fCF4bWxwLnRleHRDb250ZW50KWJyZWFrO3ZhciBkYXRhPXhtbHAudGV4dENvbnRlbnQudHJpbSgpLnNwbGl0KFwiIFwiKSxmaXJzdF9pbmRleD0tMSxjdXJyZW50X2luZGV4PS0xLHByZXZfaW5kZXg9LTEsbnVtX3ZhbHVlc19wZXJfdmVydGV4PTE7Zm9yKHZhciBiIGluIGJ1ZmZlcnMpbnVtX3ZhbHVlc19wZXJfdmVydGV4PU1hdGgubWF4KG51bV92YWx1ZXNfcGVyX3ZlcnRleCxidWZmZXJzW2JdWzRdKzEpO2Zvcih2YXIgaz0wLGw9ZGF0YS5sZW5ndGg7azxsO2srPW51bV92YWx1ZXNfcGVyX3ZlcnRleCl7dmFyIHZlcnRleF9pZD1kYXRhLnNsaWNlKGssaytudW1fdmFsdWVzX3Blcl92ZXJ0ZXgpLmpvaW4oXCIgXCIpO2lmKHByZXZfaW5kZXg9Y3VycmVudF9pbmRleCxmYWNlbWFwLmhhc093blByb3BlcnR5KHZlcnRleF9pZCkpY3VycmVudF9pbmRleD1mYWNlbWFwW3ZlcnRleF9pZF07ZWxzZXtmb3IodmFyIGo9MDtqPGJ1ZmZlcnMubGVuZ3RoOysrail7dmFyIGJ1ZmZlcj1idWZmZXJzW2pdLGFycmF5PWJ1ZmZlclsxXSxzb3VyY2U9YnVmZmVyWzNdLGluZGV4PXBhcnNlSW50KGRhdGFbaytidWZmZXJbNF1dKTswPT1qJiYodmVydGV4X3JlbWFwW2FycmF5Lmxlbmd0aC9idWZmZXJbMl1dPWluZGV4KSxpbmRleCo9YnVmZmVyWzJdO2Zvcih2YXIgeD0wO3g8YnVmZmVyWzJdOysreCl7aWYodm9pZCAwPT09c291cmNlW2luZGV4K3hdKXRocm93XCJVTkRFRklORUQhXCI7YXJyYXkucHVzaChzb3VyY2VbaW5kZXgreF0pfX1jdXJyZW50X2luZGV4PWxhc3RfaW5kZXgsbGFzdF9pbmRleCs9MSxmYWNlbWFwW3ZlcnRleF9pZF09Y3VycmVudF9pbmRleH10cmlhbmdsZXN8fCgwPT1rJiYoZmlyc3RfaW5kZXg9Y3VycmVudF9pbmRleCksaz4yJiYoaW5kaWNlc0FycmF5LnB1c2goZmlyc3RfaW5kZXgpLGluZGljZXNBcnJheS5wdXNoKHByZXZfaW5kZXgpKSksaW5kaWNlc0FycmF5LnB1c2goY3VycmVudF9pbmRleCl9fXZhciBncm91cD17bmFtZTpcImdyb3VwXCIrdHJpcyxzdGFydDpsYXN0X3N0YXJ0LGxlbmd0aDppbmRpY2VzQXJyYXkubGVuZ3RoLWxhc3Rfc3RhcnQsbWF0ZXJpYWw6bWF0ZXJpYWxfbmFtZXx8XCJcIn07bGFzdF9zdGFydD1pbmRpY2VzQXJyYXkubGVuZ3RoLGdyb3Vwcy5wdXNoKGdyb3VwKX12YXIgbWVzaD17dmVydGljZXM6bmV3IEZsb2F0MzJBcnJheShidWZmZXJzWzBdWzFdKSxpbmZvOntncm91cHM6Z3JvdXBzfSxfcmVtYXA6bmV3IFVpbnQzMkFycmF5KHZlcnRleF9yZW1hcCl9O3JldHVybiB0aGlzLnRyYW5zZm9ybU1lc2hJbmZvKG1lc2gsYnVmZmVycyxpbmRpY2VzQXJyYXkpLG1lc2h9LHJlYWRQb2x5bGlzdDpmdW5jdGlvbih4bWxfc2hhcGVfcm9vdCxzb3VyY2VzKXt2YXIgYnVmZmVycz1bXSxsYXN0X2luZGV4PTAsZmFjZW1hcD17fSx2ZXJ0ZXhfcmVtYXA9W10saW5kaWNlc0FycmF5PVtdO3htbF9zaGFwZV9yb290LmdldEF0dHJpYnV0ZShcIm1hdGVyaWFsXCIpLGJ1ZmZlcnM9dGhpcy5yZWFkU2hhcGVJbnB1dHMoeG1sX3NoYXBlX3Jvb3Qsc291cmNlcyk7Zm9yKHZhciB4bWx2Y291bnQ9eG1sX3NoYXBlX3Jvb3QucXVlcnlTZWxlY3RvcihcInZjb3VudFwiKSx2Y291bnQ9dGhpcy5yZWFkQ29udGVudEFzVUludDMyKHhtbHZjb3VudCkseG1scD14bWxfc2hhcGVfcm9vdC5xdWVyeVNlbGVjdG9yKFwicFwiKSxkYXRhPXRoaXMucmVhZENvbnRlbnRBc1VJbnQzMih4bWxwKSxudW1fZGF0YV92ZXJ0ZXg9YnVmZmVycy5sZW5ndGgscG9zPTAsaT0wLGw9dmNvdW50Lmxlbmd0aDtpPGw7KytpKWZvcih2YXIgbnVtX3ZlcnRpY2VzPXZjb3VudFtpXSxmaXJzdF9pbmRleD0tMSxjdXJyZW50X2luZGV4PS0xLHByZXZfaW5kZXg9LTEsaz0wO2s8bnVtX3ZlcnRpY2VzOysrayl7dmFyIHZlcnRleF9pZD1kYXRhLnN1YmFycmF5KHBvcyxwb3MrbnVtX2RhdGFfdmVydGV4KS5qb2luKFwiIFwiKTtpZihwcmV2X2luZGV4PWN1cnJlbnRfaW5kZXgsZmFjZW1hcC5oYXNPd25Qcm9wZXJ0eSh2ZXJ0ZXhfaWQpKWN1cnJlbnRfaW5kZXg9ZmFjZW1hcFt2ZXJ0ZXhfaWRdO2Vsc2V7Zm9yKHZhciBqPTA7ajxidWZmZXJzLmxlbmd0aDsrK2ope3ZhciBidWZmZXI9YnVmZmVyc1tqXSxpbmRleD1wYXJzZUludChkYXRhW3BvcytqXSksYXJyYXk9YnVmZmVyWzFdLHNvdXJjZT1idWZmZXJbM107MD09aiYmKHZlcnRleF9yZW1hcFthcnJheS5sZW5ndGgvbnVtX2RhdGFfdmVydGV4XT1pbmRleCksaW5kZXgqPWJ1ZmZlclsyXTtmb3IodmFyIHg9MDt4PGJ1ZmZlclsyXTsrK3gpYXJyYXkucHVzaChzb3VyY2VbaW5kZXgreF0pfWN1cnJlbnRfaW5kZXg9bGFzdF9pbmRleCxsYXN0X2luZGV4Kz0xLGZhY2VtYXBbdmVydGV4X2lkXT1jdXJyZW50X2luZGV4fW51bV92ZXJ0aWNlcz4zJiYoMD09ayYmKGZpcnN0X2luZGV4PWN1cnJlbnRfaW5kZXgpLGs+MiYmKGluZGljZXNBcnJheS5wdXNoKGZpcnN0X2luZGV4KSxpbmRpY2VzQXJyYXkucHVzaChwcmV2X2luZGV4KSkpLGluZGljZXNBcnJheS5wdXNoKGN1cnJlbnRfaW5kZXgpLHBvcys9bnVtX2RhdGFfdmVydGV4fXZhciBtZXNoPXt2ZXJ0aWNlczpuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcnNbMF1bMV0pLGluZm86e30sX3JlbWFwOm5ldyBVaW50MzJBcnJheSh2ZXJ0ZXhfcmVtYXApfTtyZXR1cm4gdGhpcy50cmFuc2Zvcm1NZXNoSW5mbyhtZXNoLGJ1ZmZlcnMsaW5kaWNlc0FycmF5KSxtZXNofSxyZWFkU2hhcGVJbnB1dHM6ZnVuY3Rpb24oeG1sX3NoYXBlX3Jvb3Qsc291cmNlcyl7Zm9yKHZhciBidWZmZXJzPVtdLHhtbGlucHV0cz14bWxfc2hhcGVfcm9vdC5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRcIiksaT0wO2k8eG1saW5wdXRzLmxlbmd0aDtpKyspe3ZhciB4bWxpbnB1dD14bWxpbnB1dHMuaXRlbShpKTtpZih4bWxpbnB1dC5nZXRBdHRyaWJ1dGUpe3ZhciBzZW1hbnRpYz14bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzZW1hbnRpY1wiKS50b1VwcGVyQ2FzZSgpLHN0cmVhbV9zb3VyY2U9c291cmNlc1t4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzb3VyY2VcIikuc3Vic3RyKDEpXSxvZmZzZXQ9cGFyc2VJbnQoeG1saW5wdXQuZ2V0QXR0cmlidXRlKFwib2Zmc2V0XCIpKSxkYXRhX3NldD0wO3htbGlucHV0LmdldEF0dHJpYnV0ZShcInNldFwiKSYmKGRhdGFfc2V0PXBhcnNlSW50KHhtbGlucHV0LmdldEF0dHJpYnV0ZShcInNldFwiKSkpLGJ1ZmZlcnMucHVzaChbc2VtYW50aWMsW10sc3RyZWFtX3NvdXJjZS5zdHJpZGUsc3RyZWFtX3NvdXJjZS5kYXRhLG9mZnNldCxkYXRhX3NldF0pfX1yZXR1cm4gYnVmZmVyc30sdHJhbnNmb3JtTWVzaEluZm86ZnVuY3Rpb24obWVzaCxidWZmZXJzLGluZGljZXNBcnJheSl7Zm9yKHZhciB0cmFuc2xhdG9yPXtub3JtYWw6XCJub3JtYWxzXCIsdGV4Y29vcmQ6XCJjb29yZHNcIn0saT0xO2k8YnVmZmVycy5sZW5ndGg7KytpKXt2YXIgbmFtZT1idWZmZXJzW2ldWzBdLnRvTG93ZXJDYXNlKCksZGF0YT1idWZmZXJzW2ldWzFdO2RhdGEubGVuZ3RoJiYodHJhbnNsYXRvcltuYW1lXSYmKG5hbWU9dHJhbnNsYXRvcltuYW1lXSksbWVzaFtuYW1lXSYmKG5hbWUrPWJ1ZmZlcnNbaV1bNV0pLG1lc2hbbmFtZV09bmV3IEZsb2F0MzJBcnJheShkYXRhKSl9cmV0dXJuIGluZGljZXNBcnJheSYmaW5kaWNlc0FycmF5Lmxlbmd0aCYmKG1lc2gudmVydGljZXMubGVuZ3RoPjY1NTM2P21lc2gudHJpYW5nbGVzPW5ldyBVaW50MzJBcnJheShpbmRpY2VzQXJyYXkpOm1lc2gudHJpYW5nbGVzPW5ldyBVaW50MTZBcnJheShpbmRpY2VzQXJyYXkpKSxtZXNofSxyZWFkTGluZVN0cmlwOmZ1bmN0aW9uKHNvdXJjZXMseG1sbGluZXN0cmlwKXtmb3IodmFyIGJ1ZmZlcnM9W10sbGFzdF9pbmRleD0wLGZhY2VtYXA9e30sdmVydGV4X3JlbWFwPVtdLGluZGljZXNBcnJheT1bXSx4bWxpbnB1dHM9eG1sbGluZXN0cmlwLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKSxpPTA7aTx4bWxpbnB1dHMubGVuZ3RoO2krKyl7dmFyIHhtbGlucHV0PXhtbGlucHV0cy5pdGVtKGkpO2lmKHhtbGlucHV0LmdldEF0dHJpYnV0ZSl7dmFyIHNlbWFudGljPXhtbGlucHV0LmdldEF0dHJpYnV0ZShcInNlbWFudGljXCIpLnRvVXBwZXJDYXNlKCksc3RyZWFtX3NvdXJjZT1zb3VyY2VzW3htbGlucHV0LmdldEF0dHJpYnV0ZShcInNvdXJjZVwiKS5zdWJzdHIoMSldLG9mZnNldD1wYXJzZUludCh4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJvZmZzZXRcIikpLGRhdGFfc2V0PTA7eG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic2V0XCIpJiYoZGF0YV9zZXQ9cGFyc2VJbnQoeG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic2V0XCIpKSksYnVmZmVycy5wdXNoKFtzZW1hbnRpYyxbXSxzdHJlYW1fc291cmNlLnN0cmlkZSxzdHJlYW1fc291cmNlLmRhdGEsb2Zmc2V0LGRhdGFfc2V0XSl9fWZvcih2YXIgeG1scHM9eG1sbGluZXN0cmlwLnF1ZXJ5U2VsZWN0b3JBbGwoXCJwXCIpLG51bV9kYXRhX3ZlcnRleD1idWZmZXJzLmxlbmd0aCxpPTA7aTx4bWxwcy5sZW5ndGg7aSsrKXt2YXIgeG1scD14bWxwcy5pdGVtKGkpO2lmKCF4bWxwfHwheG1scC50ZXh0Q29udGVudClicmVhaztmb3IodmFyIGRhdGE9eG1scC50ZXh0Q29udGVudC50cmltKCkuc3BsaXQoXCIgXCIpLGN1cnJlbnRfaW5kZXg9LTEsaz0wLGw9ZGF0YS5sZW5ndGg7azxsO2srPW51bV9kYXRhX3ZlcnRleCl7dmFyIHZlcnRleF9pZD1kYXRhLnNsaWNlKGssaytudW1fZGF0YV92ZXJ0ZXgpLmpvaW4oXCIgXCIpO2lmKGN1cnJlbnRfaW5kZXgsZmFjZW1hcC5oYXNPd25Qcm9wZXJ0eSh2ZXJ0ZXhfaWQpKWN1cnJlbnRfaW5kZXg9ZmFjZW1hcFt2ZXJ0ZXhfaWRdO2Vsc2V7Zm9yKHZhciBqPTA7ajxidWZmZXJzLmxlbmd0aDsrK2ope3ZhciBidWZmZXI9YnVmZmVyc1tqXSxpbmRleD1wYXJzZUludChkYXRhW2sral0pLGFycmF5PWJ1ZmZlclsxXSxzb3VyY2U9YnVmZmVyWzNdOzA9PWomJih2ZXJ0ZXhfcmVtYXBbYXJyYXkubGVuZ3RoL251bV9kYXRhX3ZlcnRleF09aW5kZXgpLGluZGV4Kj1idWZmZXJbMl07Zm9yKHZhciB4PTA7eDxidWZmZXJbMl07Kyt4KWFycmF5LnB1c2goc291cmNlW2luZGV4K3hdKX1jdXJyZW50X2luZGV4PWxhc3RfaW5kZXgsbGFzdF9pbmRleCs9MSxmYWNlbWFwW3ZlcnRleF9pZF09Y3VycmVudF9pbmRleH1pbmRpY2VzQXJyYXkucHVzaChjdXJyZW50X2luZGV4KX19dmFyIG1lc2g9e3ByaW1pdGl2ZTpcImxpbmVfc3RyaXBcIix2ZXJ0aWNlczpuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcnNbMF1bMV0pLGluZm86e319O3JldHVybiB0aGlzLnRyYW5zZm9ybU1lc2hJbmZvKG1lc2gsYnVmZmVycyxpbmRpY2VzQXJyYXkpfSxmaW5kWE1MTm9kZUJ5SWQ6ZnVuY3Rpb24ocm9vdCxub2RlbmFtZSxpZCl7aWYodGhpcy5feG1scm9vdC5fbm9kZXNfYnlfaWQpe3ZhciBuPXRoaXMuX3htbHJvb3QuX25vZGVzX2J5X2lkW2lkXTtpZihuJiZuLmxvY2FsTmFtZT09bm9kZW5hbWUpcmV0dXJuIG59ZWxzZXt2YXIgbj10aGlzLl94bWxyb290LmdldEVsZW1lbnRCeUlkKGlkKTtpZihuKXJldHVybiBufWZvcih2YXIgY2hpbGRzPXJvb3QuY2hpbGROb2RlcyxpPTA7aTxjaGlsZHMubGVuZ3RoOysraSl7dmFyIHhtbG5vZGU9Y2hpbGRzLml0ZW0oaSk7aWYoMT09eG1sbm9kZS5ub2RlVHlwZSYmeG1sbm9kZS5sb2NhbE5hbWU9PW5vZGVuYW1lKXtpZih4bWxub2RlLmdldEF0dHJpYnV0ZShcImlkXCIpPT1pZClyZXR1cm4geG1sbm9kZX19cmV0dXJuIG51bGx9LHJlYWRJbWFnZXM6ZnVuY3Rpb24ocm9vdCl7dmFyIHhtbGltYWdlcz1yb290LnF1ZXJ5U2VsZWN0b3IoXCJsaWJyYXJ5X2ltYWdlc1wiKTtpZigheG1saW1hZ2VzKXJldHVybiBudWxsO2Zvcih2YXIgaW1hZ2VzPXt9LHhtbGltYWdlc19jaGlsZHM9eG1saW1hZ2VzLmNoaWxkTm9kZXMsaT0wO2k8eG1saW1hZ2VzX2NoaWxkcy5sZW5ndGg7KytpKXt2YXIgeG1saW1hZ2U9eG1saW1hZ2VzX2NoaWxkcy5pdGVtKGkpO2lmKDE9PXhtbGltYWdlLm5vZGVUeXBlKXt2YXIgeG1saW5pdGZyb209eG1saW1hZ2UucXVlcnlTZWxlY3RvcihcImluaXRfZnJvbVwiKTtpZih4bWxpbml0ZnJvbSYmeG1saW5pdGZyb20udGV4dENvbnRlbnQpe3ZhciBmaWxlbmFtZT10aGlzLmdldEZpbGVuYW1lKHhtbGluaXRmcm9tLnRleHRDb250ZW50KSxpZD14bWxpbWFnZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtpbWFnZXNbaWRdPXtmaWxlbmFtZTpmaWxlbmFtZSxtYXA6aWQsbmFtZTp4bWxpbWFnZS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpLHBhdGg6eG1saW5pdGZyb20udGV4dENvbnRlbnR9fX19cmV0dXJuIGltYWdlc30scmVhZEFuaW1hdGlvbnM6ZnVuY3Rpb24ocm9vdCxzY2VuZSl7dmFyIHhtbGFuaW1hdGlvbnM9cm9vdC5xdWVyeVNlbGVjdG9yKFwibGlicmFyeV9hbmltYXRpb25zXCIpO2lmKCF4bWxhbmltYXRpb25zKXJldHVybiBudWxsO2Zvcih2YXIgeG1sYW5pbWF0aW9uX2NoaWxkcz14bWxhbmltYXRpb25zLmNoaWxkTm9kZXMsYW5pbWF0aW9ucz17b2JqZWN0X3R5cGU6XCJBbmltYXRpb25cIix0YWtlczp7fX0sZGVmYXVsdF90YWtlPXt0cmFja3M6W119LHRyYWNrcz1kZWZhdWx0X3Rha2UudHJhY2tzLGk9MDtpPHhtbGFuaW1hdGlvbl9jaGlsZHMubGVuZ3RoOysraSl7dmFyIHhtbGFuaW1hdGlvbj14bWxhbmltYXRpb25fY2hpbGRzLml0ZW0oaSk7aWYoMT09eG1sYW5pbWF0aW9uLm5vZGVUeXBlJiZcImFuaW1hdGlvblwiPT14bWxhbmltYXRpb24ubG9jYWxOYW1lKXtpZih4bWxhbmltYXRpb24uZ2V0QXR0cmlidXRlKFwiaWRcIikpdGhpcy5yZWFkQW5pbWF0aW9uKHhtbGFuaW1hdGlvbix0cmFja3MpO2Vsc2V7dmFyIHhtbGFuaW1hdGlvbjJfY2hpbGRzPXhtbGFuaW1hdGlvbi5xdWVyeVNlbGVjdG9yQWxsKFwiYW5pbWF0aW9uXCIpO2lmKHhtbGFuaW1hdGlvbjJfY2hpbGRzLmxlbmd0aClmb3IodmFyIGo9MDtqPHhtbGFuaW1hdGlvbjJfY2hpbGRzLmxlbmd0aDsrK2ope3ZhciB4bWxhbmltYXRpb24yPXhtbGFuaW1hdGlvbjJfY2hpbGRzLml0ZW0oaik7dGhpcy5yZWFkQW5pbWF0aW9uKHhtbGFuaW1hdGlvbjIsdHJhY2tzKX1lbHNlIHRoaXMucmVhZEFuaW1hdGlvbih4bWxhbmltYXRpb24sdHJhY2tzKX19fWlmKCF0cmFja3MubGVuZ3RoKXJldHVybiBudWxsO2Zvcih2YXIgbWF4X3RpbWU9MCxpPTA7aTx0cmFja3MubGVuZ3RoOysraSltYXhfdGltZTx0cmFja3NbaV0uZHVyYXRpb24mJihtYXhfdGltZT10cmFja3NbaV0uZHVyYXRpb24pO3JldHVybiBkZWZhdWx0X3Rha2UubmFtZT1cImRlZmF1bHRcIixkZWZhdWx0X3Rha2UuZHVyYXRpb249bWF4X3RpbWUsYW5pbWF0aW9ucy50YWtlc1tkZWZhdWx0X3Rha2UubmFtZV09ZGVmYXVsdF90YWtlLGFuaW1hdGlvbnN9LHJlYWRBbmltYXRpb246ZnVuY3Rpb24oeG1sYW5pbWF0aW9uLHJlc3VsdCl7aWYoXCJhbmltYXRpb25cIiE9eG1sYW5pbWF0aW9uLmxvY2FsTmFtZSlyZXR1cm4gbnVsbDt2YXIgeG1sY2hhbm5lbF9saXN0PSh4bWxhbmltYXRpb24uZ2V0QXR0cmlidXRlKFwiaWRcIikseG1sYW5pbWF0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjaGFubmVsXCIpKTtpZigheG1sY2hhbm5lbF9saXN0Lmxlbmd0aClyZXR1cm4gbnVsbDtmb3IodmFyIHRyYWNrcz1yZXN1bHR8fFtdLGk9MDtpPHhtbGNoYW5uZWxfbGlzdC5sZW5ndGg7KytpKXt2YXIgYW5pbT10aGlzLnJlYWRDaGFubmVsKHhtbGNoYW5uZWxfbGlzdC5pdGVtKGkpLHhtbGFuaW1hdGlvbik7YW5pbSYmdHJhY2tzLnB1c2goYW5pbSl9cmV0dXJuIHRyYWNrc30scmVhZENoYW5uZWw6ZnVuY3Rpb24oeG1sY2hhbm5lbCx4bWxhbmltYXRpb24pe2lmKFwiY2hhbm5lbFwiIT14bWxjaGFubmVsLmxvY2FsTmFtZXx8XCJhbmltYXRpb25cIiE9eG1sYW5pbWF0aW9uLmxvY2FsTmFtZSlyZXR1cm4gbnVsbDt2YXIgc291cmNlPXhtbGNoYW5uZWwuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpLHRhcmdldD14bWxjaGFubmVsLmdldEF0dHJpYnV0ZShcInRhcmdldFwiKSx4bWxzYW1wbGVyPXRoaXMuZmluZFhNTE5vZGVCeUlkKHhtbGFuaW1hdGlvbixcInNhbXBsZXJcIixzb3VyY2Uuc3Vic3RyKDEpKTtpZigheG1sc2FtcGxlcilyZXR1cm4gY29uc29sZS5lcnJvcihcIkVycm9yIERBRTogU2FtcGxlciBub3QgZm91bmQgaW4gXCIrc291cmNlKSxudWxsO2Zvcih2YXIgaW5wdXRzPXt9LHBhcmFtcz17fSxzb3VyY2VzPXt9LHhtbGlucHV0cz14bWxzYW1wbGVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKSx0aW1lX2RhdGE9bnVsbCxqPTA7ajx4bWxpbnB1dHMubGVuZ3RoO2orKyl7dmFyIHhtbGlucHV0PXhtbGlucHV0cy5pdGVtKGopLHNvdXJjZV9uYW1lPXhtbGlucHV0LmdldEF0dHJpYnV0ZShcInNvdXJjZVwiKSxzZW1hbnRpYz14bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzZW1hbnRpY1wiKSx4bWxzb3VyY2U9dGhpcy5maW5kWE1MTm9kZUJ5SWQoeG1sYW5pbWF0aW9uLFwic291cmNlXCIsc291cmNlX25hbWUuc3Vic3RyKDEpKTtpZih4bWxzb3VyY2Upe3ZhciB4bWxwYXJhbT14bWxzb3VyY2UucXVlcnlTZWxlY3RvcihcInBhcmFtXCIpO2lmKHhtbHBhcmFtKXt2YXIgdHlwZT14bWxwYXJhbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO2lucHV0c1tzZW1hbnRpY109e3NvdXJjZTpzb3VyY2VfbmFtZSx0eXBlOnR5cGV9O3ZhciBkYXRhX2FycmF5PW51bGw7aWYoXCJmbG9hdFwiPT10eXBlfHxcImZsb2F0NHg0XCI9PXR5cGUpe3ZhciB4bWxmbG9hdGFycmF5PXhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwiZmxvYXRfYXJyYXlcIiksZmxvYXRzPXRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWxmbG9hdGFycmF5KTtzb3VyY2VzW3NvdXJjZV9uYW1lXT1mbG9hdHMsZGF0YV9hcnJheT1mbG9hdHM7dmFyIHBhcmFtX25hbWU9eG1scGFyYW0uZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcIlRJTUVcIj09cGFyYW1fbmFtZSYmKHRpbWVfZGF0YT1kYXRhX2FycmF5KSxcIk9VVFBVVFwiPT1zZW1hbnRpYyYmKHBhcmFtX25hbWU9c2VtYW50aWMpLHBhcmFtX25hbWU/cGFyYW1zW3BhcmFtX25hbWVdPXR5cGU6Y29uc29sZS53YXJuKFwiQ29sbGFkYTogPHBhcmFtPiB3aXRob3V0IG5hbWUgYXR0cmlidXRlIGluIDxhbmltYXRpb24+XCIpfX19fWlmKCF0aW1lX2RhdGEpcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBEQUU6IG5vIFRJTUUgaW5mbyBmb3VuZCBpbiA8Y2hhbm5lbD46IFwiK3htbGNoYW5uZWwuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpKSxudWxsO3ZhciBwYXRoPXRhcmdldC5zcGxpdChcIi9cIiksYW5pbT17fSxub2RlbmFtZT1wYXRoWzBdLG5vZGU9dGhpcy5fbm9kZXNfYnlfaWRbbm9kZW5hbWVdLGxvY2F0b3I9bm9kZS5pZCtcIi9cIitwYXRoWzFdO2FuaW0ubmFtZT1wYXRoWzFdLGFuaW0ucHJvcGVydHk9bG9jYXRvcjt2YXIgdHlwZT1cIm51bWJlclwiLGVsZW1lbnRfc2l6ZT0xLHBhcmFtX3R5cGU9cGFyYW1zLk9VVFBVVDtzd2l0Y2gocGFyYW1fdHlwZSl7Y2FzZVwiZmxvYXRcIjplbGVtZW50X3NpemU9MTticmVhaztjYXNlXCJmbG9hdDN4M1wiOmVsZW1lbnRfc2l6ZT05LHR5cGU9XCJtYXQzXCI7YnJlYWs7Y2FzZVwiZmxvYXQ0eDRcIjplbGVtZW50X3NpemU9MTYsdHlwZT1cIm1hdDRcIn1hbmltLnR5cGU9dHlwZSxhbmltLnZhbHVlX3NpemU9ZWxlbWVudF9zaXplLGFuaW0uZHVyYXRpb249dGltZV9kYXRhW3RpbWVfZGF0YS5sZW5ndGgtMV07dmFyIHZhbHVlX2RhdGE9c291cmNlc1tpbnB1dHMuT1VUUFVULnNvdXJjZV07aWYoIXZhbHVlX2RhdGEpcmV0dXJuIG51bGw7Zm9yKHZhciBudW1fc2FtcGxlcz10aW1lX2RhdGEubGVuZ3RoLHNhbXBsZV9zaXplPWVsZW1lbnRfc2l6ZSsxLGFuaW1fZGF0YT1uZXcgRmxvYXQzMkFycmF5KG51bV9zYW1wbGVzKnNhbXBsZV9zaXplKSxqPTA7ajx0aW1lX2RhdGEubGVuZ3RoOysrail7YW5pbV9kYXRhW2oqc2FtcGxlX3NpemVdPXRpbWVfZGF0YVtqXTt2YXIgdmFsdWU9dmFsdWVfZGF0YS5zdWJhcnJheShqKmVsZW1lbnRfc2l6ZSwoaisxKSplbGVtZW50X3NpemUpO1wiZmxvYXQ0eDRcIj09cGFyYW1fdHlwZSYmdGhpcy50cmFuc2Zvcm1NYXRyaXgodmFsdWUsbm9kZT8wPT1ub2RlLl9kZXB0aDowKSxhbmltX2RhdGEuc2V0KHZhbHVlLGoqc2FtcGxlX3NpemUrMSl9aWYoaXNXb3JrZXImJnRoaXMudXNlX3RyYW5zZmVyYWJsZXMpe3ZhciBkYXRhPWFuaW1fZGF0YTtkYXRhJiZkYXRhLmJ1ZmZlciYmZGF0YS5sZW5ndGg+MTAwJiZ0aGlzLl90cmFuc2ZlcmFibGVzLnB1c2goZGF0YS5idWZmZXIpfXJldHVybiBhbmltLmRhdGE9YW5pbV9kYXRhLGFuaW19LGZpbmROb2RlOmZ1bmN0aW9uKHJvb3QsaWQpe2lmKHJvb3QuaWQ9PWlkKXJldHVybiByb290O2lmKHJvb3QuY2hpbGRyZW4pZm9yKHZhciBpIGluIHJvb3QuY2hpbGRyZW4pe3ZhciByZXQ9dGhpcy5maW5kTm9kZShyb290LmNoaWxkcmVuW2ldLGlkKTtpZihyZXQpcmV0dXJuIHJldH1yZXR1cm4gbnVsbH0scmVhZExpYnJhcnlDb250cm9sbGVyczpmdW5jdGlvbihzY2VuZSl7dmFyIHhtbGxpYnJhcnljb250cm9sbGVycz10aGlzLl94bWxyb290LnF1ZXJ5U2VsZWN0b3IoXCJsaWJyYXJ5X2NvbnRyb2xsZXJzXCIpO2lmKCF4bWxsaWJyYXJ5Y29udHJvbGxlcnMpcmV0dXJuIG51bGw7Zm9yKHZhciB4bWxsaWJyYXJ5Y29udHJvbGxlcnNfY2hpbGRzPXhtbGxpYnJhcnljb250cm9sbGVycy5jaGlsZE5vZGVzLGk9MDtpPHhtbGxpYnJhcnljb250cm9sbGVyc19jaGlsZHMubGVuZ3RoOysraSl7dmFyIHhtbGNvbnRyb2xsZXI9eG1sbGlicmFyeWNvbnRyb2xsZXJzX2NoaWxkcy5pdGVtKGkpO2lmKDE9PXhtbGNvbnRyb2xsZXIubm9kZVR5cGUmJlwiY29udHJvbGxlclwiPT14bWxjb250cm9sbGVyLmxvY2FsTmFtZSl7dmFyIGlkPXhtbGNvbnRyb2xsZXIuZ2V0QXR0cmlidXRlKFwiaWRcIik7dGhpcy5fY29udHJvbGxlcnNfZm91bmRbaWRdfHx0aGlzLnJlYWRDb250cm9sbGVyKHhtbGNvbnRyb2xsZXIsbnVsbCxzY2VuZSl9fX0scmVhZENvbnRyb2xsZXI6ZnVuY3Rpb24oeG1sY29udHJvbGxlcixmbGlwLHNjZW5lKXtpZihcImNvbnRyb2xsZXJcIj09IXhtbGNvbnRyb2xsZXIubG9jYWxOYW1lKXJldHVybiBjb25zb2xlLndhcm4oXCJyZWFkQ29udHJvbGxlcjogbm90IGEgY29udHJvbGxlcjogXCIreG1sY29udHJvbGxlci5sb2NhbE5hbWUpLG51bGw7dmFyIGlkPXhtbGNvbnRyb2xsZXIuZ2V0QXR0cmlidXRlKFwiaWRcIik7aWYodGhpcy5fY29udHJvbGxlcnNfZm91bmRbaWRdKXJldHVybiB0aGlzLl9jb250cm9sbGVyc19mb3VuZFtpZF07dmFyIG1lc2g9bnVsbCx4bWxza2luPXhtbGNvbnRyb2xsZXIucXVlcnlTZWxlY3RvcihcInNraW5cIik7eG1sc2tpbiYmKG1lc2g9dGhpcy5yZWFkU2tpbkNvbnRyb2xsZXIoeG1sc2tpbixmbGlwLHNjZW5lKSk7dmFyIHhtbG1vcnBoPXhtbGNvbnRyb2xsZXIucXVlcnlTZWxlY3RvcihcIm1vcnBoXCIpO3JldHVybiB4bWxtb3JwaCYmKG1lc2g9dGhpcy5yZWFkTW9ycGhDb250cm9sbGVyKHhtbG1vcnBoLGZsaXAsc2NlbmUsbWVzaCkpLHRoaXMuX2NvbnRyb2xsZXJzX2ZvdW5kW2lkXT9pZCs9XCJfMWJsYWhcIjp0aGlzLl9jb250cm9sbGVyc19mb3VuZFtpZF09bWVzaCxtZXNofSxyZWFkU2tpbkNvbnRyb2xsZXI6ZnVuY3Rpb24oeG1sc2tpbixmbGlwLHNjZW5lKXt2YXIgaWRfZ2VvbWV0cnk9eG1sc2tpbi5nZXRBdHRyaWJ1dGUoXCJzb3VyY2VcIiksbWVzaD10aGlzLnJlYWRHZW9tZXRyeShpZF9nZW9tZXRyeSxmbGlwLHNjZW5lKTtpZighbWVzaClyZXR1cm4gbnVsbDt2YXIgc291cmNlcz10aGlzLnJlYWRTb3VyY2VzKHhtbHNraW4sZmxpcCk7aWYoIXNvdXJjZXMpcmV0dXJuIG51bGw7dmFyIGJpbmRfbWF0cml4PW51bGwseG1sYmluZG1hdHJpeD14bWxza2luLnF1ZXJ5U2VsZWN0b3IoXCJiaW5kX3NoYXBlX21hdHJpeFwiKTt4bWxiaW5kbWF0cml4PyhiaW5kX21hdHJpeD10aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sYmluZG1hdHJpeCksdGhpcy50cmFuc2Zvcm1NYXRyaXgoYmluZF9tYXRyaXgsITAsITApKTpiaW5kX21hdHJpeD1fZ2xNYXRyaXgubWF0NC5jcmVhdGUoKTt2YXIgam9pbnRzPVtdLHhtbGpvaW50cz14bWxza2luLnF1ZXJ5U2VsZWN0b3IoXCJqb2ludHNcIik7aWYoeG1sam9pbnRzKXtmb3IodmFyIGpvaW50c19zb3VyY2U9bnVsbCxpbnZfYmluZF9zb3VyY2U9bnVsbCx4bWxpbnB1dHM9eG1sam9pbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKSxpPTA7aTx4bWxpbnB1dHMubGVuZ3RoO2krKyl7dmFyIHhtbGlucHV0PXhtbGlucHV0c1tpXSxzZW09eG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic2VtYW50aWNcIikudG9VcHBlckNhc2UoKSxzcmM9eG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpLHNvdXJjZT1zb3VyY2VzW3NyYy5zdWJzdHIoMSldO1wiSk9JTlRcIj09c2VtP2pvaW50c19zb3VyY2U9c291cmNlOlwiSU5WX0JJTkRfTUFUUklYXCI9PXNlbSYmKGludl9iaW5kX3NvdXJjZT1zb3VyY2UpfWlmKCFpbnZfYmluZF9zb3VyY2V8fCFqb2ludHNfc291cmNlKXJldHVybiBjb25zb2xlLmVycm9yKFwiRXJyb3IgREFFOiBubyBqb2ludHMgb3IgaW52X2JpbmQgc291cmNlcyBmb3VuZFwiKSxudWxsO2Zvcih2YXIgaSBpbiBqb2ludHNfc291cmNlKXt2YXIgaW52X21hdD1pbnZfYmluZF9zb3VyY2Uuc3ViYXJyYXkoMTYqaSwxNippKzE2KSxub2RlbmFtZT1qb2ludHNfc291cmNlW2ldLG5vZGU9dGhpcy5fbm9kZXNfYnlfaWRbbm9kZW5hbWVdO25vZGU/KHRoaXMudHJhbnNmb3JtTWF0cml4KGludl9tYXQsMD09bm9kZS5fZGVwdGgsITApLGpvaW50cy5wdXNoKFtub2RlbmFtZSxpbnZfbWF0XSkpOmNvbnNvbGUud2FybihcIk5vZGUgXCIrbm9kZW5hbWUrXCIgbm90IGZvdW5kXCIpfX12YXIgeG1sdmVydGV4d2VpZ2h0cz14bWxza2luLnF1ZXJ5U2VsZWN0b3IoXCJ2ZXJ0ZXhfd2VpZ2h0c1wiKTtpZih4bWx2ZXJ0ZXh3ZWlnaHRzKXtmb3IodmFyIHdlaWdodHNfaW5kZXhlZF9hcnJheT1udWxsLHhtbGlucHV0cz14bWx2ZXJ0ZXh3ZWlnaHRzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKSxpPTA7aTx4bWxpbnB1dHMubGVuZ3RoO2krKylcIldFSUdIVFwiPT14bWxpbnB1dHNbaV0uZ2V0QXR0cmlidXRlKFwic2VtYW50aWNcIikudG9VcHBlckNhc2UoKSYmKHdlaWdodHNfaW5kZXhlZF9hcnJheT1zb3VyY2VzW3htbGlucHV0cy5pdGVtKGkpLmdldEF0dHJpYnV0ZShcInNvdXJjZVwiKS5zdWJzdHIoMSldKTtpZighd2VpZ2h0c19pbmRleGVkX2FycmF5KXRocm93XCJubyB3ZWlnaHRzIGZvdW5kXCI7Zm9yKHZhciB4bWx2Y291bnQ9eG1sdmVydGV4d2VpZ2h0cy5xdWVyeVNlbGVjdG9yKFwidmNvdW50XCIpLHZjb3VudD10aGlzLnJlYWRDb250ZW50QXNVSW50MzIoeG1sdmNvdW50KSx4bWx2PXhtbHZlcnRleHdlaWdodHMucXVlcnlTZWxlY3RvcihcInZcIiksdj10aGlzLnJlYWRDb250ZW50QXNVSW50MzIoeG1sdiksbnVtX3ZlcnRpY2VzPW1lc2gudmVydGljZXMubGVuZ3RoLzMsd2VpZ2h0c19hcnJheT1uZXcgRmxvYXQzMkFycmF5KDQqbnVtX3ZlcnRpY2VzKSxib25lX2luZGV4X2FycmF5PW5ldyBVaW50OEFycmF5KDQqbnVtX3ZlcnRpY2VzKSxwb3M9MCxyZW1hcD1tZXNoLl9yZW1hcCxtYXhfYm9uZT0wLGk9MCxsPXZjb3VudC5sZW5ndGg7aTxsOysraSl7Zm9yKHZhciBudW1fYm9uZXM9dmNvdW50W2ldLG9mZnNldD1wb3MsYj1ib25lX2luZGV4X2FycmF5LnN1YmFycmF5KDQqaSw0KmkrNCksdz13ZWlnaHRzX2FycmF5LnN1YmFycmF5KDQqaSw0KmkrNCksc3VtPTAsaj0wO2o8bnVtX2JvbmVzJiZqPDQ7KytqKWJbal09dltvZmZzZXQrMipqXSxiW2pdPm1heF9ib25lJiYobWF4X2JvbmU9YltqXSksd1tqXT13ZWlnaHRzX2luZGV4ZWRfYXJyYXlbdltvZmZzZXQrMipqKzFdXSxzdW0rPXdbal07aWYobnVtX2JvbmVzPjQmJnN1bTwxKWZvcih2YXIgaW52X3N1bT0xL3N1bSxqPTA7ajw0Oysrail3W2pdKj1pbnZfc3VtO3Bvcys9MipudW1fYm9uZXN9Zm9yKHZhciBmaW5hbF93ZWlnaHRzPW5ldyBGbG9hdDMyQXJyYXkoNCpudW1fdmVydGljZXMpLGZpbmFsX2JvbmVfaW5kaWNlcz1uZXcgVWludDhBcnJheSg0Km51bV92ZXJ0aWNlcyksdXNlZF9qb2ludHM9W10saT0wO2k8bnVtX3ZlcnRpY2VzOysraSl7Zm9yKHZhciBwPTQqcmVtYXBbaV0sdz13ZWlnaHRzX2FycmF5LnN1YmFycmF5KHAscCs0KSxiPWJvbmVfaW5kZXhfYXJyYXkuc3ViYXJyYXkocCxwKzQpLGs9MDtrPDM7KytrKXtmb3IodmFyIG1heF9wb3M9ayxtYXhfdmFsdWU9d1trXSxqPWsrMTtqPDQ7KytqKXdbal08PW1heF92YWx1ZXx8KG1heF9wb3M9aixtYXhfdmFsdWU9d1tqXSk7aWYobWF4X3BvcyE9ayl7dmFyIHRtcD13W2tdO3dba109d1ttYXhfcG9zXSx3W21heF9wb3NdPXRtcCx0bXA9YltrXSxiW2tdPWJbbWF4X3Bvc10sYlttYXhfcG9zXT10bXB9fWZpbmFsX3dlaWdodHMuc2V0KHcsNCppKSxmaW5hbF9ib25lX2luZGljZXMuc2V0KGIsNCppKSx3WzBdJiYodXNlZF9qb2ludHNbYlswXV09ITApLHdbMV0mJih1c2VkX2pvaW50c1tiWzFdXT0hMCksd1syXSYmKHVzZWRfam9pbnRzW2JbMl1dPSEwKSx3WzNdJiYodXNlZF9qb2ludHNbYlszXV09ITApfW1heF9ib25lPj1qb2ludHMubGVuZ3RoJiZjb25zb2xlLndhcm4oXCJNZXNoIHVzZXMgaGlnaGVyIGJvbmUgaW5kZXggdGhhbiBib25lcyBmb3VuZFwiKTtmb3IodmFyIG5ld19ib25lcz1bXSxib25lc190cmFuc2xhdGlvbj17fSxpPTA7aTx1c2VkX2pvaW50cy5sZW5ndGg7KytpKXVzZWRfam9pbnRzW2ldJiYoYm9uZXNfdHJhbnNsYXRpb25baV09bmV3X2JvbmVzLmxlbmd0aCxuZXdfYm9uZXMucHVzaChqb2ludHNbaV0pKTtpZihuZXdfYm9uZXMubGVuZ3RoPGpvaW50cy5sZW5ndGgpe2Zvcih2YXIgaT0wO2k8ZmluYWxfYm9uZV9pbmRpY2VzLmxlbmd0aDtpKyspZmluYWxfYm9uZV9pbmRpY2VzW2ldPWJvbmVzX3RyYW5zbGF0aW9uW2ZpbmFsX2JvbmVfaW5kaWNlc1tpXV07am9pbnRzPW5ld19ib25lc31tZXNoLndlaWdodHM9ZmluYWxfd2VpZ2h0cyxtZXNoLmJvbmVfaW5kaWNlcz1maW5hbF9ib25lX2luZGljZXMsbWVzaC5ib25lcz1qb2ludHMsbWVzaC5iaW5kX21hdHJpeD1iaW5kX21hdHJpeH1yZXR1cm4gbWVzaH0scmVhZE1vcnBoQ29udHJvbGxlcjpmdW5jdGlvbih4bWxtb3JwaCxmbGlwLHNjZW5lLG1lc2gpe3ZhciBpZF9nZW9tZXRyeT14bWxtb3JwaC5nZXRBdHRyaWJ1dGUoXCJzb3VyY2VcIiksYmFzZV9tZXNoPXRoaXMucmVhZEdlb21ldHJ5KGlkX2dlb21ldHJ5LGZsaXAsc2NlbmUpO2lmKCFiYXNlX21lc2gpcmV0dXJuIG51bGw7dmFyIHNvdXJjZXM9dGhpcy5yZWFkU291cmNlcyh4bWxtb3JwaCxmbGlwKSxtb3JwaHM9W10seG1sdGFyZ2V0cz14bWxtb3JwaC5xdWVyeVNlbGVjdG9yKFwidGFyZ2V0c1wiKTtpZigheG1sdGFyZ2V0cylyZXR1cm4gbnVsbDtmb3IodmFyIHhtbGlucHV0cz14bWx0YXJnZXRzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKSx0YXJnZXRzPW51bGwsd2VpZ2h0cz1udWxsLGk9MDtpPHhtbGlucHV0cy5sZW5ndGg7aSsrKXt2YXIgeG1saW5wdXQ9eG1saW5wdXRzLml0ZW0oaSksc2VtYW50aWM9eG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic2VtYW50aWNcIikudG9VcHBlckNhc2UoKSxkYXRhPXNvdXJjZXNbeG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpLnN1YnN0cigxKV07XCJNT1JQSF9UQVJHRVRcIj09c2VtYW50aWM/dGFyZ2V0cz1kYXRhOlwiTU9SUEhfV0VJR0hUXCI9PXNlbWFudGljJiYod2VpZ2h0cz1kYXRhKX1pZighdGFyZ2V0c3x8IXdlaWdodHMpcmV0dXJuIGNvbnNvbGUud2FybihcIk1vcnBoIGNvbnRyb2xsZXIgd2l0aG91dCB0YXJnZXRzIG9yIHdlaWdodHMuIFNraXBwaW5nIGl0LlwiKSxudWxsO2Zvcih2YXIgaSBpbiB0YXJnZXRzKXt2YXIgaWQ9XCIjXCIrdGFyZ2V0c1tpXSxnZW9tZXRyeT10aGlzLnJlYWRHZW9tZXRyeShpZCxmbGlwLHNjZW5lKTtzY2VuZS5tZXNoZXNbaWRdPWdlb21ldHJ5LG1vcnBocy5wdXNoKHttZXNoOmlkLHdlaWdodDp3ZWlnaHRzW2ldfSl9cmV0dXJuIGJhc2VfbWVzaC5tb3JwaF90YXJnZXRzPW1vcnBocyxiYXNlX21lc2h9LHJlYWRCaW5kTWF0ZXJpYWxzOmZ1bmN0aW9uKHhtbGJpbmRfbWF0ZXJpYWwsbWVzaCl7Zm9yKHZhciBtYXRlcmlhbHM9W10seG1sdGVjaG5pcXVlcz14bWxiaW5kX21hdGVyaWFsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJ0ZWNobmlxdWVfY29tbW9uXCIpLGk9MDtpPHhtbHRlY2huaXF1ZXMubGVuZ3RoO2krKylmb3IodmFyIHhtbHRlY2huaXF1ZT14bWx0ZWNobmlxdWVzLml0ZW0oaSkseG1saW5zdGFuY2VfbWF0ZXJpYWxzPXhtbHRlY2huaXF1ZS5xdWVyeVNlbGVjdG9yQWxsKFwiaW5zdGFuY2VfbWF0ZXJpYWxcIiksaj0wO2o8eG1saW5zdGFuY2VfbWF0ZXJpYWxzLmxlbmd0aDtqKyspe3ZhciB4bWxpbnN0YW5jZV9tYXRlcmlhbD14bWxpbnN0YW5jZV9tYXRlcmlhbHMuaXRlbShqKTt4bWxpbnN0YW5jZV9tYXRlcmlhbCYmbWF0ZXJpYWxzLnB1c2goeG1saW5zdGFuY2VfbWF0ZXJpYWwuZ2V0QXR0cmlidXRlKFwic3ltYm9sXCIpKX1yZXR1cm4gbWF0ZXJpYWxzfSxyZWFkU291cmNlczpmdW5jdGlvbih4bWxub2RlLGZsaXApe2Zvcih2YXIgc291cmNlcz17fSx4bWxzb3VyY2VzPXhtbG5vZGUucXVlcnlTZWxlY3RvckFsbChcInNvdXJjZVwiKSxpPTA7aTx4bWxzb3VyY2VzLmxlbmd0aDtpKyspe3ZhciB4bWxzb3VyY2U9eG1sc291cmNlcy5pdGVtKGkpO2lmKHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKXtpZih4bWxzb3VyY2UucXVlcnlTZWxlY3RvcihcImZsb2F0X2FycmF5XCIpKXt2YXIgZmxvYXRzPXRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWxzb3VyY2UpO3NvdXJjZXNbeG1sc291cmNlLmdldEF0dHJpYnV0ZShcImlkXCIpXT1mbG9hdHN9ZWxzZXt2YXIgbmFtZV9hcnJheT14bWxzb3VyY2UucXVlcnlTZWxlY3RvcihcIk5hbWVfYXJyYXlcIik7aWYobmFtZV9hcnJheSl7dmFyIG5hbWVzPXRoaXMucmVhZENvbnRlbnRBc1N0cmluZ3NBcnJheShuYW1lX2FycmF5KTtpZighbmFtZXMpY29udGludWU7c291cmNlc1t4bWxzb3VyY2UuZ2V0QXR0cmlidXRlKFwiaWRcIildPW5hbWVzfWVsc2V7dmFyIHJlZl9hcnJheT14bWxzb3VyY2UucXVlcnlTZWxlY3RvcihcIklEUkVGX2FycmF5XCIpO2lmKHJlZl9hcnJheSl7dmFyIG5hbWVzPXRoaXMucmVhZENvbnRlbnRBc1N0cmluZ3NBcnJheShyZWZfYXJyYXkpO2lmKCFuYW1lcyljb250aW51ZTtzb3VyY2VzW3htbHNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKV09bmFtZXN9ZWxzZTt9fX19cmV0dXJuIHNvdXJjZXN9LHJlYWRDb250ZW50QXNVSW50MzI6ZnVuY3Rpb24oeG1sbm9kZSl7aWYoIXhtbG5vZGUpcmV0dXJuIG51bGw7dmFyIHRleHQ9eG1sbm9kZS50ZXh0Q29udGVudDtpZih0ZXh0PXRleHQucmVwbGFjZSgvXFxuL2dpLFwiIFwiKSx0ZXh0PXRleHQudHJpbSgpLDA9PXRleHQubGVuZ3RoKXJldHVybiBudWxsO2Zvcih2YXIgbnVtYmVycz10ZXh0LnNwbGl0KFwiIFwiKSxmbG9hdHM9bmV3IFVpbnQzMkFycmF5KG51bWJlcnMubGVuZ3RoKSxrPTA7azxudW1iZXJzLmxlbmd0aDtrKyspZmxvYXRzW2tdPXBhcnNlSW50KG51bWJlcnNba10pO3JldHVybiBmbG9hdHN9LHJlYWRDb250ZW50QXNGbG9hdHM6ZnVuY3Rpb24oeG1sbm9kZSl7aWYoIXhtbG5vZGUpcmV0dXJuIG51bGw7dmFyIHRleHQ9eG1sbm9kZS50ZXh0Q29udGVudDt0ZXh0PXRleHQucmVwbGFjZSgvXFxuL2dpLFwiIFwiKSx0ZXh0PXRleHQucmVwbGFjZSgvXFxzXFxzKy9naSxcIiBcIiksdGV4dD10ZXh0LnJlcGxhY2UoL1xcdC9naSxcIlwiKSx0ZXh0PXRleHQudHJpbSgpO2Zvcih2YXIgbnVtYmVycz10ZXh0LnNwbGl0KFwiIFwiKSxjb3VudD14bWxub2RlLmdldEF0dHJpYnV0ZShcImNvdW50XCIpLGxlbmd0aD1jb3VudD9wYXJzZUludChjb3VudCk6bnVtYmVycy5sZW5ndGgsZmxvYXRzPW5ldyBGbG9hdDMyQXJyYXkobGVuZ3RoKSxrPTA7azxudW1iZXJzLmxlbmd0aDtrKyspZmxvYXRzW2tdPXBhcnNlRmxvYXQobnVtYmVyc1trXSk7cmV0dXJuIGZsb2F0c30scmVhZENvbnRlbnRBc1N0cmluZ3NBcnJheTpmdW5jdGlvbih4bWxub2RlKXtpZigheG1sbm9kZSlyZXR1cm4gbnVsbDt2YXIgdGV4dD14bWxub2RlLnRleHRDb250ZW50O3RleHQ9dGV4dC5yZXBsYWNlKC9cXG4vZ2ksXCIgXCIpLHRleHQ9dGV4dC5yZXBsYWNlKC9cXHNcXHMvZ2ksXCIgXCIpLHRleHQ9dGV4dC50cmltKCk7Zm9yKHZhciB3b3Jkcz10ZXh0LnNwbGl0KFwiIFwiKSxrPTA7azx3b3Jkcy5sZW5ndGg7aysrKXdvcmRzW2tdPXdvcmRzW2tdLnRyaW0oKTtpZih4bWxub2RlLmdldEF0dHJpYnV0ZShcImNvdW50XCIpJiZwYXJzZUludCh4bWxub2RlLmdldEF0dHJpYnV0ZShcImNvdW50XCIpKSE9d29yZHMubGVuZ3RoKXt2YXIgbWVyZ2VkX3dvcmRzPVtdLG5hbWU9XCJcIjtmb3IodmFyIGkgaW4gd29yZHMpbmFtZT9uYW1lKz1cIiBcIit3b3Jkc1tpXTpuYW1lPXdvcmRzW2ldLHRoaXMuX25vZGVzX2J5X2lkW3RoaXMuc2FmZVN0cmluZyhuYW1lKV0mJihtZXJnZWRfd29yZHMucHVzaCh0aGlzLnNhZmVTdHJpbmcobmFtZSkpLG5hbWU9XCJcIik7dmFyIGNvdW50PXBhcnNlSW50KHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwiY291bnRcIikpO3JldHVybiBtZXJnZWRfd29yZHMubGVuZ3RoPT1jb3VudD9tZXJnZWRfd29yZHM6KGNvbnNvbGUuZXJyb3IoXCJFcnJvcjogYm9uZSBuYW1lcyBoYXZlIHNwYWNlcywgYXZvaWQgdXNpbmcgc3BhY2VzIGluIG5hbWVzXCIpLG51bGwpfXJldHVybiB3b3Jkc30sbWF4M2RfbWF0cml4XzA6bmV3IEZsb2F0MzJBcnJheShbMCwtMSwwLDAsMCwwLC0xLDAsMSwwLDAsLTAsMCwwLDAsMV0pLHRyYW5zZm9ybU1hdHJpeDpmdW5jdGlvbihtYXRyaXgsZmlyc3RfbGV2ZWwsaW52ZXJ0ZWQpe2lmKF9nbE1hdHJpeC5tYXQ0LnRyYW5zcG9zZShtYXRyaXgsbWF0cml4KSx0aGlzLm5vX2ZsaXApcmV0dXJuIG1hdHJpeDtpZihmaXJzdF9sZXZlbCl7dmFyIHRlbXA9bmV3IEZsb2F0MzJBcnJheShtYXRyaXguc3ViYXJyYXkoNCw4KSk7bWF0cml4LnNldChtYXRyaXguc3ViYXJyYXkoOCwxMiksNCksbWF0cml4LnNldCh0ZW1wLDgpLHRlbXA9bWF0cml4LnN1YmFycmF5KDgsMTIpLHZlYzQuc2NhbGUodGVtcCx0ZW1wLC0xKX1lbHNle3ZhciBNPV9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpLG09bWF0cml4O00uc2V0KFttWzBdLG1bMl0sLW1bMV1dLDApLE0uc2V0KFttWzhdLG1bMTBdLC1tWzldXSw0KSxNLnNldChbLW1bNF0sLW1bNl0sbVs1XV0sOCksTS5zZXQoW21bMTJdLG1bMTRdLC1tWzEzXV0sMTIpLG0uc2V0KE0pfXJldHVybiBtYXRyaXh9fTtleHBvcnRzLmRlZmF1bHQ9Q29sbGFkYSxtb2R1bGUuZXhwb3J0cz1leHBvcnRzLmRlZmF1bHR9KS5jYWxsKGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyg3MCkpfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjt2YXIgZyxfdHlwZW9mPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihvYmope3JldHVybiB0eXBlb2Ygb2JqfTpmdW5jdGlvbihvYmope3JldHVybiBvYmomJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmb2JqLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZvYmohPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIG9ian07Zz1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3RyeXtnPWd8fEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKXx8KDAsZXZhbCkoXCJ0aGlzXCIpfWNhdGNoKGUpe1wib2JqZWN0XCI9PT0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz9cInVuZGVmaW5lZFwiOl90eXBlb2Yod2luZG93KSkmJihnPXdpbmRvdyl9bW9kdWxlLmV4cG9ydHM9Z30sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7ZGVmYXVsdDpvYmp9fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSxDb25zdHJ1Y3Rvcil7aWYoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHwhMSxkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBkZXNjcmlwdG9yJiYoZGVzY3JpcHRvci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCxkZXNjcmlwdG9yLmtleSxkZXNjcmlwdG9yKX19cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe3JldHVybiBwcm90b1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKSxzdGF0aWNQcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyksQ29uc3RydWN0b3J9fSgpLF9QYXNzPV9fd2VicGFja19yZXF1aXJlX18oOSksX0dMVG9vbD0oX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGFzcyksX193ZWJwYWNrX3JlcXVpcmVfXygwKSksX0dMVG9vbDI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR0xUb29sKSxfR2VvbT1fX3dlYnBhY2tfcmVxdWlyZV9fKDcpLF9HZW9tMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HZW9tKSxfRnJhbWVCdWZmZXI9X193ZWJwYWNrX3JlcXVpcmVfXygxMiksX0ZyYW1lQnVmZmVyMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GcmFtZUJ1ZmZlciksRWZmZWN0Q29tcG9zZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBFZmZlY3RDb21wb3NlcihtV2lkdGgsbUhlaWdodCl7YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXTtfY2xhc3NDYWxsQ2hlY2sodGhpcyxFZmZlY3RDb21wb3NlciksdGhpcy5fd2lkdGg9bVdpZHRofHxfR0xUb29sMi5kZWZhdWx0LndpZHRoLHRoaXMuX2hlaWdodD1tSGVpZ2h0fHxfR0xUb29sMi5kZWZhdWx0LmhlaWdodCx0aGlzLl9wYXJhbXM9e30sdGhpcy5zZXRTaXplKG1XaWR0aCxtSGVpZ2h0KSx0aGlzLl9tZXNoPV9HZW9tMi5kZWZhdWx0LmJpZ1RyaWFuZ2xlKCksdGhpcy5fcGFzc2VzPVtdLHRoaXMuX3JldHVyblRleHR1cmV9cmV0dXJuIF9jcmVhdGVDbGFzcyhFZmZlY3RDb21wb3Nlcixbe2tleTpcImFkZFBhc3NcIix2YWx1ZTpmdW5jdGlvbihwYXNzKXtpZihwYXNzLnBhc3NlcylyZXR1cm4gdm9pZCB0aGlzLmFkZFBhc3MocGFzcy5wYXNzZXMpO2lmKHBhc3MubGVuZ3RoKWZvcih2YXIgaT0wO2k8cGFzcy5sZW5ndGg7aSsrKXRoaXMuX3Bhc3Nlcy5wdXNoKHBhc3NbaV0pO2Vsc2UgdGhpcy5fcGFzc2VzLnB1c2gocGFzcyl9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24obVNvdXJjZSl7dmFyIF90aGlzPXRoaXMsc291cmNlPW1Tb3VyY2UsZmJvVGFyZ2V0PXZvaWQgMDtyZXR1cm4gdGhpcy5fcGFzc2VzLmZvckVhY2goZnVuY3Rpb24ocGFzcyl7ZmJvVGFyZ2V0PXBhc3MuaGFzRmJvP3Bhc3MuZmJvOl90aGlzLl9mYm9UYXJnZXQsZmJvVGFyZ2V0LmJpbmQoKSxfR0xUb29sMi5kZWZhdWx0LmNsZWFyKDAsMCwwLDApLHBhc3MucmVuZGVyKHNvdXJjZSksX0dMVG9vbDIuZGVmYXVsdC5kcmF3KF90aGlzLl9tZXNoKSxmYm9UYXJnZXQudW5iaW5kKCkscGFzcy5oYXNGYm8/c291cmNlPXBhc3MuZmJvLmdldFRleHR1cmUoKTooX3RoaXMuX3N3YXAoKSxzb3VyY2U9X3RoaXMuX2Zib0N1cnJlbnQuZ2V0VGV4dHVyZSgpKX0pLHRoaXMuX3JldHVyblRleHR1cmU9c291cmNlLHNvdXJjZX19LHtrZXk6XCJfc3dhcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHRtcD10aGlzLl9mYm9DdXJyZW50O3RoaXMuX2Zib0N1cnJlbnQ9dGhpcy5fZmJvVGFyZ2V0LHRoaXMuX2Zib1RhcmdldD10bXAsdGhpcy5fY3VycmVudD10aGlzLl9mYm9DdXJyZW50LHRoaXMuX3RhcmdldD10aGlzLl9mYm9UYXJnZXR9fSx7a2V5Olwic2V0U2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKG1XaWR0aCxtSGVpZ2h0KXt0aGlzLl93aWR0aD1tV2lkdGgsdGhpcy5faGVpZ2h0PW1IZWlnaHQsdGhpcy5fZmJvQ3VycmVudD1uZXcgX0ZyYW1lQnVmZmVyMi5kZWZhdWx0KHRoaXMuX3dpZHRoLHRoaXMuX2hlaWdodCx0aGlzLl9wYXJhbXMpLHRoaXMuX2Zib1RhcmdldD1uZXcgX0ZyYW1lQnVmZmVyMi5kZWZhdWx0KHRoaXMuX3dpZHRoLHRoaXMuX2hlaWdodCx0aGlzLl9wYXJhbXMpfX0se2tleTpcImdldFRleHR1cmVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZXR1cm5UZXh0dXJlfX0se2tleTpcInBhc3Nlc1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wYXNzZXN9fV0pLEVmZmVjdENvbXBvc2VyfSgpO2V4cG9ydHMuZGVmYXVsdD1FZmZlY3RDb21wb3Nlcn0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7ZGVmYXVsdDpvYmp9fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSxDb25zdHJ1Y3Rvcil7aWYoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsY2FsbCl7aWYoIXNlbGYpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFjYWxsfHxcIm9iamVjdFwiIT10eXBlb2YgY2FsbCYmXCJmdW5jdGlvblwiIT10eXBlb2YgY2FsbD9zZWxmOmNhbGx9ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLHN1cGVyQ2xhc3Mpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHN1cGVyQ2xhc3MmJm51bGwhPT1zdXBlckNsYXNzKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBzdXBlckNsYXNzKTtzdWJDbGFzcy5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzJiZzdXBlckNsYXNzLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnN1YkNsYXNzLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHN1cGVyQ2xhc3MmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLHN1cGVyQ2xhc3MpOnN1YkNsYXNzLl9fcHJvdG9fXz1zdXBlckNsYXNzKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX1Bhc3NWQmx1cj1fX3dlYnBhY2tfcmVxdWlyZV9fKDM3KSxfUGFzc1ZCbHVyMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QYXNzVkJsdXIpLF9QYXNzSEJsdXI9X193ZWJwYWNrX3JlcXVpcmVfXygzOSksX1Bhc3NIQmx1cjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGFzc0hCbHVyKSxfUGFzc01hY3JvMj1fX3dlYnBhY2tfcmVxdWlyZV9fKDM2KSxfUGFzc01hY3JvMz1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QYXNzTWFjcm8yKSxQYXNzQmx1cj1mdW5jdGlvbihfUGFzc01hY3JvKXtmdW5jdGlvbiBQYXNzQmx1cigpe3ZhciBtUXVhbGl0eT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06OSxtV2lkdGg9YXJndW1lbnRzWzFdLG1IZWlnaHQ9YXJndW1lbnRzWzJdLG1QYXJhbXM9YXJndW1lbnRzWzNdO19jbGFzc0NhbGxDaGVjayh0aGlzLFBhc3NCbHVyKTt2YXIgX3RoaXM9X3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywoUGFzc0JsdXIuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoUGFzc0JsdXIpKS5jYWxsKHRoaXMpKSx2Qmx1cj1uZXcgX1Bhc3NWQmx1cjIuZGVmYXVsdChtUXVhbGl0eSxtV2lkdGgsbUhlaWdodCxtUGFyYW1zKSxoQmx1cj1uZXcgX1Bhc3NIQmx1cjIuZGVmYXVsdChtUXVhbGl0eSxtV2lkdGgsbUhlaWdodCxtUGFyYW1zKTtyZXR1cm4gX3RoaXMuYWRkUGFzcyh2Qmx1ciksX3RoaXMuYWRkUGFzcyhoQmx1ciksX3RoaXN9cmV0dXJuIF9pbmhlcml0cyhQYXNzQmx1cixfUGFzc01hY3JvKSxQYXNzQmx1cn0oX1Bhc3NNYWNybzMuZGVmYXVsdCk7ZXhwb3J0cy5kZWZhdWx0PVBhc3NCbHVyfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9XCIvLyBibHVyNS5mcmFnXFxuLy8gc291cmNlICA6IGh0dHBzOi8vZ2l0aHViLmNvbS9KYW0zL2dsc2wtZmFzdC1nYXVzc2lhbi1ibHVyXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBCTFVSXzVcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcbnVuaWZvcm0gdmVjMiB1RGlyZWN0aW9uO1xcbnVuaWZvcm0gdmVjMiB1UmVzb2x1dGlvbjtcXG5cXG52ZWM0IGJsdXI1KHNhbXBsZXIyRCBpbWFnZSwgdmVjMiB1diwgdmVjMiByZXNvbHV0aW9uLCB2ZWMyIGRpcmVjdGlvbikge1xcblxcdHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuXFx0dmVjMiBvZmYxID0gdmVjMigxLjMzMzMzMzMzMzMzMzMzMzMpICogZGlyZWN0aW9uO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYpICogMC4yOTQxMTc2NDcwNTg4MjM1NDtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjEgLyByZXNvbHV0aW9uKSkgKiAwLjM1Mjk0MTE3NjQ3MDU4ODI2O1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgLSAob2ZmMSAvIHJlc29sdXRpb24pKSAqIDAuMzUyOTQxMTc2NDcwNTg4MjY7XFxuXFx0cmV0dXJuIGNvbG9yOyBcXG59XFxuXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gYmx1cjUodGV4dHVyZSwgdlRleHR1cmVDb29yZCwgdVJlc29sdXRpb24sIHVEaXJlY3Rpb24pO1xcbn1cIn0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPVwiLy8gYmx1cjkuZnJhZ1xcbi8vIHNvdXJjZSAgOiBodHRwczovL2dpdGh1Yi5jb20vSmFtMy9nbHNsLWZhc3QtZ2F1c3NpYW4tYmx1clxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgQkxVUl85XFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG51bmlmb3JtIHZlYzIgdURpcmVjdGlvbjtcXG51bmlmb3JtIHZlYzIgdVJlc29sdXRpb247XFxuXFxudmVjNCBibHVyOShzYW1wbGVyMkQgaW1hZ2UsIHZlYzIgdXYsIHZlYzIgcmVzb2x1dGlvbiwgdmVjMiBkaXJlY3Rpb24pIHtcXG5cXHR2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcblxcdHZlYzIgb2ZmMSA9IHZlYzIoMS4zODQ2MTUzODQ2KSAqIGRpcmVjdGlvbjtcXG5cXHR2ZWMyIG9mZjIgPSB2ZWMyKDMuMjMwNzY5MjMwOCkgKiBkaXJlY3Rpb247XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1dikgKiAwLjIyNzAyNzAyNzA7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diArIChvZmYxIC8gcmVzb2x1dGlvbikpICogMC4zMTYyMTYyMTYyO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgLSAob2ZmMSAvIHJlc29sdXRpb24pKSAqIDAuMzE2MjE2MjE2MjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjIgLyByZXNvbHV0aW9uKSkgKiAwLjA3MDI3MDI3MDM7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYyIC8gcmVzb2x1dGlvbikpICogMC4wNzAyNzAyNzAzO1xcblxcdHJldHVybiBjb2xvcjtcXG59XFxuXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gYmx1cjkodGV4dHVyZSwgdlRleHR1cmVDb29yZCwgdVJlc29sdXRpb24sIHVEaXJlY3Rpb24pO1xcbn1cIn0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPVwiLy8gYmx1cjEzLmZyYWdcXG4vLyBzb3VyY2UgIDogaHR0cHM6Ly9naXRodWIuY29tL0phbTMvZ2xzbC1mYXN0LWdhdXNzaWFuLWJsdXJcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEJMVVJfMTNcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcbnVuaWZvcm0gdmVjMiB1RGlyZWN0aW9uO1xcbnVuaWZvcm0gdmVjMiB1UmVzb2x1dGlvbjtcXG5cXG52ZWM0IGJsdXIxMyhzYW1wbGVyMkQgaW1hZ2UsIHZlYzIgdXYsIHZlYzIgcmVzb2x1dGlvbiwgdmVjMiBkaXJlY3Rpb24pIHtcXG5cXHR2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcblxcdHZlYzIgb2ZmMSA9IHZlYzIoMS40MTE3NjQ3MDU4ODIzNTMpICogZGlyZWN0aW9uO1xcblxcdHZlYzIgb2ZmMiA9IHZlYzIoMy4yOTQxMTc2NDcwNTg4MjM0KSAqIGRpcmVjdGlvbjtcXG5cXHR2ZWMyIG9mZjMgPSB2ZWMyKDUuMTc2NDcwNTg4MjM1Mjk0KSAqIGRpcmVjdGlvbjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2KSAqIDAuMTk2NDgyNTUwMTUxMTQwNDtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjEgLyByZXNvbHV0aW9uKSkgKiAwLjI5NjkwNjk2NDY3MjgzNDQ7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYxIC8gcmVzb2x1dGlvbikpICogMC4yOTY5MDY5NjQ2NzI4MzQ0O1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgKyAob2ZmMiAvIHJlc29sdXRpb24pKSAqIDAuMDk0NDcwMzk3ODUwNDQ3MzI7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYyIC8gcmVzb2x1dGlvbikpICogMC4wOTQ0NzAzOTc4NTA0NDczMjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjMgLyByZXNvbHV0aW9uKSkgKiAwLjAxMDM4MTM2MjQwMTE0ODA1NztcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2IC0gKG9mZjMgLyByZXNvbHV0aW9uKSkgKiAwLjAxMDM4MTM2MjQwMTE0ODA1NztcXG5cXHRyZXR1cm4gY29sb3I7XFxufVxcblxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGJsdXIxMyh0ZXh0dXJlLCB2VGV4dHVyZUNvb3JkLCB1UmVzb2x1dGlvbiwgdURpcmVjdGlvbik7XFxufVwifSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntkZWZhdWx0Om9ian19ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLENvbnN0cnVjdG9yKXtpZighKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZixjYWxsKXtpZighc2VsZil0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWNhbGx8fFwib2JqZWN0XCIhPXR5cGVvZiBjYWxsJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBjYWxsP3NlbGY6Y2FsbH1mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3Msc3VwZXJDbGFzcyl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygc3VwZXJDbGFzcyYmbnVsbCE9PXN1cGVyQ2xhc3MpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHN1cGVyQ2xhc3MpO3N1YkNsYXNzLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MmJnN1cGVyQ2xhc3MucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6c3ViQ2xhc3MsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksc3VwZXJDbGFzcyYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3Msc3VwZXJDbGFzcyk6c3ViQ2xhc3MuX19wcm90b19fPXN1cGVyQ2xhc3MpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBfR0xUb29sPV9fd2VicGFja19yZXF1aXJlX18oMCksX0dMVG9vbDI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR0xUb29sKSxfUGFzczI9X193ZWJwYWNrX3JlcXVpcmVfXyg5KSxfUGFzczM9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGFzczIpLF9meGFhPV9fd2VicGFja19yZXF1aXJlX18oNDApLF9meGFhMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9meGFhKSxQYXNzRnhhYT1mdW5jdGlvbihfUGFzcyl7ZnVuY3Rpb24gUGFzc0Z4YWEoKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxQYXNzRnhhYSk7dmFyIF90aGlzPV9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsKFBhc3NGeGFhLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKFBhc3NGeGFhKSkuY2FsbCh0aGlzLF9meGFhMi5kZWZhdWx0KSk7cmV0dXJuIF90aGlzLnVuaWZvcm0oXCJ1UmVzb2x1dGlvblwiLFsxL19HTFRvb2wyLmRlZmF1bHQud2lkdGgsMS9fR0xUb29sMi5kZWZhdWx0LmhlaWdodF0pLF90aGlzfXJldHVybiBfaW5oZXJpdHMoUGFzc0Z4YWEsX1Bhc3MpLFBhc3NGeGFhfShfUGFzczMuZGVmYXVsdCk7ZXhwb3J0cy5kZWZhdWx0PVBhc3NGeGFhfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntkZWZhdWx0Om9ian19ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLENvbnN0cnVjdG9yKXtpZighKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZixjYWxsKXtpZighc2VsZil0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIWNhbGx8fFwib2JqZWN0XCIhPXR5cGVvZiBjYWxsJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBjYWxsP3NlbGY6Y2FsbH1mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3Msc3VwZXJDbGFzcyl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygc3VwZXJDbGFzcyYmbnVsbCE9PXN1cGVyQ2xhc3MpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHN1cGVyQ2xhc3MpO3N1YkNsYXNzLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MmJnN1cGVyQ2xhc3MucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6c3ViQ2xhc3MsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksc3VwZXJDbGFzcyYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3Msc3VwZXJDbGFzcyk6c3ViQ2xhc3MuX19wcm90b19fPXN1cGVyQ2xhc3MpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHwhMSxkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBkZXNjcmlwdG9yJiYoZGVzY3JpcHRvci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCxkZXNjcmlwdG9yLmtleSxkZXNjcmlwdG9yKX19cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe3JldHVybiBwcm90b1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKSxzdGF0aWNQcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyksQ29uc3RydWN0b3J9fSgpLF9nZXQ9ZnVuY3Rpb24gZ2V0KG9iamVjdCxwcm9wZXJ0eSxyZWNlaXZlcil7bnVsbD09PW9iamVjdCYmKG9iamVjdD1GdW5jdGlvbi5wcm90b3R5cGUpO3ZhciBkZXNjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LHByb3BlcnR5KTtpZih2b2lkIDA9PT1kZXNjKXt2YXIgcGFyZW50PU9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpO3JldHVybiBudWxsPT09cGFyZW50P3ZvaWQgMDpnZXQocGFyZW50LHByb3BlcnR5LHJlY2VpdmVyKX1pZihcInZhbHVlXCJpbiBkZXNjKXJldHVybiBkZXNjLnZhbHVlO3ZhciBnZXR0ZXI9ZGVzYy5nZXQ7aWYodm9pZCAwIT09Z2V0dGVyKXJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcil9LF9HZW9tPV9fd2VicGFja19yZXF1aXJlX18oNyksX0dlb20yPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dlb20pLF9HTFNoYWRlcj1fX3dlYnBhY2tfcmVxdWlyZV9fKDIpLF9HTFNoYWRlcjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR0xTaGFkZXIpLF9CYXRjaDI9X193ZWJwYWNrX3JlcXVpcmVfXyg0KSxfQmF0Y2gzPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JhdGNoMiksdnM9X193ZWJwYWNrX3JlcXVpcmVfXygxOCksZnM9X193ZWJwYWNrX3JlcXVpcmVfXygxOSksQmF0Y2hDb3B5PWZ1bmN0aW9uKF9CYXRjaCl7ZnVuY3Rpb24gQmF0Y2hDb3B5KCl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsQmF0Y2hDb3B5KTt2YXIgbWVzaD1fR2VvbTIuZGVmYXVsdC5iaWdUcmlhbmdsZSgpLHNoYWRlcj1uZXcgX0dMU2hhZGVyMi5kZWZhdWx0KHZzLGZzKSxfdGhpcz1fcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLChCYXRjaENvcHkuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmF0Y2hDb3B5KSkuY2FsbCh0aGlzLG1lc2gsc2hhZGVyKSk7cmV0dXJuIHNoYWRlci5iaW5kKCksc2hhZGVyLnVuaWZvcm0oXCJ0ZXh0dXJlXCIsXCJ1bmlmb3JtMWlcIiwwKSxfdGhpc31yZXR1cm4gX2luaGVyaXRzKEJhdGNoQ29weSxfQmF0Y2gpLF9jcmVhdGVDbGFzcyhCYXRjaENvcHksW3trZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odGV4dHVyZSl7dGhpcy5zaGFkZXIuYmluZCgpLHRleHR1cmUuYmluZCgwKSxfZ2V0KEJhdGNoQ29weS5wcm90b3R5cGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmF0Y2hDb3B5LnByb3RvdHlwZSksXCJkcmF3XCIsdGhpcykuY2FsbCh0aGlzKX19XSksQmF0Y2hDb3B5fShfQmF0Y2gzLmRlZmF1bHQpO2V4cG9ydHMuZGVmYXVsdD1CYXRjaENvcHl9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLGNhbGwpe2lmKCFzZWxmKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hY2FsbHx8XCJvYmplY3RcIiE9dHlwZW9mIGNhbGwmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGNhbGw/c2VsZjpjYWxsfWZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcyxzdXBlckNsYXNzKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBzdXBlckNsYXNzJiZudWxsIT09c3VwZXJDbGFzcyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2Ygc3VwZXJDbGFzcyk7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyYmc3VwZXJDbGFzcy5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpzdWJDbGFzcyxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxzdXBlckNsYXNzJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcyxzdXBlckNsYXNzKTpzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzcyl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9HTFRvb2w9X193ZWJwYWNrX3JlcXVpcmVfXygwKSxfR0xUb29sMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HTFRvb2wpLF9NZXNoPV9fd2VicGFja19yZXF1aXJlX18oNSksX01lc2gyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01lc2gpLF9HTFNoYWRlcj1fX3dlYnBhY2tfcmVxdWlyZV9fKDIpLF9HTFNoYWRlcjI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR0xTaGFkZXIpLF9CYXRjaDI9X193ZWJwYWNrX3JlcXVpcmVfXyg0KSxfQmF0Y2gzPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JhdGNoMiksdnM9X193ZWJwYWNrX3JlcXVpcmVfXyg3OSksZnM9X193ZWJwYWNrX3JlcXVpcmVfXyg4MCksQmF0Y2hBeGlzPWZ1bmN0aW9uKF9CYXRjaCl7ZnVuY3Rpb24gQmF0Y2hBeGlzKCl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsQmF0Y2hBeGlzKTt2YXIgcG9zaXRpb25zPVtdLGNvbG9ycz1bXSxpbmRpY2VzPVswLDEsMiwzLDQsNV0scj05OTk5O3Bvc2l0aW9ucy5wdXNoKFstciwwLDBdKSxwb3NpdGlvbnMucHVzaChbciwwLDBdKSxwb3NpdGlvbnMucHVzaChbMCwtciwwXSkscG9zaXRpb25zLnB1c2goWzAsciwwXSkscG9zaXRpb25zLnB1c2goWzAsMCwtcl0pLHBvc2l0aW9ucy5wdXNoKFswLDAscl0pLGNvbG9ycy5wdXNoKFsxLDAsMF0pLGNvbG9ycy5wdXNoKFsxLDAsMF0pLGNvbG9ycy5wdXNoKFswLDEsMF0pLGNvbG9ycy5wdXNoKFswLDEsMF0pLGNvbG9ycy5wdXNoKFswLDAsMV0pLGNvbG9ycy5wdXNoKFswLDAsMV0pO3ZhciBtZXNoPW5ldyBfTWVzaDIuZGVmYXVsdChfR0xUb29sMi5kZWZhdWx0LkxJTkVTKTttZXNoLmJ1ZmZlclZlcnRleChwb3NpdGlvbnMpLG1lc2guYnVmZmVySW5kZXgoaW5kaWNlcyksbWVzaC5idWZmZXJEYXRhKGNvbG9ycyxcImFDb2xvclwiLDMpO3ZhciBzaGFkZXI9bmV3IF9HTFNoYWRlcjIuZGVmYXVsdCh2cyxmcyk7cmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsKEJhdGNoQXhpcy5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihCYXRjaEF4aXMpKS5jYWxsKHRoaXMsbWVzaCxzaGFkZXIpKX1yZXR1cm4gX2luaGVyaXRzKEJhdGNoQXhpcyxfQmF0Y2gpLEJhdGNoQXhpc30oX0JhdGNoMy5kZWZhdWx0KTtleHBvcnRzLmRlZmF1bHQ9QmF0Y2hBeGlzfSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9XCIvLyBheGlzLnZlcnRcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEJBU0lDX1ZFUlRFWFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMyBhQ29sb3I7XFxuYXR0cmlidXRlIHZlYzMgYU5vcm1hbDtcXG5cXG51bmlmb3JtIG1hdDQgdU1vZGVsTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1Vmlld01hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMzIHZDb2xvcjtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdVZpZXdNYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcXG4gICAgdkNvbG9yID0gYUNvbG9yO1xcbiAgICB2Tm9ybWFsID0gYU5vcm1hbDtcXG59XCJ9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1cIi8vIGF4aXMuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgU0lNUExFX1RFWFRVUkVcXG5cXG5wcmVjaXNpb24gbG93cCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMyB2Q29sb3I7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXHQvLyB2ZWMzIGNvbG9yID0gdk5vcm1hbDtcXG5cXHR2ZWMzIGNvbG9yID0gdkNvbG9yICsgdk5vcm1hbCAqIDAuMDAwMTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcXG59XCJ9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLGNhbGwpe2lmKCFzZWxmKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hY2FsbHx8XCJvYmplY3RcIiE9dHlwZW9mIGNhbGwmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGNhbGw/c2VsZjpjYWxsfWZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcyxzdXBlckNsYXNzKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBzdXBlckNsYXNzJiZudWxsIT09c3VwZXJDbGFzcyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2Ygc3VwZXJDbGFzcyk7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyYmc3VwZXJDbGFzcy5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpzdWJDbGFzcyxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxzdXBlckNsYXNzJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcyxzdXBlckNsYXNzKTpzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzcyl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fCExLGRlc2NyaXB0b3IuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGRlc2NyaXB0b3ImJihkZXNjcmlwdG9yLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpfX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7cmV0dXJuIHByb3RvUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpLHN0YXRpY1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKSxDb25zdHJ1Y3Rvcn19KCksX2dldD1mdW5jdGlvbiBnZXQob2JqZWN0LHByb3BlcnR5LHJlY2VpdmVyKXtudWxsPT09b2JqZWN0JiYob2JqZWN0PUZ1bmN0aW9uLnByb3RvdHlwZSk7dmFyIGRlc2M9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QscHJvcGVydHkpO2lmKHZvaWQgMD09PWRlc2Mpe3ZhciBwYXJlbnQ9T2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7cmV0dXJuIG51bGw9PT1wYXJlbnQ/dm9pZCAwOmdldChwYXJlbnQscHJvcGVydHkscmVjZWl2ZXIpfWlmKFwidmFsdWVcImluIGRlc2MpcmV0dXJuIGRlc2MudmFsdWU7dmFyIGdldHRlcj1kZXNjLmdldDtpZih2b2lkIDAhPT1nZXR0ZXIpcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKX0sX0dlb209X193ZWJwYWNrX3JlcXVpcmVfXyg3KSxfR2VvbTI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR2VvbSksX0dMU2hhZGVyPV9fd2VicGFja19yZXF1aXJlX18oMiksX0dMU2hhZGVyMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HTFNoYWRlciksX0JhdGNoMj1fX3dlYnBhY2tfcmVxdWlyZV9fKDQpLF9CYXRjaDM9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmF0Y2gyKSx2cz1fX3dlYnBhY2tfcmVxdWlyZV9fKDMzKSxmcz1fX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSxCYXRjaEJhbGw9ZnVuY3Rpb24oX0JhdGNoKXtmdW5jdGlvbiBCYXRjaEJhbGwoKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxCYXRjaEJhbGwpO3ZhciBtZXNoPV9HZW9tMi5kZWZhdWx0LnNwaGVyZSgxLDI0KSxzaGFkZXI9bmV3IF9HTFNoYWRlcjIuZGVmYXVsdCh2cyxmcyk7cmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsKEJhdGNoQmFsbC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihCYXRjaEJhbGwpKS5jYWxsKHRoaXMsbWVzaCxzaGFkZXIpKX1yZXR1cm4gX2luaGVyaXRzKEJhdGNoQmFsbCxfQmF0Y2gpLF9jcmVhdGVDbGFzcyhCYXRjaEJhbGwsW3trZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgcG9zaXRpb249YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOlswLDAsMF0sc2NhbGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOlsxLDEsMV0sY29sb3I9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOlsxLDEsMV0sb3BhY2l0eT1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106MTt0aGlzLnNoYWRlci5iaW5kKCksdGhpcy5zaGFkZXIudW5pZm9ybShcInBvc2l0aW9uXCIsXCJ1bmlmb3JtM2Z2XCIscG9zaXRpb24pLHRoaXMuc2hhZGVyLnVuaWZvcm0oXCJzY2FsZVwiLFwidW5pZm9ybTNmdlwiLHNjYWxlKSx0aGlzLnNoYWRlci51bmlmb3JtKFwiY29sb3JcIixcInVuaWZvcm0zZnZcIixjb2xvciksdGhpcy5zaGFkZXIudW5pZm9ybShcIm9wYWNpdHlcIixcInVuaWZvcm0xZlwiLG9wYWNpdHkpLF9nZXQoQmF0Y2hCYWxsLnByb3RvdHlwZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihCYXRjaEJhbGwucHJvdG90eXBlKSxcImRyYXdcIix0aGlzKS5jYWxsKHRoaXMpfX1dKSxCYXRjaEJhbGx9KF9CYXRjaDMuZGVmYXVsdCk7ZXhwb3J0cy5kZWZhdWx0PUJhdGNoQmFsbH0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7ZGVmYXVsdDpvYmp9fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSxDb25zdHJ1Y3Rvcil7aWYoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsY2FsbCl7aWYoIXNlbGYpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFjYWxsfHxcIm9iamVjdFwiIT10eXBlb2YgY2FsbCYmXCJmdW5jdGlvblwiIT10eXBlb2YgY2FsbD9zZWxmOmNhbGx9ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLHN1cGVyQ2xhc3Mpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHN1cGVyQ2xhc3MmJm51bGwhPT1zdXBlckNsYXNzKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBzdXBlckNsYXNzKTtzdWJDbGFzcy5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzJiZzdXBlckNsYXNzLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnN1YkNsYXNzLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHN1cGVyQ2xhc3MmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLHN1cGVyQ2xhc3MpOnN1YkNsYXNzLl9fcHJvdG9fXz1zdXBlckNsYXNzKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ITEsZGVzY3JpcHRvci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvciYmKGRlc2NyaXB0b3Iud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcil9fXJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtyZXR1cm4gcHJvdG9Qcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyksc3RhdGljUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpLENvbnN0cnVjdG9yfX0oKSxfZ2V0PWZ1bmN0aW9uIGdldChvYmplY3QscHJvcGVydHkscmVjZWl2ZXIpe251bGw9PT1vYmplY3QmJihvYmplY3Q9RnVuY3Rpb24ucHJvdG90eXBlKTt2YXIgZGVzYz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCxwcm9wZXJ0eSk7aWYodm9pZCAwPT09ZGVzYyl7dmFyIHBhcmVudD1PYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtyZXR1cm4gbnVsbD09PXBhcmVudD92b2lkIDA6Z2V0KHBhcmVudCxwcm9wZXJ0eSxyZWNlaXZlcil9aWYoXCJ2YWx1ZVwiaW4gZGVzYylyZXR1cm4gZGVzYy52YWx1ZTt2YXIgZ2V0dGVyPWRlc2MuZ2V0O2lmKHZvaWQgMCE9PWdldHRlcilyZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpfSxfR0xUb29sPV9fd2VicGFja19yZXF1aXJlX18oMCksX0dMVG9vbDI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR0xUb29sKSxfTWVzaD1fX3dlYnBhY2tfcmVxdWlyZV9fKDUpLF9NZXNoMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZXNoKSxfR0xTaGFkZXI9X193ZWJwYWNrX3JlcXVpcmVfXygyKSxfR0xTaGFkZXIyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dMU2hhZGVyKSxfQmF0Y2gyPV9fd2VicGFja19yZXF1aXJlX18oNCksX0JhdGNoMz1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXRjaDIpLHZzPV9fd2VicGFja19yZXF1aXJlX18oODMpLGZzPV9fd2VicGFja19yZXF1aXJlX18oMTApLEJhdGNoRG90c1BsYW5lPWZ1bmN0aW9uKF9CYXRjaCl7ZnVuY3Rpb24gQmF0Y2hEb3RzUGxhbmUoKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxCYXRjaERvdHNQbGFuZSk7dmFyIHBvc2l0aW9ucz1bXSxpbmRpY2VzPVtdLGluZGV4PTAsaT12b2lkIDAsaj12b2lkIDA7Zm9yKGk9LTEwMDtpPDEwMDtpKz0xKWZvcihqPS0xMDA7ajwxMDA7ais9MSlwb3NpdGlvbnMucHVzaChbaSxqLDBdKSxpbmRpY2VzLnB1c2goaW5kZXgpLGluZGV4KysscG9zaXRpb25zLnB1c2goW2ksMCxqXSksaW5kaWNlcy5wdXNoKGluZGV4KSxpbmRleCsrO3ZhciBtZXNoPW5ldyBfTWVzaDIuZGVmYXVsdChfR0xUb29sMi5kZWZhdWx0LlBPSU5UUyk7bWVzaC5idWZmZXJWZXJ0ZXgocG9zaXRpb25zKSxtZXNoLmJ1ZmZlckluZGV4KGluZGljZXMpO3ZhciBzaGFkZXI9bmV3IF9HTFNoYWRlcjIuZGVmYXVsdCh2cyxmcyksX3RoaXM9X3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywoQmF0Y2hEb3RzUGxhbmUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmF0Y2hEb3RzUGxhbmUpKS5jYWxsKHRoaXMsbWVzaCxzaGFkZXIpKTtyZXR1cm4gX3RoaXMuY29sb3I9WzEsMSwxXSxfdGhpcy5vcGFjaXR5PS41LF90aGlzfXJldHVybiBfaW5oZXJpdHMoQmF0Y2hEb3RzUGxhbmUsX0JhdGNoKSxfY3JlYXRlQ2xhc3MoQmF0Y2hEb3RzUGxhbmUsW3trZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnNoYWRlci5iaW5kKCksdGhpcy5zaGFkZXIudW5pZm9ybShcImNvbG9yXCIsXCJ1bmlmb3JtM2Z2XCIsdGhpcy5jb2xvciksdGhpcy5zaGFkZXIudW5pZm9ybShcIm9wYWNpdHlcIixcInVuaWZvcm0xZlwiLHRoaXMub3BhY2l0eSksX2dldChCYXRjaERvdHNQbGFuZS5wcm90b3R5cGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmF0Y2hEb3RzUGxhbmUucHJvdG90eXBlKSxcImRyYXdcIix0aGlzKS5jYWxsKHRoaXMpfX1dKSxCYXRjaERvdHNQbGFuZX0oX0JhdGNoMy5kZWZhdWx0KTtleHBvcnRzLmRlZmF1bHQ9QmF0Y2hEb3RzUGxhbmV9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1cIi8vIGJhc2ljLnZlcnRcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIERPVFNfUExBTkVfVkVSVEVYXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB1Vmlld01hdHJpeCAqIHVNb2RlbE1hdHJpeCAqIHZlYzQoYVZlcnRleFBvc2l0aW9uICsgYU5vcm1hbCAqIDAuMDAwMDAxLCAxLjApO1xcbiAgICBnbF9Qb2ludFNpemUgPSAxLjA7XFxuICAgIHZOb3JtYWwgPSBhTm9ybWFsO1xcbn1cIn0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7ZGVmYXVsdDpvYmp9fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSxDb25zdHJ1Y3Rvcil7aWYoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsY2FsbCl7aWYoIXNlbGYpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFjYWxsfHxcIm9iamVjdFwiIT10eXBlb2YgY2FsbCYmXCJmdW5jdGlvblwiIT10eXBlb2YgY2FsbD9zZWxmOmNhbGx9ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLHN1cGVyQ2xhc3Mpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHN1cGVyQ2xhc3MmJm51bGwhPT1zdXBlckNsYXNzKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBzdXBlckNsYXNzKTtzdWJDbGFzcy5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzJiZzdXBlckNsYXNzLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnN1YkNsYXNzLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHN1cGVyQ2xhc3MmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLHN1cGVyQ2xhc3MpOnN1YkNsYXNzLl9fcHJvdG9fXz1zdXBlckNsYXNzKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ITEsZGVzY3JpcHRvci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvciYmKGRlc2NyaXB0b3Iud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcil9fXJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtyZXR1cm4gcHJvdG9Qcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyksc3RhdGljUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpLENvbnN0cnVjdG9yfX0oKSxfZ2V0PWZ1bmN0aW9uIGdldChvYmplY3QscHJvcGVydHkscmVjZWl2ZXIpe251bGw9PT1vYmplY3QmJihvYmplY3Q9RnVuY3Rpb24ucHJvdG90eXBlKTt2YXIgZGVzYz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCxwcm9wZXJ0eSk7aWYodm9pZCAwPT09ZGVzYyl7dmFyIHBhcmVudD1PYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtyZXR1cm4gbnVsbD09PXBhcmVudD92b2lkIDA6Z2V0KHBhcmVudCxwcm9wZXJ0eSxyZWNlaXZlcil9aWYoXCJ2YWx1ZVwiaW4gZGVzYylyZXR1cm4gZGVzYy52YWx1ZTt2YXIgZ2V0dGVyPWRlc2MuZ2V0O2lmKHZvaWQgMCE9PWdldHRlcilyZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpfSxfR0xUb29sPV9fd2VicGFja19yZXF1aXJlX18oMCksX0dMVG9vbDI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR0xUb29sKSxfTWVzaD1fX3dlYnBhY2tfcmVxdWlyZV9fKDUpLF9NZXNoMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZXNoKSxfR0xTaGFkZXI9X193ZWJwYWNrX3JlcXVpcmVfXygyKSxfR0xTaGFkZXIyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dMU2hhZGVyKSxfQmF0Y2gyPV9fd2VicGFja19yZXF1aXJlX18oNCksX0JhdGNoMz1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXRjaDIpLHZzPV9fd2VicGFja19yZXF1aXJlX18oMTEpLGZzPV9fd2VicGFja19yZXF1aXJlX18oMTApLEJhdGNoQXhpcz1mdW5jdGlvbihfQmF0Y2gpe2Z1bmN0aW9uIEJhdGNoQXhpcygpe19jbGFzc0NhbGxDaGVjayh0aGlzLEJhdGNoQXhpcyk7dmFyIHBvc2l0aW9ucz1bXSxpbmRpY2VzPVswLDFdLGNvb3Jkcz1bWzAsMF0sWzEsMV1dO3Bvc2l0aW9ucy5wdXNoKFswLDAsMF0pLHBvc2l0aW9ucy5wdXNoKFswLDAsMF0pO3ZhciBtZXNoPW5ldyBfTWVzaDIuZGVmYXVsdChfR0xUb29sMi5kZWZhdWx0LkxJTkVTKTttZXNoLmJ1ZmZlclZlcnRleChwb3NpdGlvbnMpLG1lc2guYnVmZmVyVGV4Q29vcmQoY29vcmRzKSxtZXNoLmJ1ZmZlckluZGV4KGluZGljZXMpO3ZhciBzaGFkZXI9bmV3IF9HTFNoYWRlcjIuZGVmYXVsdCh2cyxmcyk7cmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsKEJhdGNoQXhpcy5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihCYXRjaEF4aXMpKS5jYWxsKHRoaXMsbWVzaCxzaGFkZXIpKX1yZXR1cm4gX2luaGVyaXRzKEJhdGNoQXhpcyxfQmF0Y2gpLF9jcmVhdGVDbGFzcyhCYXRjaEF4aXMsW3trZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24obVBvc2l0aW9uQSxtUG9zaXRpb25CKXt2YXIgY29sb3I9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOlsxLDEsMV0sb3BhY2l0eT1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106MTt0aGlzLl9tZXNoLmJ1ZmZlclZlcnRleChbbVBvc2l0aW9uQSxtUG9zaXRpb25CXSksdGhpcy5fc2hhZGVyLmJpbmQoKSx0aGlzLl9zaGFkZXIudW5pZm9ybShcImNvbG9yXCIsXCJ2ZWMzXCIsY29sb3IpLHRoaXMuX3NoYWRlci51bmlmb3JtKFwib3BhY2l0eVwiLFwiZmxvYXRcIixvcGFjaXR5KSxfZ2V0KEJhdGNoQXhpcy5wcm90b3R5cGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmF0Y2hBeGlzLnByb3RvdHlwZSksXCJkcmF3XCIsdGhpcykuY2FsbCh0aGlzKX19XSksQmF0Y2hBeGlzfShfQmF0Y2gzLmRlZmF1bHQpO2V4cG9ydHMuZGVmYXVsdD1CYXRjaEF4aXN9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLGNhbGwpe2lmKCFzZWxmKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hY2FsbHx8XCJvYmplY3RcIiE9dHlwZW9mIGNhbGwmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGNhbGw/c2VsZjpjYWxsfWZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcyxzdXBlckNsYXNzKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBzdXBlckNsYXNzJiZudWxsIT09c3VwZXJDbGFzcyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2Ygc3VwZXJDbGFzcyk7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyYmc3VwZXJDbGFzcy5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpzdWJDbGFzcyxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxzdXBlckNsYXNzJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcyxzdXBlckNsYXNzKTpzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzcyl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fCExLGRlc2NyaXB0b3IuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGRlc2NyaXB0b3ImJihkZXNjcmlwdG9yLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpfX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7cmV0dXJuIHByb3RvUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpLHN0YXRpY1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKSxDb25zdHJ1Y3Rvcn19KCksX2dldD1mdW5jdGlvbiBnZXQob2JqZWN0LHByb3BlcnR5LHJlY2VpdmVyKXtudWxsPT09b2JqZWN0JiYob2JqZWN0PUZ1bmN0aW9uLnByb3RvdHlwZSk7dmFyIGRlc2M9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QscHJvcGVydHkpO2lmKHZvaWQgMD09PWRlc2Mpe3ZhciBwYXJlbnQ9T2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7cmV0dXJuIG51bGw9PT1wYXJlbnQ/dm9pZCAwOmdldChwYXJlbnQscHJvcGVydHkscmVjZWl2ZXIpfWlmKFwidmFsdWVcImluIGRlc2MpcmV0dXJuIGRlc2MudmFsdWU7dmFyIGdldHRlcj1kZXNjLmdldDtpZih2b2lkIDAhPT1nZXR0ZXIpcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKX0sX0dlb209X193ZWJwYWNrX3JlcXVpcmVfXyg3KSxfR2VvbTI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR2VvbSksX0dMU2hhZGVyPV9fd2VicGFja19yZXF1aXJlX18oMiksX0dMU2hhZGVyMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HTFNoYWRlciksX0JhdGNoMj1fX3dlYnBhY2tfcmVxdWlyZV9fKDQpLF9CYXRjaDM9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmF0Y2gyKSx2cz1fX3dlYnBhY2tfcmVxdWlyZV9fKDM0KSxmcz1fX3dlYnBhY2tfcmVxdWlyZV9fKDM1KSxCYXRjaFNreWJveD1mdW5jdGlvbihfQmF0Y2gpe2Z1bmN0aW9uIEJhdGNoU2t5Ym94KCl7dmFyIHNpemU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOjIwO19jbGFzc0NhbGxDaGVjayh0aGlzLEJhdGNoU2t5Ym94KTt2YXIgbWVzaD1fR2VvbTIuZGVmYXVsdC5za3lib3goc2l6ZSksc2hhZGVyPW5ldyBfR0xTaGFkZXIyLmRlZmF1bHQodnMsZnMpO3JldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLChCYXRjaFNreWJveC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihCYXRjaFNreWJveCkpLmNhbGwodGhpcyxtZXNoLHNoYWRlcikpfXJldHVybiBfaW5oZXJpdHMoQmF0Y2hTa3lib3gsX0JhdGNoKSxfY3JlYXRlQ2xhc3MoQmF0Y2hTa3lib3gsW3trZXk6XCJkcmF3XCIsdmFsdWU6ZnVuY3Rpb24odGV4dHVyZSl7dGhpcy5zaGFkZXIuYmluZCgpLHRleHR1cmUuYmluZCgwKSxfZ2V0KEJhdGNoU2t5Ym94LnByb3RvdHlwZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihCYXRjaFNreWJveC5wcm90b3R5cGUpLFwiZHJhd1wiLHRoaXMpLmNhbGwodGhpcyl9fV0pLEJhdGNoU2t5Ym94fShfQmF0Y2gzLmRlZmF1bHQpO2V4cG9ydHMuZGVmYXVsdD1CYXRjaFNreWJveH0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7ZGVmYXVsdDpvYmp9fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSxDb25zdHJ1Y3Rvcil7aWYoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsY2FsbCl7aWYoIXNlbGYpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFjYWxsfHxcIm9iamVjdFwiIT10eXBlb2YgY2FsbCYmXCJmdW5jdGlvblwiIT10eXBlb2YgY2FsbD9zZWxmOmNhbGx9ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLHN1cGVyQ2xhc3Mpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHN1cGVyQ2xhc3MmJm51bGwhPT1zdXBlckNsYXNzKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBzdXBlckNsYXNzKTtzdWJDbGFzcy5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzJiZzdXBlckNsYXNzLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnN1YkNsYXNzLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHN1cGVyQ2xhc3MmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLHN1cGVyQ2xhc3MpOnN1YkNsYXNzLl9fcHJvdG9fXz1zdXBlckNsYXNzKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ITEsZGVzY3JpcHRvci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvciYmKGRlc2NyaXB0b3Iud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcil9fXJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtyZXR1cm4gcHJvdG9Qcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyksc3RhdGljUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpLENvbnN0cnVjdG9yfX0oKSxfZ2V0PWZ1bmN0aW9uIGdldChvYmplY3QscHJvcGVydHkscmVjZWl2ZXIpe251bGw9PT1vYmplY3QmJihvYmplY3Q9RnVuY3Rpb24ucHJvdG90eXBlKTt2YXIgZGVzYz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCxwcm9wZXJ0eSk7aWYodm9pZCAwPT09ZGVzYyl7dmFyIHBhcmVudD1PYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtyZXR1cm4gbnVsbD09PXBhcmVudD92b2lkIDA6Z2V0KHBhcmVudCxwcm9wZXJ0eSxyZWNlaXZlcil9aWYoXCJ2YWx1ZVwiaW4gZGVzYylyZXR1cm4gZGVzYy52YWx1ZTt2YXIgZ2V0dGVyPWRlc2MuZ2V0O2lmKHZvaWQgMCE9PWdldHRlcilyZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpfSxfR2VvbT1fX3dlYnBhY2tfcmVxdWlyZV9fKDcpLF9HZW9tMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HZW9tKSxfR0xTaGFkZXI9X193ZWJwYWNrX3JlcXVpcmVfXygyKSxfR0xTaGFkZXIyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dMU2hhZGVyKSxfQmF0Y2gyPV9fd2VicGFja19yZXF1aXJlX18oNCksX0JhdGNoMz1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXRjaDIpLHZzPV9fd2VicGFja19yZXF1aXJlX18oODcpLGZzPV9fd2VicGFja19yZXF1aXJlX18oMTkpLEJhdGNoU2t5PWZ1bmN0aW9uKF9CYXRjaCl7ZnVuY3Rpb24gQmF0Y2hTa3koKXt2YXIgc2l6ZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06NTAsc2VnPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXToyNDtfY2xhc3NDYWxsQ2hlY2sodGhpcyxCYXRjaFNreSk7dmFyIG1lc2g9X0dlb20yLmRlZmF1bHQuc3BoZXJlKHNpemUsc2VnLCEwKSxzaGFkZXI9bmV3IF9HTFNoYWRlcjIuZGVmYXVsdCh2cyxmcyk7cmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsKEJhdGNoU2t5Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKEJhdGNoU2t5KSkuY2FsbCh0aGlzLG1lc2gsc2hhZGVyKSl9cmV0dXJuIF9pbmhlcml0cyhCYXRjaFNreSxfQmF0Y2gpLF9jcmVhdGVDbGFzcyhCYXRjaFNreSxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0ZXh0dXJlKXt0aGlzLnNoYWRlci5iaW5kKCksdGV4dHVyZS5iaW5kKDApLF9nZXQoQmF0Y2hTa3kucHJvdG90eXBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKEJhdGNoU2t5LnByb3RvdHlwZSksXCJkcmF3XCIsdGhpcykuY2FsbCh0aGlzKX19XSksQmF0Y2hTa3l9KF9CYXRjaDMuZGVmYXVsdCk7ZXhwb3J0cy5kZWZhdWx0PUJhdGNoU2t5fSxmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9XCIvLyBza3kudmVydFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFx0bWF0NCBtYXRWaWV3ID0gdVZpZXdNYXRyaXg7XFxuXFx0bWF0Vmlld1szXVswXSA9IDAuMDtcXG5cXHRtYXRWaWV3WzNdWzFdID0gMC4wO1xcblxcdG1hdFZpZXdbM11bMl0gPSAwLjA7XFxuXFx0XFxuICAgIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiBtYXRWaWV3ICogdU1vZGVsTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24sIDEuMCk7XFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcbiAgICB2Tm9ybWFsID0gYU5vcm1hbDtcXG59XCJ9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLGNhbGwpe2lmKCFzZWxmKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hY2FsbHx8XCJvYmplY3RcIiE9dHlwZW9mIGNhbGwmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGNhbGw/c2VsZjpjYWxsfWZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcyxzdXBlckNsYXNzKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBzdXBlckNsYXNzJiZudWxsIT09c3VwZXJDbGFzcyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2Ygc3VwZXJDbGFzcyk7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyYmc3VwZXJDbGFzcy5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpzdWJDbGFzcyxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxzdXBlckNsYXNzJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcyxzdXBlckNsYXNzKTpzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzcyl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fCExLGRlc2NyaXB0b3IuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGRlc2NyaXB0b3ImJihkZXNjcmlwdG9yLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpfX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7cmV0dXJuIHByb3RvUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpLHN0YXRpY1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKSxDb25zdHJ1Y3Rvcn19KCksX2dldD1mdW5jdGlvbiBnZXQob2JqZWN0LHByb3BlcnR5LHJlY2VpdmVyKXtudWxsPT09b2JqZWN0JiYob2JqZWN0PUZ1bmN0aW9uLnByb3RvdHlwZSk7dmFyIGRlc2M9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QscHJvcGVydHkpO2lmKHZvaWQgMD09PWRlc2Mpe3ZhciBwYXJlbnQ9T2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7cmV0dXJuIG51bGw9PT1wYXJlbnQ/dm9pZCAwOmdldChwYXJlbnQscHJvcGVydHkscmVjZWl2ZXIpfWlmKFwidmFsdWVcImluIGRlc2MpcmV0dXJuIGRlc2MudmFsdWU7dmFyIGdldHRlcj1kZXNjLmdldDtpZih2b2lkIDAhPT1nZXR0ZXIpcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKX0sX0dMVG9vbD1fX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9HTFRvb2wyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dMVG9vbCksX0dlb209X193ZWJwYWNrX3JlcXVpcmVfXyg3KSxfR2VvbTI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfR2VvbSksX0dMU2hhZGVyPV9fd2VicGFja19yZXF1aXJlX18oMiksX0dMU2hhZGVyMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HTFNoYWRlciksX0JhdGNoMj1fX3dlYnBhY2tfcmVxdWlyZV9fKDQpLF9CYXRjaDM9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmF0Y2gyKSx2cz1fX3dlYnBhY2tfcmVxdWlyZV9fKDE4KSxmcz1fX3dlYnBhY2tfcmVxdWlyZV9fKDQwKSxCYXRjaEZYQUE9ZnVuY3Rpb24oX0JhdGNoKXtmdW5jdGlvbiBCYXRjaEZYQUEoKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxCYXRjaEZYQUEpO3ZhciBtZXNoPV9HZW9tMi5kZWZhdWx0LmJpZ1RyaWFuZ2xlKCksc2hhZGVyPW5ldyBfR0xTaGFkZXIyLmRlZmF1bHQodnMsZnMpLF90aGlzPV9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsKEJhdGNoRlhBQS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihCYXRjaEZYQUEpKS5jYWxsKHRoaXMsbWVzaCxzaGFkZXIpKTtyZXR1cm4gc2hhZGVyLmJpbmQoKSxzaGFkZXIudW5pZm9ybShcInRleHR1cmVcIixcInVuaWZvcm0xaVwiLDApLF90aGlzfXJldHVybiBfaW5oZXJpdHMoQmF0Y2hGWEFBLF9CYXRjaCksX2NyZWF0ZUNsYXNzKEJhdGNoRlhBQSxbe2tleTpcImRyYXdcIix2YWx1ZTpmdW5jdGlvbih0ZXh0dXJlKXt0aGlzLnNoYWRlci5iaW5kKCksdGV4dHVyZS5iaW5kKDApLHRoaXMuc2hhZGVyLnVuaWZvcm0oXCJ1UmVzb2x1dGlvblwiLFwidmVjMlwiLFsxL19HTFRvb2wyLmRlZmF1bHQud2lkdGgsMS9fR0xUb29sMi5kZWZhdWx0LmhlaWdodF0pLF9nZXQoQmF0Y2hGWEFBLnByb3RvdHlwZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihCYXRjaEZYQUEucHJvdG90eXBlKSxcImRyYXdcIix0aGlzKS5jYWxsKHRoaXMpfX1dKSxCYXRjaEZYQUF9KF9CYXRjaDMuZGVmYXVsdCk7ZXhwb3J0cy5kZWZhdWx0PUJhdGNoRlhBQX0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7ZGVmYXVsdDpvYmp9fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSxDb25zdHJ1Y3Rvcil7aWYoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHwhMSxkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBkZXNjcmlwdG9yJiYoZGVzY3JpcHRvci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCxkZXNjcmlwdG9yLmtleSxkZXNjcmlwdG9yKX19cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe3JldHVybiBwcm90b1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKSxzdGF0aWNQcm9wcyYmZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyksQ29uc3RydWN0b3J9fSgpLF9zY2hlZHVsaW5nPV9fd2VicGFja19yZXF1aXJlX18oNiksX3NjaGVkdWxpbmcyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NjaGVkdWxpbmcpLF9HTFRvb2w9X193ZWJwYWNrX3JlcXVpcmVfXygwKSxfR0xUb29sMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HTFRvb2wpLF9DYW1lcmFQZXJzcGVjdGl2ZT1fX3dlYnBhY2tfcmVxdWlyZV9fKDE2KSxfQ2FtZXJhUGVyc3BlY3RpdmUyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhbWVyYVBlcnNwZWN0aXZlKSxfQ2FtZXJhT3J0aG89X193ZWJwYWNrX3JlcXVpcmVfXygzMCksX0NhbWVyYU9ydGhvMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYW1lcmFPcnRobyksX09yYml0YWxDb250cm9sPV9fd2VicGFja19yZXF1aXJlX18oMjkpLF9PcmJpdGFsQ29udHJvbDI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChfT3JiaXRhbENvbnRyb2wpLFNjZW5lPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gU2NlbmUoKXt2YXIgX3RoaXM9dGhpcztfY2xhc3NDYWxsQ2hlY2sodGhpcyxTY2VuZSksdGhpcy5fY2hpbGRyZW49W10sdGhpcy5fbWF0cml4SWRlbnRpdHk9bWF0NC5jcmVhdGUoKSxfR0xUb29sMi5kZWZhdWx0LmVuYWJsZUFscGhhQmxlbmRpbmcoKSx0aGlzLl9pbml0KCksdGhpcy5faW5pdFRleHR1cmVzKCksdGhpcy5faW5pdFZpZXdzKCksdGhpcy5fZWZJbmRleD1fc2NoZWR1bGluZzIuZGVmYXVsdC5hZGRFRihmdW5jdGlvbigpe3JldHVybiBfdGhpcy5fbG9vcCgpfSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIixmdW5jdGlvbigpe3JldHVybiBfdGhpcy5yZXNpemUoKX0pfXJldHVybiBfY3JlYXRlQ2xhc3MoU2NlbmUsW3trZXk6XCJ1cGRhdGVcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJzdG9wXCIsdmFsdWU6ZnVuY3Rpb24oKXstMSE9PXRoaXMuX2VmSW5kZXgmJih0aGlzLl9lZkluZGV4PV9zY2hlZHVsaW5nMi5kZWZhdWx0LnJlbW92ZUVGKHRoaXMuX2VmSW5kZXgpKX19LHtrZXk6XCJzdGFydFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIF90aGlzMj10aGlzOy0xPT09dGhpcy5fZWZJbmRleCYmKHRoaXMuX2VmSW5kZXg9X3NjaGVkdWxpbmcyLmRlZmF1bHQuYWRkRUYoZnVuY3Rpb24oKXtyZXR1cm4gX3RoaXMyLl9sb29wKCl9KSl9fSx7a2V5OlwicmVzaXplXCIsdmFsdWU6ZnVuY3Rpb24oKXtfR0xUb29sMi5kZWZhdWx0LnNldFNpemUod2luZG93LmlubmVyV2lkdGgsd2luZG93LmlubmVySGVpZ2h0KSx0aGlzLmNhbWVyYS5zZXRBc3BlY3RSYXRpbyhfR0xUb29sMi5kZWZhdWx0LmFzcGVjdFJhdGlvKX19LHtrZXk6XCJhZGRDaGlsZFwiLHZhbHVlOmZ1bmN0aW9uKG1DaGlsZCl7dGhpcy5fY2hpbGRyZW4ucHVzaChtQ2hpbGQpfX0se2tleTpcInJlbW92ZUNoaWxkXCIsdmFsdWU6ZnVuY3Rpb24obUNoaWxkKXt2YXIgaW5kZXg9dGhpcy5fY2hpbGRyZW4uaW5kZXhPZihtQ2hpbGQpO2lmKC0xPT1pbmRleClyZXR1cm4gdm9pZCBjb25zb2xlLndhcm4oXCJDaGlsZCBubyBleGlzdFwiKTt0aGlzLl9jaGlsZHJlbi5zcGxpY2UoaW5kZXgsMSl9fSx7a2V5OlwiX2luaXRUZXh0dXJlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcIl9pbml0Vmlld3NcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJfcmVuZGVyQ2hpbGRyZW5cIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgY2hpbGQ9dm9pZCAwLGk9MDtpPHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtpKyspY2hpbGQ9dGhpcy5fY2hpbGRyZW5baV0sY2hpbGQudG9SZW5kZXIoKTtfR0xUb29sMi5kZWZhdWx0LnJvdGF0ZSh0aGlzLl9tYXRyaXhJZGVudGl0eSl9fSx7a2V5OlwiX2luaXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY2FtZXJhPW5ldyBfQ2FtZXJhUGVyc3BlY3RpdmUyLmRlZmF1bHQsdGhpcy5jYW1lcmEuc2V0UGVyc3BlY3RpdmUoNDUqTWF0aC5QSS8xODAsX0dMVG9vbDIuZGVmYXVsdC5hc3BlY3RSYXRpbywuMSwxMDApLHRoaXMub3JiaXRhbENvbnRyb2w9bmV3IF9PcmJpdGFsQ29udHJvbDIuZGVmYXVsdCh0aGlzLmNhbWVyYSx3aW5kb3csMTUpLHRoaXMub3JiaXRhbENvbnRyb2wucmFkaXVzLnZhbHVlPTEwLHRoaXMuY2FtZXJhT3J0aG89bmV3IF9DYW1lcmFPcnRobzIuZGVmYXVsdH19LHtrZXk6XCJfbG9vcFwiLHZhbHVlOmZ1bmN0aW9uKCl7X0dMVG9vbDIuZGVmYXVsdC52aWV3cG9ydCgwLDAsX0dMVG9vbDIuZGVmYXVsdC53aWR0aCxfR0xUb29sMi5kZWZhdWx0LmhlaWdodCksX0dMVG9vbDIuZGVmYXVsdC5zZXRNYXRyaWNlcyh0aGlzLmNhbWVyYSksdGhpcy51cGRhdGUoKSx0aGlzLl9yZW5kZXJDaGlsZHJlbigpLHRoaXMucmVuZGVyKCl9fV0pLFNjZW5lfSgpO2V4cG9ydHMuZGVmYXVsdD1TY2VuZX0sZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLENvbnN0cnVjdG9yKXtpZighKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fCExLGRlc2NyaXB0b3IuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGRlc2NyaXB0b3ImJihkZXNjcmlwdG9yLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpfX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7cmV0dXJuIHByb3RvUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpLHN0YXRpY1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKSxDb25zdHJ1Y3Rvcn19KCksX0dMU2hhZGVyPV9fd2VicGFja19yZXF1aXJlX18oMiksX0dMU2hhZGVyMj1mdW5jdGlvbihvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7ZGVmYXVsdDpvYmp9fShfR0xTaGFkZXIpLFZpZXc9ZnVuY3Rpb24oKXtmdW5jdGlvbiBWaWV3KG1TdHJWZXJ0ZXgsbVN0ckZyYWcpe19jbGFzc0NhbGxDaGVjayh0aGlzLFZpZXcpLHRoaXMuc2hhZGVyPW5ldyBfR0xTaGFkZXIyLmRlZmF1bHQobVN0clZlcnRleCxtU3RyRnJhZyksdGhpcy5faW5pdCgpfXJldHVybiBfY3JlYXRlQ2xhc3MoVmlldyxbe2tleTpcIl9pbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt9fV0pLFZpZXd9KCk7ZXhwb3J0cy5kZWZhdWx0PVZpZXd9LGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsQ29uc3RydWN0b3Ipe2lmKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLGNhbGwpe2lmKCFzZWxmKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hY2FsbHx8XCJvYmplY3RcIiE9dHlwZW9mIGNhbGwmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGNhbGw/c2VsZjpjYWxsfWZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcyxzdXBlckNsYXNzKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBzdXBlckNsYXNzJiZudWxsIT09c3VwZXJDbGFzcyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2Ygc3VwZXJDbGFzcyk7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyYmc3VwZXJDbGFzcy5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpzdWJDbGFzcyxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxzdXBlckNsYXNzJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcyxzdXBlckNsYXNzKTpzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzcyl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fCExLGRlc2NyaXB0b3IuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGRlc2NyaXB0b3ImJihkZXNjcmlwdG9yLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpfX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7cmV0dXJuIHByb3RvUHJvcHMmJmRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpLHN0YXRpY1Byb3BzJiZkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKSxDb25zdHJ1Y3Rvcn19KCksX09iamVjdDNEMj1fX3dlYnBhY2tfcmVxdWlyZV9fKDMxKSxfT2JqZWN0M0QzPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX09iamVjdDNEMiksX0dMU2hhZGVyPV9fd2VicGFja19yZXF1aXJlX18oMiksX0dMU2hhZGVyMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9HTFNoYWRlciksX0dMVG9vbD1fX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9HTFRvb2wyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dMVG9vbCksVmlldzNEPWZ1bmN0aW9uKF9PYmplY3QzRCl7ZnVuY3Rpb24gVmlldzNEKG1TdHJWZXJ0ZXgsbVN0ckZyYWcpe19jbGFzc0NhbGxDaGVjayh0aGlzLFZpZXczRCk7dmFyIF90aGlzPV9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsKFZpZXczRC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihWaWV3M0QpKS5jYWxsKHRoaXMpKTtyZXR1cm4gX3RoaXMuX2NoaWxkcmVuPVtdLF90aGlzLnNoYWRlcj1uZXcgX0dMU2hhZGVyMi5kZWZhdWx0KG1TdHJWZXJ0ZXgsbVN0ckZyYWcpLF90aGlzLl9pbml0KCksX3RoaXMuX21hdHJpeFRlbXA9bWF0NC5jcmVhdGUoKSxfdGhpc31yZXR1cm4gX2luaGVyaXRzKFZpZXczRCxfT2JqZWN0M0QpLF9jcmVhdGVDbGFzcyhWaWV3M0QsW3trZXk6XCJfaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcImFkZENoaWxkXCIsdmFsdWU6ZnVuY3Rpb24obUNoaWxkKXt0aGlzLl9jaGlsZHJlbi5wdXNoKG1DaGlsZCl9fSx7a2V5OlwicmVtb3ZlQ2hpbGRcIix2YWx1ZTpmdW5jdGlvbihtQ2hpbGQpe3ZhciBpbmRleD10aGlzLl9jaGlsZHJlbi5pbmRleE9mKG1DaGlsZCk7aWYoLTE9PWluZGV4KXJldHVybiB2b2lkIGNvbnNvbGUud2FybihcIkNoaWxkIG5vIGV4aXN0XCIpO3RoaXMuX2NoaWxkcmVuLnNwbGljZShpbmRleCwxKX19LHtrZXk6XCJ0b1JlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKG1hdHJpeCl7dm9pZCAwPT09bWF0cml4JiYobWF0cml4PW1hdDQuY3JlYXRlKCkpLG1hdDQubXVsKHRoaXMuX21hdHJpeFRlbXAsbWF0cml4LHRoaXMubWF0cml4KSxfR0xUb29sMi5kZWZhdWx0LnJvdGF0ZSh0aGlzLl9tYXRyaXhUZW1wKSx0aGlzLnJlbmRlcigpO2Zvcih2YXIgaT0wO2k8dGhpcy5fY2hpbGRyZW4ubGVuZ3RoO2krKyl7dGhpcy5fY2hpbGRyZW5baV0udG9SZW5kZXIodGhpcy5tYXRyaXgpfX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe319XSksVmlldzNEfShfT2JqZWN0M0QzLmRlZmF1bHQpO2V4cG9ydHMuZGVmYXVsdD1WaWV3M0R9XSl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hbGZyaWQvYnVpbGQvYWxmcmlkLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gQ29uZmlnLmpzXG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0bnVtVHJlZXM6NjAsXG5cdHRyZWVTY2FsZToyLjEsXG5cdGZsb29yUmFkaXVzOjMuNSxcblx0bWF4Rmxvb3JIZWlnaHQ6MC42LFxuXHR0cmVlQnVtcEhlaWdodDowLjI1LFxuXHRudW1TbGlkZXM6NTAwLFxuXHRub2lzZU51bTo4LFxuXHRub2lzZVNjYWxlOjMsXG5cdGFuaW1hdGVkOmZhbHNlLFxuXHRmeGFhOnRydWUsXG5cdG92ZXJsYXlPcGFjaXR5Oi4yNSxcblx0Ymxvb21TdHJlbmd0aDouMjUsXG5cdHBpeGVsYXRlTWl4aW5nOjAuMDUsXG5cdGFuaW1hbDonZGVlcicsXG5cdGZvZ01vdmluZ1NwZWVkOi41LFxuXHRncmFkaWVudE1hcDowLjUsXG5cdHNob3dTbm93OnRydWUsXG5cdHNub3dTcGVlZDouNVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9Db25maWcuanMiLCIvKiFcbiAqIFZFUlNJT046IDIuMC4yXG4gKiBEQVRFOiAyMDE4LTA4LTI3XG4gKiBVUERBVEVTIEFORCBET0NTIEFUOiBodHRwOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwOC0yMDE4LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHdvcmsgaXMgc3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cDovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBzb2Z0d2FyZSBhZ3JlZW1lbnQgdGhhdCB3YXMgaXNzdWVkIHdpdGggeW91ciBtZW1iZXJzaGlwLlxuICpcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICovXG5cbi8qIEVTNiBjaGFuZ2VzOlxuXHQtIGRlY2xhcmUgYW5kIGV4cG9ydCBfZ3NTY29wZSBhdCB0b3AuXG5cdC0gc2V0IHZhciBUd2VlbkxpdGUgPSB0aGUgcmVzdWx0IG9mIHRoZSBtYWluIGZ1bmN0aW9uXG5cdC0gZXhwb3J0IGRlZmF1bHQgVHdlZW5MaXRlIGF0IHRoZSBib3R0b21cblx0LSByZXR1cm4gVHdlZW5MaXRlIGF0IHRoZSBib3R0b20gb2YgdGhlIG1haW4gZnVuY3Rpb25cblx0LSBwYXNzIGluIF9nc1Njb3BlIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgb2YgdGhlIG1haW4gZnVuY3Rpb24gKHdoaWNoIGlzIGFjdHVhbGx5IGF0IHRoZSBib3R0b20pXG5cdC0gcmVtb3ZlIHRoZSBcImV4cG9ydCB0byBtdWx0aXBsZSBlbnZpcm9ubWVudHNcIiBpbiBEZWZpbml0aW9uKCkuXG4gKi9cbmV4cG9ydCB2YXIgX2dzU2NvcGUgPSAodHlwZW9mKHdpbmRvdykgIT09IFwidW5kZWZpbmVkXCIpID8gd2luZG93IDogKHR5cGVvZihtb2R1bGUpICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZihnbG9iYWwpICE9PSBcInVuZGVmaW5lZFwiKSA/IGdsb2JhbCA6IHRoaXMgfHwge307XG5cbmV4cG9ydCB2YXIgVHdlZW5MaXRlID0gKGZ1bmN0aW9uKHdpbmRvdywgbW9kdWxlTmFtZSkge1xuXG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0dmFyIF9leHBvcnRzID0ge30sXG5cdFx0XHRfZG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRcdFx0X2dsb2JhbHMgPSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyA9IHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzIHx8IHdpbmRvdztcblx0XHRpZiAoX2dsb2JhbHMuVHdlZW5MaXRlKSB7XG5cdFx0XHRyZXR1cm4gX2dsb2JhbHMuVHdlZW5MaXRlOyAvL2luIGNhc2UgdGhlIGNvcmUgc2V0IG9mIGNsYXNzZXMgaXMgYWxyZWFkeSBsb2FkZWQsIGRvbid0IGluc3RhbnRpYXRlIHR3aWNlLlxuXHRcdH1cblx0XHR2YXIgX25hbWVzcGFjZSA9IGZ1bmN0aW9uKG5zKSB7XG5cdFx0XHRcdHZhciBhID0gbnMuc3BsaXQoXCIuXCIpLFxuXHRcdFx0XHRcdHAgPSBfZ2xvYmFscywgaTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRwW2FbaV1dID0gcCA9IHBbYVtpXV0gfHwge307XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHA7XG5cdFx0XHR9LFxuXHRcdFx0Z3MgPSBfbmFtZXNwYWNlKFwiY29tLmdyZWVuc29ja1wiKSxcblx0XHRcdF90aW55TnVtID0gMC4wMDAwMDAwMDAxLFxuXHRcdFx0X3NsaWNlID0gZnVuY3Rpb24oYSkgeyAvL2Rvbid0IHVzZSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0YXJnZXQsIDApIGJlY2F1c2UgdGhhdCBkb2Vzbid0IHdvcmsgaW4gSUU4IHdpdGggYSBOb2RlTGlzdCB0aGF0J3MgcmV0dXJuZWQgYnkgcXVlcnlTZWxlY3RvckFsbCgpXG5cdFx0XHRcdHZhciBiID0gW10sXG5cdFx0XHRcdFx0bCA9IGEubGVuZ3RoLFxuXHRcdFx0XHRcdGk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgIT09IGw7IGIucHVzaChhW2krK10pKSB7fVxuXHRcdFx0XHRyZXR1cm4gYjtcblx0XHRcdH0sXG5cdFx0XHRfZW1wdHlGdW5jID0gZnVuY3Rpb24oKSB7fSxcblx0XHRcdF9pc0FycmF5ID0gKGZ1bmN0aW9uKCkgeyAvL3dvcmtzIGFyb3VuZCBpc3N1ZXMgaW4gaWZyYW1lIGVudmlyb25tZW50cyB3aGVyZSB0aGUgQXJyYXkgZ2xvYmFsIGlzbid0IHNoYXJlZCwgdGh1cyBpZiB0aGUgb2JqZWN0IG9yaWdpbmF0ZXMgaW4gYSBkaWZmZXJlbnQgd2luZG93L2lmcmFtZSwgXCIob2JqIGluc3RhbmNlb2YgQXJyYXkpXCIgd2lsbCBldmFsdWF0ZSBmYWxzZS4gV2UgYWRkZWQgc29tZSBzcGVlZCBvcHRpbWl6YXRpb25zIHRvIGF2b2lkIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCgpIHVubGVzcyBpdCdzIGFic29sdXRlbHkgbmVjZXNzYXJ5IGJlY2F1c2UgaXQncyBWRVJZIHNsb3cgKGxpa2UgMjB4IHNsb3dlcilcblx0XHRcdFx0dmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcblx0XHRcdFx0XHRhcnJheSA9IHRvU3RyaW5nLmNhbGwoW10pO1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIChvYmogaW5zdGFuY2VvZiBBcnJheSB8fCAodHlwZW9mKG9iaikgPT09IFwib2JqZWN0XCIgJiYgISFvYmoucHVzaCAmJiB0b1N0cmluZy5jYWxsKG9iaikgPT09IGFycmF5KSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9KCkpLFxuXHRcdFx0YSwgaSwgcCwgX3RpY2tlciwgX3RpY2tlckFjdGl2ZSxcblx0XHRcdF9kZWZMb29rdXAgPSB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHRcdCAqIERlZmluZXMgYSBHcmVlblNvY2sgY2xhc3MsIG9wdGlvbmFsbHkgd2l0aCBhbiBhcnJheSBvZiBkZXBlbmRlbmNpZXMgdGhhdCBtdXN0IGJlIGluc3RhbnRpYXRlZCBmaXJzdCBhbmQgcGFzc2VkIGludG8gdGhlIGRlZmluaXRpb24uXG5cdFx0XHQgKiBUaGlzIGFsbG93cyB1c2VycyB0byBsb2FkIEdyZWVuU29jayBKUyBmaWxlcyBpbiBhbnkgb3JkZXIgZXZlbiBpZiB0aGV5IGhhdmUgaW50ZXJkZXBlbmRlbmNpZXMgKGxpa2UgQ1NTUGx1Z2luIGV4dGVuZHMgVHdlZW5QbHVnaW4gd2hpY2ggaXNcblx0XHRcdCAqIGluc2lkZSBUd2VlbkxpdGUuanMsIGJ1dCBpZiBDU1NQbHVnaW4gaXMgbG9hZGVkIGZpcnN0LCBpdCBzaG91bGQgd2FpdCB0byBydW4gaXRzIGNvZGUgdW50aWwgVHdlZW5MaXRlLmpzIGxvYWRzIGFuZCBpbnN0YW50aWF0ZXMgVHdlZW5QbHVnaW5cblx0XHRcdCAqIGFuZCB0aGVuIHBhc3MgVHdlZW5QbHVnaW4gdG8gQ1NTUGx1Z2luJ3MgZGVmaW5pdGlvbikuIFRoaXMgaXMgYWxsIGRvbmUgYXV0b21hdGljYWxseSBhbmQgaW50ZXJuYWxseS5cblx0XHRcdCAqXG5cdFx0XHQgKiBFdmVyeSBkZWZpbml0aW9uIHdpbGwgYmUgYWRkZWQgdG8gYSBcImNvbS5ncmVlbnNvY2tcIiBnbG9iYWwgb2JqZWN0ICh0eXBpY2FsbHkgd2luZG93LCBidXQgaWYgYSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyBvYmplY3QgaXMgZm91bmQsXG5cdFx0XHQgKiBpdCB3aWxsIGdvIHRoZXJlIGFzIG9mIHYxLjcpLiBGb3IgZXhhbXBsZSwgVHdlZW5MaXRlIHdpbGwgYmUgZm91bmQgYXQgd2luZG93LmNvbS5ncmVlbnNvY2suVHdlZW5MaXRlIGFuZCBzaW5jZSBpdCdzIGEgZ2xvYmFsIGNsYXNzIHRoYXQgc2hvdWxkIGJlIGF2YWlsYWJsZSBhbnl3aGVyZSxcblx0XHRcdCAqIGl0IGlzIEFMU08gcmVmZXJlbmNlZCBhdCB3aW5kb3cuVHdlZW5MaXRlLiBIb3dldmVyIHNvbWUgY2xhc3NlcyBhcmVuJ3QgY29uc2lkZXJlZCBnbG9iYWwsIGxpa2UgdGhlIGJhc2UgY29tLmdyZWVuc29jay5jb3JlLkFuaW1hdGlvbiBjbGFzcywgc29cblx0XHRcdCAqIHRob3NlIHdpbGwgb25seSBiZSBhdCB0aGUgcGFja2FnZSBsaWtlIHdpbmRvdy5jb20uZ3JlZW5zb2NrLmNvcmUuQW5pbWF0aW9uLiBBZ2FpbiwgaWYgeW91IGRlZmluZSBhIEdyZWVuU29ja0dsb2JhbHMgb2JqZWN0IG9uIHRoZSB3aW5kb3csIGV2ZXJ5dGhpbmdcblx0XHRcdCAqIGdldHMgdHVja2VkIG5lYXRseSBpbnNpZGUgdGhlcmUgaW5zdGVhZCBvZiBvbiB0aGUgd2luZG93IGRpcmVjdGx5LiBUaGlzIGFsbG93cyB5b3UgdG8gZG8gYWR2YW5jZWQgdGhpbmdzIGxpa2UgbG9hZCBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBHcmVlblNvY2tcblx0XHRcdCAqIGZpbGVzIGFuZCBwdXQgdGhlbSBpbnRvIGRpc3RpbmN0IG9iamVjdHMgKGltYWdpbmUgYSBiYW5uZXIgYWQgdXNlcyBhIG5ld2VyIHZlcnNpb24gYnV0IHRoZSBtYWluIHNpdGUgdXNlcyBhbiBvbGRlciBvbmUpLiBJbiB0aGF0IGNhc2UsIHlvdSBjb3VsZFxuXHRcdFx0ICogc2FuZGJveCB0aGUgYmFubmVyIG9uZSBsaWtlOlxuXHRcdFx0ICpcblx0XHRcdCAqIDxzY3JpcHQ+XG5cdFx0XHQgKiAgICAgdmFyIGdzID0gd2luZG93LkdyZWVuU29ja0dsb2JhbHMgPSB7fTsgLy90aGUgbmV3ZXIgdmVyc2lvbiB3ZSdyZSBhYm91dCB0byBsb2FkIGNvdWxkIG5vdyBiZSByZWZlcmVuY2VkIGluIGEgXCJnc1wiIG9iamVjdCwgbGlrZSBncy5Ud2VlbkxpdGUudG8oLi4uKS4gVXNlIHdoYXRldmVyIGFsaWFzIHlvdSB3YW50IGFzIGxvbmcgYXMgaXQncyB1bmlxdWUsIFwiZ3NcIiBvciBcImJhbm5lclwiIG9yIHdoYXRldmVyLlxuXHRcdFx0ICogPC9zY3JpcHQ+XG5cdFx0XHQgKiA8c2NyaXB0IHNyYz1cImpzL2dyZWVuc29jay92MS43L1R3ZWVuTWF4LmpzXCI+PC9zY3JpcHQ+XG5cdFx0XHQgKiA8c2NyaXB0PlxuXHRcdFx0ICogICAgIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0gd2luZG93Ll9nc1F1ZXVlID0gd2luZG93Ll9nc0RlZmluZSA9IG51bGw7IC8vcmVzZXQgaXQgYmFjayB0byBudWxsIChhbG9uZyB3aXRoIHRoZSBzcGVjaWFsIF9nc1F1ZXVlIHZhcmlhYmxlKSBzbyB0aGF0IHRoZSBuZXh0IGxvYWQgb2YgVHdlZW5NYXggYWZmZWN0cyB0aGUgd2luZG93IGFuZCB3ZSBjYW4gcmVmZXJlbmNlIHRoaW5ncyBkaXJlY3RseSBsaWtlIFR3ZWVuTGl0ZS50byguLi4pXG5cdFx0XHQgKiA8L3NjcmlwdD5cblx0XHRcdCAqIDxzY3JpcHQgc3JjPVwianMvZ3JlZW5zb2NrL3YxLjYvVHdlZW5NYXguanNcIj48L3NjcmlwdD5cblx0XHRcdCAqIDxzY3JpcHQ+XG5cdFx0XHQgKiAgICAgZ3MuVHdlZW5MaXRlLnRvKC4uLik7IC8vd291bGQgdXNlIHYxLjdcblx0XHRcdCAqICAgICBUd2VlbkxpdGUudG8oLi4uKTsgLy93b3VsZCB1c2UgdjEuNlxuXHRcdFx0ICogPC9zY3JpcHQ+XG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBucyBUaGUgbmFtZXNwYWNlIG9mIHRoZSBjbGFzcyBkZWZpbml0aW9uLCBsZWF2aW5nIG9mZiBcImNvbS5ncmVlbnNvY2suXCIgYXMgdGhhdCdzIGFzc3VtZWQuIEZvciBleGFtcGxlLCBcIlR3ZWVuTGl0ZVwiIG9yIFwicGx1Z2lucy5DU1NQbHVnaW5cIiBvciBcImVhc2luZy5CYWNrXCIuXG5cdFx0XHQgKiBAcGFyYW0geyFBcnJheS48c3RyaW5nPn0gZGVwZW5kZW5jaWVzIEFuIGFycmF5IG9mIGRlcGVuZGVuY2llcyAoZGVzY3JpYmVkIGFzIHRoZWlyIG5hbWVzcGFjZXMgbWludXMgXCJjb20uZ3JlZW5zb2NrLlwiIHByZWZpeCkuIEZvciBleGFtcGxlIFtcIlR3ZWVuTGl0ZVwiLFwicGx1Z2lucy5Ud2VlblBsdWdpblwiLFwiY29yZS5BbmltYXRpb25cIl1cblx0XHRcdCAqIEBwYXJhbSB7IWZ1bmN0aW9uKCk6T2JqZWN0fSBmdW5jIFRoZSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgYW5kIHBhc3NlZCB0aGUgcmVzb2x2ZWQgZGVwZW5kZW5jaWVzIHdoaWNoIHdpbGwgcmV0dXJuIHRoZSBhY3R1YWwgY2xhc3MgZm9yIHRoaXMgZGVmaW5pdGlvbi5cblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IGdsb2JhbCBJZiB0cnVlLCB0aGUgY2xhc3Mgd2lsbCBiZSBhZGRlZCB0byB0aGUgZ2xvYmFsIHNjb3BlICh0eXBpY2FsbHkgd2luZG93IHVubGVzcyB5b3UgZGVmaW5lIGEgd2luZG93LkdyZWVuU29ja0dsb2JhbHMgb2JqZWN0KVxuXHRcdFx0ICovXG5cdFx0XHREZWZpbml0aW9uID0gZnVuY3Rpb24obnMsIGRlcGVuZGVuY2llcywgZnVuYywgZ2xvYmFsKSB7XG5cdFx0XHRcdHRoaXMuc2MgPSAoX2RlZkxvb2t1cFtuc10pID8gX2RlZkxvb2t1cFtuc10uc2MgOiBbXTsgLy9zdWJjbGFzc2VzXG5cdFx0XHRcdF9kZWZMb29rdXBbbnNdID0gdGhpcztcblx0XHRcdFx0dGhpcy5nc0NsYXNzID0gbnVsbDtcblx0XHRcdFx0dGhpcy5mdW5jID0gZnVuYztcblx0XHRcdFx0dmFyIF9jbGFzc2VzID0gW107XG5cdFx0XHRcdHRoaXMuY2hlY2sgPSBmdW5jdGlvbihpbml0KSB7XG5cdFx0XHRcdFx0dmFyIGkgPSBkZXBlbmRlbmNpZXMubGVuZ3RoLFxuXHRcdFx0XHRcdFx0bWlzc2luZyA9IGksXG5cdFx0XHRcdFx0XHRjdXIsIGEsIG4sIGNsO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKChjdXIgPSBfZGVmTG9va3VwW2RlcGVuZGVuY2llc1tpXV0gfHwgbmV3IERlZmluaXRpb24oZGVwZW5kZW5jaWVzW2ldLCBbXSkpLmdzQ2xhc3MpIHtcblx0XHRcdFx0XHRcdFx0X2NsYXNzZXNbaV0gPSBjdXIuZ3NDbGFzcztcblx0XHRcdFx0XHRcdFx0bWlzc2luZy0tO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChpbml0KSB7XG5cdFx0XHRcdFx0XHRcdGN1ci5zYy5wdXNoKHRoaXMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWlzc2luZyA9PT0gMCAmJiBmdW5jKSB7XG5cdFx0XHRcdFx0XHRhID0gKFwiY29tLmdyZWVuc29jay5cIiArIG5zKS5zcGxpdChcIi5cIik7XG5cdFx0XHRcdFx0XHRuID0gYS5wb3AoKTtcblx0XHRcdFx0XHRcdGNsID0gX25hbWVzcGFjZShhLmpvaW4oXCIuXCIpKVtuXSA9IHRoaXMuZ3NDbGFzcyA9IGZ1bmMuYXBwbHkoZnVuYywgX2NsYXNzZXMpO1xuXG5cdFx0XHRcdFx0XHQvL2V4cG9ydHMgdG8gbXVsdGlwbGUgZW52aXJvbm1lbnRzXG5cdFx0XHRcdFx0XHRpZiAoZ2xvYmFsKSB7XG5cdFx0XHRcdFx0XHRcdF9nbG9iYWxzW25dID0gX2V4cG9ydHNbbl0gPSBjbDsgLy9wcm92aWRlcyBhIHdheSB0byBhdm9pZCBnbG9iYWwgbmFtZXNwYWNlIHBvbGx1dGlvbi4gQnkgZGVmYXVsdCwgdGhlIG1haW4gY2xhc3NlcyBsaWtlIFR3ZWVuTGl0ZSwgUG93ZXIxLCBTdHJvbmcsIGV0Yy4gYXJlIGFkZGVkIHRvIHdpbmRvdyB1bmxlc3MgYSBHcmVlblNvY2tHbG9iYWxzIGlzIGRlZmluZWQuIFNvIGlmIHlvdSB3YW50IHRvIGhhdmUgdGhpbmdzIGFkZGVkIHRvIGEgY3VzdG9tIG9iamVjdCBpbnN0ZWFkLCBqdXN0IGRvIHNvbWV0aGluZyBsaWtlIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0ge30gYmVmb3JlIGxvYWRpbmcgYW55IEdyZWVuU29jayBmaWxlcy4gWW91IGNhbiBldmVuIHNldCB1cCBhbiBhbGlhcyBsaWtlIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0gd2luZG93cy5ncyA9IHt9IHNvIHRoYXQgeW91IGNhbiBhY2Nlc3MgZXZlcnl0aGluZyBsaWtlIGdzLlR3ZWVuTGl0ZS4gQWxzbyByZW1lbWJlciB0aGF0IEFMTCBjbGFzc2VzIGFyZSBhZGRlZCB0byB0aGUgd2luZG93LmNvbS5ncmVlbnNvY2sgb2JqZWN0IChpbiB0aGVpciByZXNwZWN0aXZlIHBhY2thZ2VzLCBsaWtlIGNvbS5ncmVlbnNvY2suZWFzaW5nLlBvd2VyMSwgY29tLmdyZWVuc29jay5Ud2VlbkxpdGUsIGV0Yy4pXG5cdFx0XHRcdFx0XHRcdC8qXG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YobW9kdWxlKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cykgeyAvL25vZGVcblx0XHRcdFx0XHRcdFx0XHRpZiAobnMgPT09IG1vZHVsZU5hbWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZS5leHBvcnRzID0gX2V4cG9ydHNbbW9kdWxlTmFtZV0gPSBjbDtcblx0XHRcdFx0XHRcdFx0XHRcdGZvciAoaSBpbiBfZXhwb3J0cykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbFtpXSA9IF9leHBvcnRzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoX2V4cG9ydHNbbW9kdWxlTmFtZV0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdF9leHBvcnRzW21vZHVsZU5hbWVdW25dID0gY2w7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZihkZWZpbmUpID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCl7IC8vQU1EXG5cdFx0XHRcdFx0XHRcdFx0ZGVmaW5lKCh3aW5kb3cuR3JlZW5Tb2NrQU1EUGF0aCA/IHdpbmRvdy5HcmVlblNvY2tBTURQYXRoICsgXCIvXCIgOiBcIlwiKSArIG5zLnNwbGl0KFwiLlwiKS5wb3AoKSwgW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2w7IH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdCovXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5zYy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNjW2ldLmNoZWNrKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLmNoZWNrKHRydWUpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly91c2VkIHRvIGNyZWF0ZSBEZWZpbml0aW9uIGluc3RhbmNlcyAod2hpY2ggYmFzaWNhbGx5IHJlZ2lzdGVycyBhIGNsYXNzIHRoYXQgaGFzIGRlcGVuZGVuY2llcykuXG5cdFx0XHRfZ3NEZWZpbmUgPSB3aW5kb3cuX2dzRGVmaW5lID0gZnVuY3Rpb24obnMsIGRlcGVuZGVuY2llcywgZnVuYywgZ2xvYmFsKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgRGVmaW5pdGlvbihucywgZGVwZW5kZW5jaWVzLCBmdW5jLCBnbG9iYWwpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly9hIHF1aWNrIHdheSB0byBjcmVhdGUgYSBjbGFzcyB0aGF0IGRvZXNuJ3QgaGF2ZSBhbnkgZGVwZW5kZW5jaWVzLiBSZXR1cm5zIHRoZSBjbGFzcywgYnV0IGZpcnN0IHJlZ2lzdGVycyBpdCBpbiB0aGUgR3JlZW5Tb2NrIG5hbWVzcGFjZSBzbyB0aGF0IG90aGVyIGNsYXNzZXMgY2FuIGdyYWIgaXQgKG90aGVyIGNsYXNzZXMgbWlnaHQgYmUgZGVwZW5kZW50IG9uIHRoZSBjbGFzcykuXG5cdFx0XHRfY2xhc3MgPSBncy5fY2xhc3MgPSBmdW5jdGlvbihucywgZnVuYywgZ2xvYmFsKSB7XG5cdFx0XHRcdGZ1bmMgPSBmdW5jIHx8IGZ1bmN0aW9uKCkge307XG5cdFx0XHRcdF9nc0RlZmluZShucywgW10sIGZ1bmN0aW9uKCl7IHJldHVybiBmdW5jOyB9LCBnbG9iYWwpO1xuXHRcdFx0XHRyZXR1cm4gZnVuYztcblx0XHRcdH07XG5cblx0XHRfZ3NEZWZpbmUuZ2xvYmFscyA9IF9nbG9iYWxzO1xuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEVhc2VcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBfYmFzZVBhcmFtcyA9IFswLCAwLCAxLCAxXSxcblx0XHRcdEVhc2UgPSBfY2xhc3MoXCJlYXNpbmcuRWFzZVwiLCBmdW5jdGlvbihmdW5jLCBleHRyYVBhcmFtcywgdHlwZSwgcG93ZXIpIHtcblx0XHRcdFx0dGhpcy5fZnVuYyA9IGZ1bmM7XG5cdFx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlIHx8IDA7XG5cdFx0XHRcdHRoaXMuX3Bvd2VyID0gcG93ZXIgfHwgMDtcblx0XHRcdFx0dGhpcy5fcGFyYW1zID0gZXh0cmFQYXJhbXMgPyBfYmFzZVBhcmFtcy5jb25jYXQoZXh0cmFQYXJhbXMpIDogX2Jhc2VQYXJhbXM7XG5cdFx0XHR9LCB0cnVlKSxcblx0XHRcdF9lYXNlTWFwID0gRWFzZS5tYXAgPSB7fSxcblx0XHRcdF9lYXNlUmVnID0gRWFzZS5yZWdpc3RlciA9IGZ1bmN0aW9uKGVhc2UsIG5hbWVzLCB0eXBlcywgY3JlYXRlKSB7XG5cdFx0XHRcdHZhciBuYSA9IG5hbWVzLnNwbGl0KFwiLFwiKSxcblx0XHRcdFx0XHRpID0gbmEubGVuZ3RoLFxuXHRcdFx0XHRcdHRhID0gKHR5cGVzIHx8IFwiZWFzZUluLGVhc2VPdXQsZWFzZUluT3V0XCIpLnNwbGl0KFwiLFwiKSxcblx0XHRcdFx0XHRlLCBuYW1lLCBqLCB0eXBlO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRuYW1lID0gbmFbaV07XG5cdFx0XHRcdFx0ZSA9IGNyZWF0ZSA/IF9jbGFzcyhcImVhc2luZy5cIituYW1lLCBudWxsLCB0cnVlKSA6IGdzLmVhc2luZ1tuYW1lXSB8fCB7fTtcblx0XHRcdFx0XHRqID0gdGEubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWogPiAtMSkge1xuXHRcdFx0XHRcdFx0dHlwZSA9IHRhW2pdO1xuXHRcdFx0XHRcdFx0X2Vhc2VNYXBbbmFtZSArIFwiLlwiICsgdHlwZV0gPSBfZWFzZU1hcFt0eXBlICsgbmFtZV0gPSBlW3R5cGVdID0gZWFzZS5nZXRSYXRpbyA/IGVhc2UgOiBlYXNlW3R5cGVdIHx8IG5ldyBlYXNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0cCA9IEVhc2UucHJvdG90eXBlO1xuXHRcdHAuX2NhbGNFbmQgPSBmYWxzZTtcblx0XHRwLmdldFJhdGlvID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0aWYgKHRoaXMuX2Z1bmMpIHtcblx0XHRcdFx0dGhpcy5fcGFyYW1zWzBdID0gcDtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2Z1bmMuYXBwbHkobnVsbCwgdGhpcy5fcGFyYW1zKTtcblx0XHRcdH1cblx0XHRcdHZhciB0ID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0cHcgPSB0aGlzLl9wb3dlcixcblx0XHRcdFx0ciA9ICh0ID09PSAxKSA/IDEgLSBwIDogKHQgPT09IDIpID8gcCA6IChwIDwgMC41KSA/IHAgKiAyIDogKDEgLSBwKSAqIDI7XG5cdFx0XHRpZiAocHcgPT09IDEpIHtcblx0XHRcdFx0ciAqPSByO1xuXHRcdFx0fSBlbHNlIGlmIChwdyA9PT0gMikge1xuXHRcdFx0XHRyICo9IHIgKiByO1xuXHRcdFx0fSBlbHNlIGlmIChwdyA9PT0gMykge1xuXHRcdFx0XHRyICo9IHIgKiByICogcjtcblx0XHRcdH0gZWxzZSBpZiAocHcgPT09IDQpIHtcblx0XHRcdFx0ciAqPSByICogciAqIHIgKiByO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0ID09PSAxKSA/IDEgLSByIDogKHQgPT09IDIpID8gciA6IChwIDwgMC41KSA/IHIgLyAyIDogMSAtIChyIC8gMik7XG5cdFx0fTtcblxuXHRcdC8vY3JlYXRlIGFsbCB0aGUgc3RhbmRhcmQgZWFzZXMgbGlrZSBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBhbmQgUG93ZXI0IChlYWNoIHdpdGggZWFzZUluLCBlYXNlT3V0LCBhbmQgZWFzZUluT3V0KVxuXHRcdGEgPSBbXCJMaW5lYXJcIixcIlF1YWRcIixcIkN1YmljXCIsXCJRdWFydFwiLFwiUXVpbnQsU3Ryb25nXCJdO1xuXHRcdGkgPSBhLmxlbmd0aDtcblx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdHAgPSBhW2ldK1wiLFBvd2VyXCIraTtcblx0XHRcdF9lYXNlUmVnKG5ldyBFYXNlKG51bGwsbnVsbCwxLGkpLCBwLCBcImVhc2VPdXRcIiwgdHJ1ZSk7XG5cdFx0XHRfZWFzZVJlZyhuZXcgRWFzZShudWxsLG51bGwsMixpKSwgcCwgXCJlYXNlSW5cIiArICgoaSA9PT0gMCkgPyBcIixlYXNlTm9uZVwiIDogXCJcIikpO1xuXHRcdFx0X2Vhc2VSZWcobmV3IEVhc2UobnVsbCxudWxsLDMsaSksIHAsIFwiZWFzZUluT3V0XCIpO1xuXHRcdH1cblx0XHRfZWFzZU1hcC5saW5lYXIgPSBncy5lYXNpbmcuTGluZWFyLmVhc2VJbjtcblx0XHRfZWFzZU1hcC5zd2luZyA9IGdzLmVhc2luZy5RdWFkLmVhc2VJbk91dDsgLy9mb3IgalF1ZXJ5IGZvbGtzXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEV2ZW50RGlzcGF0Y2hlclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIEV2ZW50RGlzcGF0Y2hlciA9IF9jbGFzcyhcImV2ZW50cy5FdmVudERpc3BhdGNoZXJcIiwgZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0XHR0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblx0XHRcdHRoaXMuX2V2ZW50VGFyZ2V0ID0gdGFyZ2V0IHx8IHRoaXM7XG5cdFx0fSk7XG5cdFx0cCA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGU7XG5cblx0XHRwLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaywgc2NvcGUsIHVzZVBhcmFtLCBwcmlvcml0eSkge1xuXHRcdFx0cHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwO1xuXHRcdFx0dmFyIGxpc3QgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0sXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGlzdGVuZXIsIGk7XG5cdFx0XHRpZiAodGhpcyA9PT0gX3RpY2tlciAmJiAhX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHRcdGlmIChsaXN0ID09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5fbGlzdGVuZXJzW3R5cGVdID0gbGlzdCA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0aSA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGxpc3RlbmVyID0gbGlzdFtpXTtcblx0XHRcdFx0aWYgKGxpc3RlbmVyLmMgPT09IGNhbGxiYWNrICYmIGxpc3RlbmVyLnMgPT09IHNjb3BlKSB7XG5cdFx0XHRcdFx0bGlzdC5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaW5kZXggPT09IDAgJiYgbGlzdGVuZXIucHIgPCBwcmlvcml0eSkge1xuXHRcdFx0XHRcdGluZGV4ID0gaSArIDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxpc3Quc3BsaWNlKGluZGV4LCAwLCB7YzpjYWxsYmFjaywgczpzY29wZSwgdXA6dXNlUGFyYW0sIHByOnByaW9yaXR5fSk7XG5cdFx0fTtcblxuXHRcdHAucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSwgaTtcblx0XHRcdGlmIChsaXN0KSB7XG5cdFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKGxpc3RbaV0uYyA9PT0gY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSxcblx0XHRcdFx0aSwgdCwgbGlzdGVuZXI7XG5cdFx0XHRpZiAobGlzdCkge1xuXHRcdFx0XHRpID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdGlmIChpID4gMSkge1xuXHRcdFx0XHRcdGxpc3QgPSBsaXN0LnNsaWNlKDApOyAvL2luIGNhc2UgYWRkRXZlbnRMaXN0ZW5lcigpIGlzIGNhbGxlZCBmcm9tIHdpdGhpbiBhIGxpc3RlbmVyL2NhbGxiYWNrIChvdGhlcndpc2UgdGhlIGluZGV4IGNvdWxkIGNoYW5nZSwgcmVzdWx0aW5nIGluIGEgc2tpcClcblx0XHRcdFx0fVxuXHRcdFx0XHR0ID0gdGhpcy5fZXZlbnRUYXJnZXQ7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGxpc3RlbmVyID0gbGlzdFtpXTtcblx0XHRcdFx0XHRpZiAobGlzdGVuZXIpIHtcblx0XHRcdFx0XHRcdGlmIChsaXN0ZW5lci51cCkge1xuXHRcdFx0XHRcdFx0XHRsaXN0ZW5lci5jLmNhbGwobGlzdGVuZXIucyB8fCB0LCB7dHlwZTp0eXBlLCB0YXJnZXQ6dH0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGlzdGVuZXIuYy5jYWxsKGxpc3RlbmVyLnMgfHwgdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVGlja2VyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbiBcdFx0dmFyIF9yZXFBbmltRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuXHRcdFx0X2NhbmNlbEFuaW1GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSxcblx0XHRcdF9nZXRUaW1lID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7cmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO30sXG5cdFx0XHRfbGFzdFVwZGF0ZSA9IF9nZXRUaW1lKCk7XG5cblx0XHQvL25vdyB0cnkgdG8gZGV0ZXJtaW5lIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYW5kIGNhbmNlbEFuaW1hdGlvbkZyYW1lIGZ1bmN0aW9ucyBhbmQgaWYgbm9uZSBhcmUgZm91bmQsIHdlJ2xsIHVzZSBhIHNldFRpbWVvdXQoKS9jbGVhclRpbWVvdXQoKSBwb2x5ZmlsbC5cblx0XHRhID0gW1wibXNcIixcIm1velwiLFwid2Via2l0XCIsXCJvXCJdO1xuXHRcdGkgPSBhLmxlbmd0aDtcblx0XHR3aGlsZSAoLS1pID4gLTEgJiYgIV9yZXFBbmltRnJhbWUpIHtcblx0XHRcdF9yZXFBbmltRnJhbWUgPSB3aW5kb3dbYVtpXSArIFwiUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuXHRcdFx0X2NhbmNlbEFuaW1GcmFtZSA9IHdpbmRvd1thW2ldICsgXCJDYW5jZWxBbmltYXRpb25GcmFtZVwiXSB8fCB3aW5kb3dbYVtpXSArIFwiQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuXHRcdH1cblxuXHRcdF9jbGFzcyhcIlRpY2tlclwiLCBmdW5jdGlvbihmcHMsIHVzZVJBRikge1xuXHRcdFx0dmFyIF9zZWxmID0gdGhpcyxcblx0XHRcdFx0X3N0YXJ0VGltZSA9IF9nZXRUaW1lKCksXG5cdFx0XHRcdF91c2VSQUYgPSAodXNlUkFGICE9PSBmYWxzZSAmJiBfcmVxQW5pbUZyYW1lKSA/IFwiYXV0b1wiIDogZmFsc2UsXG5cdFx0XHRcdF9sYWdUaHJlc2hvbGQgPSA1MDAsXG5cdFx0XHRcdF9hZGp1c3RlZExhZyA9IDMzLFxuXHRcdFx0XHRfdGlja1dvcmQgPSBcInRpY2tcIiwgLy9oZWxwcyByZWR1Y2UgZ2MgYnVyZGVuXG5cdFx0XHRcdF9mcHMsIF9yZXEsIF9pZCwgX2dhcCwgX25leHRUaW1lLFxuXHRcdFx0XHRfdGljayA9IGZ1bmN0aW9uKG1hbnVhbCkge1xuXHRcdFx0XHRcdHZhciBlbGFwc2VkID0gX2dldFRpbWUoKSAtIF9sYXN0VXBkYXRlLFxuXHRcdFx0XHRcdFx0b3ZlcmxhcCwgZGlzcGF0Y2g7XG5cdFx0XHRcdFx0aWYgKGVsYXBzZWQgPiBfbGFnVGhyZXNob2xkKSB7XG5cdFx0XHRcdFx0XHRfc3RhcnRUaW1lICs9IGVsYXBzZWQgLSBfYWRqdXN0ZWRMYWc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF9sYXN0VXBkYXRlICs9IGVsYXBzZWQ7XG5cdFx0XHRcdFx0X3NlbGYudGltZSA9IChfbGFzdFVwZGF0ZSAtIF9zdGFydFRpbWUpIC8gMTAwMDtcblx0XHRcdFx0XHRvdmVybGFwID0gX3NlbGYudGltZSAtIF9uZXh0VGltZTtcblx0XHRcdFx0XHRpZiAoIV9mcHMgfHwgb3ZlcmxhcCA+IDAgfHwgbWFudWFsID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRfc2VsZi5mcmFtZSsrO1xuXHRcdFx0XHRcdFx0X25leHRUaW1lICs9IG92ZXJsYXAgKyAob3ZlcmxhcCA+PSBfZ2FwID8gMC4wMDQgOiBfZ2FwIC0gb3ZlcmxhcCk7XG5cdFx0XHRcdFx0XHRkaXNwYXRjaCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtYW51YWwgIT09IHRydWUpIHsgLy9tYWtlIHN1cmUgdGhlIHJlcXVlc3QgaXMgbWFkZSBiZWZvcmUgd2UgZGlzcGF0Y2ggdGhlIFwidGlja1wiIGV2ZW50IHNvIHRoYXQgdGltaW5nIGlzIG1haW50YWluZWQuIE90aGVyd2lzZSwgaWYgcHJvY2Vzc2luZyB0aGUgXCJ0aWNrXCIgcmVxdWlyZXMgYSBidW5jaCBvZiB0aW1lIChsaWtlIDE1bXMpIGFuZCB3ZSdyZSB1c2luZyBhIHNldFRpbWVvdXQoKSB0aGF0J3MgYmFzZWQgb24gMTYuN21zLCBpdCdkIHRlY2huaWNhbGx5IHRha2UgMzEuN21zIGJldHdlZW4gZnJhbWVzIG90aGVyd2lzZS5cblx0XHRcdFx0XHRcdF9pZCA9IF9yZXEoX3RpY2spO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZGlzcGF0Y2gpIHtcblx0XHRcdFx0XHRcdF9zZWxmLmRpc3BhdGNoRXZlbnQoX3RpY2tXb3JkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdEV2ZW50RGlzcGF0Y2hlci5jYWxsKF9zZWxmKTtcblx0XHRcdF9zZWxmLnRpbWUgPSBfc2VsZi5mcmFtZSA9IDA7XG5cdFx0XHRfc2VsZi50aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF90aWNrKHRydWUpO1xuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYubGFnU21vb3RoaW5nID0gZnVuY3Rpb24odGhyZXNob2xkLCBhZGp1c3RlZExhZykge1xuXHRcdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHsgLy9pZiBsYWdTbW9vdGhpbmcoKSBpcyBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIHRyZWF0IGl0IGxpa2UgYSBnZXR0ZXIgdGhhdCByZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGl0J3MgZW5hYmxlZCBvciBub3QuIFRoaXMgaXMgcHVycG9zZWx5IHVuZG9jdW1lbnRlZCBhbmQgaXMgZm9yIGludGVybmFsIHVzZS5cblx0XHRcdFx0XHRyZXR1cm4gKF9sYWdUaHJlc2hvbGQgPCAxIC8gX3RpbnlOdW0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9sYWdUaHJlc2hvbGQgPSB0aHJlc2hvbGQgfHwgKDEgLyBfdGlueU51bSk7IC8vemVybyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYmFzaWNhbGx5IHVubGltaXRlZFxuXHRcdFx0XHRfYWRqdXN0ZWRMYWcgPSBNYXRoLm1pbihhZGp1c3RlZExhZywgX2xhZ1RocmVzaG9sZCwgMCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRfc2VsZi5zbGVlcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoX2lkID09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFfdXNlUkFGIHx8ICFfY2FuY2VsQW5pbUZyYW1lKSB7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KF9pZCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X2NhbmNlbEFuaW1GcmFtZShfaWQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9yZXEgPSBfZW1wdHlGdW5jO1xuXHRcdFx0XHRfaWQgPSBudWxsO1xuXHRcdFx0XHRpZiAoX3NlbGYgPT09IF90aWNrZXIpIHtcblx0XHRcdFx0XHRfdGlja2VyQWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLndha2UgPSBmdW5jdGlvbihzZWFtbGVzcykge1xuXHRcdFx0XHRpZiAoX2lkICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0X3NlbGYuc2xlZXAoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChzZWFtbGVzcykge1xuXHRcdFx0XHRcdF9zdGFydFRpbWUgKz0gLV9sYXN0VXBkYXRlICsgKF9sYXN0VXBkYXRlID0gX2dldFRpbWUoKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoX3NlbGYuZnJhbWUgPiAxMCkgeyAvL2Rvbid0IHRyaWdnZXIgbGFnU21vb3RoaW5nIGlmIHdlJ3JlIGp1c3Qgd2FraW5nIHVwLCBhbmQgbWFrZSBzdXJlIHRoYXQgYXQgbGVhc3QgMTAgZnJhbWVzIGhhdmUgZWxhcHNlZCBiZWNhdXNlIG9mIHRoZSBpT1MgYnVnIHRoYXQgd2Ugd29yayBhcm91bmQgYmVsb3cgd2l0aCB0aGUgMS41LXNlY29uZCBzZXRUaW1vdXQoKS5cblx0XHRcdFx0XHRfbGFzdFVwZGF0ZSA9IF9nZXRUaW1lKCkgLSBfbGFnVGhyZXNob2xkICsgNTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfcmVxID0gKF9mcHMgPT09IDApID8gX2VtcHR5RnVuYyA6ICghX3VzZVJBRiB8fCAhX3JlcUFuaW1GcmFtZSkgPyBmdW5jdGlvbihmKSB7IHJldHVybiBzZXRUaW1lb3V0KGYsICgoX25leHRUaW1lIC0gX3NlbGYudGltZSkgKiAxMDAwICsgMSkgfCAwKTsgfSA6IF9yZXFBbmltRnJhbWU7XG5cdFx0XHRcdGlmIChfc2VsZiA9PT0gX3RpY2tlcikge1xuXHRcdFx0XHRcdF90aWNrZXJBY3RpdmUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF90aWNrKDIpO1xuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYuZnBzID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9mcHM7XG5cdFx0XHRcdH1cblx0XHRcdFx0X2ZwcyA9IHZhbHVlO1xuXHRcdFx0XHRfZ2FwID0gMSAvIChfZnBzIHx8IDYwKTtcblx0XHRcdFx0X25leHRUaW1lID0gdGhpcy50aW1lICsgX2dhcDtcblx0XHRcdFx0X3NlbGYud2FrZSgpO1xuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYudXNlUkFGID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF91c2VSQUY7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3NlbGYuc2xlZXAoKTtcblx0XHRcdFx0X3VzZVJBRiA9IHZhbHVlO1xuXHRcdFx0XHRfc2VsZi5mcHMoX2Zwcyk7XG5cdFx0XHR9O1xuXHRcdFx0X3NlbGYuZnBzKGZwcyk7XG5cblx0XHRcdC8vYSBidWcgaW4gaU9TIDYgU2FmYXJpIG9jY2FzaW9uYWxseSBwcmV2ZW50cyB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZyb20gd29ya2luZyBpbml0aWFsbHksIHNvIHdlIHVzZSBhIDEuNS1zZWNvbmQgdGltZW91dCB0aGF0IGF1dG9tYXRpY2FsbHkgZmFsbHMgYmFjayB0byBzZXRUaW1lb3V0KCkgaWYgaXQgc2Vuc2VzIHRoaXMgY29uZGl0aW9uLlxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKF91c2VSQUYgPT09IFwiYXV0b1wiICYmIF9zZWxmLmZyYW1lIDwgNSAmJiAoX2RvYyB8fCB7fSkudmlzaWJpbGl0eVN0YXRlICE9PSBcImhpZGRlblwiKSB7XG5cdFx0XHRcdFx0X3NlbGYudXNlUkFGKGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMTUwMCk7XG5cdFx0fSk7XG5cblx0XHRwID0gZ3MuVGlja2VyLnByb3RvdHlwZSA9IG5ldyBncy5ldmVudHMuRXZlbnREaXNwYXRjaGVyKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IGdzLlRpY2tlcjtcblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQW5pbWF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgQW5pbWF0aW9uID0gX2NsYXNzKFwiY29yZS5BbmltYXRpb25cIiwgZnVuY3Rpb24oZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdFx0dGhpcy52YXJzID0gdmFycyA9IHZhcnMgfHwge307XG5cdFx0XHRcdHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDA7XG5cdFx0XHRcdHRoaXMuX2RlbGF5ID0gTnVtYmVyKHZhcnMuZGVsYXkpIHx8IDA7XG5cdFx0XHRcdHRoaXMuX3RpbWVTY2FsZSA9IDE7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciA9PT0gdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuZGF0YSA9IHZhcnMuZGF0YTtcblx0XHRcdFx0dGhpcy5fcmV2ZXJzZWQgPSAodmFycy5yZXZlcnNlZCA9PT0gdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKCFfcm9vdFRpbWVsaW5lKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkgeyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgaU9TIDYgU2FmYXJpKSBzaHV0IGRvd24gSmF2YVNjcmlwdCBleGVjdXRpb24gd2hlbiB0aGUgdGFiIGlzIGRpc2FibGVkIGFuZCB0aGV5IFtvY2Nhc2lvbmFsbHldIG5lZ2xlY3QgdG8gc3RhcnQgdXAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGFnYWluIHdoZW4gcmV0dXJuaW5nIC0gdGhpcyBjb2RlIGVuc3VyZXMgdGhhdCB0aGUgZW5naW5lIHN0YXJ0cyB1cCBhZ2FpbiBwcm9wZXJseS5cblx0XHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB0bCA9IHRoaXMudmFycy51c2VGcmFtZXMgPyBfcm9vdEZyYW1lc1RpbWVsaW5lIDogX3Jvb3RUaW1lbGluZTtcblx0XHRcdFx0dGwuYWRkKHRoaXMsIHRsLl90aW1lKTtcblxuXHRcdFx0XHRpZiAodGhpcy52YXJzLnBhdXNlZCkge1xuXHRcdFx0XHRcdHRoaXMucGF1c2VkKHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdF90aWNrZXIgPSBBbmltYXRpb24udGlja2VyID0gbmV3IGdzLlRpY2tlcigpO1xuXHRcdHAgPSBBbmltYXRpb24ucHJvdG90eXBlO1xuXHRcdHAuX2RpcnR5ID0gcC5fZ2MgPSBwLl9pbml0dGVkID0gcC5fcGF1c2VkID0gZmFsc2U7XG5cdFx0cC5fdG90YWxUaW1lID0gcC5fdGltZSA9IDA7XG5cdFx0cC5fcmF3UHJldlRpbWUgPSAtMTtcblx0XHRwLl9uZXh0ID0gcC5fbGFzdCA9IHAuX29uVXBkYXRlID0gcC5fdGltZWxpbmUgPSBwLnRpbWVsaW5lID0gbnVsbDtcblx0XHRwLl9wYXVzZWQgPSBmYWxzZTtcblxuXG5cdFx0Ly9zb21lIGJyb3dzZXJzIChsaWtlIGlPUykgb2NjYXNpb25hbGx5IGRyb3AgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBldmVudCB3aGVuIHRoZSB1c2VyIHN3aXRjaGVzIHRvIGEgZGlmZmVyZW50IHRhYiBhbmQgdGhlbiBjb21lcyBiYWNrIGFnYWluLCBzbyB3ZSB1c2UgYSAyLXNlY29uZCBzZXRUaW1lb3V0KCkgdG8gc2Vuc2UgaWYvd2hlbiB0aGF0IGNvbmRpdGlvbiBvY2N1cnMgYW5kIHRoZW4gd2FrZSgpIHRoZSB0aWNrZXIuXG5cdFx0dmFyIF9jaGVja1RpbWVvdXQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKF90aWNrZXJBY3RpdmUgJiYgX2dldFRpbWUoKSAtIF9sYXN0VXBkYXRlID4gMjAwMCAmJiAoKF9kb2MgfHwge30pLnZpc2liaWxpdHlTdGF0ZSAhPT0gXCJoaWRkZW5cIiB8fCAhX3RpY2tlci5sYWdTbW9vdGhpbmcoKSkpIHsgLy9ub3RlOiBpZiB0aGUgdGFiIGlzIGhpZGRlbiwgd2Ugc2hvdWxkIHN0aWxsIHdha2UgaWYgbGFnU21vb3RoaW5nIGhhcyBiZWVuIGRpc2FibGVkLlxuXHRcdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciB0ID0gc2V0VGltZW91dChfY2hlY2tUaW1lb3V0LCAyMDAwKTtcblx0XHRcdFx0aWYgKHQudW5yZWYpIHtcblx0XHRcdFx0XHQvLyBhbGxvd3MgYSBub2RlIHByb2Nlc3MgdG8gZXhpdCBldmVuIGlmIHRoZSB0aW1lb3V04oCZcyBjYWxsYmFjayBoYXNuJ3QgYmVlbiBpbnZva2VkLiBXaXRob3V0IGl0LCB0aGUgbm9kZSBwcm9jZXNzIGNvdWxkIGhhbmcgYXMgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZXZlcnkgdHdvIHNlY29uZHMuXG5cdFx0XHRcdFx0dC51bnJlZigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdF9jaGVja1RpbWVvdXQoKTtcblxuXG5cdFx0cC5wbGF5ID0gZnVuY3Rpb24oZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmIChmcm9tICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zZWVrKGZyb20sIHN1cHByZXNzRXZlbnRzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnJldmVyc2VkKGZhbHNlKS5wYXVzZWQoZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLnBhdXNlID0gZnVuY3Rpb24oYXRUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKGF0VGltZSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc2VlayhhdFRpbWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnBhdXNlZCh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5yZXN1bWUgPSBmdW5jdGlvbihmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKGZyb20gIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnNlZWsoZnJvbSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucGF1c2VkKGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5zZWVrID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZShOdW1iZXIodGltZSksIHN1cHByZXNzRXZlbnRzICE9PSBmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAucmVzdGFydCA9IGZ1bmN0aW9uKGluY2x1ZGVEZWxheSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnJldmVyc2VkKGZhbHNlKS5wYXVzZWQoZmFsc2UpLnRvdGFsVGltZShpbmNsdWRlRGVsYXkgPyAtdGhpcy5fZGVsYXkgOiAwLCAoc3VwcHJlc3NFdmVudHMgIT09IGZhbHNlKSwgdHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAucmV2ZXJzZSA9IGZ1bmN0aW9uKGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoZnJvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc2VlaygoZnJvbSB8fCB0aGlzLnRvdGFsRHVyYXRpb24oKSksIHN1cHByZXNzRXZlbnRzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnJldmVyc2VkKHRydWUpLnBhdXNlZChmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHQvL3N0dWIgLSB3ZSBvdmVycmlkZSB0aGlzIG1ldGhvZCBpbiBzdWJjbGFzc2VzLlxuXHRcdH07XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgPSAwO1xuXHRcdFx0dGhpcy5faW5pdHRlZCA9IHRoaXMuX2djID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IC0xO1xuXHRcdFx0aWYgKHRoaXMuX2djIHx8ICF0aGlzLnRpbWVsaW5lKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRsID0gdGhpcy5fdGltZWxpbmUsIC8vdGhlIDIgcm9vdCB0aW1lbGluZXMgd29uJ3QgaGF2ZSBhIF90aW1lbGluZTsgdGhleSdyZSBhbHdheXMgYWN0aXZlLlxuXHRcdFx0XHRzdGFydFRpbWUgPSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0XHRcdHJhd1RpbWU7XG5cdFx0XHRyZXR1cm4gKCF0bCB8fCAoIXRoaXMuX2djICYmICF0aGlzLl9wYXVzZWQgJiYgdGwuaXNBY3RpdmUoKSAmJiAocmF3VGltZSA9IHRsLnJhd1RpbWUodHJ1ZSkpID49IHN0YXJ0VGltZSAmJiByYXdUaW1lIDwgc3RhcnRUaW1lICsgdGhpcy50b3RhbER1cmF0aW9uKCkgLyB0aGlzLl90aW1lU2NhbGUgLSAwLjAwMDAwMDEpKTtcblx0XHR9O1xuXG5cdFx0cC5fZW5hYmxlZCA9IGZ1bmN0aW9uIChlbmFibGVkLCBpZ25vcmVUaW1lbGluZSkge1xuXHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7XG5cdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZ2MgPSAhZW5hYmxlZDtcblx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRoaXMuaXNBY3RpdmUoKTtcblx0XHRcdGlmIChpZ25vcmVUaW1lbGluZSAhPT0gdHJ1ZSkge1xuXHRcdFx0XHRpZiAoZW5hYmxlZCAmJiAhdGhpcy50aW1lbGluZSkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWVsaW5lLmFkZCh0aGlzLCB0aGlzLl9zdGFydFRpbWUgLSB0aGlzLl9kZWxheSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgdGhpcy50aW1lbGluZSkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWVsaW5lLl9yZW1vdmUodGhpcywgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24odmFycywgdGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLmtpbGwgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQpIHtcblx0XHRcdHRoaXMuX2tpbGwodmFycywgdGFyZ2V0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLl91bmNhY2hlID0gZnVuY3Rpb24oaW5jbHVkZVNlbGYpIHtcblx0XHRcdHZhciB0d2VlbiA9IGluY2x1ZGVTZWxmID8gdGhpcyA6IHRoaXMudGltZWxpbmU7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0dHdlZW4uX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi50aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLl9zd2FwU2VsZkluUGFyYW1zID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cdFx0XHR2YXIgaSA9IHBhcmFtcy5sZW5ndGgsXG5cdFx0XHRcdGNvcHkgPSBwYXJhbXMuY29uY2F0KCk7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKHBhcmFtc1tpXSA9PT0gXCJ7c2VsZn1cIikge1xuXHRcdFx0XHRcdGNvcHlbaV0gPSB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29weTtcblx0XHR9O1xuXG5cdFx0cC5fY2FsbGJhY2sgPSBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgdiA9IHRoaXMudmFycyxcblx0XHRcdFx0Y2FsbGJhY2sgPSB2W3R5cGVdLFxuXHRcdFx0XHRwYXJhbXMgPSB2W3R5cGUgKyBcIlBhcmFtc1wiXSxcblx0XHRcdFx0c2NvcGUgPSB2W3R5cGUgKyBcIlNjb3BlXCJdIHx8IHYuY2FsbGJhY2tTY29wZSB8fCB0aGlzLFxuXHRcdFx0XHRsID0gcGFyYW1zID8gcGFyYW1zLmxlbmd0aCA6IDA7XG5cdFx0XHRzd2l0Y2ggKGwpIHsgLy9zcGVlZCBvcHRpbWl6YXRpb247IGNhbGwoKSBpcyBmYXN0ZXIgdGhhbiBhcHBseSgpIHNvIHVzZSBpdCB3aGVuIHRoZXJlIGFyZSBvbmx5IGEgZmV3IHBhcmFtZXRlcnMgKHdoaWNoIGlzIGJ5IGZhciBtb3N0IGNvbW1vbikuIFByZXZpb3VzbHkgd2Ugc2ltcGx5IGRpZCB2YXIgdiA9IHRoaXMudmFyczsgdlt0eXBlXS5hcHBseSh2W3R5cGUgKyBcIlNjb3BlXCJdIHx8IHYuY2FsbGJhY2tTY29wZSB8fCB0aGlzLCB2W3R5cGUgKyBcIlBhcmFtc1wiXSB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdGNhc2UgMDogY2FsbGJhY2suY2FsbChzY29wZSk7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIDE6IGNhbGxiYWNrLmNhbGwoc2NvcGUsIHBhcmFtc1swXSk7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIDI6IGNhbGxiYWNrLmNhbGwoc2NvcGUsIHBhcmFtc1swXSwgcGFyYW1zWzFdKTsgYnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6IGNhbGxiYWNrLmFwcGx5KHNjb3BlLCBwYXJhbXMpO1xuXHRcdFx0fVxuXHRcdH07XG5cbi8vLS0tLUFuaW1hdGlvbiBnZXR0ZXJzL3NldHRlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdHAuZXZlbnRDYWxsYmFjayA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG5cdFx0XHRpZiAoKHR5cGUgfHwgXCJcIikuc3Vic3RyKDAsMikgPT09IFwib25cIikge1xuXHRcdFx0XHR2YXIgdiA9IHRoaXMudmFycztcblx0XHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRyZXR1cm4gdlt0eXBlXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2FsbGJhY2sgPT0gbnVsbCkge1xuXHRcdFx0XHRcdGRlbGV0ZSB2W3R5cGVdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZbdHlwZV0gPSBjYWxsYmFjaztcblx0XHRcdFx0XHR2W3R5cGUgKyBcIlBhcmFtc1wiXSA9IChfaXNBcnJheShwYXJhbXMpICYmIHBhcmFtcy5qb2luKFwiXCIpLmluZGV4T2YoXCJ7c2VsZn1cIikgIT09IC0xKSA/IHRoaXMuX3N3YXBTZWxmSW5QYXJhbXMocGFyYW1zKSA6IHBhcmFtcztcblx0XHRcdFx0XHR2W3R5cGUgKyBcIlNjb3BlXCJdID0gc2NvcGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGUgPT09IFwib25VcGRhdGVcIikge1xuXHRcdFx0XHRcdHRoaXMuX29uVXBkYXRlID0gY2FsbGJhY2s7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmRlbGF5ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZGVsYXk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0dGhpcy5zdGFydFRpbWUoIHRoaXMuX3N0YXJ0VGltZSArIHZhbHVlIC0gdGhpcy5fZGVsYXkgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2RlbGF5ID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5kdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uID0gdmFsdWU7XG5cdFx0XHR0aGlzLl91bmNhY2hlKHRydWUpOyAvL3RydWUgaW4gY2FzZSBpdCdzIGEgVHdlZW5NYXggb3IgVGltZWxpbmVNYXggdGhhdCBoYXMgYSByZXBlYXQgLSB3ZSdsbCBuZWVkIHRvIHJlZnJlc2ggdGhlIHRvdGFsRHVyYXRpb24uXG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIGlmICh0aGlzLl90aW1lID4gMCkgaWYgKHRoaXMuX3RpbWUgPCB0aGlzLl9kdXJhdGlvbikgaWYgKHZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdHRoaXMudG90YWxUaW1lKHRoaXMuX3RvdGFsVGltZSAqICh2YWx1ZSAvIHRoaXMuX2R1cmF0aW9uKSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/IHRoaXMuX3RvdGFsRHVyYXRpb24gOiB0aGlzLmR1cmF0aW9uKHZhbHVlKTtcblx0XHR9O1xuXG5cdFx0cC50aW1lID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0dGhpcy50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUoKHZhbHVlID4gdGhpcy5fZHVyYXRpb24pID8gdGhpcy5fZHVyYXRpb24gOiB2YWx1ZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsVGltZSA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCB1bmNhcHBlZCkge1xuXHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7XG5cdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b3RhbFRpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUpIHtcblx0XHRcdFx0aWYgKHRpbWUgPCAwICYmICF1bmNhcHBlZCkge1xuXHRcdFx0XHRcdHRpbWUgKz0gdGhpcy50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIHRvdGFsRHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uLFxuXHRcdFx0XHRcdFx0dGwgPSB0aGlzLl90aW1lbGluZTtcblx0XHRcdFx0XHRpZiAodGltZSA+IHRvdGFsRHVyYXRpb24gJiYgIXVuY2FwcGVkKSB7XG5cdFx0XHRcdFx0XHR0aW1lID0gdG90YWxEdXJhdGlvbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gKHRoaXMuX3BhdXNlZCA/IHRoaXMuX3BhdXNlVGltZSA6IHRsLl90aW1lKSAtICgoIXRoaXMuX3JldmVyc2VkID8gdGltZSA6IHRvdGFsRHVyYXRpb24gLSB0aW1lKSAvIHRoaXMuX3RpbWVTY2FsZSk7XG5cdFx0XHRcdFx0aWYgKCF0bC5fZGlydHkpIHsgLy9mb3IgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQuIElmIHRoZSBwYXJlbnQncyBjYWNoZSBpcyBhbHJlYWR5IGRpcnR5LCBpdCBhbHJlYWR5IHRvb2sgY2FyZSBvZiBtYXJraW5nIHRoZSBhbmNlc3RvcnMgYXMgZGlydHkgdG9vLCBzbyBza2lwIHRoZSBmdW5jdGlvbiBjYWxsIGhlcmUuXG5cdFx0XHRcdFx0XHR0aGlzLl91bmNhY2hlKGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3IgdGltZWxpbmVzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZCwgd2Ugc2hvdWxkIHJlc2V0IHRoZWlyIHRvdGFsVGltZSgpIHdoaWNoIHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGV5J3JlIGxpbmVkIHVwIHByb3Blcmx5IGFuZCBlbmFibGVkLiBTa2lwIGZvciBhbmltYXRpb25zIHRoYXQgYXJlIG9uIHRoZSByb290ICh3YXN0ZWZ1bCkuIEV4YW1wbGU6IGEgVGltZWxpbmVMaXRlLmV4cG9ydFJvb3QoKSBpcyBwZXJmb3JtZWQgd2hlbiB0aGVyZSdzIGEgcGF1c2VkIHR3ZWVuIG9uIHRoZSByb290LCB0aGUgZXhwb3J0IHdpbGwgbm90IGNvbXBsZXRlIHVudGlsIHRoYXQgdHdlZW4gaXMgdW5wYXVzZWQsIGJ1dCBpbWFnaW5lIGEgY2hpbGQgZ2V0cyByZXN0YXJ0ZWQgbGF0ZXIsIGFmdGVyIGFsbCBbdW5wYXVzZWRdIHR3ZWVucyBoYXZlIGNvbXBsZXRlZC4gVGhlIHN0YXJ0VGltZSBvZiB0aGF0IGNoaWxkIHdvdWxkIGdldCBwdXNoZWQgb3V0LCBidXQgb25lIG9mIHRoZSBhbmNlc3RvcnMgbWF5IGhhdmUgY29tcGxldGVkLlxuXHRcdFx0XHRcdGlmICh0bC5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHRcdHdoaWxlICh0bC5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHRsLl90aW1lbGluZS5fdGltZSAhPT0gKHRsLl9zdGFydFRpbWUgKyB0bC5fdG90YWxUaW1lKSAvIHRsLl90aW1lU2NhbGUpIHtcblx0XHRcdFx0XHRcdFx0XHR0bC50b3RhbFRpbWUodGwuX3RvdGFsVGltZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGwgPSB0bC5fdGltZWxpbmU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl9nYykge1xuXHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl90b3RhbFRpbWUgIT09IHRpbWUgfHwgdGhpcy5fZHVyYXRpb24gPT09IDApIHtcblx0XHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZmFsc2UpO1xuXHRcdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIHNvbWVvbmUgY2FsbHMgc2VlaygpIG9yIHRpbWUoKSBvciBwcm9ncmVzcygpLCB0aGV5IGV4cGVjdCBhbiBpbW1lZGlhdGUgcmVuZGVyLlxuXHRcdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnByb2dyZXNzID0gcC50b3RhbFByb2dyZXNzID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHR2YXIgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uKCk7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/IChkdXJhdGlvbiA/IHRoaXMuX3RpbWUgLyBkdXJhdGlvbiA6IHRoaXMucmF0aW8pIDogdGhpcy50b3RhbFRpbWUoZHVyYXRpb24gKiB2YWx1ZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnN0YXJ0VGltZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3N0YXJ0VGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPT0gdGhpcy5fc3RhcnRUaW1lKSB7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IHZhbHVlO1xuXHRcdFx0XHRpZiAodGhpcy50aW1lbGluZSkgaWYgKHRoaXMudGltZWxpbmUuX3NvcnRDaGlsZHJlbikge1xuXHRcdFx0XHRcdHRoaXMudGltZWxpbmUuYWRkKHRoaXMsIHZhbHVlIC0gdGhpcy5fZGVsYXkpOyAvL2Vuc3VyZXMgdGhhdCBhbnkgbmVjZXNzYXJ5IHJlLXNlcXVlbmNpbmcgb2YgQW5pbWF0aW9ucyBpbiB0aGUgdGltZWxpbmUgb2NjdXJzIHRvIG1ha2Ugc3VyZSB0aGUgcmVuZGVyaW5nIG9yZGVyIGlzIGNvcnJlY3QuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmVuZFRpbWUgPSBmdW5jdGlvbihpbmNsdWRlUmVwZWF0cykge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3N0YXJ0VGltZSArICgoaW5jbHVkZVJlcGVhdHMgIT0gZmFsc2UpID8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLmR1cmF0aW9uKCkpIC8gdGhpcy5fdGltZVNjYWxlO1xuXHRcdH07XG5cblx0XHRwLnRpbWVTY2FsZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RpbWVTY2FsZTtcblx0XHRcdH1cblx0XHRcdHZhciBwYXVzZVRpbWUsIHQ7XG5cdFx0XHR2YWx1ZSA9IHZhbHVlIHx8IF90aW55TnVtOyAvL2Nhbid0IGFsbG93IHplcm8gYmVjYXVzZSBpdCdsbCB0aHJvdyB0aGUgbWF0aCBvZmZcblx0XHRcdGlmICh0aGlzLl90aW1lbGluZSAmJiB0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHRwYXVzZVRpbWUgPSB0aGlzLl9wYXVzZVRpbWU7XG5cdFx0XHRcdHQgPSAocGF1c2VUaW1lIHx8IHBhdXNlVGltZSA9PT0gMCkgPyBwYXVzZVRpbWUgOiB0aGlzLl90aW1lbGluZS50b3RhbFRpbWUoKTtcblx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gdCAtICgodCAtIHRoaXMuX3N0YXJ0VGltZSkgKiB0aGlzLl90aW1lU2NhbGUgLyB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90aW1lU2NhbGUgPSB2YWx1ZTtcblx0XHRcdHQgPSB0aGlzLnRpbWVsaW5lO1xuXHRcdFx0d2hpbGUgKHQgJiYgdC50aW1lbGluZSkgeyAvL211c3QgdXBkYXRlIHRoZSBkdXJhdGlvbi90b3RhbER1cmF0aW9uIG9mIGFsbCBhbmNlc3RvciB0aW1lbGluZXMgaW1tZWRpYXRlbHkgaW4gY2FzZSBpbiB0aGUgbWlkZGxlIG9mIGEgcmVuZGVyIGxvb3AsIG9uZSB0d2VlbiBhbHRlcnMgYW5vdGhlciB0d2VlbidzIHRpbWVTY2FsZSB3aGljaCBzaG92ZXMgaXRzIHN0YXJ0VGltZSBiZWZvcmUgMCwgZm9yY2luZyB0aGUgcGFyZW50IHRpbWVsaW5lIHRvIHNoaWZ0IGFyb3VuZCBhbmQgc2hpZnRDaGlsZHJlbigpIHdoaWNoIGNvdWxkIGFmZmVjdCB0aGF0IG5leHQgdHdlZW4ncyByZW5kZXIgKHN0YXJ0VGltZSkuIERvZXNuJ3QgbWF0dGVyIGZvciB0aGUgcm9vdCB0aW1lbGluZSB0aG91Z2guXG5cdFx0XHRcdHQuX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0dC50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHRcdHQgPSB0LnRpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucmV2ZXJzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPSB0aGlzLl9yZXZlcnNlZCkge1xuXHRcdFx0XHR0aGlzLl9yZXZlcnNlZCA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLnRvdGFsVGltZSgoKHRoaXMuX3RpbWVsaW5lICYmICF0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSAtIHRoaXMuX3RvdGFsVGltZSA6IHRoaXMuX3RvdGFsVGltZSksIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucGF1c2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGF1c2VkO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRsID0gdGhpcy5fdGltZWxpbmUsXG5cdFx0XHRcdHJhdywgZWxhcHNlZDtcblx0XHRcdGlmICh2YWx1ZSAhPSB0aGlzLl9wYXVzZWQpIGlmICh0bCkge1xuXHRcdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUgJiYgIXZhbHVlKSB7XG5cdFx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmF3ID0gdGwucmF3VGltZSgpO1xuXHRcdFx0XHRlbGFwc2VkID0gcmF3IC0gdGhpcy5fcGF1c2VUaW1lO1xuXHRcdFx0XHRpZiAoIXZhbHVlICYmIHRsLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lICs9IGVsYXBzZWQ7XG5cdFx0XHRcdFx0dGhpcy5fdW5jYWNoZShmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcGF1c2VUaW1lID0gdmFsdWUgPyByYXcgOiBudWxsO1xuXHRcdFx0XHR0aGlzLl9wYXVzZWQgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdGhpcy5pc0FjdGl2ZSgpO1xuXHRcdFx0XHRpZiAoIXZhbHVlICYmIGVsYXBzZWQgIT09IDAgJiYgdGhpcy5faW5pdHRlZCAmJiB0aGlzLmR1cmF0aW9uKCkpIHtcblx0XHRcdFx0XHRyYXcgPSB0bC5zbW9vdGhDaGlsZFRpbWluZyA/IHRoaXMuX3RvdGFsVGltZSA6IChyYXcgLSB0aGlzLl9zdGFydFRpbWUpIC8gdGhpcy5fdGltZVNjYWxlO1xuXHRcdFx0XHRcdHRoaXMucmVuZGVyKHJhdywgKHJhdyA9PT0gdGhpcy5fdG90YWxUaW1lKSwgdHJ1ZSk7IC8vaW4gY2FzZSB0aGUgdGFyZ2V0J3MgcHJvcGVydGllcyBjaGFuZ2VkIHZpYSBzb21lIG90aGVyIHR3ZWVuIG9yIG1hbnVhbCB1cGRhdGUgYnkgdGhlIHVzZXIsIHdlIHNob3VsZCBmb3JjZSBhIHJlbmRlci5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2djICYmICF2YWx1ZSkge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFNpbXBsZVRpbWVsaW5lXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgU2ltcGxlVGltZWxpbmUgPSBfY2xhc3MoXCJjb3JlLlNpbXBsZVRpbWVsaW5lXCIsIGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdEFuaW1hdGlvbi5jYWxsKHRoaXMsIDAsIHZhcnMpO1xuXHRcdFx0dGhpcy5hdXRvUmVtb3ZlQ2hpbGRyZW4gPSB0aGlzLnNtb290aENoaWxkVGltaW5nID0gdHJ1ZTtcblx0XHR9KTtcblxuXHRcdHAgPSBTaW1wbGVUaW1lbGluZS5wcm90b3R5cGUgPSBuZXcgQW5pbWF0aW9uKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFNpbXBsZVRpbWVsaW5lO1xuXHRcdHAua2lsbCgpLl9nYyA9IGZhbHNlO1xuXHRcdHAuX2ZpcnN0ID0gcC5fbGFzdCA9IHAuX3JlY2VudCA9IG51bGw7XG5cdFx0cC5fc29ydENoaWxkcmVuID0gZmFsc2U7XG5cblx0XHRwLmFkZCA9IHAuaW5zZXJ0ID0gZnVuY3Rpb24oY2hpbGQsIHBvc2l0aW9uLCBhbGlnbiwgc3RhZ2dlcikge1xuXHRcdFx0dmFyIHByZXZUd2Vlbiwgc3Q7XG5cdFx0XHRjaGlsZC5fc3RhcnRUaW1lID0gTnVtYmVyKHBvc2l0aW9uIHx8IDApICsgY2hpbGQuX2RlbGF5O1xuXHRcdFx0aWYgKGNoaWxkLl9wYXVzZWQpIGlmICh0aGlzICE9PSBjaGlsZC5fdGltZWxpbmUpIHsgLy93ZSBvbmx5IGFkanVzdCB0aGUgX3BhdXNlVGltZSBpZiBpdCB3YXNuJ3QgaW4gdGhpcyB0aW1lbGluZSBhbHJlYWR5LiBSZW1lbWJlciwgc29tZXRpbWVzIGEgdHdlZW4gd2lsbCBiZSBpbnNlcnRlZCBhZ2FpbiBpbnRvIHRoZSBzYW1lIHRpbWVsaW5lIHdoZW4gaXRzIHN0YXJ0VGltZSBpcyBjaGFuZ2VkIHNvIHRoYXQgdGhlIHR3ZWVucyBpbiB0aGUgVGltZWxpbmVMaXRlL01heCBhcmUgcmUtb3JkZXJlZCBwcm9wZXJseSBpbiB0aGUgbGlua2VkIGxpc3QgKHNvIGV2ZXJ5dGhpbmcgcmVuZGVycyBpbiB0aGUgcHJvcGVyIG9yZGVyKS5cblx0XHRcdFx0Y2hpbGQuX3BhdXNlVGltZSA9IHRoaXMucmF3VGltZSgpIC0gKGNoaWxkLl90aW1lbGluZS5yYXdUaW1lKCkgLSBjaGlsZC5fcGF1c2VUaW1lKTtcblx0XHRcdH1cblx0XHRcdGlmIChjaGlsZC50aW1lbGluZSkge1xuXHRcdFx0XHRjaGlsZC50aW1lbGluZS5fcmVtb3ZlKGNoaWxkLCB0cnVlKTsgLy9yZW1vdmVzIGZyb20gZXhpc3RpbmcgdGltZWxpbmUgc28gdGhhdCBpdCBjYW4gYmUgcHJvcGVybHkgYWRkZWQgdG8gdGhpcyBvbmUuXG5cdFx0XHR9XG5cdFx0XHRjaGlsZC50aW1lbGluZSA9IGNoaWxkLl90aW1lbGluZSA9IHRoaXM7XG5cdFx0XHRpZiAoY2hpbGQuX2djKSB7XG5cdFx0XHRcdGNoaWxkLl9lbmFibGVkKHRydWUsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cHJldlR3ZWVuID0gdGhpcy5fbGFzdDtcblx0XHRcdGlmICh0aGlzLl9zb3J0Q2hpbGRyZW4pIHtcblx0XHRcdFx0c3QgPSBjaGlsZC5fc3RhcnRUaW1lO1xuXHRcdFx0XHR3aGlsZSAocHJldlR3ZWVuICYmIHByZXZUd2Vlbi5fc3RhcnRUaW1lID4gc3QpIHtcblx0XHRcdFx0XHRwcmV2VHdlZW4gPSBwcmV2VHdlZW4uX3ByZXY7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChwcmV2VHdlZW4pIHtcblx0XHRcdFx0Y2hpbGQuX25leHQgPSBwcmV2VHdlZW4uX25leHQ7XG5cdFx0XHRcdHByZXZUd2Vlbi5fbmV4dCA9IGNoaWxkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hpbGQuX25leHQgPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0dGhpcy5fZmlyc3QgPSBjaGlsZDtcblx0XHRcdH1cblx0XHRcdGlmIChjaGlsZC5fbmV4dCkge1xuXHRcdFx0XHRjaGlsZC5fbmV4dC5fcHJldiA9IGNoaWxkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fbGFzdCA9IGNoaWxkO1xuXHRcdFx0fVxuXHRcdFx0Y2hpbGQuX3ByZXYgPSBwcmV2VHdlZW47XG5cdFx0XHR0aGlzLl9yZWNlbnQgPSBjaGlsZDtcblx0XHRcdGlmICh0aGlzLl90aW1lbGluZSkge1xuXHRcdFx0XHR0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuX3JlbW92ZSA9IGZ1bmN0aW9uKHR3ZWVuLCBza2lwRGlzYWJsZSkge1xuXHRcdFx0aWYgKHR3ZWVuLnRpbWVsaW5lID09PSB0aGlzKSB7XG5cdFx0XHRcdGlmICghc2tpcERpc2FibGUpIHtcblx0XHRcdFx0XHR0d2Vlbi5fZW5hYmxlZChmYWxzZSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodHdlZW4uX3ByZXYpIHtcblx0XHRcdFx0XHR0d2Vlbi5fcHJldi5fbmV4dCA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2ZpcnN0ID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0ID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR3ZWVuLl9uZXh0KSB7XG5cdFx0XHRcdFx0dHdlZW4uX25leHQuX3ByZXYgPSB0d2Vlbi5fcHJldjtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9sYXN0ID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdHRoaXMuX2xhc3QgPSB0d2Vlbi5fcHJldjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0d2Vlbi5fbmV4dCA9IHR3ZWVuLl9wcmV2ID0gdHdlZW4udGltZWxpbmUgPSBudWxsO1xuXHRcdFx0XHRpZiAodHdlZW4gPT09IHRoaXMuX3JlY2VudCkge1xuXHRcdFx0XHRcdHRoaXMuX3JlY2VudCA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHR0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0LFxuXHRcdFx0XHRuZXh0O1xuXHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRuZXh0ID0gdHdlZW4uX25leHQ7IC8vcmVjb3JkIGl0IGhlcmUgYmVjYXVzZSB0aGUgdmFsdWUgY291bGQgY2hhbmdlIGFmdGVyIHJlbmRlcmluZy4uLlxuXHRcdFx0XHRpZiAodHdlZW4uX2FjdGl2ZSB8fCAodGltZSA+PSB0d2Vlbi5fc3RhcnRUaW1lICYmICF0d2Vlbi5fcGF1c2VkICYmICF0d2Vlbi5fZ2MpKSB7XG5cdFx0XHRcdFx0aWYgKCF0d2Vlbi5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCgoIXR3ZWVuLl9kaXJ0eSkgPyB0d2Vlbi5fdG90YWxEdXJhdGlvbiA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSkgLSAoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAucmF3VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7XG5cdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3RvdGFsVGltZTtcblx0XHR9O1xuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVHdlZW5MaXRlXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgVHdlZW5MaXRlID0gX2NsYXNzKFwiVHdlZW5MaXRlXCIsIGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdFx0QW5pbWF0aW9uLmNhbGwodGhpcywgZHVyYXRpb24sIHZhcnMpO1xuXHRcdFx0XHR0aGlzLnJlbmRlciA9IFR3ZWVuTGl0ZS5wcm90b3R5cGUucmVuZGVyOyAvL3NwZWVkIG9wdGltaXphdGlvbiAoYXZvaWQgcHJvdG90eXBlIGxvb2t1cCBvbiB0aGlzIFwiaG90XCIgbWV0aG9kKVxuXG5cdFx0XHRcdGlmICh0YXJnZXQgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHRocm93IFwiQ2Fubm90IHR3ZWVuIGEgbnVsbCB0YXJnZXQuXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnRhcmdldCA9IHRhcmdldCA9ICh0eXBlb2YodGFyZ2V0KSAhPT0gXCJzdHJpbmdcIikgPyB0YXJnZXQgOiBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0KSB8fCB0YXJnZXQ7XG5cblx0XHRcdFx0dmFyIGlzU2VsZWN0b3IgPSAodGFyZ2V0LmpxdWVyeSB8fCAodGFyZ2V0Lmxlbmd0aCAmJiB0YXJnZXQgIT09IHdpbmRvdyAmJiB0YXJnZXRbMF0gJiYgKHRhcmdldFswXSA9PT0gd2luZG93IHx8ICh0YXJnZXRbMF0ubm9kZVR5cGUgJiYgdGFyZ2V0WzBdLnN0eWxlICYmICF0YXJnZXQubm9kZVR5cGUpKSkpLFxuXHRcdFx0XHRcdG92ZXJ3cml0ZSA9IHRoaXMudmFycy5vdmVyd3JpdGUsXG5cdFx0XHRcdFx0aSwgdGFyZywgdGFyZ2V0cztcblxuXHRcdFx0XHR0aGlzLl9vdmVyd3JpdGUgPSBvdmVyd3JpdGUgPSAob3ZlcndyaXRlID09IG51bGwpID8gX292ZXJ3cml0ZUxvb2t1cFtUd2VlbkxpdGUuZGVmYXVsdE92ZXJ3cml0ZV0gOiAodHlwZW9mKG92ZXJ3cml0ZSkgPT09IFwibnVtYmVyXCIpID8gb3ZlcndyaXRlID4+IDAgOiBfb3ZlcndyaXRlTG9va3VwW292ZXJ3cml0ZV07XG5cblx0XHRcdFx0aWYgKChpc1NlbGVjdG9yIHx8IHRhcmdldCBpbnN0YW5jZW9mIEFycmF5IHx8ICh0YXJnZXQucHVzaCAmJiBfaXNBcnJheSh0YXJnZXQpKSkgJiYgdHlwZW9mKHRhcmdldFswXSkgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHR0aGlzLl90YXJnZXRzID0gdGFyZ2V0cyA9IF9zbGljZSh0YXJnZXQpOyAgLy9kb24ndCB1c2UgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGFyZ2V0LCAwKSBiZWNhdXNlIHRoYXQgZG9lc24ndCB3b3JrIGluIElFOCB3aXRoIGEgTm9kZUxpc3QgdGhhdCdzIHJldHVybmVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwoKVxuXHRcdFx0XHRcdHRoaXMuX3Byb3BMb29rdXAgPSBbXTtcblx0XHRcdFx0XHR0aGlzLl9zaWJsaW5ncyA9IFtdO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR0YXJnID0gdGFyZ2V0c1tpXTtcblx0XHRcdFx0XHRcdGlmICghdGFyZykge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRzLnNwbGljZShpLS0sIDEpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHRhcmcpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmcgPSB0YXJnZXRzW2ktLV0gPSBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZyk7IC8vaW4gY2FzZSBpdCdzIGFuIGFycmF5IG9mIHN0cmluZ3Ncblx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZih0YXJnKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGkrMSwgMSk7IC8vdG8gYXZvaWQgYW4gZW5kbGVzcyBsb29wIChjYW4ndCBpbWFnaW5lIHdoeSB0aGUgc2VsZWN0b3Igd291bGQgcmV0dXJuIGEgc3RyaW5nLCBidXQganVzdCBpbiBjYXNlKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0YXJnLmxlbmd0aCAmJiB0YXJnICE9PSB3aW5kb3cgJiYgdGFyZ1swXSAmJiAodGFyZ1swXSA9PT0gd2luZG93IHx8ICh0YXJnWzBdLm5vZGVUeXBlICYmIHRhcmdbMF0uc3R5bGUgJiYgIXRhcmcubm9kZVR5cGUpKSkgeyAvL2luIGNhc2UgdGhlIHVzZXIgaXMgcGFzc2luZyBpbiBhbiBhcnJheSBvZiBzZWxlY3RvciBvYmplY3RzIChsaWtlIGpRdWVyeSBvYmplY3RzKSwgd2UgbmVlZCB0byBjaGVjayBvbmUgbW9yZSBsZXZlbCBhbmQgcHVsbCB0aGluZ3Mgb3V0IGlmIG5lY2Vzc2FyeS4gQWxzbyBub3RlIHRoYXQgPHNlbGVjdD4gZWxlbWVudHMgcGFzcyBhbGwgdGhlIGNyaXRlcmlhIHJlZ2FyZGluZyBsZW5ndGggYW5kIHRoZSBmaXJzdCBjaGlsZCBoYXZpbmcgc3R5bGUsIHNvIHdlIG11c3QgYWxzbyBjaGVjayB0byBlbnN1cmUgdGhlIHRhcmdldCBpc24ndCBhbiBIVE1MIG5vZGUgaXRzZWxmLlxuXHRcdFx0XHRcdFx0XHR0YXJnZXRzLnNwbGljZShpLS0sIDEpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl90YXJnZXRzID0gdGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KF9zbGljZSh0YXJnKSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fc2libGluZ3NbaV0gPSBfcmVnaXN0ZXIodGFyZywgdGhpcywgZmFsc2UpO1xuXHRcdFx0XHRcdFx0aWYgKG92ZXJ3cml0ZSA9PT0gMSkgaWYgKHRoaXMuX3NpYmxpbmdzW2ldLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRcdFx0X2FwcGx5T3ZlcndyaXRlKHRhcmcsIHRoaXMsIG51bGwsIDEsIHRoaXMuX3NpYmxpbmdzW2ldKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9wcm9wTG9va3VwID0ge307XG5cdFx0XHRcdFx0dGhpcy5fc2libGluZ3MgPSBfcmVnaXN0ZXIodGFyZ2V0LCB0aGlzLCBmYWxzZSk7XG5cdFx0XHRcdFx0aWYgKG92ZXJ3cml0ZSA9PT0gMSkgaWYgKHRoaXMuX3NpYmxpbmdzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRcdF9hcHBseU92ZXJ3cml0ZSh0YXJnZXQsIHRoaXMsIG51bGwsIDEsIHRoaXMuX3NpYmxpbmdzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIgfHwgKGR1cmF0aW9uID09PSAwICYmIHRoaXMuX2RlbGF5ID09PSAwICYmIHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIgIT09IGZhbHNlKSkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSAtX3RpbnlOdW07IC8vZm9yY2VzIGEgcmVuZGVyIHdpdGhvdXQgaGF2aW5nIHRvIHNldCB0aGUgcmVuZGVyKCkgXCJmb3JjZVwiIHBhcmFtZXRlciB0byB0cnVlIGJlY2F1c2Ugd2Ugd2FudCB0byBhbGxvdyBsYXp5aW5nIGJ5IGRlZmF1bHQgKHVzaW5nIHRoZSBcImZvcmNlXCIgcGFyYW1ldGVyIGFsd2F5cyBmb3JjZXMgYW4gaW1tZWRpYXRlIGZ1bGwgcmVuZGVyKVxuXHRcdFx0XHRcdHRoaXMucmVuZGVyKE1hdGgubWluKDAsIC10aGlzLl9kZWxheSkpOyAvL2luIGNhc2UgZGVsYXkgaXMgbmVnYXRpdmVcblx0XHRcdFx0fVxuXHRcdFx0fSwgdHJ1ZSksXG5cdFx0XHRfaXNTZWxlY3RvciA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0cmV0dXJuICh2ICYmIHYubGVuZ3RoICYmIHYgIT09IHdpbmRvdyAmJiB2WzBdICYmICh2WzBdID09PSB3aW5kb3cgfHwgKHZbMF0ubm9kZVR5cGUgJiYgdlswXS5zdHlsZSAmJiAhdi5ub2RlVHlwZSkpKTsgLy93ZSBjYW5ub3QgY2hlY2sgXCJub2RlVHlwZVwiIGlmIHRoZSB0YXJnZXQgaXMgd2luZG93IGZyb20gd2l0aGluIGFuIGlmcmFtZSwgb3RoZXJ3aXNlIGl0IHdpbGwgdHJpZ2dlciBhIHNlY3VyaXR5IGVycm9yIGluIHNvbWUgYnJvd3NlcnMgbGlrZSBGaXJlZm94LlxuXHRcdFx0fSxcblx0XHRcdF9hdXRvQ1NTID0gZnVuY3Rpb24odmFycywgdGFyZ2V0KSB7XG5cdFx0XHRcdHZhciBjc3MgPSB7fSxcblx0XHRcdFx0XHRwO1xuXHRcdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRcdGlmICghX3Jlc2VydmVkUHJvcHNbcF0gJiYgKCEocCBpbiB0YXJnZXQpIHx8IHAgPT09IFwidHJhbnNmb3JtXCIgfHwgcCA9PT0gXCJ4XCIgfHwgcCA9PT0gXCJ5XCIgfHwgcCA9PT0gXCJ3aWR0aFwiIHx8IHAgPT09IFwiaGVpZ2h0XCIgfHwgcCA9PT0gXCJjbGFzc05hbWVcIiB8fCBwID09PSBcImJvcmRlclwiKSAmJiAoIV9wbHVnaW5zW3BdIHx8IChfcGx1Z2luc1twXSAmJiBfcGx1Z2luc1twXS5fYXV0b0NTUykpKSB7IC8vbm90ZTogPGltZz4gZWxlbWVudHMgY29udGFpbiByZWFkLW9ubHkgXCJ4XCIgYW5kIFwieVwiIHByb3BlcnRpZXMuIFdlIHNob3VsZCBhbHNvIHByaW9yaXRpemUgZWRpdGluZyBjc3Mgd2lkdGgvaGVpZ2h0IHJhdGhlciB0aGFuIHRoZSBlbGVtZW50J3MgcHJvcGVydGllcy5cblx0XHRcdFx0XHRcdGNzc1twXSA9IHZhcnNbcF07XG5cdFx0XHRcdFx0XHRkZWxldGUgdmFyc1twXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFycy5jc3MgPSBjc3M7XG5cdFx0XHR9O1xuXG5cdFx0cCA9IFR3ZWVuTGl0ZS5wcm90b3R5cGUgPSBuZXcgQW5pbWF0aW9uKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFR3ZWVuTGl0ZTtcblx0XHRwLmtpbGwoKS5fZ2MgPSBmYWxzZTtcblxuLy8tLS0tVHdlZW5MaXRlIGRlZmF1bHRzLCBvdmVyd3JpdGUgbWFuYWdlbWVudCwgYW5kIHJvb3QgdXBkYXRlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRwLnJhdGlvID0gMDtcblx0XHRwLl9maXJzdFBUID0gcC5fdGFyZ2V0cyA9IHAuX292ZXJ3cml0dGVuUHJvcHMgPSBwLl9zdGFydEF0ID0gbnVsbDtcblx0XHRwLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkID0gcC5fbGF6eSA9IGZhbHNlO1xuXG5cdFx0VHdlZW5MaXRlLnZlcnNpb24gPSBcIjIuMC4yXCI7XG5cdFx0VHdlZW5MaXRlLmRlZmF1bHRFYXNlID0gcC5fZWFzZSA9IG5ldyBFYXNlKG51bGwsIG51bGwsIDEsIDEpO1xuXHRcdFR3ZWVuTGl0ZS5kZWZhdWx0T3ZlcndyaXRlID0gXCJhdXRvXCI7XG5cdFx0VHdlZW5MaXRlLnRpY2tlciA9IF90aWNrZXI7XG5cdFx0VHdlZW5MaXRlLmF1dG9TbGVlcCA9IDEyMDtcblx0XHRUd2VlbkxpdGUubGFnU21vb3RoaW5nID0gZnVuY3Rpb24odGhyZXNob2xkLCBhZGp1c3RlZExhZykge1xuXHRcdFx0X3RpY2tlci5sYWdTbW9vdGhpbmcodGhyZXNob2xkLCBhZGp1c3RlZExhZyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5zZWxlY3RvciA9IHdpbmRvdy4kIHx8IHdpbmRvdy5qUXVlcnkgfHwgZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHNlbGVjdG9yID0gd2luZG93LiQgfHwgd2luZG93LmpRdWVyeTtcblx0XHRcdGlmIChzZWxlY3Rvcikge1xuXHRcdFx0XHRUd2VlbkxpdGUuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0cmV0dXJuIHNlbGVjdG9yKGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFfZG9jKSB7IC8vaW4gc29tZSBkZXYgZW52aXJvbm1lbnRzIChsaWtlIEFuZ3VsYXIgNiksIEdTQVAgZ2V0cyBsb2FkZWQgYmVmb3JlIHRoZSBkb2N1bWVudCBpcyBkZWZpbmVkISBTbyByZS1xdWVyeSBpdCBoZXJlIGlmL3doZW4gbmVjZXNzYXJ5LlxuXHRcdFx0XHRfZG9jID0gd2luZG93LmRvY3VtZW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICghX2RvYykgPyBlIDogKF9kb2MucXVlcnlTZWxlY3RvckFsbCA/IF9kb2MucXVlcnlTZWxlY3RvckFsbChlKSA6IF9kb2MuZ2V0RWxlbWVudEJ5SWQoKGUuY2hhckF0KDApID09PSBcIiNcIikgPyBlLnN1YnN0cigxKSA6IGUpKTtcblx0XHR9O1xuXG5cdFx0dmFyIF9sYXp5VHdlZW5zID0gW10sXG5cdFx0XHRfbGF6eUxvb2t1cCA9IHt9LFxuXHRcdFx0X251bWJlcnNFeHAgPSAvKD86KC18LT18XFwrPSk/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT8pWzAtOV0vaWcsXG5cdFx0XHRfcmVsRXhwID0gL1tcXCstXT0tP1tcXC5cXGRdLyxcblx0XHRcdC8vX25vbk51bWJlcnNFeHAgPSAvKD86KFtcXC0rXSg/IShcXGR8PSkpKXxbXlxcZFxcLSs9ZV18KGUoPyFbXFwtK11bXFxkXSkpKSsvaWcsXG5cdFx0XHRfc2V0UmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciBwdCA9IHRoaXMuX2ZpcnN0UFQsXG5cdFx0XHRcdFx0bWluID0gMC4wMDAwMDEsXG5cdFx0XHRcdFx0dmFsO1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHR2YWwgPSAhcHQuYmxvYiA/IHB0LmMgKiB2ICsgcHQucyA6ICh2ID09PSAxICYmIHRoaXMuZW5kICE9IG51bGwpID8gdGhpcy5lbmQgOiB2ID8gdGhpcy5qb2luKFwiXCIpIDogdGhpcy5zdGFydDtcblx0XHRcdFx0XHRpZiAocHQubSkge1xuXHRcdFx0XHRcdFx0dmFsID0gcHQubS5jYWxsKHRoaXMuX3R3ZWVuLCB2YWwsIHRoaXMuX3RhcmdldCB8fCBwdC50LCB0aGlzLl90d2Vlbik7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWwgPCBtaW4pIGlmICh2YWwgPiAtbWluICYmICFwdC5ibG9iKSB7IC8vcHJldmVudHMgaXNzdWVzIHdpdGggY29udmVydGluZyB2ZXJ5IHNtYWxsIG51bWJlcnMgdG8gc3RyaW5ncyBpbiB0aGUgYnJvd3NlclxuXHRcdFx0XHRcdFx0dmFsID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFwdC5mKSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gdmFsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHQuZnApIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0ocHQuZnAsIHZhbCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0odmFsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8vY29tcGFyZXMgdHdvIHN0cmluZ3MgKHN0YXJ0L2VuZCksIGZpbmRzIHRoZSBudW1iZXJzIHRoYXQgYXJlIGRpZmZlcmVudCBhbmQgc3BpdHMgYmFjayBhbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIHdob2xlIHZhbHVlIGJ1dCB3aXRoIHRoZSBjaGFuZ2luZyB2YWx1ZXMgaXNvbGF0ZWQgYXMgZWxlbWVudHMuIEZvciBleGFtcGxlLCBcInJnYigwLDAsMClcIiBhbmQgXCJyZ2IoMTAwLDUwLDApXCIgd291bGQgYmVjb21lIFtcInJnYihcIiwgMCwgXCIsXCIsIDUwLCBcIiwwKVwiXS4gTm90aWNlIGl0IG1lcmdlcyB0aGUgcGFydHMgdGhhdCBhcmUgaWRlbnRpY2FsIChwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pLiBUaGUgYXJyYXkgYWxzbyBoYXMgYSBsaW5rZWQgbGlzdCBvZiBQcm9wVHdlZW5zIGF0dGFjaGVkIHN0YXJ0aW5nIHdpdGggX2ZpcnN0UFQgdGhhdCBjb250YWluIHRoZSB0d2VlbmluZyBkYXRhICh0LCBwLCBzLCBjLCBmLCBldGMuKS4gSXQgYWxzbyBzdG9yZXMgdGhlIHN0YXJ0aW5nIHZhbHVlIGFzIGEgXCJzdGFydFwiIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIHJldmVydCB0byBpdCBpZi93aGVuIG5lY2Vzc2FyeSwgbGlrZSB3aGVuIGEgdHdlZW4gcmV3aW5kcyBmdWxseS4gSWYgdGhlIHF1YW50aXR5IG9mIG51bWJlcnMgZGlmZmVycyBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kLCBpdCB3aWxsIGFsd2F5cyBwcmlvcml0aXplIHRoZSBlbmQgdmFsdWUocykuIFRoZSBwdCBwYXJhbWV0ZXIgaXMgb3B0aW9uYWwgLSBpdCdzIGZvciBhIFByb3BUd2VlbiB0aGF0IHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgbGlua2VkIGxpc3QgYW5kIGlzIHR5cGljYWxseSBmb3IgYWN0dWFsbHkgc2V0dGluZyB0aGUgdmFsdWUgYWZ0ZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBoYXZlIGJlZW4gdXBkYXRlZCAod2l0aCBhcnJheS5qb2luKFwiXCIpKS5cblx0XHRcdF9ibG9iRGlmID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgZmlsdGVyLCBwdCkge1xuXHRcdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHRcdGNoYXJJbmRleCA9IDAsXG5cdFx0XHRcdFx0cyA9IFwiXCIsXG5cdFx0XHRcdFx0Y29sb3IgPSAwLFxuXHRcdFx0XHRcdHN0YXJ0TnVtcywgZW5kTnVtcywgbnVtLCBpLCBsLCBub25OdW1iZXJzLCBjdXJyZW50TnVtO1xuXHRcdFx0XHRhLnN0YXJ0ID0gc3RhcnQ7XG5cdFx0XHRcdGEuZW5kID0gZW5kO1xuXHRcdFx0XHRzdGFydCA9IGFbMF0gPSBzdGFydCArIFwiXCI7IC8vZW5zdXJlIHZhbHVlcyBhcmUgc3RyaW5nc1xuXHRcdFx0XHRlbmQgPSBhWzFdID0gZW5kICsgXCJcIjtcblx0XHRcdFx0aWYgKGZpbHRlcikge1xuXHRcdFx0XHRcdGZpbHRlcihhKTsgLy9wYXNzIGFuIGFycmF5IHdpdGggdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIGFuZCBsZXQgdGhlIGZpbHRlciBkbyB3aGF0ZXZlciBpdCBuZWVkcyB0byB0aGUgdmFsdWVzLlxuXHRcdFx0XHRcdHN0YXJ0ID0gYVswXTtcblx0XHRcdFx0XHRlbmQgPSBhWzFdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGEubGVuZ3RoID0gMDtcblx0XHRcdFx0c3RhcnROdW1zID0gc3RhcnQubWF0Y2goX251bWJlcnNFeHApIHx8IFtdO1xuXHRcdFx0XHRlbmROdW1zID0gZW5kLm1hdGNoKF9udW1iZXJzRXhwKSB8fCBbXTtcblx0XHRcdFx0aWYgKHB0KSB7XG5cdFx0XHRcdFx0cHQuX25leHQgPSBudWxsO1xuXHRcdFx0XHRcdHB0LmJsb2IgPSAxO1xuXHRcdFx0XHRcdGEuX2ZpcnN0UFQgPSBhLl9hcHBseVBUID0gcHQ7IC8vYXBwbHkgbGFzdCBpbiB0aGUgbGlua2VkIGxpc3QgKHdoaWNoIG1lYW5zIGluc2VydGluZyBpdCBmaXJzdClcblx0XHRcdFx0fVxuXHRcdFx0XHRsID0gZW5kTnVtcy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRjdXJyZW50TnVtID0gZW5kTnVtc1tpXTtcblx0XHRcdFx0XHRub25OdW1iZXJzID0gZW5kLnN1YnN0cihjaGFySW5kZXgsIGVuZC5pbmRleE9mKGN1cnJlbnROdW0sIGNoYXJJbmRleCktY2hhckluZGV4KTtcblx0XHRcdFx0XHRzICs9IChub25OdW1iZXJzIHx8ICFpKSA/IG5vbk51bWJlcnMgOiBcIixcIjsgLy9ub3RlOiBTVkcgc3BlYyBhbGxvd3Mgb21pc3Npb24gb2YgY29tbWEvc3BhY2Ugd2hlbiBhIG5lZ2F0aXZlIHNpZ24gaXMgd2VkZ2VkIGJldHdlZW4gdHdvIG51bWJlcnMsIGxpa2UgMi41LTUuMyBpbnN0ZWFkIG9mIDIuNSwtNS4zIGJ1dCB3aGVuIHR3ZWVuaW5nLCB0aGUgbmVnYXRpdmUgdmFsdWUgbWF5IHN3aXRjaCB0byBwb3NpdGl2ZSwgc28gd2UgaW5zZXJ0IHRoZSBjb21tYSBqdXN0IGluIGNhc2UuXG5cdFx0XHRcdFx0Y2hhckluZGV4ICs9IG5vbk51bWJlcnMubGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChjb2xvcikgeyAvL3NlbnNlIHJnYmEoKSB2YWx1ZXMgYW5kIHJvdW5kIHRoZW0uXG5cdFx0XHRcdFx0XHRjb2xvciA9IChjb2xvciArIDEpICUgNTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG5vbk51bWJlcnMuc3Vic3RyKC01KSA9PT0gXCJyZ2JhKFwiKSB7XG5cdFx0XHRcdFx0XHRjb2xvciA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChjdXJyZW50TnVtID09PSBzdGFydE51bXNbaV0gfHwgc3RhcnROdW1zLmxlbmd0aCA8PSBpKSB7XG5cdFx0XHRcdFx0XHRzICs9IGN1cnJlbnROdW07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChzKSB7XG5cdFx0XHRcdFx0XHRcdGEucHVzaChzKTtcblx0XHRcdFx0XHRcdFx0cyA9IFwiXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRudW0gPSBwYXJzZUZsb2F0KHN0YXJ0TnVtc1tpXSk7XG5cdFx0XHRcdFx0XHRhLnB1c2gobnVtKTtcblx0XHRcdFx0XHRcdGEuX2ZpcnN0UFQgPSB7X25leHQ6IGEuX2ZpcnN0UFQsIHQ6YSwgcDogYS5sZW5ndGgtMSwgczpudW0sIGM6KChjdXJyZW50TnVtLmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gcGFyc2VJbnQoY3VycmVudE51bS5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogcGFyc2VGbG9hdChjdXJyZW50TnVtLnN1YnN0cigyKSkgOiAocGFyc2VGbG9hdChjdXJyZW50TnVtKSAtIG51bSkpIHx8IDAsIGY6MCwgbTooY29sb3IgJiYgY29sb3IgPCA0KSA/IE1hdGgucm91bmQgOiAwfTtcblx0XHRcdFx0XHRcdC8vbm90ZTogd2UgZG9uJ3Qgc2V0IF9wcmV2IGJlY2F1c2Ugd2UnbGwgbmV2ZXIgbmVlZCB0byByZW1vdmUgaW5kaXZpZHVhbCBQcm9wVHdlZW5zIGZyb20gdGhpcyBsaXN0LlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjaGFySW5kZXggKz0gY3VycmVudE51bS5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0cyArPSBlbmQuc3Vic3RyKGNoYXJJbmRleCk7XG5cdFx0XHRcdGlmIChzKSB7XG5cdFx0XHRcdFx0YS5wdXNoKHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGEuc2V0UmF0aW8gPSBfc2V0UmF0aW87XG5cdFx0XHRcdGlmIChfcmVsRXhwLnRlc3QoZW5kKSkgeyAvL2lmIHRoZSBlbmQgc3RyaW5nIGNvbnRhaW5zIHJlbGF0aXZlIHZhbHVlcywgZGVsZXRlIGl0IHNvIHRoYXQgb24gdGhlIGZpbmFsIHJlbmRlciAoaW4gX3NldFJhdGlvKCkpLCB3ZSBkb24ndCBhY3R1YWxseSBzZXQgaXQgdG8gdGhlIHN0cmluZyB3aXRoICs9IG9yIC09IGNoYXJhY3RlcnMgKGZvcmNlcyBpdCB0byB1c2UgdGhlIGNhbGN1bGF0ZWQgdmFsdWUpLlxuXHRcdFx0XHRcdGEuZW5kID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdH0sXG5cdFx0XHQvL25vdGU6IFwiZnVuY1BhcmFtXCIgaXMgb25seSBuZWNlc3NhcnkgZm9yIGZ1bmN0aW9uLWJhc2VkIGdldHRlcnMvc2V0dGVycyB0aGF0IHJlcXVpcmUgYW4gZXh0cmEgcGFyYW1ldGVyIGxpa2UgZ2V0QXR0cmlidXRlKFwid2lkdGhcIikgYW5kIHNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHZhbHVlKS4gSW4gdGhpcyBleGFtcGxlLCBmdW5jUGFyYW0gd291bGQgYmUgXCJ3aWR0aFwiLiBVc2VkIGJ5IEF0dHJQbHVnaW4gZm9yIGV4YW1wbGUuXG5cdFx0XHRfYWRkUHJvcFR3ZWVuID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBvdmVyd3JpdGVQcm9wLCBtb2QsIGZ1bmNQYXJhbSwgc3RyaW5nRmlsdGVyLCBpbmRleCkge1xuXHRcdFx0XHRpZiAodHlwZW9mKGVuZCkgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGVuZCA9IGVuZChpbmRleCB8fCAwLCB0YXJnZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciB0eXBlID0gdHlwZW9mKHRhcmdldFtwcm9wXSksXG5cdFx0XHRcdFx0Z2V0dGVyTmFtZSA9ICh0eXBlICE9PSBcImZ1bmN0aW9uXCIpID8gXCJcIiA6ICgocHJvcC5pbmRleE9mKFwic2V0XCIpIHx8IHR5cGVvZih0YXJnZXRbXCJnZXRcIiArIHByb3Auc3Vic3RyKDMpXSkgIT09IFwiZnVuY3Rpb25cIikgPyBwcm9wIDogXCJnZXRcIiArIHByb3Auc3Vic3RyKDMpKSxcblx0XHRcdFx0XHRzID0gKHN0YXJ0ICE9PSBcImdldFwiKSA/IHN0YXJ0IDogIWdldHRlck5hbWUgPyB0YXJnZXRbcHJvcF0gOiBmdW5jUGFyYW0gPyB0YXJnZXRbZ2V0dGVyTmFtZV0oZnVuY1BhcmFtKSA6IHRhcmdldFtnZXR0ZXJOYW1lXSgpLFxuXHRcdFx0XHRcdGlzUmVsYXRpdmUgPSAodHlwZW9mKGVuZCkgPT09IFwic3RyaW5nXCIgJiYgZW5kLmNoYXJBdCgxKSA9PT0gXCI9XCIpLFxuXHRcdFx0XHRcdHB0ID0ge3Q6dGFyZ2V0LCBwOnByb3AsIHM6cywgZjoodHlwZSA9PT0gXCJmdW5jdGlvblwiKSwgcGc6MCwgbjpvdmVyd3JpdGVQcm9wIHx8IHByb3AsIG06KCFtb2QgPyAwIDogKHR5cGVvZihtb2QpID09PSBcImZ1bmN0aW9uXCIpID8gbW9kIDogTWF0aC5yb3VuZCksIHByOjAsIGM6aXNSZWxhdGl2ZSA/IHBhcnNlSW50KGVuZC5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogcGFyc2VGbG9hdChlbmQuc3Vic3RyKDIpKSA6IChwYXJzZUZsb2F0KGVuZCkgLSBzKSB8fCAwfSxcblx0XHRcdFx0XHRibG9iO1xuXG5cdFx0XHRcdGlmICh0eXBlb2YocykgIT09IFwibnVtYmVyXCIgfHwgKHR5cGVvZihlbmQpICE9PSBcIm51bWJlclwiICYmICFpc1JlbGF0aXZlKSkge1xuXHRcdFx0XHRcdGlmIChmdW5jUGFyYW0gfHwgaXNOYU4ocykgfHwgKCFpc1JlbGF0aXZlICYmIGlzTmFOKGVuZCkpIHx8IHR5cGVvZihzKSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZW9mKGVuZCkgPT09IFwiYm9vbGVhblwiKSB7XG5cdFx0XHRcdFx0XHQvL2EgYmxvYiAoc3RyaW5nIHRoYXQgaGFzIG11bHRpcGxlIG51bWJlcnMgaW4gaXQpXG5cdFx0XHRcdFx0XHRwdC5mcCA9IGZ1bmNQYXJhbTtcblx0XHRcdFx0XHRcdGJsb2IgPSBfYmxvYkRpZihzLCAoaXNSZWxhdGl2ZSA/IChwYXJzZUZsb2F0KHB0LnMpICsgcHQuYykgKyAocHQucyArIFwiXCIpLnJlcGxhY2UoL1swLTlcXC1cXC5dL2csIFwiXCIpIDogZW5kKSwgc3RyaW5nRmlsdGVyIHx8IFR3ZWVuTGl0ZS5kZWZhdWx0U3RyaW5nRmlsdGVyLCBwdCk7XG5cdFx0XHRcdFx0XHRwdCA9IHt0OiBibG9iLCBwOiBcInNldFJhdGlvXCIsIHM6IDAsIGM6IDEsIGY6IDIsIHBnOiAwLCBuOiBvdmVyd3JpdGVQcm9wIHx8IHByb3AsIHByOiAwLCBtOiAwfTsgLy9cIjJcIiBpbmRpY2F0ZXMgaXQncyBhIEJsb2IgcHJvcGVydHkgdHdlZW4uIE5lZWRlZCBmb3IgUm91bmRQcm9wc1BsdWdpbiBmb3IgZXhhbXBsZS5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQucyA9IHBhcnNlRmxvYXQocyk7XG5cdFx0XHRcdFx0XHRpZiAoIWlzUmVsYXRpdmUpIHtcblx0XHRcdFx0XHRcdFx0cHQuYyA9IChwYXJzZUZsb2F0KGVuZCkgLSBwdC5zKSB8fCAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHQuYykgeyAvL29ubHkgYWRkIGl0IHRvIHRoZSBsaW5rZWQgbGlzdCBpZiB0aGVyZSdzIGEgY2hhbmdlLlxuXHRcdFx0XHRcdGlmICgocHQuX25leHQgPSB0aGlzLl9maXJzdFBUKSkge1xuXHRcdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0O1xuXHRcdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF9pbnRlcm5hbHMgPSBUd2VlbkxpdGUuX2ludGVybmFscyA9IHtpc0FycmF5Ol9pc0FycmF5LCBpc1NlbGVjdG9yOl9pc1NlbGVjdG9yLCBsYXp5VHdlZW5zOl9sYXp5VHdlZW5zLCBibG9iRGlmOl9ibG9iRGlmfSwgLy9naXZlcyB1cyBhIHdheSB0byBleHBvc2UgY2VydGFpbiBwcml2YXRlIHZhbHVlcyB0byBvdGhlciBHcmVlblNvY2sgY2xhc3NlcyB3aXRob3V0IGNvbnRhbWluYXRpbmcgdGhhIG1haW4gVHdlZW5MaXRlIG9iamVjdC5cblx0XHRcdF9wbHVnaW5zID0gVHdlZW5MaXRlLl9wbHVnaW5zID0ge30sXG5cdFx0XHRfdHdlZW5Mb29rdXAgPSBfaW50ZXJuYWxzLnR3ZWVuTG9va3VwID0ge30sXG5cdFx0XHRfdHdlZW5Mb29rdXBOdW0gPSAwLFxuXHRcdFx0X3Jlc2VydmVkUHJvcHMgPSBfaW50ZXJuYWxzLnJlc2VydmVkUHJvcHMgPSB7ZWFzZToxLCBkZWxheToxLCBvdmVyd3JpdGU6MSwgb25Db21wbGV0ZToxLCBvbkNvbXBsZXRlUGFyYW1zOjEsIG9uQ29tcGxldGVTY29wZToxLCB1c2VGcmFtZXM6MSwgcnVuQmFja3dhcmRzOjEsIHN0YXJ0QXQ6MSwgb25VcGRhdGU6MSwgb25VcGRhdGVQYXJhbXM6MSwgb25VcGRhdGVTY29wZToxLCBvblN0YXJ0OjEsIG9uU3RhcnRQYXJhbXM6MSwgb25TdGFydFNjb3BlOjEsIG9uUmV2ZXJzZUNvbXBsZXRlOjEsIG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOjEsIG9uUmV2ZXJzZUNvbXBsZXRlU2NvcGU6MSwgb25SZXBlYXQ6MSwgb25SZXBlYXRQYXJhbXM6MSwgb25SZXBlYXRTY29wZToxLCBlYXNlUGFyYW1zOjEsIHlveW86MSwgaW1tZWRpYXRlUmVuZGVyOjEsIHJlcGVhdDoxLCByZXBlYXREZWxheToxLCBkYXRhOjEsIHBhdXNlZDoxLCByZXZlcnNlZDoxLCBhdXRvQ1NTOjEsIGxhenk6MSwgb25PdmVyd3JpdGU6MSwgY2FsbGJhY2tTY29wZToxLCBzdHJpbmdGaWx0ZXI6MSwgaWQ6MSwgeW95b0Vhc2U6MX0sXG5cdFx0XHRfb3ZlcndyaXRlTG9va3VwID0ge25vbmU6MCwgYWxsOjEsIGF1dG86MiwgY29uY3VycmVudDozLCBhbGxPblN0YXJ0OjQsIHByZWV4aXN0aW5nOjUsIFwidHJ1ZVwiOjEsIFwiZmFsc2VcIjowfSxcblx0XHRcdF9yb290RnJhbWVzVGltZWxpbmUgPSBBbmltYXRpb24uX3Jvb3RGcmFtZXNUaW1lbGluZSA9IG5ldyBTaW1wbGVUaW1lbGluZSgpLFxuXHRcdFx0X3Jvb3RUaW1lbGluZSA9IEFuaW1hdGlvbi5fcm9vdFRpbWVsaW5lID0gbmV3IFNpbXBsZVRpbWVsaW5lKCksXG5cdFx0XHRfbmV4dEdDRnJhbWUgPSAzMCxcblx0XHRcdF9sYXp5UmVuZGVyID0gX2ludGVybmFscy5sYXp5UmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpID0gX2xhenlUd2VlbnMubGVuZ3RoLFxuXHRcdFx0XHRcdHR3ZWVuO1xuXHRcdFx0XHRfbGF6eUxvb2t1cCA9IHt9O1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHR0d2VlbiA9IF9sYXp5VHdlZW5zW2ldO1xuXHRcdFx0XHRcdGlmICh0d2VlbiAmJiB0d2Vlbi5fbGF6eSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcih0d2Vlbi5fbGF6eVswXSwgdHdlZW4uX2xhenlbMV0sIHRydWUpO1xuXHRcdFx0XHRcdFx0dHdlZW4uX2xhenkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0X2xhenlUd2VlbnMubGVuZ3RoID0gMDtcblx0XHRcdH07XG5cblx0XHRfcm9vdFRpbWVsaW5lLl9zdGFydFRpbWUgPSBfdGlja2VyLnRpbWU7XG5cdFx0X3Jvb3RGcmFtZXNUaW1lbGluZS5fc3RhcnRUaW1lID0gX3RpY2tlci5mcmFtZTtcblx0XHRfcm9vdFRpbWVsaW5lLl9hY3RpdmUgPSBfcm9vdEZyYW1lc1RpbWVsaW5lLl9hY3RpdmUgPSB0cnVlO1xuXHRcdHNldFRpbWVvdXQoX2xhenlSZW5kZXIsIDEpOyAvL29uIHNvbWUgbW9iaWxlIGRldmljZXMsIHRoZXJlIGlzbid0IGEgXCJ0aWNrXCIgYmVmb3JlIGNvZGUgcnVucyB3aGljaCBtZWFucyBhbnkgbGF6eSByZW5kZXJzIHdvdWxkbid0IHJ1biBiZWZvcmUgdGhlIG5leHQgb2ZmaWNpYWwgXCJ0aWNrXCIuXG5cblx0XHRBbmltYXRpb24uX3VwZGF0ZVJvb3QgPSBUd2VlbkxpdGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpLCBhLCBwO1xuXHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaWYgY29kZSBpcyBydW4gb3V0c2lkZSBvZiB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGxvb3AsIHRoZXJlIG1heSBiZSB0d2VlbnMgcXVldWVkIEFGVEVSIHRoZSBlbmdpbmUgcmVmcmVzaGVkLCBzbyB3ZSBuZWVkIHRvIGVuc3VyZSBhbnkgcGVuZGluZyByZW5kZXJzIG9jY3VyIGJlZm9yZSB3ZSByZWZyZXNoIGFnYWluLlxuXHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3Jvb3RUaW1lbGluZS5yZW5kZXIoKF90aWNrZXIudGltZSAtIF9yb290VGltZWxpbmUuX3N0YXJ0VGltZSkgKiBfcm9vdFRpbWVsaW5lLl90aW1lU2NhbGUsIGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdF9yb290RnJhbWVzVGltZWxpbmUucmVuZGVyKChfdGlja2VyLmZyYW1lIC0gX3Jvb3RGcmFtZXNUaW1lbGluZS5fc3RhcnRUaW1lKSAqIF9yb290RnJhbWVzVGltZWxpbmUuX3RpbWVTY2FsZSwgZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkge1xuXHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF90aWNrZXIuZnJhbWUgPj0gX25leHRHQ0ZyYW1lKSB7IC8vZHVtcCBnYXJiYWdlIGV2ZXJ5IDEyMCBmcmFtZXMgb3Igd2hhdGV2ZXIgdGhlIHVzZXIgc2V0cyBUd2VlbkxpdGUuYXV0b1NsZWVwIHRvXG5cdFx0XHRcdFx0X25leHRHQ0ZyYW1lID0gX3RpY2tlci5mcmFtZSArIChwYXJzZUludChUd2VlbkxpdGUuYXV0b1NsZWVwLCAxMCkgfHwgMTIwKTtcblx0XHRcdFx0XHRmb3IgKHAgaW4gX3R3ZWVuTG9va3VwKSB7XG5cdFx0XHRcdFx0XHRhID0gX3R3ZWVuTG9va3VwW3BdLnR3ZWVucztcblx0XHRcdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoYVtpXS5fZ2MpIHtcblx0XHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGEubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBfdHdlZW5Mb29rdXBbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vaWYgdGhlcmUgYXJlIG5vIG1vcmUgdHdlZW5zIGluIHRoZSByb290IHRpbWVsaW5lcywgb3IgaWYgdGhleSdyZSBhbGwgcGF1c2VkLCBtYWtlIHRoZSBfdGltZXIgc2xlZXAgdG8gcmVkdWNlIGxvYWQgb24gdGhlIENQVSBzbGlnaHRseVxuXHRcdFx0XHRcdHAgPSBfcm9vdFRpbWVsaW5lLl9maXJzdDtcblx0XHRcdFx0XHRpZiAoIXAgfHwgcC5fcGF1c2VkKSBpZiAoVHdlZW5MaXRlLmF1dG9TbGVlcCAmJiAhX3Jvb3RGcmFtZXNUaW1lbGluZS5fZmlyc3QgJiYgX3RpY2tlci5fbGlzdGVuZXJzLnRpY2subGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAocCAmJiBwLl9wYXVzZWQpIHtcblx0XHRcdFx0XHRcdFx0cCA9IHAuX25leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXApIHtcblx0XHRcdFx0XHRcdFx0X3RpY2tlci5zbGVlcCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdF90aWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgQW5pbWF0aW9uLl91cGRhdGVSb290KTtcblxuXHRcdHZhciBfcmVnaXN0ZXIgPSBmdW5jdGlvbih0YXJnZXQsIHR3ZWVuLCBzY3J1Yikge1xuXHRcdFx0XHR2YXIgaWQgPSB0YXJnZXQuX2dzVHdlZW5JRCwgYSwgaTtcblx0XHRcdFx0aWYgKCFfdHdlZW5Mb29rdXBbaWQgfHwgKHRhcmdldC5fZ3NUd2VlbklEID0gaWQgPSBcInRcIiArIChfdHdlZW5Mb29rdXBOdW0rKykpXSkge1xuXHRcdFx0XHRcdF90d2Vlbkxvb2t1cFtpZF0gPSB7dGFyZ2V0OnRhcmdldCwgdHdlZW5zOltdfTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHdlZW4pIHtcblx0XHRcdFx0XHRhID0gX3R3ZWVuTG9va3VwW2lkXS50d2VlbnM7XG5cdFx0XHRcdFx0YVsoaSA9IGEubGVuZ3RoKV0gPSB0d2Vlbjtcblx0XHRcdFx0XHRpZiAoc2NydWIpIHtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoYVtpXSA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gX3R3ZWVuTG9va3VwW2lkXS50d2VlbnM7XG5cdFx0XHR9LFxuXHRcdFx0X29uT3ZlcndyaXRlID0gZnVuY3Rpb24ob3ZlcndyaXR0ZW5Ud2Vlbiwgb3ZlcndyaXRpbmdUd2VlbiwgdGFyZ2V0LCBraWxsZWRQcm9wcykge1xuXHRcdFx0XHR2YXIgZnVuYyA9IG92ZXJ3cml0dGVuVHdlZW4udmFycy5vbk92ZXJ3cml0ZSwgcjEsIHIyO1xuXHRcdFx0XHRpZiAoZnVuYykge1xuXHRcdFx0XHRcdHIxID0gZnVuYyhvdmVyd3JpdHRlblR3ZWVuLCBvdmVyd3JpdGluZ1R3ZWVuLCB0YXJnZXQsIGtpbGxlZFByb3BzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmdW5jID0gVHdlZW5MaXRlLm9uT3ZlcndyaXRlO1xuXHRcdFx0XHRpZiAoZnVuYykge1xuXHRcdFx0XHRcdHIyID0gZnVuYyhvdmVyd3JpdHRlblR3ZWVuLCBvdmVyd3JpdGluZ1R3ZWVuLCB0YXJnZXQsIGtpbGxlZFByb3BzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gKHIxICE9PSBmYWxzZSAmJiByMiAhPT0gZmFsc2UpO1xuXHRcdFx0fSxcblx0XHRcdF9hcHBseU92ZXJ3cml0ZSA9IGZ1bmN0aW9uKHRhcmdldCwgdHdlZW4sIHByb3BzLCBtb2RlLCBzaWJsaW5ncykge1xuXHRcdFx0XHR2YXIgaSwgY2hhbmdlZCwgY3VyVHdlZW4sIGw7XG5cdFx0XHRcdGlmIChtb2RlID09PSAxIHx8IG1vZGUgPj0gNCkge1xuXHRcdFx0XHRcdGwgPSBzaWJsaW5ncy5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKChjdXJUd2VlbiA9IHNpYmxpbmdzW2ldKSAhPT0gdHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFjdXJUd2Vlbi5fZ2MpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoY3VyVHdlZW4uX2tpbGwobnVsbCwgdGFyZ2V0LCB0d2VlbikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChtb2RlID09PSA1KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL05PVEU6IEFkZCAwLjAwMDAwMDAwMDEgdG8gb3ZlcmNvbWUgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIHRoYXQgY2FuIGNhdXNlIHRoZSBzdGFydFRpbWUgdG8gYmUgVkVSWSBzbGlnaHRseSBvZmYgKHdoZW4gYSB0d2VlbidzIHRpbWUoKSBpcyBzZXQgZm9yIGV4YW1wbGUpXG5cdFx0XHRcdHZhciBzdGFydFRpbWUgPSB0d2Vlbi5fc3RhcnRUaW1lICsgX3RpbnlOdW0sXG5cdFx0XHRcdFx0b3ZlcmxhcHMgPSBbXSxcblx0XHRcdFx0XHRvQ291bnQgPSAwLFxuXHRcdFx0XHRcdHplcm9EdXIgPSAodHdlZW4uX2R1cmF0aW9uID09PSAwKSxcblx0XHRcdFx0XHRnbG9iYWxTdGFydDtcblx0XHRcdFx0aSA9IHNpYmxpbmdzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKChjdXJUd2VlbiA9IHNpYmxpbmdzW2ldKSA9PT0gdHdlZW4gfHwgY3VyVHdlZW4uX2djIHx8IGN1clR3ZWVuLl9wYXVzZWQpIHtcblx0XHRcdFx0XHRcdC8vaWdub3JlXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjdXJUd2Vlbi5fdGltZWxpbmUgIT09IHR3ZWVuLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdFx0Z2xvYmFsU3RhcnQgPSBnbG9iYWxTdGFydCB8fCBfY2hlY2tPdmVybGFwKHR3ZWVuLCAwLCB6ZXJvRHVyKTtcblx0XHRcdFx0XHRcdGlmIChfY2hlY2tPdmVybGFwKGN1clR3ZWVuLCBnbG9iYWxTdGFydCwgemVyb0R1cikgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0b3ZlcmxhcHNbb0NvdW50KytdID0gY3VyVHdlZW47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjdXJUd2Vlbi5fc3RhcnRUaW1lIDw9IHN0YXJ0VGltZSkgaWYgKGN1clR3ZWVuLl9zdGFydFRpbWUgKyBjdXJUd2Vlbi50b3RhbER1cmF0aW9uKCkgLyBjdXJUd2Vlbi5fdGltZVNjYWxlID4gc3RhcnRUaW1lKSBpZiAoISgoemVyb0R1ciB8fCAhY3VyVHdlZW4uX2luaXR0ZWQpICYmIHN0YXJ0VGltZSAtIGN1clR3ZWVuLl9zdGFydFRpbWUgPD0gMC4wMDAwMDAwMDAyKSkge1xuXHRcdFx0XHRcdFx0b3ZlcmxhcHNbb0NvdW50KytdID0gY3VyVHdlZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSA9IG9Db3VudDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0Y3VyVHdlZW4gPSBvdmVybGFwc1tpXTtcblx0XHRcdFx0XHRsID0gY3VyVHdlZW4uX2ZpcnN0UFQ7IC8vd2UgbmVlZCB0byBkaXNjZXJuIGlmIHRoZXJlIHdlcmUgcHJvcGVydHkgdHdlZW5zIG9yaWdpbmFsbHk7IGlmIHRoZXkgYWxsIGdldCByZW1vdmVkIGluIHRoZSBuZXh0IGxpbmUncyBfa2lsbCgpIGNhbGwsIHRoZSB0d2VlbiBzaG91bGQgYmUga2lsbGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HcmVlblNvY2stSlMvaXNzdWVzLzI3OFxuXHRcdFx0XHRcdGlmIChtb2RlID09PSAyKSBpZiAoY3VyVHdlZW4uX2tpbGwocHJvcHMsIHRhcmdldCwgdHdlZW4pKSB7XG5cdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1vZGUgIT09IDIgfHwgKCFjdXJUd2Vlbi5fZmlyc3RQVCAmJiBjdXJUd2Vlbi5faW5pdHRlZCAmJiBsKSkge1xuXHRcdFx0XHRcdFx0aWYgKG1vZGUgIT09IDIgJiYgIV9vbk92ZXJ3cml0ZShjdXJUd2VlbiwgdHdlZW4pKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGN1clR3ZWVuLl9lbmFibGVkKGZhbHNlLCBmYWxzZSkpIHsgLy9pZiBhbGwgcHJvcGVydHkgdHdlZW5zIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiwga2lsbCB0aGUgdHdlZW4uXG5cdFx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHRcdH0sXG5cdFx0XHRfY2hlY2tPdmVybGFwID0gZnVuY3Rpb24odHdlZW4sIHJlZmVyZW5jZSwgemVyb0R1cikge1xuXHRcdFx0XHR2YXIgdGwgPSB0d2Vlbi5fdGltZWxpbmUsXG5cdFx0XHRcdFx0dHMgPSB0bC5fdGltZVNjYWxlLFxuXHRcdFx0XHRcdHQgPSB0d2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHR3aGlsZSAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0dCArPSB0bC5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdHRzICo9IHRsLl90aW1lU2NhbGU7XG5cdFx0XHRcdFx0aWYgKHRsLl9wYXVzZWQpIHtcblx0XHRcdFx0XHRcdHJldHVybiAtMTAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bCA9IHRsLl90aW1lbGluZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0IC89IHRzO1xuXHRcdFx0XHRyZXR1cm4gKHQgPiByZWZlcmVuY2UpID8gdCAtIHJlZmVyZW5jZSA6ICgoemVyb0R1ciAmJiB0ID09PSByZWZlcmVuY2UpIHx8ICghdHdlZW4uX2luaXR0ZWQgJiYgdCAtIHJlZmVyZW5jZSA8IDIgKiBfdGlueU51bSkpID8gX3RpbnlOdW0gOiAoKHQgKz0gdHdlZW4udG90YWxEdXJhdGlvbigpIC8gdHdlZW4uX3RpbWVTY2FsZSAvIHRzKSA+IHJlZmVyZW5jZSArIF90aW55TnVtKSA/IDAgOiB0IC0gcmVmZXJlbmNlIC0gX3RpbnlOdW07XG5cdFx0XHR9O1xuXG5cbi8vLS0tLSBUd2VlbkxpdGUgaW5zdGFuY2UgbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0cC5faW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHYgPSB0aGlzLnZhcnMsXG5cdFx0XHRcdG9wID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyxcblx0XHRcdFx0ZHVyID0gdGhpcy5fZHVyYXRpb24sXG5cdFx0XHRcdGltbWVkaWF0ZSA9ICEhdi5pbW1lZGlhdGVSZW5kZXIsXG5cdFx0XHRcdGVhc2UgPSB2LmVhc2UsXG5cdFx0XHRcdGksIGluaXRQbHVnaW5zLCBwdCwgcCwgc3RhcnRWYXJzLCBsO1xuXHRcdFx0aWYgKHYuc3RhcnRBdCkge1xuXHRcdFx0XHRpZiAodGhpcy5fc3RhcnRBdCkge1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKTsgLy9pZiB3ZSd2ZSBydW4gYSBzdGFydEF0IHByZXZpb3VzbHkgKHdoZW4gdGhlIHR3ZWVuIGluc3RhbnRpYXRlZCksIHdlIHNob3VsZCByZXZlcnQgaXQgc28gdGhhdCB0aGUgdmFsdWVzIHJlLWluc3RhbnRpYXRlIGNvcnJlY3RseSBwYXJ0aWN1bGFybHkgZm9yIHJlbGF0aXZlIHR3ZWVucy4gV2l0aG91dCB0aGlzLCBhIFR3ZWVuTGl0ZS5mcm9tVG8ob2JqLCAxLCB7eDpcIis9MTAwXCJ9LCB7eDpcIi09MTAwXCJ9KSwgZm9yIGV4YW1wbGUsIHdvdWxkIGFjdHVhbGx5IGp1bXAgdG8gKz0yMDAgYmVjYXVzZSB0aGUgc3RhcnRBdCB3b3VsZCBydW4gdHdpY2UsIGRvdWJsaW5nIHRoZSByZWxhdGl2ZSBjaGFuZ2UuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5raWxsKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RhcnRWYXJzID0ge307XG5cdFx0XHRcdGZvciAocCBpbiB2LnN0YXJ0QXQpIHsgLy9jb3B5IHRoZSBwcm9wZXJ0aWVzL3ZhbHVlcyBpbnRvIGEgbmV3IG9iamVjdCB0byBhdm9pZCBjb2xsaXNpb25zLCBsaWtlIHZhciB0byA9IHt4OjB9LCBmcm9tID0ge3g6NTAwfTsgdGltZWxpbmUuZnJvbVRvKGUsIDEsIGZyb20sIHRvKS5mcm9tVG8oZSwgMSwgdG8sIGZyb20pO1xuXHRcdFx0XHRcdHN0YXJ0VmFyc1twXSA9IHYuc3RhcnRBdFtwXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFydFZhcnMuZGF0YSA9IFwiaXNTdGFydFwiO1xuXHRcdFx0XHRzdGFydFZhcnMub3ZlcndyaXRlID0gZmFsc2U7XG5cdFx0XHRcdHN0YXJ0VmFycy5pbW1lZGlhdGVSZW5kZXIgPSB0cnVlO1xuXHRcdFx0XHRzdGFydFZhcnMubGF6eSA9IChpbW1lZGlhdGUgJiYgdi5sYXp5ICE9PSBmYWxzZSk7XG5cdFx0XHRcdHN0YXJ0VmFycy5zdGFydEF0ID0gc3RhcnRWYXJzLmRlbGF5ID0gbnVsbDsgLy9ubyBuZXN0aW5nIG9mIHN0YXJ0QXQgb2JqZWN0cyBhbGxvd2VkIChvdGhlcndpc2UgaXQgY291bGQgY2F1c2UgYW4gaW5maW5pdGUgbG9vcCkuXG5cdFx0XHRcdHN0YXJ0VmFycy5vblVwZGF0ZSA9IHYub25VcGRhdGU7XG5cdFx0XHRcdHN0YXJ0VmFycy5vblVwZGF0ZVBhcmFtcyA9IHYub25VcGRhdGVQYXJhbXM7XG5cdFx0XHRcdHN0YXJ0VmFycy5vblVwZGF0ZVNjb3BlID0gdi5vblVwZGF0ZVNjb3BlIHx8IHYuY2FsbGJhY2tTY29wZSB8fCB0aGlzO1xuXHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gVHdlZW5MaXRlLnRvKHRoaXMudGFyZ2V0IHx8IHt9LCAwLCBzdGFydFZhcnMpO1xuXHRcdFx0XHRpZiAoaW1tZWRpYXRlKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgPiAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gbnVsbDsgLy90d2VlbnMgdGhhdCByZW5kZXIgaW1tZWRpYXRlbHkgKGxpa2UgbW9zdCBmcm9tKCkgYW5kIGZyb21UbygpIHR3ZWVucykgc2hvdWxkbid0IHJldmVydCB3aGVuIHRoZWlyIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgcGFzdCB0aGUgc3RhcnRUaW1lIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIGNvdWxkIGhhdmUgaGFwcGVuZWQgYW55dGltZSBhbmQgaXQgc2hvdWxkbid0IGJlIGRpcmVjdGx5IGNvcnJlbGF0ZWQgdG8gdGhpcyB0d2VlbidzIHN0YXJ0VGltZS4gSW1hZ2luZSBzZXR0aW5nIHVwIGEgY29tcGxleCBhbmltYXRpb24gd2hlcmUgdGhlIGJlZ2lubmluZyBzdGF0ZXMgb2YgdmFyaW91cyBvYmplY3RzIGFyZSByZW5kZXJlZCBpbW1lZGlhdGVseSBidXQgdGhlIHR3ZWVuIGRvZXNuJ3QgaGFwcGVuIGZvciBxdWl0ZSBzb21lIHRpbWUgLSBpZiB3ZSByZXZlcnQgdG8gdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcyBzb29uIGFzIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHR3ZWVuJ3Mgc3RhcnRUaW1lLCBpdCB3aWxsIHRocm93IHRoaW5ncyBvZmYgdmlzdWFsbHkuIFJldmVyc2lvbiBzaG91bGQgb25seSBoYXBwZW4gaW4gVGltZWxpbmVMaXRlL01heCBpbnN0YW5jZXMgd2hlcmUgaW1tZWRpYXRlUmVuZGVyIHdhcyBmYWxzZSAod2hpY2ggaXMgdGhlIGRlZmF1bHQgaW4gdGhlIGNvbnZlbmllbmNlIG1ldGhvZHMgbGlrZSBmcm9tKCkpLlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZHVyICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47IC8vd2Ugc2tpcCBpbml0aWFsaXphdGlvbiBoZXJlIHNvIHRoYXQgb3ZlcndyaXRpbmcgZG9lc24ndCBvY2N1ciB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zLiBPdGhlcndpc2UsIGlmIHlvdSBjcmVhdGUgc2V2ZXJhbCBpbW1lZGlhdGVSZW5kZXI6dHJ1ZSB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0L3Byb3BlcnRpZXMgdG8gZHJvcCBpbnRvIGEgVGltZWxpbmVMaXRlIG9yIFRpbWVsaW5lTWF4LCB0aGUgbGFzdCBvbmUgY3JlYXRlZCB3b3VsZCBvdmVyd3JpdGUgdGhlIGZpcnN0IG9uZXMgYmVjYXVzZSB0aGV5IGRpZG4ndCBnZXQgcGxhY2VkIGludG8gdGhlIHRpbWVsaW5lIHlldCBiZWZvcmUgdGhlIGZpcnN0IHJlbmRlciBvY2N1cnMgYW5kIGtpY2tzIGluIG92ZXJ3cml0aW5nLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh2LnJ1bkJhY2t3YXJkcyAmJiBkdXIgIT09IDApIHtcblx0XHRcdFx0Ly9mcm9tKCkgdHdlZW5zIG11c3QgYmUgaGFuZGxlZCB1bmlxdWVseTogdGhlaXIgYmVnaW5uaW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkIGJ1dCB3ZSBkb24ndCB3YW50IG92ZXJ3cml0aW5nIHRvIG9jY3VyIHlldCAod2hlbiB0aW1lIGlzIHN0aWxsIDApLiBXYWl0IHVudGlsIHRoZSB0d2VlbiBhY3R1YWxseSBiZWdpbnMgYmVmb3JlIGRvaW5nIGFsbCB0aGUgcm91dGluZXMgbGlrZSBvdmVyd3JpdGluZy4gQXQgdGhhdCB0aW1lLCB3ZSBzaG91bGQgcmVuZGVyIGF0IHRoZSBFTkQgb2YgdGhlIHR3ZWVuIHRvIGVuc3VyZSB0aGF0IHRoaW5ncyBpbml0aWFsaXplIGNvcnJlY3RseSAocmVtZW1iZXIsIGZyb20oKSB0d2VlbnMgZ28gYmFja3dhcmRzKVxuXHRcdFx0XHRpZiAodGhpcy5fc3RhcnRBdCkge1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKTtcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LmtpbGwoKTtcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSAhPT0gMCkgeyAvL2luIHJhcmUgY2FzZXMgKGxpa2UgaWYgYSBmcm9tKCkgdHdlZW4gcnVucyBhbmQgdGhlbiBpcyBpbnZhbGlkYXRlKCktZWQpLCBpbW1lZGlhdGVSZW5kZXIgY291bGQgYmUgdHJ1ZSBidXQgdGhlIGluaXRpYWwgZm9yY2VkLXJlbmRlciBnZXRzIHNraXBwZWQsIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSB0aGUgcmVuZGVyIGluIHRoaXMgY29udGV4dCB3aGVuIHRoZSBfdGltZSBpcyBncmVhdGVyIHRoYW4gMFxuXHRcdFx0XHRcdFx0aW1tZWRpYXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0ge307XG5cdFx0XHRcdFx0Zm9yIChwIGluIHYpIHsgLy9jb3B5IHByb3BzIGludG8gYSBuZXcgb2JqZWN0IGFuZCBza2lwIGFueSByZXNlcnZlZCBwcm9wcywgb3RoZXJ3aXNlIG9uQ29tcGxldGUgb3Igb25VcGRhdGUgb3Igb25TdGFydCBjb3VsZCBmaXJlLiBXZSBzaG91bGQsIGhvd2V2ZXIsIHBlcm1pdCBhdXRvQ1NTIHRvIGdvIHRocm91Z2guXG5cdFx0XHRcdFx0XHRpZiAoIV9yZXNlcnZlZFByb3BzW3BdIHx8IHAgPT09IFwiYXV0b0NTU1wiKSB7XG5cdFx0XHRcdFx0XHRcdHB0W3BdID0gdltwXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQub3ZlcndyaXRlID0gMDtcblx0XHRcdFx0XHRwdC5kYXRhID0gXCJpc0Zyb21TdGFydFwiOyAvL3dlIHRhZyB0aGUgdHdlZW4gd2l0aCBhcyBcImlzRnJvbVN0YXJ0XCIgc28gdGhhdCBpZiBbaW5zaWRlIGEgcGx1Z2luXSB3ZSBuZWVkIHRvIG9ubHkgZG8gc29tZXRoaW5nIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuLCB3ZSBoYXZlIGEgd2F5IG9mIGlkZW50aWZ5aW5nIHRoaXMgdHdlZW4gYXMgbWVyZWx5IHRoZSBvbmUgdGhhdCdzIHNldHRpbmcgdGhlIGJlZ2lubmluZyB2YWx1ZXMgZm9yIGEgXCJmcm9tKClcIiB0d2Vlbi4gRm9yIGV4YW1wbGUsIGNsZWFyUHJvcHMgaW4gQ1NTUGx1Z2luIHNob3VsZCBvbmx5IGdldCBhcHBsaWVkIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuIGFuZCB3aXRob3V0IHRoaXMgdGFnLCBmcm9tKC4uLntoZWlnaHQ6MTAwLCBjbGVhclByb3BzOlwiaGVpZ2h0XCIsIGRlbGF5OjF9KSB3b3VsZCB3aXBlIHRoZSBoZWlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4gYW5kIGFmdGVyIDEgc2Vjb25kLCBpdCdkIGtpY2sgYmFjayBpbi5cblx0XHRcdFx0XHRwdC5sYXp5ID0gKGltbWVkaWF0ZSAmJiB2LmxhenkgIT09IGZhbHNlKTtcblx0XHRcdFx0XHRwdC5pbW1lZGlhdGVSZW5kZXIgPSBpbW1lZGlhdGU7IC8vemVyby1kdXJhdGlvbiB0d2VlbnMgcmVuZGVyIGltbWVkaWF0ZWx5IGJ5IGRlZmF1bHQsIGJ1dCBpZiB3ZSdyZSBub3Qgc3BlY2lmaWNhbGx5IGluc3RydWN0ZWQgdG8gcmVuZGVyIHRoaXMgdHdlZW4gaW1tZWRpYXRlbHksIHdlIHNob3VsZCBza2lwIHRoaXMgYW5kIG1lcmVseSBfaW5pdCgpIHRvIHJlY29yZCB0aGUgc3RhcnRpbmcgdmFsdWVzIChyZW5kZXJpbmcgdGhlbSBpbW1lZGlhdGVseSB3b3VsZCBwdXNoIHRoZW0gdG8gY29tcGxldGlvbiB3aGljaCBpcyB3YXN0ZWZ1bCBpbiB0aGF0IGNhc2UgLSB3ZSdkIGhhdmUgdG8gcmVuZGVyKC0xKSBpbW1lZGlhdGVseSBhZnRlcilcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gVHdlZW5MaXRlLnRvKHRoaXMudGFyZ2V0LCAwLCBwdCk7XG5cdFx0XHRcdFx0aWYgKCFpbW1lZGlhdGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQuX2luaXQoKTsgLy9lbnN1cmVzIHRoYXQgdGhlIGluaXRpYWwgdmFsdWVzIGFyZSByZWNvcmRlZFxuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5fZW5hYmxlZChmYWxzZSk7IC8vbm8gbmVlZCB0byBoYXZlIHRoZSB0d2VlbiByZW5kZXIgb24gdGhlIG5leHQgY3ljbGUuIERpc2FibGUgaXQgYmVjYXVzZSB3ZSdsbCBhbHdheXMgbWFudWFsbHkgY29udHJvbCB0aGUgcmVuZGVycyBvZiB0aGUgX3N0YXJ0QXQgdHdlZW4uXG5cdFx0XHRcdFx0XHRpZiAodGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlcikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgPT09IDApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2Vhc2UgPSBlYXNlID0gKCFlYXNlKSA/IFR3ZWVuTGl0ZS5kZWZhdWx0RWFzZSA6IChlYXNlIGluc3RhbmNlb2YgRWFzZSkgPyBlYXNlIDogKHR5cGVvZihlYXNlKSA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyBFYXNlKGVhc2UsIHYuZWFzZVBhcmFtcykgOiBfZWFzZU1hcFtlYXNlXSB8fCBUd2VlbkxpdGUuZGVmYXVsdEVhc2U7XG5cdFx0XHRpZiAodi5lYXNlUGFyYW1zIGluc3RhbmNlb2YgQXJyYXkgJiYgZWFzZS5jb25maWcpIHtcblx0XHRcdFx0dGhpcy5fZWFzZSA9IGVhc2UuY29uZmlnLmFwcGx5KGVhc2UsIHYuZWFzZVBhcmFtcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9lYXNlVHlwZSA9IHRoaXMuX2Vhc2UuX3R5cGU7XG5cdFx0XHR0aGlzLl9lYXNlUG93ZXIgPSB0aGlzLl9lYXNlLl9wb3dlcjtcblx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBudWxsO1xuXG5cdFx0XHRpZiAodGhpcy5fdGFyZ2V0cykge1xuXHRcdFx0XHRsID0gdGhpcy5fdGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMuX2luaXRQcm9wcyggdGhpcy5fdGFyZ2V0c1tpXSwgKHRoaXMuX3Byb3BMb29rdXBbaV0gPSB7fSksIHRoaXMuX3NpYmxpbmdzW2ldLCAob3AgPyBvcFtpXSA6IG51bGwpLCBpKSApIHtcblx0XHRcdFx0XHRcdGluaXRQbHVnaW5zID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluaXRQbHVnaW5zID0gdGhpcy5faW5pdFByb3BzKHRoaXMudGFyZ2V0LCB0aGlzLl9wcm9wTG9va3VwLCB0aGlzLl9zaWJsaW5ncywgb3AsIDApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaW5pdFBsdWdpbnMpIHtcblx0XHRcdFx0VHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50KFwiX29uSW5pdEFsbFByb3BzXCIsIHRoaXMpOyAvL3Jlb3JkZXJzIHRoZSBhcnJheSBpbiBvcmRlciBvZiBwcmlvcml0eS4gVXNlcyBhIHN0YXRpYyBUd2VlblBsdWdpbiBtZXRob2QgaW4gb3JkZXIgdG8gbWluaW1pemUgZmlsZSBzaXplIGluIFR3ZWVuTGl0ZVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9wKSBpZiAoIXRoaXMuX2ZpcnN0UFQpIGlmICh0eXBlb2YodGhpcy50YXJnZXQpICE9PSBcImZ1bmN0aW9uXCIpIHsgLy9pZiBhbGwgdHdlZW5pbmcgcHJvcGVydGllcyBoYXZlIGJlZW4gb3ZlcndyaXR0ZW4sIGtpbGwgdGhlIHR3ZWVuLiBJZiB0aGUgdGFyZ2V0IGlzIGEgZnVuY3Rpb24sIGl0J3MgcHJvYmFibHkgYSBkZWxheWVkQ2FsbCBzbyBsZXQgaXQgbGl2ZS5cblx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHYucnVuQmFja3dhcmRzKSB7XG5cdFx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0cHQucyArPSBwdC5jO1xuXHRcdFx0XHRcdHB0LmMgPSAtcHQuYztcblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9vblVwZGF0ZSA9IHYub25VcGRhdGU7XG5cdFx0XHR0aGlzLl9pbml0dGVkID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0cC5faW5pdFByb3BzID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wTG9va3VwLCBzaWJsaW5ncywgb3ZlcndyaXR0ZW5Qcm9wcywgaW5kZXgpIHtcblx0XHRcdHZhciBwLCBpLCBpbml0UGx1Z2lucywgcGx1Z2luLCBwdCwgdjtcblx0XHRcdGlmICh0YXJnZXQgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChfbGF6eUxvb2t1cFt0YXJnZXQuX2dzVHdlZW5JRF0pIHtcblx0XHRcdFx0X2xhenlSZW5kZXIoKTsgLy9pZiBvdGhlciB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0IGhhdmUgcmVjZW50bHkgaW5pdHRlZCBidXQgaGF2ZW4ndCByZW5kZXJlZCB5ZXQsIHdlJ3ZlIGdvdCB0byBmb3JjZSB0aGUgcmVuZGVyIHNvIHRoYXQgdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcmUgY29ycmVjdCAoaW1hZ2luZSBwb3B1bGF0aW5nIGEgdGltZWxpbmUgd2l0aCBhIGJ1bmNoIG9mIHNlcXVlbnRpYWwgdHdlZW5zIGFuZCB0aGVuIGp1bXBpbmcgdG8gdGhlIGVuZClcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLnZhcnMuY3NzKSBpZiAodGFyZ2V0LnN0eWxlKSBpZiAodGFyZ2V0ICE9PSB3aW5kb3cgJiYgdGFyZ2V0Lm5vZGVUeXBlKSBpZiAoX3BsdWdpbnMuY3NzKSBpZiAodGhpcy52YXJzLmF1dG9DU1MgIT09IGZhbHNlKSB7IC8vaXQncyBzbyBjb21tb24gdG8gdXNlIFR3ZWVuTGl0ZS9NYXggdG8gYW5pbWF0ZSB0aGUgY3NzIG9mIERPTSBlbGVtZW50cywgd2UgYXNzdW1lIHRoYXQgaWYgdGhlIHRhcmdldCBpcyBhIERPTSBlbGVtZW50LCB0aGF0J3Mgd2hhdCBpcyBpbnRlbmRlZCAoYSBjb252ZW5pZW5jZSBzbyB0aGF0IHVzZXJzIGRvbid0IGhhdmUgdG8gd3JhcCB0aGluZ3MgaW4gY3NzOnt9LCBhbHRob3VnaCB3ZSBzdGlsbCByZWNvbW1lbmQgaXQgZm9yIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGJvb3N0IGFuZCBiZXR0ZXIgc3BlY2lmaWNpdHkpLiBOb3RlOiB3ZSBjYW5ub3QgY2hlY2sgXCJub2RlVHlwZVwiIG9uIHRoZSB3aW5kb3cgaW5zaWRlIGFuIGlmcmFtZS5cblx0XHRcdFx0X2F1dG9DU1ModGhpcy52YXJzLCB0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChwIGluIHRoaXMudmFycykge1xuXHRcdFx0XHR2ID0gdGhpcy52YXJzW3BdO1xuXHRcdFx0XHRpZiAoX3Jlc2VydmVkUHJvcHNbcF0pIHtcblx0XHRcdFx0XHRpZiAodikgaWYgKCh2IGluc3RhbmNlb2YgQXJyYXkpIHx8ICh2LnB1c2ggJiYgX2lzQXJyYXkodikpKSBpZiAodi5qb2luKFwiXCIpLmluZGV4T2YoXCJ7c2VsZn1cIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnZhcnNbcF0gPSB2ID0gdGhpcy5fc3dhcFNlbGZJblBhcmFtcyh2LCB0aGlzKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmIChfcGx1Z2luc1twXSAmJiAocGx1Z2luID0gbmV3IF9wbHVnaW5zW3BdKCkpLl9vbkluaXRUd2Vlbih0YXJnZXQsIHRoaXMudmFyc1twXSwgdGhpcywgaW5kZXgpKSB7XG5cblx0XHRcdFx0XHQvL3QgLSB0YXJnZXQgXHRcdFtvYmplY3RdXG5cdFx0XHRcdFx0Ly9wIC0gcHJvcGVydHkgXHRcdFtzdHJpbmddXG5cdFx0XHRcdFx0Ly9zIC0gc3RhcnRcdFx0XHRbbnVtYmVyXVxuXHRcdFx0XHRcdC8vYyAtIGNoYW5nZVx0XHRbbnVtYmVyXVxuXHRcdFx0XHRcdC8vZiAtIGlzRnVuY3Rpb25cdFtib29sZWFuXVxuXHRcdFx0XHRcdC8vbiAtIG5hbWVcdFx0XHRbc3RyaW5nXVxuXHRcdFx0XHRcdC8vcGcgLSBpc1BsdWdpbiBcdFtib29sZWFuXVxuXHRcdFx0XHRcdC8vcHIgLSBwcmlvcml0eVx0XHRbbnVtYmVyXVxuXHRcdFx0XHRcdC8vbSAtIG1vZCAgICAgICAgICAgW2Z1bmN0aW9uIHwgMF1cblx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQgPSB7X25leHQ6dGhpcy5fZmlyc3RQVCwgdDpwbHVnaW4sIHA6XCJzZXRSYXRpb1wiLCBzOjAsIGM6MSwgZjoxLCBuOnAsIHBnOjEsIHByOnBsdWdpbi5fcHJpb3JpdHksIG06MH07XG5cdFx0XHRcdFx0aSA9IHBsdWdpbi5fb3ZlcndyaXRlUHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0cHJvcExvb2t1cFtwbHVnaW4uX292ZXJ3cml0ZVByb3BzW2ldXSA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwbHVnaW4uX3ByaW9yaXR5IHx8IHBsdWdpbi5fb25Jbml0QWxsUHJvcHMpIHtcblx0XHRcdFx0XHRcdGluaXRQbHVnaW5zID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBsdWdpbi5fb25EaXNhYmxlIHx8IHBsdWdpbi5fb25FbmFibGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocHQuX25leHQpIHtcblx0XHRcdFx0XHRcdHB0Ll9uZXh0Ll9wcmV2ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHJvcExvb2t1cFtwXSA9IF9hZGRQcm9wVHdlZW4uY2FsbCh0aGlzLCB0YXJnZXQsIHAsIFwiZ2V0XCIsIHYsIHAsIDAsIG51bGwsIHRoaXMudmFycy5zdHJpbmdGaWx0ZXIsIGluZGV4KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3ZlcndyaXR0ZW5Qcm9wcykgaWYgKHRoaXMuX2tpbGwob3ZlcndyaXR0ZW5Qcm9wcywgdGFyZ2V0KSkgeyAvL2Fub3RoZXIgdHdlZW4gbWF5IGhhdmUgdHJpZWQgdG8gb3ZlcndyaXRlIHByb3BlcnRpZXMgb2YgdGhpcyB0d2VlbiBiZWZvcmUgaW5pdCgpIHdhcyBjYWxsZWQgKGxpa2UgaWYgdHdvIHR3ZWVucyBzdGFydCBhdCB0aGUgc2FtZSB0aW1lLCB0aGUgb25lIGNyZWF0ZWQgc2Vjb25kIHdpbGwgcnVuIGZpcnN0KVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5faW5pdFByb3BzKHRhcmdldCwgcHJvcExvb2t1cCwgc2libGluZ3MsIG92ZXJ3cml0dGVuUHJvcHMsIGluZGV4KTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9vdmVyd3JpdGUgPiAxKSBpZiAodGhpcy5fZmlyc3RQVCkgaWYgKHNpYmxpbmdzLmxlbmd0aCA+IDEpIGlmIChfYXBwbHlPdmVyd3JpdGUodGFyZ2V0LCB0aGlzLCBwcm9wTG9va3VwLCB0aGlzLl9vdmVyd3JpdGUsIHNpYmxpbmdzKSkge1xuXHRcdFx0XHR0aGlzLl9raWxsKHByb3BMb29rdXAsIHRhcmdldCk7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9pbml0UHJvcHModGFyZ2V0LCBwcm9wTG9va3VwLCBzaWJsaW5ncywgb3ZlcndyaXR0ZW5Qcm9wcywgaW5kZXgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2ZpcnN0UFQpIGlmICgodGhpcy52YXJzLmxhenkgIT09IGZhbHNlICYmIHRoaXMuX2R1cmF0aW9uKSB8fCAodGhpcy52YXJzLmxhenkgJiYgIXRoaXMuX2R1cmF0aW9uKSkgeyAvL3plcm8gZHVyYXRpb24gdHdlZW5zIGRvbid0IGxhenkgcmVuZGVyIGJ5IGRlZmF1bHQ7IGV2ZXJ5dGhpbmcgZWxzZSBkb2VzLlxuXHRcdFx0XHRfbGF6eUxvb2t1cFt0YXJnZXQuX2dzVHdlZW5JRF0gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGluaXRQbHVnaW5zO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0dmFyIHByZXZUaW1lID0gdGhpcy5fdGltZSxcblx0XHRcdFx0ZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbixcblx0XHRcdFx0cHJldlJhd1ByZXZUaW1lID0gdGhpcy5fcmF3UHJldlRpbWUsXG5cdFx0XHRcdGlzQ29tcGxldGUsIGNhbGxiYWNrLCBwdCwgcmF3UHJldlRpbWU7XG5cdFx0XHRpZiAodGltZSA+PSBkdXJhdGlvbiAtIDAuMDAwMDAwMSAmJiB0aW1lID49IDApIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gZHVyYXRpb247XG5cdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLl9jYWxjRW5kID8gdGhpcy5fZWFzZS5nZXRSYXRpbygxKSA6IDE7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV2ZXJzZWQgKSB7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uQ29tcGxldGVcIjtcblx0XHRcdFx0XHRmb3JjZSA9IChmb3JjZSB8fCB0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pOyAvL290aGVyd2lzZSwgaWYgdGhlIGFuaW1hdGlvbiBpcyB1bnBhdXNlZC9hY3RpdmF0ZWQgYWZ0ZXIgaXQncyBhbHJlYWR5IGZpbmlzaGVkLCBpdCBkb2Vzbid0IGdldCByZW1vdmVkIGZyb20gdGhlIHBhcmVudCB0aW1lbGluZS5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDApIGlmICh0aGlzLl9pbml0dGVkIHx8ICF0aGlzLnZhcnMubGF6eSB8fCBmb3JjZSkgeyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIGFyZSB0cmlja3kgYmVjYXVzZSB3ZSBtdXN0IGRpc2Nlcm4gdGhlIG1vbWVudHVtL2RpcmVjdGlvbiBvZiB0aW1lIGluIG9yZGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBzdGFydGluZyB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkIG9yIHRoZSBlbmRpbmcgdmFsdWVzLiBJZiB0aGUgXCJwbGF5aGVhZFwiIG9mIGl0cyB0aW1lbGluZSBnb2VzIHBhc3QgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uIG9yIGxhbmRzIGRpcmVjdGx5IG9uIGl0LCB0aGUgZW5kIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQsIGJ1dCBpZiB0aGUgdGltZWxpbmUncyBcInBsYXloZWFkXCIgbW92ZXMgcGFzdCBpdCBpbiB0aGUgYmFja3dhcmQgZGlyZWN0aW9uIChmcm9tIGEgcG9zdGl0aXZlIHRpbWUgdG8gYSBuZWdhdGl2ZSB0aW1lKSwgdGhlIHN0YXJ0aW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9zdGFydFRpbWUgPT09IHRoaXMuX3RpbWVsaW5lLl9kdXJhdGlvbikgeyAvL2lmIGEgemVyby1kdXJhdGlvbiB0d2VlbiBpcyBhdCB0aGUgVkVSWSBlbmQgb2YgYSB0aW1lbGluZSBhbmQgdGhhdCB0aW1lbGluZSByZW5kZXJzIGF0IGl0cyBlbmQsIGl0IHdpbGwgdHlwaWNhbGx5IGFkZCBhIHRpbnkgYml0IG9mIGN1c2hpb24gdG8gdGhlIHJlbmRlciB0aW1lIHRvIHByZXZlbnQgcm91bmRpbmcgZXJyb3JzIGZyb20gZ2V0dGluZyBpbiB0aGUgd2F5IG9mIHR3ZWVucyByZW5kZXJpbmcgdGhlaXIgVkVSWSBlbmQuIElmIHdlIHRoZW4gcmV2ZXJzZSgpIHRoYXQgdGltZWxpbmUsIHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIHdpbGwgdHJpZ2dlciBpdHMgb25SZXZlcnNlQ29tcGxldGUgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHkgdGhlIHBsYXloZWFkIGRpZG4ndCBwYXNzIG92ZXIgaXQgYWdhaW4uIEl0J3MgYSB2ZXJ5IHNwZWNpZmljIGVkZ2UgY2FzZSB3ZSBtdXN0IGFjY29tbW9kYXRlLlxuXHRcdFx0XHRcdFx0dGltZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPCAwIHx8ICh0aW1lIDw9IDAgJiYgdGltZSA+PSAtMC4wMDAwMDAxKSB8fCAocHJldlJhd1ByZXZUaW1lID09PSBfdGlueU51bSAmJiB0aGlzLmRhdGEgIT09IFwiaXNQYXVzZVwiKSkgaWYgKHByZXZSYXdQcmV2VGltZSAhPT0gdGltZSkgeyAvL25vdGU6IHdoZW4gdGhpcy5kYXRhIGlzIFwiaXNQYXVzZVwiLCBpdCdzIGEgY2FsbGJhY2sgYWRkZWQgYnkgYWRkUGF1c2UoKSBvbiBhIHRpbWVsaW5lIHRoYXQgd2Ugc2hvdWxkIG5vdCBiZSB0cmlnZ2VyZWQgd2hlbiBMRUFWSU5HIGl0cyBleGFjdCBzdGFydCB0aW1lLiBJbiBvdGhlciB3b3JkcywgdGwuYWRkUGF1c2UoMSkucGxheSgxKSBzaG91bGRuJ3QgcGF1c2UuXG5cdFx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lID4gX3RpbnlOdW0pIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcmF3UHJldlRpbWUgPSAoIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgcHJldlJhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKHRpbWUgPCAwLjAwMDAwMDEpIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLCByb3VuZCBzdXBlciBzbWFsbCB2YWx1ZXMgdG8gMC5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IDA7XG5cdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLl9jYWxjRW5kID8gdGhpcy5fZWFzZS5nZXRSYXRpbygwKSA6IDA7XG5cdFx0XHRcdGlmIChwcmV2VGltZSAhPT0gMCB8fCAoZHVyYXRpb24gPT09IDAgJiYgcHJldlJhd1ByZXZUaW1lID4gMCkpIHtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRpbWUgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwKSBpZiAodGhpcy5faW5pdHRlZCB8fCAhdGhpcy52YXJzLmxhenkgfHwgZm9yY2UpIHsgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyBhcmUgdHJpY2t5IGJlY2F1c2Ugd2UgbXVzdCBkaXNjZXJuIHRoZSBtb21lbnR1bS9kaXJlY3Rpb24gb2YgdGltZSBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc3RhcnRpbmcgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCBvciB0aGUgZW5kaW5nIHZhbHVlcy4gSWYgdGhlIFwicGxheWhlYWRcIiBvZiBpdHMgdGltZWxpbmUgZ29lcyBwYXN0IHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbiBvciBsYW5kcyBkaXJlY3RseSBvbiBpdCwgdGhlIGVuZCB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkLCBidXQgaWYgdGhlIHRpbWVsaW5lJ3MgXCJwbGF5aGVhZFwiIG1vdmVzIHBhc3QgaXQgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiAoZnJvbSBhIHBvc3RpdGl2ZSB0aW1lIHRvIGEgbmVnYXRpdmUgdGltZSksIHRoZSBzdGFydGluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZC5cblx0XHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPj0gMCAmJiAhKHByZXZSYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0gJiYgdGhpcy5kYXRhID09PSBcImlzUGF1c2VcIikpIHtcblx0XHRcdFx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSByYXdQcmV2VGltZSA9ICghc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCBwcmV2UmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQgfHwgKHRoaXMuX3N0YXJ0QXQgJiYgdGhpcy5fc3RhcnRBdC5wcm9ncmVzcygpKSkgeyAvL2lmIHdlIHJlbmRlciB0aGUgdmVyeSBiZWdpbm5pbmcgKHRpbWUgPT0gMCkgb2YgYSBmcm9tVG8oKSwgd2UgbXVzdCBmb3JjZSB0aGUgcmVuZGVyIChub3JtYWwgdHdlZW5zIHdvdWxkbid0IG5lZWQgdG8gcmVuZGVyIGF0IGEgdGltZSBvZiAwIHdoZW4gdGhlIHByZXZUaW1lIHdhcyBhbHNvIDApLiBUaGlzIGlzIGFsc28gbWFuZGF0b3J5IHRvIG1ha2Ugc3VyZSBvdmVyd3JpdGluZyBraWNrcyBpbiBpbW1lZGlhdGVseS4gQWxzbywgd2UgY2hlY2sgcHJvZ3Jlc3MoKSBiZWNhdXNlIGlmIHN0YXJ0QXQgaGFzIGFscmVhZHkgcmVuZGVyZWQgYXQgaXRzIGVuZCwgd2Ugc2hvdWxkIGZvcmNlIGEgcmVuZGVyIGF0IGl0cyBiZWdpbm5pbmcuIE90aGVyd2lzZSwgaWYgeW91IHB1dCB0aGUgcGxheWhlYWQgZGlyZWN0bHkgb24gdG9wIG9mIHdoZXJlIGEgZnJvbVRvKHtpbW1lZGlhdGVSZW5kZXI6ZmFsc2V9KSBzdGFydHMsIGFuZCB0aGVuIG1vdmUgaXQgYmFja3dhcmRzLCB0aGUgZnJvbSgpIHdvbid0IHJldmVydCBpdHMgdmFsdWVzLlxuXHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRpbWU7XG5cblx0XHRcdFx0aWYgKHRoaXMuX2Vhc2VUeXBlKSB7XG5cdFx0XHRcdFx0dmFyIHIgPSB0aW1lIC8gZHVyYXRpb24sIHR5cGUgPSB0aGlzLl9lYXNlVHlwZSwgcG93ID0gdGhpcy5fZWFzZVBvd2VyO1xuXHRcdFx0XHRcdGlmICh0eXBlID09PSAxIHx8ICh0eXBlID09PSAzICYmIHIgPj0gMC41KSkge1xuXHRcdFx0XHRcdFx0ciA9IDEgLSByO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMykge1xuXHRcdFx0XHRcdFx0ciAqPSAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocG93ID09PSAxKSB7XG5cdFx0XHRcdFx0XHRyICo9IHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDIpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDMpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHIgKiByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSA0KSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByICogciAqIHI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSAxIC0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IDIpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGltZSAvIGR1cmF0aW9uIDwgMC41KSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gciAvIDI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSAxIC0gKHIgLyAyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbyh0aW1lIC8gZHVyYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl90aW1lID09PSBwcmV2VGltZSAmJiAhZm9yY2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0KCk7XG5cdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCB8fCB0aGlzLl9nYykgeyAvL2ltbWVkaWF0ZVJlbmRlciB0d2VlbnMgdHlwaWNhbGx5IHdvbid0IGluaXRpYWxpemUgdW50aWwgdGhlIHBsYXloZWFkIGFkdmFuY2VzIChfdGltZSBpcyBncmVhdGVyIHRoYW4gMCkgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgb3ZlcndyaXRpbmcgb2NjdXJzIHByb3Blcmx5LiBBbHNvLCBpZiBhbGwgb2YgdGhlIHR3ZWVuaW5nIHByb3BlcnRpZXMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuICh3aGljaCB3b3VsZCBjYXVzZSBfZ2MgdG8gYmUgdHJ1ZSwgYXMgc2V0IGluIF9pbml0KCkpLCB3ZSBzaG91bGRuJ3QgY29udGludWUgb3RoZXJ3aXNlIGFuIG9uU3RhcnQgY2FsbGJhY2sgY291bGQgYmUgY2FsbGVkIGZvciBleGFtcGxlLlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIGlmICghZm9yY2UgJiYgdGhpcy5fZmlyc3RQVCAmJiAoKHRoaXMudmFycy5sYXp5ICE9PSBmYWxzZSAmJiB0aGlzLl9kdXJhdGlvbikgfHwgKHRoaXMudmFycy5sYXp5ICYmICF0aGlzLl9kdXJhdGlvbikpKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IHByZXZUaW1lO1xuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcHJldlJhd1ByZXZUaW1lO1xuXHRcdFx0XHRcdF9sYXp5VHdlZW5zLnB1c2godGhpcyk7XG5cdFx0XHRcdFx0dGhpcy5fbGF6eSA9IFt0aW1lLCBzdXBwcmVzc0V2ZW50c107XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vX2Vhc2UgaXMgaW5pdGlhbGx5IHNldCB0byBkZWZhdWx0RWFzZSwgc28gbm93IHRoYXQgaW5pdCgpIGhhcyBydW4sIF9lYXNlIGlzIHNldCBwcm9wZXJseSBhbmQgd2UgbmVlZCB0byByZWNhbGN1bGF0ZSB0aGUgcmF0aW8uIE92ZXJhbGwgdGhpcyBpcyBmYXN0ZXIgdGhhbiB1c2luZyBjb25kaXRpb25hbCBsb2dpYyBlYXJsaWVyIGluIHRoZSBtZXRob2QgdG8gYXZvaWQgaGF2aW5nIHRvIHNldCByYXRpbyB0d2ljZSBiZWNhdXNlIHdlIG9ubHkgaW5pdCgpIG9uY2UgYnV0IHJlbmRlclRpbWUoKSBnZXRzIGNhbGxlZCBWRVJZIGZyZXF1ZW50bHkuXG5cdFx0XHRcdGlmICh0aGlzLl90aW1lICYmICFpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8odGhpcy5fdGltZSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpc0NvbXBsZXRlICYmIHRoaXMuX2Vhc2UuX2NhbGNFbmQpIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbygodGhpcy5fdGltZSA9PT0gMCkgPyAwIDogMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9sYXp5ICE9PSBmYWxzZSkgeyAvL2luIGNhc2UgYSBsYXp5IHJlbmRlciBpcyBwZW5kaW5nLCB3ZSBzaG91bGQgZmx1c2ggaXQgYmVjYXVzZSB0aGUgbmV3IHJlbmRlciBpcyBvY2N1cnJpbmcgbm93IChpbWFnaW5lIGEgbGF6eSB0d2VlbiBpbnN0YW50aWF0aW5nIGFuZCB0aGVuIGltbWVkaWF0ZWx5IHRoZSB1c2VyIGNhbGxzIHR3ZWVuLnNlZWsodHdlZW4uZHVyYXRpb24oKSksIHNraXBwaW5nIHRvIHRoZSBlbmQgLSB0aGUgZW5kIHJlbmRlciB3b3VsZCBiZSBmb3JjZWQsIGFuZCB0aGVuIGlmIHdlIGRpZG4ndCBmbHVzaCB0aGUgbGF6eSByZW5kZXIsIGl0J2QgZmlyZSBBRlRFUiB0aGUgc2VlaygpLCByZW5kZXJpbmcgaXQgYXQgdGhlIHdyb25nIHRpbWUuXG5cdFx0XHRcdHRoaXMuX2xhenkgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmICghdGhpcy5fYWN0aXZlKSBpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl90aW1lICE9PSBwcmV2VGltZSAmJiB0aW1lID49IDApIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTsgIC8vc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGEgdHdlZW4gKGFzIG9wcG9zZWQgdG8gdGhlIHRpbWVsaW5lIHJlbmRlcmluZyBpdCksIHRoZSB0aW1lbGluZSBpcyBmb3JjZWQgdG8gcmUtcmVuZGVyIGFuZCBhbGlnbiBpdCB3aXRoIHRoZSBwcm9wZXIgdGltZS9mcmFtZSBvbiB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUuIE1heWJlIHRoZSB0d2VlbiBhbHJlYWR5IGZpbmlzaGVkIGJ1dCB0aGUgdXNlciBtYW51YWxseSByZS1yZW5kZXJzIGl0IGFzIGhhbGZ3YXkgZG9uZS5cblx0XHRcdH1cblx0XHRcdGlmIChwcmV2VGltZSA9PT0gMCkge1xuXHRcdFx0XHRpZiAodGhpcy5fc3RhcnRBdCkge1xuXHRcdFx0XHRcdGlmICh0aW1lID49IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHRydWUsIGZvcmNlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFjYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIl9kdW1teUdTXCI7IC8vaWYgbm8gY2FsbGJhY2sgaXMgZGVmaW5lZCwgdXNlIGEgZHVtbXkgdmFsdWUganVzdCBzbyB0aGF0IHRoZSBjb25kaXRpb24gYXQgdGhlIGVuZCBldmFsdWF0ZXMgYXMgdHJ1ZSBiZWNhdXNlIF9zdGFydEF0IHNob3VsZCByZW5kZXIgQUZURVIgdGhlIG5vcm1hbCByZW5kZXIgbG9vcCB3aGVuIHRoZSB0aW1lIGlzIG5lZ2F0aXZlLiBXZSBjb3VsZCBoYW5kbGUgdGhpcyBpbiBhIG1vcmUgaW50dWl0aXZlIHdheSwgb2YgY291cnNlLCBidXQgdGhlIHJlbmRlciBsb29wIGlzIHRoZSBNT1NUIGltcG9ydGFudCB0aGluZyB0byBvcHRpbWl6ZSwgc28gdGhpcyB0ZWNobmlxdWUgYWxsb3dzIHVzIHRvIGF2b2lkIGFkZGluZyBleHRyYSBjb25kaXRpb25hbCBsb2dpYyBpbiBhIGhpZ2gtZnJlcXVlbmN5IGFyZWEuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLnZhcnMub25TdGFydCkgaWYgKHRoaXMuX3RpbWUgIT09IDAgfHwgZHVyYXRpb24gPT09IDApIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uU3RhcnRcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAocHQuZikge1xuXHRcdFx0XHRcdHB0LnRbcHQucF0ocHQuYyAqIHRoaXMucmF0aW8gKyBwdC5zKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQuYyAqIHRoaXMucmF0aW8gKyBwdC5zO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9vblVwZGF0ZSkge1xuXHRcdFx0XHRpZiAodGltZSA8IDApIGlmICh0aGlzLl9zdGFydEF0ICYmIHRpbWUgIT09IC0wLjAwMDEpIHsgLy9pZiB0aGUgdHdlZW4gaXMgcG9zaXRpb25lZCBhdCB0aGUgVkVSWSBiZWdpbm5pbmcgKF9zdGFydFRpbWUgMCkgb2YgaXRzIHBhcmVudCB0aW1lbGluZSwgaXQncyBpbGxlZ2FsIGZvciB0aGUgcGxheWhlYWQgdG8gZ28gYmFjayBmdXJ0aGVyLCBzbyB3ZSBzaG91bGQgbm90IHJlbmRlciB0aGUgcmVjb3JkZWQgc3RhcnRBdCB2YWx1ZXMuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgdHJ1ZSwgZm9yY2UpOyAvL25vdGU6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSB0dWNrIHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW5zaWRlIGxlc3MgdHJhdmVsZWQgYXJlYXMgKG1vc3QgdHdlZW5zIGRvbid0IGhhdmUgYW4gb25VcGRhdGUpLiBXZSdkIGp1c3QgaGF2ZSBpdCBhdCB0aGUgZW5kIGJlZm9yZSB0aGUgb25Db21wbGV0ZSwgYnV0IHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQgYmVmb3JlIGFueSBvblVwZGF0ZSBpcyBjYWxsZWQsIHNvIHdlIEFMU08gcHV0IGl0IGhlcmUgYW5kIHRoZW4gaWYgaXQncyBub3QgY2FsbGVkLCB3ZSBkbyBzbyBsYXRlciBuZWFyIHRoZSBvbkNvbXBsZXRlLlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMpIGlmICh0aGlzLl90aW1lICE9PSBwcmV2VGltZSB8fCBpc0NvbXBsZXRlIHx8IGZvcmNlKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGNhbGxiYWNrKSBpZiAoIXRoaXMuX2djIHx8IGZvcmNlKSB7IC8vY2hlY2sgX2djIGJlY2F1c2UgdGhlcmUncyBhIGNoYW5jZSB0aGF0IGtpbGwoKSBjb3VsZCBiZSBjYWxsZWQgaW4gYW4gb25VcGRhdGVcblx0XHRcdFx0aWYgKHRpbWUgPCAwICYmIHRoaXMuX3N0YXJ0QXQgJiYgIXRoaXMuX29uVXBkYXRlICYmIHRpbWUgIT09IC0wLjAwMDEpIHsgLy8tMC4wMDAxIGlzIGEgc3BlY2lhbCB2YWx1ZSB0aGF0IHdlIHVzZSB3aGVuIGxvb3BpbmcgYmFjayB0byB0aGUgYmVnaW5uaW5nIG9mIGEgcmVwZWF0ZWQgVGltZWxpbmVNYXgsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkbid0IHJlbmRlciB0aGUgX3N0YXJ0QXQgdmFsdWVzLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHRydWUsIGZvcmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnZhcnNbY2FsbGJhY2tdKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soY2FsbGJhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCAmJiB0aGlzLl9yYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0gJiYgcmF3UHJldlRpbWUgIT09IF90aW55TnVtKSB7IC8vdGhlIG9uQ29tcGxldGUgb3Igb25SZXZlcnNlQ29tcGxldGUgY291bGQgdHJpZ2dlciBtb3ZlbWVudCBvZiB0aGUgcGxheWhlYWQgYW5kIGZvciB6ZXJvLWR1cmF0aW9uIHR3ZWVucyAod2hpY2ggbXVzdCBkaXNjZXJuIGRpcmVjdGlvbikgdGhhdCBsYW5kIGRpcmVjdGx5IGJhY2sgb24gdGhlaXIgc3RhcnQgdGltZSwgd2UgZG9uJ3Qgd2FudCB0byBmaXJlIGFnYWluIG9uIHRoZSBuZXh0IHJlbmRlci4gVGhpbmsgb2Ygc2V2ZXJhbCBhZGRQYXVzZSgpJ3MgaW4gYSB0aW1lbGluZSB0aGF0IGZvcmNlcyB0aGUgcGxheWhlYWQgdG8gYSBjZXJ0YWluIHNwb3QsIGJ1dCB3aGF0IGlmIGl0J3MgYWxyZWFkeSBwYXVzZWQgYW5kIGFub3RoZXIgdHdlZW4gaXMgdHdlZW5pbmcgdGhlIFwidGltZVwiIG9mIHRoZSB0aW1lbGluZT8gRWFjaCB0aW1lIGl0IG1vdmVzIFtmb3J3YXJkXSBwYXN0IHRoYXQgc3BvdCwgaXQgd291bGQgbW92ZSBiYWNrLCBhbmQgc2luY2Ugc3VwcHJlc3NFdmVudHMgaXMgdHJ1ZSwgaXQnZCByZXNldCBfcmF3UHJldlRpbWUgdG8gX3RpbnlOdW0gc28gdGhhdCB3aGVuIGl0IGJlZ2lucyBhZ2FpbiwgdGhlIGNhbGxiYWNrIHdvdWxkIGZpcmUgKHNvIHVsdGltYXRlbHkgaXQgY291bGQgYm91bmNlIGJhY2sgYW5kIGZvcnRoIGR1cmluZyB0aGF0IHR3ZWVuKS4gQWdhaW4sIHRoaXMgaXMgYSB2ZXJ5IHVuY29tbW9uIHNjZW5hcmlvLCBidXQgcG9zc2libGUgbm9uZXRoZWxlc3MuXG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQsIG92ZXJ3cml0aW5nVHdlZW4pIHtcblx0XHRcdGlmICh2YXJzID09PSBcImFsbFwiKSB7XG5cdFx0XHRcdHZhcnMgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhcnMgPT0gbnVsbCkgaWYgKHRhcmdldCA9PSBudWxsIHx8IHRhcmdldCA9PT0gdGhpcy50YXJnZXQpIHtcblx0XHRcdFx0dGhpcy5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0ID0gKHR5cGVvZih0YXJnZXQpICE9PSBcInN0cmluZ1wiKSA/ICh0YXJnZXQgfHwgdGhpcy5fdGFyZ2V0cyB8fCB0aGlzLnRhcmdldCkgOiBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0KSB8fCB0YXJnZXQ7XG5cdFx0XHR2YXIgc2ltdWx0YW5lb3VzT3ZlcndyaXRlID0gKG92ZXJ3cml0aW5nVHdlZW4gJiYgdGhpcy5fdGltZSAmJiBvdmVyd3JpdGluZ1R3ZWVuLl9zdGFydFRpbWUgPT09IHRoaXMuX3N0YXJ0VGltZSAmJiB0aGlzLl90aW1lbGluZSA9PT0gb3ZlcndyaXRpbmdUd2Vlbi5fdGltZWxpbmUpLFxuXHRcdFx0XHRmaXJzdFBUID0gdGhpcy5fZmlyc3RQVCxcblx0XHRcdFx0aSwgb3ZlcndyaXR0ZW5Qcm9wcywgcCwgcHQsIHByb3BMb29rdXAsIGNoYW5nZWQsIGtpbGxQcm9wcywgcmVjb3JkLCBraWxsZWQ7XG5cdFx0XHRpZiAoKF9pc0FycmF5KHRhcmdldCkgfHwgX2lzU2VsZWN0b3IodGFyZ2V0KSkgJiYgdHlwZW9mKHRhcmdldFswXSkgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0aSA9IHRhcmdldC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9raWxsKHZhcnMsIHRhcmdldFtpXSwgb3ZlcndyaXRpbmdUd2VlbikpIHtcblx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRoaXMuX3RhcmdldHMpIHtcblx0XHRcdFx0XHRpID0gdGhpcy5fdGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0ID09PSB0aGlzLl90YXJnZXRzW2ldKSB7XG5cdFx0XHRcdFx0XHRcdHByb3BMb29rdXAgPSB0aGlzLl9wcm9wTG9va3VwW2ldIHx8IHt9O1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdHRlblByb3BzID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyB8fCBbXTtcblx0XHRcdFx0XHRcdFx0b3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHNbaV0gPSB2YXJzID8gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wc1tpXSB8fCB7fSA6IFwiYWxsXCI7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh0YXJnZXQgIT09IHRoaXMudGFyZ2V0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHByb3BMb29rdXAgPSB0aGlzLl9wcm9wTG9va3VwO1xuXHRcdFx0XHRcdG92ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzID0gdmFycyA/IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMgfHwge30gOiBcImFsbFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHByb3BMb29rdXApIHtcblx0XHRcdFx0XHRraWxsUHJvcHMgPSB2YXJzIHx8IHByb3BMb29rdXA7XG5cdFx0XHRcdFx0cmVjb3JkID0gKHZhcnMgIT09IG92ZXJ3cml0dGVuUHJvcHMgJiYgb3ZlcndyaXR0ZW5Qcm9wcyAhPT0gXCJhbGxcIiAmJiB2YXJzICE9PSBwcm9wTG9va3VwICYmICh0eXBlb2YodmFycykgIT09IFwib2JqZWN0XCIgfHwgIXZhcnMuX3RlbXBLaWxsKSk7IC8vX3RlbXBLaWxsIGlzIGEgc3VwZXItc2VjcmV0IHdheSB0byBkZWxldGUgYSBwYXJ0aWN1bGFyIHR3ZWVuaW5nIHByb3BlcnR5IGJ1dCBOT1QgaGF2ZSBpdCByZW1lbWJlcmVkIGFzIGFuIG9mZmljaWFsIG92ZXJ3cml0dGVuIHByb3BlcnR5IChsaWtlIGluIEJlemllclBsdWdpbilcblx0XHRcdFx0XHRpZiAob3ZlcndyaXRpbmdUd2VlbiAmJiAoVHdlZW5MaXRlLm9uT3ZlcndyaXRlIHx8IHRoaXMudmFycy5vbk92ZXJ3cml0ZSkpIHtcblx0XHRcdFx0XHRcdGZvciAocCBpbiBraWxsUHJvcHMpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHByb3BMb29rdXBbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIWtpbGxlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0a2lsbGVkID0gW107XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGtpbGxlZC5wdXNoKHApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoKGtpbGxlZCB8fCAhdmFycykgJiYgIV9vbk92ZXJ3cml0ZSh0aGlzLCBvdmVyd3JpdGluZ1R3ZWVuLCB0YXJnZXQsIGtpbGxlZCkpIHsgLy9pZiB0aGUgb25PdmVyd3JpdGUgcmV0dXJuZWQgZmFsc2UsIHRoYXQgbWVhbnMgdGhlIHVzZXIgd2FudHMgdG8gb3ZlcnJpZGUgdGhlIG92ZXJ3cml0aW5nIChjYW5jZWwgaXQpLlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yIChwIGluIGtpbGxQcm9wcykge1xuXHRcdFx0XHRcdFx0aWYgKChwdCA9IHByb3BMb29rdXBbcF0pKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChzaW11bHRhbmVvdXNPdmVyd3JpdGUpIHsgLy9pZiBhbm90aGVyIHR3ZWVuIG92ZXJ3cml0ZXMgdGhpcyBvbmUgYW5kIHRoZXkgYm90aCBzdGFydCBhdCBleGFjdGx5IHRoZSBzYW1lIHRpbWUsIHlldCB0aGlzIHR3ZWVuIGhhcyBhbHJlYWR5IHJlbmRlcmVkIG9uY2UgKGZvciBleGFtcGxlLCBhdCAwLjAwMSkgYmVjYXVzZSBpdCdzIGZpcnN0IGluIHRoZSBxdWV1ZSwgd2Ugc2hvdWxkIHJldmVydCB0aGUgdmFsdWVzIHRvIHdoZXJlIHRoZXkgd2VyZSBhdCAwIHNvIHRoYXQgdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcmVuJ3QgY29udGFtaW5hdGVkIG9uIHRoZSBvdmVyd3JpdGluZyB0d2Vlbi5cblx0XHRcdFx0XHRcdFx0XHRpZiAocHQuZikge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXShwdC5zKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnM7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChwdC5wZyAmJiBwdC50Ll9raWxsKGtpbGxQcm9wcykpIHtcblx0XHRcdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTsgLy9zb21lIHBsdWdpbnMgbmVlZCB0byBiZSBub3RpZmllZCBzbyB0aGV5IGNhbiBwZXJmb3JtIGNsZWFudXAgdGFza3MgZmlyc3Rcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoIXB0LnBnIHx8IHB0LnQuX292ZXJ3cml0ZVByb3BzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChwdC5fcHJldikge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0ID09PSB0aGlzLl9maXJzdFBUKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdC5fcHJldjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cHQuX25leHQgPSBwdC5fcHJldiA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHByb3BMb29rdXBbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAocmVjb3JkKSB7XG5cdFx0XHRcdFx0XHRcdG92ZXJ3cml0dGVuUHJvcHNbcF0gPSAxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIXRoaXMuX2ZpcnN0UFQgJiYgdGhpcy5faW5pdHRlZCAmJiBmaXJzdFBUKSB7IC8vaWYgYWxsIHR3ZWVuaW5nIHByb3BlcnRpZXMgYXJlIGtpbGxlZCwga2lsbCB0aGUgdHdlZW4uIFdpdGhvdXQgdGhpcyBsaW5lLCBpZiB0aGVyZSdzIGEgdHdlZW4gd2l0aCBtdWx0aXBsZSB0YXJnZXRzIGFuZCB0aGVuIHlvdSBraWxsVHdlZW5zT2YoKSBlYWNoIHRhcmdldCBpbmRpdmlkdWFsbHksIHRoZSB0d2VlbiB3b3VsZCB0ZWNobmljYWxseSBzdGlsbCByZW1haW4gYWN0aXZlIGFuZCBmaXJlIGl0cyBvbkNvbXBsZXRlIGV2ZW4gdGhvdWdoIHRoZXJlIGFyZW4ndCBhbnkgbW9yZSBwcm9wZXJ0aWVzIHR3ZWVuaW5nLlxuXHRcdFx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0fTtcblxuXHRcdHAuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQpIHtcblx0XHRcdFx0VHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50KFwiX29uRGlzYWJsZVwiLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2ZpcnN0UFQgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzID0gdGhpcy5fc3RhcnRBdCA9IHRoaXMuX29uVXBkYXRlID0gbnVsbDtcblx0XHRcdHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQgPSB0aGlzLl9hY3RpdmUgPSB0aGlzLl9sYXp5ID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9wcm9wTG9va3VwID0gKHRoaXMuX3RhcmdldHMpID8ge30gOiBbXTtcblx0XHRcdEFuaW1hdGlvbi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdFx0aWYgKHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIpIHtcblx0XHRcdFx0dGhpcy5fdGltZSA9IC1fdGlueU51bTsgLy9mb3JjZXMgYSByZW5kZXIgd2l0aG91dCBoYXZpbmcgdG8gc2V0IHRoZSByZW5kZXIoKSBcImZvcmNlXCIgcGFyYW1ldGVyIHRvIHRydWUgYmVjYXVzZSB3ZSB3YW50IHRvIGFsbG93IGxhenlpbmcgYnkgZGVmYXVsdCAodXNpbmcgdGhlIFwiZm9yY2VcIiBwYXJhbWV0ZXIgYWx3YXlzIGZvcmNlcyBhbiBpbW1lZGlhdGUgZnVsbCByZW5kZXIpXG5cdFx0XHRcdHRoaXMucmVuZGVyKE1hdGgubWluKDAsIC10aGlzLl9kZWxheSkpOyAvL2luIGNhc2UgZGVsYXkgaXMgbmVnYXRpdmUuXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5fZW5hYmxlZCA9IGZ1bmN0aW9uKGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKSB7XG5cdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZW5hYmxlZCAmJiB0aGlzLl9nYykge1xuXHRcdFx0XHR2YXIgdGFyZ2V0cyA9IHRoaXMuX3RhcmdldHMsXG5cdFx0XHRcdFx0aTtcblx0XHRcdFx0aWYgKHRhcmdldHMpIHtcblx0XHRcdFx0XHRpID0gdGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zaWJsaW5nc1tpXSA9IF9yZWdpc3Rlcih0YXJnZXRzW2ldLCB0aGlzLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fc2libGluZ3MgPSBfcmVnaXN0ZXIodGhpcy50YXJnZXQsIHRoaXMsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRBbmltYXRpb24ucHJvdG90eXBlLl9lbmFibGVkLmNhbGwodGhpcywgZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpO1xuXHRcdFx0aWYgKHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQpIGlmICh0aGlzLl9maXJzdFBUKSB7XG5cdFx0XHRcdHJldHVybiBUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQoKGVuYWJsZWQgPyBcIl9vbkVuYWJsZVwiIDogXCJfb25EaXNhYmxlXCIpLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cbi8vLS0tLVR3ZWVuTGl0ZSBzdGF0aWMgbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0VHdlZW5MaXRlLnRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5mcm9tID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0dmFycy5ydW5CYWNrd2FyZHMgPSB0cnVlO1xuXHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5mcm9tVG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzKSB7XG5cdFx0XHR0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuXHRcdFx0dG9WYXJzLmltbWVkaWF0ZVJlbmRlciA9ICh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlICYmIGZyb21WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTGl0ZSh0YXJnZXQsIGR1cmF0aW9uLCB0b1ZhcnMpO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuZGVsYXllZENhbGwgPSBmdW5jdGlvbihkZWxheSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUsIHVzZUZyYW1lcykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUoY2FsbGJhY2ssIDAsIHtkZWxheTpkZWxheSwgb25Db21wbGV0ZTpjYWxsYmFjaywgb25Db21wbGV0ZVBhcmFtczpwYXJhbXMsIGNhbGxiYWNrU2NvcGU6c2NvcGUsIG9uUmV2ZXJzZUNvbXBsZXRlOmNhbGxiYWNrLCBvblJldmVyc2VDb21wbGV0ZVBhcmFtczpwYXJhbXMsIGltbWVkaWF0ZVJlbmRlcjpmYWxzZSwgbGF6eTpmYWxzZSwgdXNlRnJhbWVzOnVzZUZyYW1lcywgb3ZlcndyaXRlOjB9KTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLnNldCA9IGZ1bmN0aW9uKHRhcmdldCwgdmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCAwLCB2YXJzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmdldFR3ZWVuc09mID0gZnVuY3Rpb24odGFyZ2V0LCBvbmx5QWN0aXZlKSB7XG5cdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHsgcmV0dXJuIFtdOyB9XG5cdFx0XHR0YXJnZXQgPSAodHlwZW9mKHRhcmdldCkgIT09IFwic3RyaW5nXCIpID8gdGFyZ2V0IDogVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldCkgfHwgdGFyZ2V0O1xuXHRcdFx0dmFyIGksIGEsIGosIHQ7XG5cdFx0XHRpZiAoKF9pc0FycmF5KHRhcmdldCkgfHwgX2lzU2VsZWN0b3IodGFyZ2V0KSkgJiYgdHlwZW9mKHRhcmdldFswXSkgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0aSA9IHRhcmdldC5sZW5ndGg7XG5cdFx0XHRcdGEgPSBbXTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0YSA9IGEuY29uY2F0KFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZih0YXJnZXRbaV0sIG9ubHlBY3RpdmUpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdC8vbm93IGdldCByaWQgb2YgYW55IGR1cGxpY2F0ZXMgKHR3ZWVucyBvZiBhcnJheXMgb2Ygb2JqZWN0cyBjb3VsZCBjYXVzZSBkdXBsaWNhdGVzKVxuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHR0ID0gYVtpXTtcblx0XHRcdFx0XHRqID0gaTtcblx0XHRcdFx0XHR3aGlsZSAoLS1qID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmICh0ID09PSBhW2pdKSB7XG5cdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0YXJnZXQuX2dzVHdlZW5JRCkge1xuXHRcdFx0XHRhID0gX3JlZ2lzdGVyKHRhcmdldCkuY29uY2F0KCk7XG5cdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKGFbaV0uX2djIHx8IChvbmx5QWN0aXZlICYmICFhW2ldLmlzQWN0aXZlKCkpKSB7XG5cdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBhIHx8IFtdO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUua2lsbFR3ZWVuc09mID0gVHdlZW5MaXRlLmtpbGxEZWxheWVkQ2FsbHNUbyA9IGZ1bmN0aW9uKHRhcmdldCwgb25seUFjdGl2ZSwgdmFycykge1xuXHRcdFx0aWYgKHR5cGVvZihvbmx5QWN0aXZlKSA9PT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHR2YXJzID0gb25seUFjdGl2ZTsgLy9mb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKGJlZm9yZSBcIm9ubHlBY3RpdmVcIiBwYXJhbWV0ZXIgd2FzIGluc2VydGVkKVxuXHRcdFx0XHRvbmx5QWN0aXZlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYSA9IFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZih0YXJnZXQsIG9ubHlBY3RpdmUpLFxuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0YVtpXS5fa2lsbCh2YXJzLCB0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdH07XG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVHdlZW5QbHVnaW4gICAoY291bGQgZWFzaWx5IGJlIHNwbGl0IG91dCBhcyBhIHNlcGFyYXRlIGZpbGUvY2xhc3MsIGJ1dCBpbmNsdWRlZCBmb3IgZWFzZSBvZiB1c2UgKHNvIHRoYXQgcGVvcGxlIGRvbid0IG5lZWQgdG8gaW5jbHVkZSBhbm90aGVyIHNjcmlwdCBjYWxsIGJlZm9yZSBsb2FkaW5nIHBsdWdpbnMgd2hpY2ggaXMgZWFzeSB0byBmb3JnZXQpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgVHdlZW5QbHVnaW4gPSBfY2xhc3MoXCJwbHVnaW5zLlR3ZWVuUGx1Z2luXCIsIGZ1bmN0aW9uKHByb3BzLCBwcmlvcml0eSkge1xuXHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzID0gKHByb3BzIHx8IFwiXCIpLnNwbGl0KFwiLFwiKTtcblx0XHRcdFx0XHR0aGlzLl9wcm9wTmFtZSA9IHRoaXMuX292ZXJ3cml0ZVByb3BzWzBdO1xuXHRcdFx0XHRcdHRoaXMuX3ByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDtcblx0XHRcdFx0XHR0aGlzLl9zdXBlciA9IFR3ZWVuUGx1Z2luLnByb3RvdHlwZTtcblx0XHRcdFx0fSwgdHJ1ZSk7XG5cblx0XHRwID0gVHdlZW5QbHVnaW4ucHJvdG90eXBlO1xuXHRcdFR3ZWVuUGx1Z2luLnZlcnNpb24gPSBcIjEuMTkuMFwiO1xuXHRcdFR3ZWVuUGx1Z2luLkFQSSA9IDI7XG5cdFx0cC5fZmlyc3RQVCA9IG51bGw7XG5cdFx0cC5fYWRkVHdlZW4gPSBfYWRkUHJvcFR3ZWVuO1xuXHRcdHAuc2V0UmF0aW8gPSBfc2V0UmF0aW87XG5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24obG9va3VwKSB7XG5cdFx0XHR2YXIgYSA9IHRoaXMuX292ZXJ3cml0ZVByb3BzLFxuXHRcdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQsXG5cdFx0XHRcdGk7XG5cdFx0XHRpZiAobG9va3VwW3RoaXMuX3Byb3BOYW1lXSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzID0gW107XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmIChsb29rdXBbYVtpXV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKGxvb2t1cFtwdC5uXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0Ll9wcmV2O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocHQuX3ByZXYpIHtcblx0XHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0XHRwdC5fcHJldiA9IG51bGw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9maXJzdFBUID09PSBwdCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHRwLl9tb2QgPSBwLl9yb3VuZFByb3BzID0gZnVuY3Rpb24obG9va3VwKSB7XG5cdFx0XHR2YXIgcHQgPSB0aGlzLl9maXJzdFBULFxuXHRcdFx0XHR2YWw7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0dmFsID0gbG9va3VwW3RoaXMuX3Byb3BOYW1lXSB8fCAocHQubiAhPSBudWxsICYmIGxvb2t1cFsgcHQubi5zcGxpdCh0aGlzLl9wcm9wTmFtZSArIFwiX1wiKS5qb2luKFwiXCIpIF0pO1xuXHRcdFx0XHRpZiAodmFsICYmIHR5cGVvZih2YWwpID09PSBcImZ1bmN0aW9uXCIpIHsgLy9zb21lIHByb3BlcnRpZXMgdGhhdCBhcmUgdmVyeSBwbHVnaW4tc3BlY2lmaWMgYWRkIGEgcHJlZml4IG5hbWVkIGFmdGVyIHRoZSBfcHJvcE5hbWUgcGx1cyBhbiB1bmRlcnNjb3JlLCBzbyB3ZSBuZWVkIHRvIGlnbm9yZSB0aGF0IGV4dHJhIHN0dWZmIGhlcmUuXG5cdFx0XHRcdFx0aWYgKHB0LmYgPT09IDIpIHtcblx0XHRcdFx0XHRcdHB0LnQuX2FwcGx5UFQubSA9IHZhbDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQubSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50ID0gZnVuY3Rpb24odHlwZSwgdHdlZW4pIHtcblx0XHRcdHZhciBwdCA9IHR3ZWVuLl9maXJzdFBULFxuXHRcdFx0XHRjaGFuZ2VkLCBwdDIsIGZpcnN0LCBsYXN0LCBuZXh0O1xuXHRcdFx0aWYgKHR5cGUgPT09IFwiX29uSW5pdEFsbFByb3BzXCIpIHtcblx0XHRcdFx0Ly9zb3J0cyB0aGUgUHJvcFR3ZWVuIGxpbmtlZCBsaXN0IGluIG9yZGVyIG9mIHByaW9yaXR5IGJlY2F1c2Ugc29tZSBwbHVnaW5zIG5lZWQgdG8gcmVuZGVyIGVhcmxpZXIvbGF0ZXIgdGhhbiBvdGhlcnMsIGxpa2UgTW90aW9uQmx1clBsdWdpbiBhcHBsaWVzIGl0cyBlZmZlY3RzIGFmdGVyIGFsbCB4L3kvYWxwaGEgdHdlZW5zIGhhdmUgcmVuZGVyZWQgb24gZWFjaCBmcmFtZS5cblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0bmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdHB0MiA9IGZpcnN0O1xuXHRcdFx0XHRcdHdoaWxlIChwdDIgJiYgcHQyLnByID4gcHQucHIpIHtcblx0XHRcdFx0XHRcdHB0MiA9IHB0Mi5fbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKChwdC5fcHJldiA9IHB0MiA/IHB0Mi5fcHJldiA6IGxhc3QpKSB7XG5cdFx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmaXJzdCA9IHB0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoKHB0Ll9uZXh0ID0gcHQyKSkge1xuXHRcdFx0XHRcdFx0cHQyLl9wcmV2ID0gcHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxhc3QgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gdHdlZW4uX2ZpcnN0UFQgPSBmaXJzdDtcblx0XHRcdH1cblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAocHQucGcpIGlmICh0eXBlb2YocHQudFt0eXBlXSkgPT09IFwiZnVuY3Rpb25cIikgaWYgKHB0LnRbdHlwZV0oKSkge1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9O1xuXG5cdFx0VHdlZW5QbHVnaW4uYWN0aXZhdGUgPSBmdW5jdGlvbihwbHVnaW5zKSB7XG5cdFx0XHR2YXIgaSA9IHBsdWdpbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmIChwbHVnaW5zW2ldLkFQSSA9PT0gVHdlZW5QbHVnaW4uQVBJKSB7XG5cdFx0XHRcdFx0X3BsdWdpbnNbKG5ldyBwbHVnaW5zW2ldKCkpLl9wcm9wTmFtZV0gPSBwbHVnaW5zW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0Ly9wcm92aWRlcyBhIG1vcmUgY29uY2lzZSB3YXkgdG8gZGVmaW5lIHBsdWdpbnMgdGhhdCBoYXZlIG5vIGRlcGVuZGVuY2llcyBiZXNpZGVzIFR3ZWVuUGx1Z2luIGFuZCBUd2VlbkxpdGUsIHdyYXBwaW5nIGNvbW1vbiBib2lsZXJwbGF0ZSBzdHVmZiBpbnRvIG9uZSBmdW5jdGlvbiAoYWRkZWQgaW4gMS45LjApLiBZb3UgZG9uJ3QgTkVFRCB0byB1c2UgdGhpcyB0byBkZWZpbmUgYSBwbHVnaW4gLSB0aGUgb2xkIHdheSBzdGlsbCB3b3JrcyBhbmQgY2FuIGJlIHVzZWZ1bCBpbiBjZXJ0YWluIChyYXJlKSBzaXR1YXRpb25zLlxuXHRcdF9nc0RlZmluZS5wbHVnaW4gPSBmdW5jdGlvbihjb25maWcpIHtcblx0XHRcdGlmICghY29uZmlnIHx8ICFjb25maWcucHJvcE5hbWUgfHwgIWNvbmZpZy5pbml0IHx8ICFjb25maWcuQVBJKSB7IHRocm93IFwiaWxsZWdhbCBwbHVnaW4gZGVmaW5pdGlvbi5cIjsgfVxuXHRcdFx0dmFyIHByb3BOYW1lID0gY29uZmlnLnByb3BOYW1lLFxuXHRcdFx0XHRwcmlvcml0eSA9IGNvbmZpZy5wcmlvcml0eSB8fCAwLFxuXHRcdFx0XHRvdmVyd3JpdGVQcm9wcyA9IGNvbmZpZy5vdmVyd3JpdGVQcm9wcyxcblx0XHRcdFx0bWFwID0ge2luaXQ6XCJfb25Jbml0VHdlZW5cIiwgc2V0Olwic2V0UmF0aW9cIiwga2lsbDpcIl9raWxsXCIsIHJvdW5kOlwiX21vZFwiLCBtb2Q6XCJfbW9kXCIsIGluaXRBbGw6XCJfb25Jbml0QWxsUHJvcHNcIn0sXG5cdFx0XHRcdFBsdWdpbiA9IF9jbGFzcyhcInBsdWdpbnMuXCIgKyBwcm9wTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BOYW1lLnN1YnN0cigxKSArIFwiUGx1Z2luXCIsXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRUd2VlblBsdWdpbi5jYWxsKHRoaXMsIHByb3BOYW1lLCBwcmlvcml0eSk7XG5cdFx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcyA9IG92ZXJ3cml0ZVByb3BzIHx8IFtdO1xuXHRcdFx0XHRcdH0sIChjb25maWcuZ2xvYmFsID09PSB0cnVlKSksXG5cdFx0XHRcdHAgPSBQbHVnaW4ucHJvdG90eXBlID0gbmV3IFR3ZWVuUGx1Z2luKHByb3BOYW1lKSxcblx0XHRcdFx0cHJvcDtcblx0XHRcdHAuY29uc3RydWN0b3IgPSBQbHVnaW47XG5cdFx0XHRQbHVnaW4uQVBJID0gY29uZmlnLkFQSTtcblx0XHRcdGZvciAocHJvcCBpbiBtYXApIHtcblx0XHRcdFx0aWYgKHR5cGVvZihjb25maWdbcHJvcF0pID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRwW21hcFtwcm9wXV0gPSBjb25maWdbcHJvcF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFBsdWdpbi52ZXJzaW9uID0gY29uZmlnLnZlcnNpb247XG5cdFx0XHRUd2VlblBsdWdpbi5hY3RpdmF0ZShbUGx1Z2luXSk7XG5cdFx0XHRyZXR1cm4gUGx1Z2luO1xuXHRcdH07XG5cblxuXHRcdC8vbm93IHJ1biB0aHJvdWdoIGFsbCB0aGUgZGVwZW5kZW5jaWVzIGRpc2NvdmVyZWQgYW5kIGlmIGFueSBhcmUgbWlzc2luZywgbG9nIHRoYXQgdG8gdGhlIGNvbnNvbGUgYXMgYSB3YXJuaW5nLiBUaGlzIGlzIHdoeSBpdCdzIGJlc3QgdG8gaGF2ZSBUd2VlbkxpdGUgbG9hZCBsYXN0IC0gaXQgY2FuIGNoZWNrIGFsbCB0aGUgZGVwZW5kZW5jaWVzIGZvciB5b3UuXG5cdFx0YSA9IHdpbmRvdy5fZ3NRdWV1ZTtcblx0XHRpZiAoYSkge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0YVtpXSgpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChwIGluIF9kZWZMb29rdXApIHtcblx0XHRcdFx0aWYgKCFfZGVmTG9va3VwW3BdLmZ1bmMpIHtcblx0XHRcdFx0XHR3aW5kb3cuY29uc29sZS5sb2coXCJHU0FQIGVuY291bnRlcmVkIG1pc3NpbmcgZGVwZW5kZW5jeTogXCIgKyBwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF90aWNrZXJBY3RpdmUgPSBmYWxzZTsgLy9lbnN1cmVzIHRoYXQgdGhlIGZpcnN0IG9mZmljaWFsIGFuaW1hdGlvbiBmb3JjZXMgYSB0aWNrZXIudGljaygpIHRvIHVwZGF0ZSB0aGUgdGltZSB3aGVuIGl0IGlzIGluc3RhbnRpYXRlZFxuXG5cdFx0cmV0dXJuIFR3ZWVuTGl0ZTtcblxufSkoX2dzU2NvcGUsIFwiVHdlZW5MaXRlXCIpO1xuXG5leHBvcnQgdmFyIGdsb2JhbHMgPSBfZ3NTY29wZS5HcmVlblNvY2tHbG9iYWxzO1xudmFyIG5vbkdsb2JhbHMgPSBnbG9iYWxzLmNvbS5ncmVlbnNvY2s7XG5leHBvcnQgeyBUd2VlbkxpdGUgYXMgZGVmYXVsdCB9O1xuZXhwb3J0IHZhciBTaW1wbGVUaW1lbGluZSA9IG5vbkdsb2JhbHMuY29yZS5TaW1wbGVUaW1lbGluZTtcbmV4cG9ydCB2YXIgQW5pbWF0aW9uID0gbm9uR2xvYmFscy5jb3JlLkFuaW1hdGlvbjtcbmV4cG9ydCB2YXIgRWFzZSA9IGdsb2JhbHMuRWFzZTtcbmV4cG9ydCB2YXIgTGluZWFyID0gZ2xvYmFscy5MaW5lYXI7XG5leHBvcnQgdmFyIFBvd2VyMCA9IExpbmVhcjtcbmV4cG9ydCB2YXIgUG93ZXIxID0gZ2xvYmFscy5Qb3dlcjE7XG5leHBvcnQgdmFyIFBvd2VyMiA9IGdsb2JhbHMuUG93ZXIyO1xuZXhwb3J0IHZhciBQb3dlcjMgPSBnbG9iYWxzLlBvd2VyMztcbmV4cG9ydCB2YXIgUG93ZXI0ID0gZ2xvYmFscy5Qb3dlcjQ7XG5leHBvcnQgdmFyIFR3ZWVuUGx1Z2luID0gZ2xvYmFscy5Ud2VlblBsdWdpbjtcbmV4cG9ydCB2YXIgRXZlbnREaXNwYXRjaGVyID0gbm9uR2xvYmFscy5ldmVudHMuRXZlbnREaXNwYXRjaGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ3NhcC9Ud2VlbkxpdGUuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQXNzZXRzLmpzXG5cbmltcG9ydCBhc3NldHNUb0xvYWQgZnJvbSAnLi9hc3NldC1saXN0JztcbmltcG9ydCBhbGZyaWQsIHsgR0xUZXh0dXJlLCBHTEN1YmVUZXh0dXJlLCBNZXNoLCBPYmpMb2FkZXIgfSBmcm9tICdhbGZyaWQnO1xuXG5jb25zdCBBc3NldHMgPSB7fTtcbmxldCBfYXNzZXRzID0gW107XG5cbmNvbnN0IGdldEFzc2V0ID0gZnVuY3Rpb24oaWQpIHtcblx0cmV0dXJuIGFzc2V0cy5maW5kKCAoYSkgPT4gYS5pZCA9PT0gaWQpLmZpbGU7XG59XG5cbmNvbnN0IGdldEV4dGVuc2lvbiA9IGZ1bmN0aW9uKG1GaWxlKSB7XG5cdGNvbnN0IGFyeSA9IG1GaWxlLnNwbGl0KCcuJyk7XG5cdHJldHVybiBhcnlbYXJ5Lmxlbmd0aCAtIDFdO1xufVxuXG5Bc3NldHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRsZXQgaGRyQ3ViZW1hcHMgPSB7fTtcblx0X2Fzc2V0cyA9IGFzc2V0c1RvTG9hZC5tYXAoKG8pPT4ge1xuXHRcdGNvbnN0IGV4dCA9IGdldEV4dGVuc2lvbihvLnVybCk7XG5cdFx0Y29uc3QgZmlsZSA9IGdldEFzc2V0KG8uaWQpO1xuXHRcdGxldCB0ZXh0dXJlO1xuXG5cdFx0c3dpdGNoKGV4dCkge1xuXHRcdFx0Y2FzZSAnanBnJzpcblx0XHRcdGNhc2UgJ3BuZyc6XG5cdFx0XHRcdHRleHR1cmUgPSBuZXcgR0xUZXh0dXJlKGZpbGUpO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGlkOm8uaWQsXG5cdFx0XHRcdFx0ZmlsZTp0ZXh0dXJlXG5cdFx0XHRcdH07XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdoZHInOlxuXHRcdFx0XHRsZXQgY3ViZW1hcE5hbWUgPSBvLmlkLnNwbGl0KCdfJylbMF07XG5cdFx0XHRcdHRleHR1cmUgPSBhbGZyaWQuSERSTG9hZGVyLnBhcnNlKGZpbGUpO1xuXG5cdFx0XHRcdGNvbnN0IG9Bc3NldCA9IHtcblx0XHRcdFx0XHRpZDpvLmlkLFxuXHRcdFx0XHRcdGZpbGU6dGV4dHVyZVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGlmKCFoZHJDdWJlbWFwc1tjdWJlbWFwTmFtZV0pIHtcblx0XHRcdFx0XHRoZHJDdWJlbWFwc1tjdWJlbWFwTmFtZV0gPSBbXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGhkckN1YmVtYXBzW2N1YmVtYXBOYW1lXS5wdXNoKG9Bc3NldCk7XG5cdFx0XHRcdHJldHVybiBvQXNzZXQ7XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdkZHMnOlxuXHRcdFx0XHR0ZXh0dXJlID0gR0xDdWJlVGV4dHVyZS5wYXJzZUREUyhmaWxlKTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpZDpvLmlkLFxuXHRcdFx0XHRcdGZpbGU6dGV4dHVyZVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnb2JqJzpcblx0XHRcdFx0Y29uc3QgbWVzaCA9IE9iakxvYWRlci5wYXJzZShmaWxlKTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpZDpvLmlkLFxuXHRcdFx0XHRcdGZpbGU6bWVzaFxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHR9KTtcblxuXHRmb3IobGV0IHMgaW4gaGRyQ3ViZW1hcHMpIHtcblx0XHRpZihoZHJDdWJlbWFwc1tzXS5sZW5ndGggPT0gNikge1xuXHRcdFx0Y29uc29sZS5sb2coJ0dlbmVyYXRlIEN1YmVtYXAgOicsIHMpO1xuXG5cdFx0XHRjb25zdCBhcnkgPSBbXG5cdFx0XHRcdEFzc2V0cy5nZXQoYCR7c31fcG9zeGApLFxuXHRcdFx0XHRBc3NldHMuZ2V0KGAke3N9X25lZ3hgKSxcblx0XHRcdFx0QXNzZXRzLmdldChgJHtzfV9wb3N5YCksXG5cdFx0XHRcdEFzc2V0cy5nZXQoYCR7c31fbmVneWApLFxuXHRcdFx0XHRBc3NldHMuZ2V0KGAke3N9X3Bvc3pgKSxcblx0XHRcdFx0QXNzZXRzLmdldChgJHtzfV9uZWd6YClcblx0XHRcdF07XG5cblx0XHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgYWxmcmlkLkdMQ3ViZVRleHR1cmUoYXJ5KTtcblx0XHRcdF9hc3NldHMucHVzaCh7XG5cdFx0XHRcdGlkOnMsXG5cdFx0XHRcdGZpbGU6dGV4dHVyZVxuXHRcdFx0fSlcblx0XHR9XG5cdH1cblxuXHRpZihfYXNzZXRzLmxlbmd0aCA+IDApIHtcblx0XHRjb25zb2xlLmRlYnVnKCdBU1NFVFM6Jyk7XG5cdFx0Y29uc29sZS50YWJsZShfYXNzZXRzKTtcdFxuXHR9XG5cdFxufVxuXG5Bc3NldHMuZ2V0ID0gZnVuY3Rpb24obUlkKSB7XG5cdHJldHVybiBfYXNzZXRzLmZpbmQoKGEpID0+IHtcblx0XHRyZXR1cm4gYS5pZCA9PT0gbUlkO1xuXHR9KS5maWxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBBc3NldHM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL0Fzc2V0cy5qcyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImh0bWwsIGJvZHkge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHBvc2l0aW9uOiBzdGF0aWM7XFxuICBiYWNrZ3JvdW5kOiBibGFjazsgfVxcblxcbmh0bWwge1xcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiBub25lO1xcbiAgLW1vei10ZXh0LXNpemUtYWRqdXN0OiBub25lO1xcbiAgdGV4dC1zaXplLWFkanVzdDogbm9uZTsgfVxcblxcbmgxLCBoMiwgaDMsIGg0LCB0ZXh0LCBwIHtcXG4gIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbiAgLW1vei1vc3gtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gIGZvbnQtZmFtaWx5OiAnT3BlbiBTYW5zJywgc2Fucy1zZXJpZjtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxuICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlOyB9XFxuXFxuLmxvYWRpbmctYW5pbSB7XFxuICB3aWR0aDogMTAwcHg7XFxuICBoZWlnaHQ6IDEwMHB4O1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgbGVmdDogNTAlO1xcbiAgdG9wOiA1MCU7XFxuICBtYXJnaW4tbGVmdDogLTUwcHg7XFxuICBtYXJnaW4tdG9wOiAtMTAwcHg7XFxuICB6LWluZGV4OiA5OTk4O1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAxcyBlYXNlLW91dDsgfVxcbiAgLmxvYWRpbmctYW5pbS5jbG9zZSB7XFxuICAgIG9wYWNpdHk6IDA7IH1cXG5cXG4uY29udGFpbmVyIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDsgfVxcblxcbi5hdWRpby10b2dnbGUge1xcbiAgd2lkdGg6IDE4cHg7XFxuICBoZWlnaHQ6IDE4cHg7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB6LWluZGV4OiA5OTk5O1xcbiAgYm90dG9tOiA1JTtcXG4gIGxlZnQ6IDUlO1xcbiAgYmFja2dyb3VuZDogbm9uZTtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIHBhZGRpbmc6IDA7XFxuICBmb250OiBpbmhlcml0O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgb3V0bGluZTogaW5oZXJpdDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAwLCAwLCAwLjEpO1xcbiAgb3BhY2l0eTogLjU7IH1cXG5cXG4uc291bmQtb24ge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCIuLi8uLi9hc3NldHMvY3NzLWltZy9zb3VuZE9uLnBuZ1xcXCIpOyB9XFxuICAuaXNTb3VuZE9uIC5zb3VuZC1vbiB7XFxuICAgIG9wYWNpdHk6IDA7IH1cXG5cXG4uc291bmQtb2ZmIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiLi4vLi4vYXNzZXRzL2Nzcy1pbWcvc291bmRPZmYucG5nXFxcIik7XFxuICBvcGFjaXR5OiAwOyB9XFxuICAuaXNTb3VuZE9uIC5zb3VuZC1vZmYge1xcbiAgICBvcGFjaXR5OiAxOyB9XFxuXFxuLnNvdW5kLWljb24ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYmFja2dyb3VuZC1zaXplOiAxMDAlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAuNXMgZWFzZS1vdXQ7IH1cXG5cXG4uZGVzYyB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICBvcGFjaXR5OiAxO1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgYm90dG9tOiAxMCU7XFxuICB3aWR0aDogMTAwJTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGxldHRlci1zcGFjaW5nOiA1cHg7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IC41cyBlYXNlLW91dDsgfVxcbiAgLmlzTG9hZGluZyAuZGVzYyB7XFxuICAgIG9wYWNpdHk6IDA7IH1cXG4gIC5pc01vYmlsZSAuZGVzYyB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgIG9wYWNpdHk6IDA7IH1cXG4gIC5oYXNJbnRlcmFjdCAuZGVzYyB7XFxuICAgIG9wYWNpdHk6IDA7IH1cXG5cXG4uZnVsbHNjcmVlbiB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiA5OTk5O1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgYm90dG9tOiAxMCU7XFxuICB3aWR0aDogMTAwJTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGJhY2tncm91bmQ6IG5vbmU7XFxuICBib3JkZXI6IG5vbmU7XFxuICBwYWRkaW5nOiAwO1xcbiAgZm9udDogaW5oZXJpdDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIG91dGxpbmU6IGluaGVyaXQ7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgb3BhY2l0eTogMDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGxldHRlci1zcGFjaW5nOiA1cHg7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IC41cyBlYXNlLW91dDtcXG4gIG1hcmdpbi1sZWZ0OiAtOTk5OXB4OyB9XFxuICAuaXNNb2JpbGVDaHJvbWUgLmZ1bGxzY3JlZW4ge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIG9wYWNpdHk6IDE7IH1cXG5cXG4uTWFpbi1DYW52YXMge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB0b3A6IDBweDtcXG4gIGxlZnQ6IDBweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIC8qdXNlci1zZWxlY3Q6bm9uZTsqL1xcbiAgb3BhY2l0eTogMTtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgLjVzIGVhc2Utb3V0IC4yNXM7IH1cXG4gIC5pc0xvYWRpbmcgLk1haW4tQ2FudmFzIHtcXG4gICAgb3BhY2l0eTogMDsgfVxcblxcbmRpdjotd2Via2l0LWZ1bGwtc2NyZWVuIHtcXG4gIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7IH1cXG5cXG5kaXY6LW1vei1mdWxsLXNjcmVlbiB7XFxuICB3aWR0aDogMTAwJSAhaW1wb3J0YW50OyB9XFxuXFxuZGl2Oi1tcy1mdWxsc2NyZWVuIHtcXG4gIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7IH1cXG5cXG5kaXY6ZnVsbHNjcmVlbiB7XFxuICB3aWR0aDogMTAwJSAhaW1wb3J0YW50OyB9XFxuXFxuLyogV2hpbGUgaW4gZnVsbHNjcmVlbiwgaGlkZSBhbnkgY2hpbGRyZW4gd2l0aCBjbGFzcyAndG9oaWRlJyAqL1xcbjotd2Via2l0LWZ1bGwtc2NyZWVuIC50b2hpZGUge1xcbiAgZGlzcGxheTogbm9uZTsgfVxcblxcbjotbW96LWZ1bGwtc2NyZWVuIC50b2hpZGUge1xcbiAgZGlzcGxheTogbm9uZTsgfVxcblxcbjotbXMtZnVsbHNjcmVlbiAudG9oaWRlIHtcXG4gIGRpc3BsYXk6IG5vbmU7IH1cXG5cXG46ZnVsbHNjcmVlbiAudG9oaWRlIHtcXG4gIGRpc3BsYXk6IG5vbmU7IH1cXG5cXG4uY29udGFpbmVyLXVpIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIG9wYWNpdHk6IDA7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IC41cyBlYXNlLW91dDsgfVxcbiAgLmlzT3BlbmVkIC5jb250YWluZXItdWkge1xcbiAgICBvcGFjaXR5OiAxOyB9XFxuXFxuLk1lc3NhZ2Uge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogOTk5O1xcbiAgd2lkdGg6IDEwMCU7XFxuICB0b3A6IGNhbGMoNTAlIC0gNTBweCk7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBsZXR0ZXItc3BhY2luZzogMTFweDtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIG9wYWNpdHk6IDA7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IC41cyBlYXNlLW91dCwgbGV0dGVyLXNwYWNpbmcgLjVzIGVhc2Utb3V0OyB9XFxuICAuaXNMb2FkaW5nIC5NZXNzYWdlIHtcXG4gICAgbGV0dGVyLXNwYWNpbmc6IDEwcHg7XFxuICAgIG9wYWNpdHk6IDE7IH1cXG5cXG4uTG9hZGluZy1CYXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogOTk4O1xcbiAgd2lkdGg6IDAlO1xcbiAgaGVpZ2h0OiAxcHg7XFxuICB0b3A6IDU1JTtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcXG4gIG9wYWNpdHk6IDA7XFxuICB0cmFuc2l0aW9uOiB3aWR0aCAuNXMgZWFzZS1vdXQsIG9wYWNpdHkgLjVzIGVhc2Utb3V0OyB9XFxuICAuaXNMb2FkaW5nIC5Mb2FkaW5nLUJhciB7XFxuICAgIG9wYWNpdHk6IDE7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyP3VybD1mYWxzZSEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vc3JjL3Njc3MvZ2xvYmFsLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaW5kZXguanNcblxuZXhwb3J0IHsgZ2VuZXJhdGVUcmVlcyB9IGZyb20gJy4vZ2VuZXJhdGVUcmVlcyc7XG5leHBvcnQgeyBnZW5lcmF0ZUhlaWdodE1hcCB9IGZyb20gJy4vZ2VuZXJhdGVIZWlnaHRNYXAnO1xuZXhwb3J0IHsgZ2V0Qm91bmRpbmdCb3ggfSBmcm9tICcuL2dldEJvdW5kaW5nQm94JztcbmV4cG9ydCB7IHNhdmVKc29uIH0gZnJvbSAnLi9zYXZlSnNvbic7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvdXRpbHMvaW5kZXguanMiLCJcbmNvbnN0IGFzc2V0c1RvTG9hZCA9IFtcblx0e1wiaWRcIjpcImdyYWRpZW50TWFwXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvZ3JhZGllbnRNYXAucG5nXCIsXCJ0eXBlXCI6XCJwbmdcIn0sXG5cdHtcImlkXCI6XCJub2lzZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL25vaXNlLmpwZ1wiLFwidHlwZVwiOlwianBnXCJ9LFxuXHR7XCJpZFwiOlwiYmVhclwiLFwidXJsXCI6XCJhc3NldHMvb2JqL2JlYXIub2JqXCIsXCJ0eXBlXCI6XCJ0ZXh0XCJ9LFxuXHR7XCJpZFwiOlwiZGVlclwiLFwidXJsXCI6XCJhc3NldHMvb2JqL2RlZXIub2JqXCIsXCJ0eXBlXCI6XCJ0ZXh0XCJ9LFxuXHR7XCJpZFwiOlwibGFwdXRhXCIsXCJ1cmxcIjpcImFzc2V0cy9vYmovbGFwdXRhLm9ialwiLFwidHlwZVwiOlwidGV4dFwifSxcblx0e1wiaWRcIjpcInJvY2tcIixcInVybFwiOlwiYXNzZXRzL29iai9yb2NrLm9ialwiLFwidHlwZVwiOlwidGV4dFwifSxcblx0e1wiaWRcIjpcInRyZWUxXCIsXCJ1cmxcIjpcImFzc2V0cy9vYmovdHJlZTEub2JqXCIsXCJ0eXBlXCI6XCJ0ZXh0XCJ9LFxuXHR7XCJpZFwiOlwidHJlZTJcIixcInVybFwiOlwiYXNzZXRzL29iai90cmVlMi5vYmpcIixcInR5cGVcIjpcInRleHRcIn0sXG5cdHtcImlkXCI6XCJ3aGFsZVwiLFwidXJsXCI6XCJhc3NldHMvb2JqL3doYWxlLm9ialwiLFwidHlwZVwiOlwidGV4dFwifVxuXTtcblxuXG5leHBvcnQgZGVmYXVsdCBhc3NldHNUb0xvYWQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2Fzc2V0LWxpc3QuanMiLCIvLyBTZXR0aW5ncy5qc1xuXG5pbXBvcnQgQ29uZmlnIGZyb20gJy4vQ29uZmlnJztcbmltcG9ydCB1cmwgZnJvbSAnZmFzdC11cmwtcGFyc2VyJztcbnVybC5xdWVyeVN0cmluZyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ3BhcnNlclwiKTtcblxubGV0IGVuYWJsZWQgPSB0cnVlO1xuXG5cbmNvbnN0IHJlbG9hZCA9ICgpID0+IHtcblx0aWYoIWVuYWJsZWQpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0d2luZG93LmxvY2F0aW9uLmhyZWYgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luK3dpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArICc/Y29uZmlnPScgKyBKU09OLnN0cmluZ2lmeShDb25maWcpO1xufVxuXG5jb25zdCByZWZyZXNoID0gKCkgPT4ge1xuXHRpZighZW5hYmxlZCkge1xuXHRcdHJldHVybjtcblx0fVxuXHR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoJ2V4cGVyaW1lbnQnLCAnVGl0bGUnLCB3aW5kb3cubG9jYXRpb24ub3JpZ2luK3dpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArICc/Y29uZmlnPScgKyBKU09OLnN0cmluZ2lmeShDb25maWcpKTtcdFxufVxuXG5cbmxldCBkZWxheUluZGV4ID0gLTE7XG5cbmNvbnN0IGRlbGF5UmVsb2FkID0gKCkgPT4ge1xuXHRpZighZW5hYmxlZCkge1xuXHRcdHJldHVybjtcblx0fVxuXHR3aW5kb3cuY2xlYXJUaW1lb3V0KGRlbGF5SW5kZXgpO1xuXG5cdGRlbGF5SW5kZXggPSB3aW5kb3cuc2V0VGltZW91dCgoKT0+IHtcblx0XHR3aW5kb3cubG9jYXRpb24uaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4rd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgJz9jb25maWc9JyArIEpTT04uc3RyaW5naWZ5KENvbmZpZyk7XG5cdH0sIDUwMCk7XG59XG5cblxuY29uc3QgaW5pdCA9IChtRW5hYmxlZD10cnVlKSA9PiB7XG5cdGVuYWJsZWQgPSBtRW5hYmxlZDtcblx0Y29uc3QgcGFyc2VkID0gdXJsLnBhcnNlKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gsIHRydWUpO1xuXG5cdGlmKHBhcnNlZC5xdWVyeS5jb25maWcpIHtcblx0XHRjb25zdCBvQ29uZmlnID0gSlNPTi5wYXJzZShwYXJzZWQucXVlcnkuY29uZmlnKTtcblxuXHRcdGZvcihsZXQga2V5IGluIG9Db25maWcpIHtcblx0XHRcdENvbmZpZ1trZXldID0gb0NvbmZpZ1trZXldO1xuXHRcdH1cblx0fVxuXG5cdGNvbnNvbGUubG9nKCdDb25maWcgOicsIENvbmZpZyk7XG5cdHJlZnJlc2goKTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCB7XG5cdGVuYWJsZWQsXG5cdHJlbG9hZCxcblx0cmVmcmVzaCxcblx0ZGVsYXlSZWxvYWQsXG5cdGluaXRcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvU2V0dGluZ3MuanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjNCB2U2NyZWVuUG9zaXRpb247XFxudmFyeWluZyBmbG9hdCB2T3BhY2l0eTtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdGZsb2F0IHogPSB2U2NyZWVuUG9zaXRpb24ueiAvIHZTY3JlZW5Qb3NpdGlvbi53O1xcblxcdC8vIHogPSBzbW9vdGhzdGVwKDAuOSwgMS4wLCB6KTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKHogKiAwLjI1KSwgMS4wKTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zaGFkZXJzL2RlcHRoLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVmlld0ZvZy5qc1xuXG5pbXBvcnQgYWxmcmlkLCB7IEdMIH0gZnJvbSAnYWxmcmlkJztcbmltcG9ydCBDb25maWcgZnJvbSAnLi9Db25maWcnO1xuaW1wb3J0IHZzIGZyb20gJ3NoYWRlcnMvZm9nLnZlcnQnO1xuaW1wb3J0IGZzIGZyb20gJ3NoYWRlcnMvZm9nLmZyYWcnO1xuXG5jbGFzcyBWaWV3Rm9nIGV4dGVuZHMgYWxmcmlkLlZpZXcge1xuXHRcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIodnMsIGZzKTtcblx0fVxuXG5cblx0X2luaXQoKSB7XG5cdFx0dGhpcy5yZXNldChDb25maWcubnVtU2xpZGVzKTtcblx0fVxuXG5cblx0cmVzZXQobU51bVNsaWRlcykge1xuXHRcdHRoaXMuX251bVNsaWRlcyA9IG1OdW1TbGlkZXM7XG5cblx0XHRjb25zb2xlLmxvZygnU2V0dGluZyBudW1iZXIgb2Ygc2xpZGVzIDogJywgbU51bVNsaWRlcyk7XG5cblx0XHRsZXQgcyA9IENvbmZpZy5mbG9vclJhZGl1cyAqIDI7XG5cdFx0dGhpcy5tZXNoID0gYWxmcmlkLkdlb20ucGxhbmUocywgcywgMSk7XG5cblx0XHQvLyBjb25zdCB7IG51bVNsaWRlcyB9ID0gQ29uZmlnO1xuXHRcdGNvbnN0IG51bVNsaWRlcyA9IHRoaXMuX251bVNsaWRlcztcblx0XHRjb25zdCBwb3NPZmZzZXQgPSBbXTtcblxuXHRcdGZvcihsZXQgaT0wOyBpPG51bVNsaWRlczsgaSsrKSB7XG5cdFx0XHRsZXQgeiA9IChpL251bVNsaWRlcyAtIDAuNSkgKiBzO1xuXHRcdFx0cG9zT2Zmc2V0LnB1c2goWzAsIHMvMiwgel0pO1xuXHRcdH1cblxuXHRcdHRoaXMub2Zmc2V0ID0gMC4yMztcblx0XHR0aGlzLm1lc2guYnVmZmVySW5zdGFuY2UocG9zT2Zmc2V0LCAnYVBvc09mZnNldCcpO1xuXHRcdGNvbnNvbGUubG9nKHBvc09mZnNldC5sZW5ndGgpO1xuXG5cdH1cblxuXG5cdHJlbmRlcih0ZXh0dXJlMCwgdGV4dHVyZTEsIHBlcmNlbnQpIHtcblx0XHRHTC5lbmFibGVBZGRpdGl2ZUJsZW5kaW5nKCk7XG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oXCJ1T2Zmc2V0XCIsIFwiZmxvYXRcIiwgdGhpcy5vZmZzZXQpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oXCJ1TnVtXCIsIFwiZmxvYXRcIiwgQ29uZmlnLm5vaXNlTnVtKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKFwidU51bVNsaWNlc1wiLCBcImZsb2F0XCIsIHRoaXMuX251bVNsaWRlcyk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybShcInRleHR1cmUwXCIsIFwidW5pZm9ybTFpXCIsIDApO1xuXHRcdHRleHR1cmUwLmJpbmQoMCk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybShcInRleHR1cmUxXCIsIFwidW5pZm9ybTFpXCIsIDEpO1xuXHRcdHRleHR1cmUxLmJpbmQoMSk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybShcInVQZXJjZW50XCIsIFwiZmxvYXRcIiwgcGVyY2VudCk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybShcInVTaXplXCIsIFwiZmxvYXRcIiwgQ29uZmlnLmZsb29yUmFkaXVzKTtcblxuXHRcdEdMLmRyYXcodGhpcy5tZXNoKTtcdFxuXHRcdEdMLmVuYWJsZUFscGhhQmxlbmRpbmcoKTtcblx0fVxuXG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmlld0ZvZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvVmlld0ZvZy5qcyIsIi8qIVxuICogVkVSU0lPTjogMi4wLjJcbiAqIERBVEU6IDIwMTgtMDgtMjdcbiAqIFVQREFURVMgQU5EIERPQ1MgQVQ6IGh0dHA6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDA4LTIwMTgsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgd29yayBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIHNvZnR3YXJlIGFncmVlbWVudCB0aGF0IHdhcyBpc3N1ZWQgd2l0aCB5b3VyIG1lbWJlcnNoaXAuXG4gKiBcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICovXG5pbXBvcnQgVHdlZW5MaXRlLCB7IF9nc1Njb3BlLCBnbG9iYWxzLCBBbmltYXRpb24sIFNpbXBsZVRpbWVsaW5lIH0gZnJvbSBcIi4vVHdlZW5MaXRlLmpzXCI7XG5cbl9nc1Njb3BlLl9nc0RlZmluZShcIlRpbWVsaW5lTGl0ZVwiLCBbXCJjb3JlLkFuaW1hdGlvblwiLFwiY29yZS5TaW1wbGVUaW1lbGluZVwiLFwiVHdlZW5MaXRlXCJdLCBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBUaW1lbGluZUxpdGUgPSBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHRcdFNpbXBsZVRpbWVsaW5lLmNhbGwodGhpcywgdmFycyk7XG5cdFx0XHRcdHRoaXMuX2xhYmVscyA9IHt9O1xuXHRcdFx0XHR0aGlzLmF1dG9SZW1vdmVDaGlsZHJlbiA9ICh0aGlzLnZhcnMuYXV0b1JlbW92ZUNoaWxkcmVuID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5zbW9vdGhDaGlsZFRpbWluZyA9ICh0aGlzLnZhcnMuc21vb3RoQ2hpbGRUaW1pbmcgPT09IHRydWUpO1xuXHRcdFx0XHR0aGlzLl9zb3J0Q2hpbGRyZW4gPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9vblVwZGF0ZSA9IHRoaXMudmFycy5vblVwZGF0ZTtcblx0XHRcdFx0dmFyIHYgPSB0aGlzLnZhcnMsXG5cdFx0XHRcdFx0dmFsLCBwO1xuXHRcdFx0XHRmb3IgKHAgaW4gdikge1xuXHRcdFx0XHRcdHZhbCA9IHZbcF07XG5cdFx0XHRcdFx0aWYgKF9pc0FycmF5KHZhbCkpIGlmICh2YWwuam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0dltwXSA9IHRoaXMuX3N3YXBTZWxmSW5QYXJhbXModmFsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF9pc0FycmF5KHYudHdlZW5zKSkge1xuXHRcdFx0XHRcdHRoaXMuYWRkKHYudHdlZW5zLCAwLCB2LmFsaWduLCB2LnN0YWdnZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3RpbnlOdW0gPSAwLjAwMDAwMDAwMDEsXG5cdFx0XHRUd2VlbkxpdGVJbnRlcm5hbHMgPSBUd2VlbkxpdGUuX2ludGVybmFscyxcblx0XHRcdF9pbnRlcm5hbHMgPSBUaW1lbGluZUxpdGUuX2ludGVybmFscyA9IHt9LFxuXHRcdFx0X2lzU2VsZWN0b3IgPSBUd2VlbkxpdGVJbnRlcm5hbHMuaXNTZWxlY3Rvcixcblx0XHRcdF9pc0FycmF5ID0gVHdlZW5MaXRlSW50ZXJuYWxzLmlzQXJyYXksXG5cdFx0XHRfbGF6eVR3ZWVucyA9IFR3ZWVuTGl0ZUludGVybmFscy5sYXp5VHdlZW5zLFxuXHRcdFx0X2xhenlSZW5kZXIgPSBUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVJlbmRlcixcblx0XHRcdF9nbG9iYWxzID0gX2dzU2NvcGUuX2dzRGVmaW5lLmdsb2JhbHMsXG5cdFx0XHRfY29weSA9IGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdFx0dmFyIGNvcHkgPSB7fSwgcDtcblx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0XHRjb3B5W3BdID0gdmFyc1twXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gY29weTtcblx0XHRcdH0sXG5cdFx0XHRfYXBwbHlDeWNsZSA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldHMsIGkpIHtcblx0XHRcdFx0dmFyIGFsdCA9IHZhcnMuY3ljbGUsXG5cdFx0XHRcdFx0cCwgdmFsO1xuXHRcdFx0XHRmb3IgKHAgaW4gYWx0KSB7XG5cdFx0XHRcdFx0dmFsID0gYWx0W3BdO1xuXHRcdFx0XHRcdHZhcnNbcF0gPSAodHlwZW9mKHZhbCkgPT09IFwiZnVuY3Rpb25cIikgPyB2YWwoaSwgdGFyZ2V0c1tpXSkgOiB2YWxbaSAlIHZhbC5sZW5ndGhdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSB2YXJzLmN5Y2xlO1xuXHRcdFx0fSxcblx0XHRcdF9wYXVzZUNhbGxiYWNrID0gX2ludGVybmFscy5wYXVzZUNhbGxiYWNrID0gZnVuY3Rpb24oKSB7fSxcblx0XHRcdF9zbGljZSA9IGZ1bmN0aW9uKGEpIHsgLy9kb24ndCB1c2UgW10uc2xpY2UgYmVjYXVzZSB0aGF0IGRvZXNuJ3Qgd29yayBpbiBJRTggd2l0aCBhIE5vZGVMaXN0IHRoYXQncyByZXR1cm5lZCBieSBxdWVyeVNlbGVjdG9yQWxsKClcblx0XHRcdFx0dmFyIGIgPSBbXSxcblx0XHRcdFx0XHRsID0gYS5sZW5ndGgsXG5cdFx0XHRcdFx0aTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSAhPT0gbDsgYi5wdXNoKGFbaSsrXSkpO1xuXHRcdFx0XHRyZXR1cm4gYjtcblx0XHRcdH0sXG5cdFx0XHRwID0gVGltZWxpbmVMaXRlLnByb3RvdHlwZSA9IG5ldyBTaW1wbGVUaW1lbGluZSgpO1xuXG5cdFx0VGltZWxpbmVMaXRlLnZlcnNpb24gPSBcIjIuMC4yXCI7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFRpbWVsaW5lTGl0ZTtcblx0XHRwLmtpbGwoKS5fZ2MgPSBwLl9mb3JjaW5nUGxheWhlYWQgPSBwLl9oYXNQYXVzZSA9IGZhbHNlO1xuXG5cdFx0LyogbWlnaHQgdXNlIGxhdGVyLi4uXG5cdFx0Ly90cmFuc2xhdGVzIGEgbG9jYWwgdGltZSBpbnNpZGUgYW4gYW5pbWF0aW9uIHRvIHRoZSBjb3JyZXNwb25kaW5nIHRpbWUgb24gdGhlIHJvb3QvZ2xvYmFsIHRpbWVsaW5lLCBmYWN0b3JpbmcgaW4gYWxsIG5lc3RpbmcgYW5kIHRpbWVTY2FsZXMuXG5cdFx0ZnVuY3Rpb24gbG9jYWxUb0dsb2JhbCh0aW1lLCBhbmltYXRpb24pIHtcblx0XHRcdHdoaWxlIChhbmltYXRpb24pIHtcblx0XHRcdFx0dGltZSA9ICh0aW1lIC8gYW5pbWF0aW9uLl90aW1lU2NhbGUpICsgYW5pbWF0aW9uLl9zdGFydFRpbWU7XG5cdFx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbi50aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aW1lO1xuXHRcdH1cblxuXHRcdC8vdHJhbnNsYXRlcyB0aGUgc3VwcGxpZWQgdGltZSBvbiB0aGUgcm9vdC9nbG9iYWwgdGltZWxpbmUgaW50byB0aGUgY29ycmVzcG9uZGluZyBsb2NhbCB0aW1lIGluc2lkZSBhIHBhcnRpY3VsYXIgYW5pbWF0aW9uLCBmYWN0b3JpbmcgaW4gYWxsIG5lc3RpbmcgYW5kIHRpbWVTY2FsZXNcblx0XHRmdW5jdGlvbiBnbG9iYWxUb0xvY2FsKHRpbWUsIGFuaW1hdGlvbikge1xuXHRcdFx0dmFyIHNjYWxlID0gMTtcblx0XHRcdHRpbWUgLT0gbG9jYWxUb0dsb2JhbCgwLCBhbmltYXRpb24pO1xuXHRcdFx0d2hpbGUgKGFuaW1hdGlvbikge1xuXHRcdFx0XHRzY2FsZSAqPSBhbmltYXRpb24uX3RpbWVTY2FsZTtcblx0XHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uLnRpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRpbWUgKiBzY2FsZTtcblx0XHR9XG5cdFx0Ki9cblxuXHRcdHAudG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzLCBwb3NpdGlvbikge1xuXHRcdFx0dmFyIEVuZ2luZSA9ICh2YXJzLnJlcGVhdCAmJiBfZ2xvYmFscy5Ud2Vlbk1heCkgfHwgVHdlZW5MaXRlO1xuXHRcdFx0cmV0dXJuIGR1cmF0aW9uID8gdGhpcy5hZGQoIG5ldyBFbmdpbmUodGFyZ2V0LCBkdXJhdGlvbiwgdmFycyksIHBvc2l0aW9uKSA6IHRoaXMuc2V0KHRhcmdldCwgdmFycywgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLmZyb20gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzLCBwb3NpdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKCAoKHZhcnMucmVwZWF0ICYmIF9nbG9iYWxzLlR3ZWVuTWF4KSB8fCBUd2VlbkxpdGUpLmZyb20odGFyZ2V0LCBkdXJhdGlvbiwgdmFycyksIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5mcm9tVG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzLCBwb3NpdGlvbikge1xuXHRcdFx0dmFyIEVuZ2luZSA9ICh0b1ZhcnMucmVwZWF0ICYmIF9nbG9iYWxzLlR3ZWVuTWF4KSB8fCBUd2VlbkxpdGU7XG5cdFx0XHRyZXR1cm4gZHVyYXRpb24gPyB0aGlzLmFkZCggRW5naW5lLmZyb21Ubyh0YXJnZXQsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzKSwgcG9zaXRpb24pIDogdGhpcy5zZXQodGFyZ2V0LCB0b1ZhcnMsIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5zdGFnZ2VyVG8gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSkge1xuXHRcdFx0dmFyIHRsID0gbmV3IFRpbWVsaW5lTGl0ZSh7b25Db21wbGV0ZTpvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlUGFyYW1zOm9uQ29tcGxldGVBbGxQYXJhbXMsIGNhbGxiYWNrU2NvcGU6b25Db21wbGV0ZUFsbFNjb3BlLCBzbW9vdGhDaGlsZFRpbWluZzp0aGlzLnNtb290aENoaWxkVGltaW5nfSksXG5cdFx0XHRcdGN5Y2xlID0gdmFycy5jeWNsZSxcblx0XHRcdFx0Y29weSwgaTtcblx0XHRcdGlmICh0eXBlb2YodGFyZ2V0cykgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0dGFyZ2V0cyA9IFR3ZWVuTGl0ZS5zZWxlY3Rvcih0YXJnZXRzKSB8fCB0YXJnZXRzO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0cyA9IHRhcmdldHMgfHwgW107XG5cdFx0XHRpZiAoX2lzU2VsZWN0b3IodGFyZ2V0cykpIHsgLy9zZW5zZXMgaWYgdGhlIHRhcmdldHMgb2JqZWN0IGlzIGEgc2VsZWN0b3IuIElmIGl0IGlzLCB3ZSBzaG91bGQgdHJhbnNsYXRlIGl0IGludG8gYW4gYXJyYXkuXG5cdFx0XHRcdHRhcmdldHMgPSBfc2xpY2UodGFyZ2V0cyk7XG5cdFx0XHR9XG5cdFx0XHRzdGFnZ2VyID0gc3RhZ2dlciB8fCAwO1xuXHRcdFx0aWYgKHN0YWdnZXIgPCAwKSB7XG5cdFx0XHRcdHRhcmdldHMgPSBfc2xpY2UodGFyZ2V0cyk7XG5cdFx0XHRcdHRhcmdldHMucmV2ZXJzZSgpO1xuXHRcdFx0XHRzdGFnZ2VyICo9IC0xO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29weSA9IF9jb3B5KHZhcnMpO1xuXHRcdFx0XHRpZiAoY29weS5zdGFydEF0KSB7XG5cdFx0XHRcdFx0Y29weS5zdGFydEF0ID0gX2NvcHkoY29weS5zdGFydEF0KTtcblx0XHRcdFx0XHRpZiAoY29weS5zdGFydEF0LmN5Y2xlKSB7XG5cdFx0XHRcdFx0XHRfYXBwbHlDeWNsZShjb3B5LnN0YXJ0QXQsIHRhcmdldHMsIGkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY3ljbGUpIHtcblx0XHRcdFx0XHRfYXBwbHlDeWNsZShjb3B5LCB0YXJnZXRzLCBpKTtcblx0XHRcdFx0XHRpZiAoY29weS5kdXJhdGlvbiAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbiA9IGNvcHkuZHVyYXRpb247XG5cdFx0XHRcdFx0XHRkZWxldGUgY29weS5kdXJhdGlvbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGwudG8odGFyZ2V0c1tpXSwgZHVyYXRpb24sIGNvcHksIGkgKiBzdGFnZ2VyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmFkZCh0bCwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnN0YWdnZXJGcm9tID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHZhcnMucnVuQmFja3dhcmRzID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSk7XG5cdFx0fTtcblxuXHRcdHAuc3RhZ2dlckZyb21UbyA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuXHRcdFx0dG9WYXJzLmltbWVkaWF0ZVJlbmRlciA9ICh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlICYmIGZyb21WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSk7XG5cdFx0fTtcblxuXHRcdHAuY2FsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlLCBwb3NpdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKCBUd2VlbkxpdGUuZGVsYXllZENhbGwoMCwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuc2V0ID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzLCBwb3NpdGlvbikge1xuXHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uLCAwLCB0cnVlKTtcblx0XHRcdGlmICh2YXJzLmltbWVkaWF0ZVJlbmRlciA9PSBudWxsKSB7XG5cdFx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHBvc2l0aW9uID09PSB0aGlzLl90aW1lICYmICF0aGlzLl9wYXVzZWQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKCBuZXcgVHdlZW5MaXRlKHRhcmdldCwgMCwgdmFycyksIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0VGltZWxpbmVMaXRlLmV4cG9ydFJvb3QgPSBmdW5jdGlvbih2YXJzLCBpZ25vcmVEZWxheWVkQ2FsbHMpIHtcblx0XHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0aWYgKHZhcnMuc21vb3RoQ2hpbGRUaW1pbmcgPT0gbnVsbCkge1xuXHRcdFx0XHR2YXJzLnNtb290aENoaWxkVGltaW5nID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHZhciB0bCA9IG5ldyBUaW1lbGluZUxpdGUodmFycyksXG5cdFx0XHRcdHJvb3QgPSB0bC5fdGltZWxpbmUsXG5cdFx0XHRcdGhhc05lZ2F0aXZlU3RhcnQsIHRpbWUsXHR0d2VlbiwgbmV4dDtcblx0XHRcdGlmIChpZ25vcmVEZWxheWVkQ2FsbHMgPT0gbnVsbCkge1xuXHRcdFx0XHRpZ25vcmVEZWxheWVkQ2FsbHMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cm9vdC5fcmVtb3ZlKHRsLCB0cnVlKTtcblx0XHRcdHRsLl9zdGFydFRpbWUgPSAwO1xuXHRcdFx0dGwuX3Jhd1ByZXZUaW1lID0gdGwuX3RpbWUgPSB0bC5fdG90YWxUaW1lID0gcm9vdC5fdGltZTtcblx0XHRcdHR3ZWVuID0gcm9vdC5fZmlyc3Q7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRpZiAoIWlnbm9yZURlbGF5ZWRDYWxscyB8fCAhKHR3ZWVuIGluc3RhbmNlb2YgVHdlZW5MaXRlICYmIHR3ZWVuLnRhcmdldCA9PT0gdHdlZW4udmFycy5vbkNvbXBsZXRlKSkge1xuXHRcdFx0XHRcdHRpbWUgPSB0d2Vlbi5fc3RhcnRUaW1lIC0gdHdlZW4uX2RlbGF5O1xuXHRcdFx0XHRcdGlmICh0aW1lIDwgMCkge1xuXHRcdFx0XHRcdFx0aGFzTmVnYXRpdmVTdGFydCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRsLmFkZCh0d2VlbiwgdGltZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0fVxuXHRcdFx0cm9vdC5hZGQodGwsIDApO1xuXHRcdFx0aWYgKGhhc05lZ2F0aXZlU3RhcnQpIHsgLy9jYWxsaW5nIHRvdGFsRHVyYXRpb24oKSB3aWxsIGZvcmNlIHRoZSBhZGp1c3RtZW50IG5lY2Vzc2FyeSB0byBzaGlmdCB0aGUgY2hpbGRyZW4gZm9yd2FyZCBzbyBub25lIG9mIHRoZW0gc3RhcnQgYmVmb3JlIHplcm8sIGFuZCBtb3ZlcyB0aGUgdGltZWxpbmUgYmFja3dhcmRzIHRoZSBzYW1lIGFtb3VudCwgc28gdGhlIHBsYXloZWFkIGlzIHN0aWxsIGFsaWduZWQgd2hlcmUgaXQgc2hvdWxkIGJlIGdsb2JhbGx5LCBidXQgdGhlIHRpbWVsaW5lIGRvZXNuJ3QgaGF2ZSBpbGxlZ2FsIGNoaWxkcmVuIHRoYXQgc3RhcnQgYmVmb3JlIHplcm8uXG5cdFx0XHRcdHRsLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0bDtcblx0XHR9O1xuXG5cdFx0cC5hZGQgPSBmdW5jdGlvbih2YWx1ZSwgcG9zaXRpb24sIGFsaWduLCBzdGFnZ2VyKSB7XG5cdFx0XHR2YXIgY3VyVGltZSwgbCwgaSwgY2hpbGQsIHRsLCBiZWZvcmVSYXdUaW1lO1xuXHRcdFx0aWYgKHR5cGVvZihwb3NpdGlvbikgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uLCAwLCB0cnVlLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFuaW1hdGlvbikpIHtcblx0XHRcdFx0aWYgKCh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB8fCAodmFsdWUgJiYgdmFsdWUucHVzaCAmJiBfaXNBcnJheSh2YWx1ZSkpKSB7XG5cdFx0XHRcdFx0YWxpZ24gPSBhbGlnbiB8fCBcIm5vcm1hbFwiO1xuXHRcdFx0XHRcdHN0YWdnZXIgPSBzdGFnZ2VyIHx8IDA7XG5cdFx0XHRcdFx0Y3VyVGltZSA9IHBvc2l0aW9uO1xuXHRcdFx0XHRcdGwgPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKF9pc0FycmF5KGNoaWxkID0gdmFsdWVbaV0pKSB7XG5cdFx0XHRcdFx0XHRcdGNoaWxkID0gbmV3IFRpbWVsaW5lTGl0ZSh7dHdlZW5zOmNoaWxkfSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLmFkZChjaGlsZCwgY3VyVGltZSk7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKGNoaWxkKSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YoY2hpbGQpICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGFsaWduID09PSBcInNlcXVlbmNlXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRjdXJUaW1lID0gY2hpbGQuX3N0YXJ0VGltZSArIChjaGlsZC50b3RhbER1cmF0aW9uKCkgLyBjaGlsZC5fdGltZVNjYWxlKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChhbGlnbiA9PT0gXCJzdGFydFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGQuX3N0YXJ0VGltZSAtPSBjaGlsZC5kZWxheSgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjdXJUaW1lICs9IHN0YWdnZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hZGRMYWJlbCh2YWx1ZSwgcG9zaXRpb24pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHZhbHVlID0gVHdlZW5MaXRlLmRlbGF5ZWRDYWxsKDAsIHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyhcIkNhbm5vdCBhZGQgXCIgKyB2YWx1ZSArIFwiIGludG8gdGhlIHRpbWVsaW5lOyBpdCBpcyBub3QgYSB0d2VlbiwgdGltZWxpbmUsIGZ1bmN0aW9uLCBvciBzdHJpbmcuXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdFNpbXBsZVRpbWVsaW5lLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCB2YWx1ZSwgcG9zaXRpb24pO1xuXG5cdFx0XHRpZiAodmFsdWUuX3RpbWUpIHsgLy9pbiBjYXNlLCBmb3IgZXhhbXBsZSwgdGhlIF9zdGFydFRpbWUgaXMgbW92ZWQgb24gYSB0d2VlbiB0aGF0IGhhcyBhbHJlYWR5IHJlbmRlcmVkLiBJbWFnaW5lIGl0J3MgYXQgaXRzIGVuZCBzdGF0ZSwgdGhlbiB0aGUgc3RhcnRUaW1lIGlzIG1vdmVkIFdBWSBsYXRlciAoYWZ0ZXIgdGhlIGVuZCBvZiB0aGlzIHRpbWVsaW5lKSwgaXQgc2hvdWxkIHJlbmRlciBhdCBpdHMgYmVnaW5uaW5nLlxuXHRcdFx0XHRjdXJUaW1lID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odmFsdWUudG90YWxEdXJhdGlvbigpLCAodGhpcy5yYXdUaW1lKCkgLSB2YWx1ZS5fc3RhcnRUaW1lKSAqIHZhbHVlLl90aW1lU2NhbGUpKTtcblx0XHRcdFx0aWYgKE1hdGguYWJzKGN1clRpbWUgLSB2YWx1ZS5fdG90YWxUaW1lKSA+IDAuMDAwMDEpIHsgLy9pZiBhbiBvbkNvbXBsZXRlIHJlc3RhcnRzIHRoZSB0d2VlbiBpbiBhIG5lc3RlZCB0aW1lbGluZSwgZm9yIGV4YW1wbGUsIHRoZXJlIGNvdWxkIGJlIGFuIGVuZGxlc3MgbG9vcCB3aXRob3V0IHRoaXMgbG9naWMgKHYyLjAuMiksIGxpa2UgdmFyIG1hc3RlclRMID0gbmV3IFRpbWVsaW5lTWF4KHthdXRvUmVtb3ZlQ2hpbGRyZW46IHRydWV9KSwgdGwgPSBuZXcgVGltZWxpbmVNYXgoKTsgdGwuZXZlbnRDYWxsYmFjayhcIm9uQ29tcGxldGVcIiwgZnVuY3Rpb24oKSB7IHRsLnJlc3RhcnQoKSB9ICk7dGwuZnJvbVRvKCdkaXYnLCAxLjEsIHsgcm90YXRpb246IDAgfSwgeyByb3RhdGlvbjogMzYwIH0sIDApO21hc3RlclRMLmFkZCh0bCk7XG5cdFx0XHRcdFx0dmFsdWUucmVuZGVyKGN1clRpbWUsIGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly9pZiB0aGUgdGltZWxpbmUgaGFzIGFscmVhZHkgZW5kZWQgYnV0IHRoZSBpbnNlcnRlZCB0d2Vlbi90aW1lbGluZSBleHRlbmRzIHRoZSBkdXJhdGlvbiwgd2Ugc2hvdWxkIGVuYWJsZSB0aGlzIHRpbWVsaW5lIGFnYWluIHNvIHRoYXQgaXQgcmVuZGVycyBwcm9wZXJseS4gV2Ugc2hvdWxkIGFsc28gYWxpZ24gdGhlIHBsYXloZWFkIHdpdGggdGhlIHBhcmVudCB0aW1lbGluZSdzIHdoZW4gYXBwcm9wcmlhdGUuXG5cdFx0XHRpZiAodGhpcy5fZ2MgfHwgdGhpcy5fdGltZSA9PT0gdGhpcy5fZHVyYXRpb24pIGlmICghdGhpcy5fcGF1c2VkKSBpZiAodGhpcy5fZHVyYXRpb24gPCB0aGlzLmR1cmF0aW9uKCkpIHtcblx0XHRcdFx0Ly9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3JzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZC4uLlxuXHRcdFx0XHR0bCA9IHRoaXM7XG5cdFx0XHRcdGJlZm9yZVJhd1RpbWUgPSAodGwucmF3VGltZSgpID4gdmFsdWUuX3N0YXJ0VGltZSk7IC8vaWYgdGhlIHR3ZWVuIGlzIHBsYWNlZCBvbiB0aGUgdGltZWxpbmUgc28gdGhhdCBpdCBzdGFydHMgQkVGT1JFIHRoZSBjdXJyZW50IHJhd1RpbWUsIHdlIHNob3VsZCBhbGlnbiB0aGUgcGxheWhlYWQgKG1vdmUgdGhlIHRpbWVsaW5lKS4gVGhpcyBpcyBiZWNhdXNlIHNvbWV0aW1lcyB1c2VycyB3aWxsIGNyZWF0ZSBhIHRpbWVsaW5lLCBsZXQgaXQgZmluaXNoLCBhbmQgbXVjaCBsYXRlciBhcHBlbmQgYSB0d2VlbiBhbmQgZXhwZWN0IGl0IHRvIHJ1biBpbnN0ZWFkIG9mIGp1bXBpbmcgdG8gaXRzIGVuZCBzdGF0ZS4gV2hpbGUgdGVjaG5pY2FsbHkgb25lIGNvdWxkIGFyZ3VlIHRoYXQgaXQgc2hvdWxkIGp1bXAgdG8gaXRzIGVuZCBzdGF0ZSwgdGhhdCdzIG5vdCB3aGF0IHVzZXJzIGludHVpdGl2ZWx5IGV4cGVjdC5cblx0XHRcdFx0d2hpbGUgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdGlmIChiZWZvcmVSYXdUaW1lICYmIHRsLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHRcdFx0dGwudG90YWxUaW1lKHRsLl90b3RhbFRpbWUsIHRydWUpOyAvL21vdmVzIHRoZSB0aW1lbGluZSAoc2hpZnRzIGl0cyBzdGFydFRpbWUpIGlmIG5lY2Vzc2FyeSwgYW5kIGFsc28gZW5hYmxlcyBpdC5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRsLl9nYykge1xuXHRcdFx0XHRcdFx0dGwuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bCA9IHRsLl90aW1lbGluZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5yZW1vdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQW5pbWF0aW9uKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZSh2YWx1ZSwgZmFsc2UpO1xuXHRcdFx0XHR2YXIgdGwgPSB2YWx1ZS5fdGltZWxpbmUgPSB2YWx1ZS52YXJzLnVzZUZyYW1lcyA/IEFuaW1hdGlvbi5fcm9vdEZyYW1lc1RpbWVsaW5lIDogQW5pbWF0aW9uLl9yb290VGltZWxpbmU7IC8vbm93IHRoYXQgaXQncyByZW1vdmVkLCBkZWZhdWx0IGl0IHRvIHRoZSByb290IHRpbWVsaW5lIHNvIHRoYXQgaWYgaXQgZ2V0cyBwbGF5ZWQgYWdhaW4sIGl0IGRvZXNuJ3QganVtcCBiYWNrIGludG8gdGhpcyB0aW1lbGluZS5cblx0XHRcdFx0dmFsdWUuX3N0YXJ0VGltZSA9ICh2YWx1ZS5fcGF1c2VkID8gdmFsdWUuX3BhdXNlVGltZSA6IHRsLl90aW1lKSAtICgoIXZhbHVlLl9yZXZlcnNlZCA/IHZhbHVlLl90b3RhbFRpbWUgOiB2YWx1ZS50b3RhbER1cmF0aW9uKCkgLSB2YWx1ZS5fdG90YWxUaW1lKSAvIHZhbHVlLl90aW1lU2NhbGUpOyAvL2Vuc3VyZSB0aGF0IGlmIGl0IGdldHMgcGxheWVkIGFnYWluLCB0aGUgdGltaW5nIGlzIGNvcnJlY3QuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5IHx8ICh2YWx1ZSAmJiB2YWx1ZS5wdXNoICYmIF9pc0FycmF5KHZhbHVlKSkpIHtcblx0XHRcdFx0dmFyIGkgPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlKHZhbHVlW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmVMYWJlbCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5raWxsKG51bGwsIHZhbHVlKTtcblx0XHR9O1xuXG5cdFx0cC5fcmVtb3ZlID0gZnVuY3Rpb24odHdlZW4sIHNraXBEaXNhYmxlKSB7XG5cdFx0XHRTaW1wbGVUaW1lbGluZS5wcm90b3R5cGUuX3JlbW92ZS5jYWxsKHRoaXMsIHR3ZWVuLCBza2lwRGlzYWJsZSk7XG5cdFx0XHR2YXIgbGFzdCA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRpZiAoIWxhc3QpIHtcblx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbiA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgPiB0aGlzLmR1cmF0aW9uKCkpIHtcblx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX2R1cmF0aW9uO1xuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90b3RhbER1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuYXBwZW5kID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldE9yTGFiZWwpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCh2YWx1ZSwgdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChudWxsLCBvZmZzZXRPckxhYmVsLCB0cnVlLCB2YWx1ZSkpO1xuXHRcdH07XG5cblx0XHRwLmluc2VydCA9IHAuaW5zZXJ0TXVsdGlwbGUgPSBmdW5jdGlvbih2YWx1ZSwgcG9zaXRpb24sIGFsaWduLCBzdGFnZ2VyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQodmFsdWUsIHBvc2l0aW9uIHx8IDAsIGFsaWduLCBzdGFnZ2VyKTtcblx0XHR9O1xuXG5cdFx0cC5hcHBlbmRNdWx0aXBsZSA9IGZ1bmN0aW9uKHR3ZWVucywgb2Zmc2V0T3JMYWJlbCwgYWxpZ24sIHN0YWdnZXIpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCh0d2VlbnMsIHRoaXMuX3BhcnNlVGltZU9yTGFiZWwobnVsbCwgb2Zmc2V0T3JMYWJlbCwgdHJ1ZSwgdHdlZW5zKSwgYWxpZ24sIHN0YWdnZXIpO1xuXHRcdH07XG5cblx0XHRwLmFkZExhYmVsID0gZnVuY3Rpb24obGFiZWwsIHBvc2l0aW9uKSB7XG5cdFx0XHR0aGlzLl9sYWJlbHNbbGFiZWxdID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5hZGRQYXVzZSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSkge1xuXHRcdFx0dmFyIHQgPSBUd2VlbkxpdGUuZGVsYXllZENhbGwoMCwgX3BhdXNlQ2FsbGJhY2ssIHBhcmFtcywgc2NvcGUgfHwgdGhpcyk7XG5cdFx0XHR0LnZhcnMub25Db21wbGV0ZSA9IHQudmFycy5vblJldmVyc2VDb21wbGV0ZSA9IGNhbGxiYWNrO1xuXHRcdFx0dC5kYXRhID0gXCJpc1BhdXNlXCI7XG5cdFx0XHR0aGlzLl9oYXNQYXVzZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQodCwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnJlbW92ZUxhYmVsID0gZnVuY3Rpb24obGFiZWwpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl9sYWJlbHNbbGFiZWxdO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuZ2V0TGFiZWxUaW1lID0gZnVuY3Rpb24obGFiZWwpIHtcblx0XHRcdHJldHVybiAodGhpcy5fbGFiZWxzW2xhYmVsXSAhPSBudWxsKSA/IHRoaXMuX2xhYmVsc1tsYWJlbF0gOiAtMTtcblx0XHR9O1xuXG5cdFx0cC5fcGFyc2VUaW1lT3JMYWJlbCA9IGZ1bmN0aW9uKHRpbWVPckxhYmVsLCBvZmZzZXRPckxhYmVsLCBhcHBlbmRJZkFic2VudCwgaWdub3JlKSB7XG5cdFx0XHR2YXIgY2xpcHBlZER1cmF0aW9uLCBpO1xuXHRcdFx0Ly9pZiB3ZSdyZSBhYm91dCB0byBhZGQgYSB0d2Vlbi90aW1lbGluZSAob3IgYW4gYXJyYXkgb2YgdGhlbSkgdGhhdCdzIGFscmVhZHkgYSBjaGlsZCBvZiB0aGlzIHRpbWVsaW5lLCB3ZSBzaG91bGQgcmVtb3ZlIGl0IGZpcnN0IHNvIHRoYXQgaXQgZG9lc24ndCBjb250YW1pbmF0ZSB0aGUgZHVyYXRpb24oKS5cblx0XHRcdGlmIChpZ25vcmUgaW5zdGFuY2VvZiBBbmltYXRpb24gJiYgaWdub3JlLnRpbWVsaW5lID09PSB0aGlzKSB7XG5cdFx0XHRcdHRoaXMucmVtb3ZlKGlnbm9yZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGlnbm9yZSAmJiAoKGlnbm9yZSBpbnN0YW5jZW9mIEFycmF5KSB8fCAoaWdub3JlLnB1c2ggJiYgX2lzQXJyYXkoaWdub3JlKSkpKSB7XG5cdFx0XHRcdGkgPSBpZ25vcmUubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAoaWdub3JlW2ldIGluc3RhbmNlb2YgQW5pbWF0aW9uICYmIGlnbm9yZVtpXS50aW1lbGluZSA9PT0gdGhpcykge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmUoaWdub3JlW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNsaXBwZWREdXJhdGlvbiA9ICh0eXBlb2YodGltZU9yTGFiZWwpID09PSBcIm51bWJlclwiICYmICFvZmZzZXRPckxhYmVsKSA/IDAgOiAodGhpcy5kdXJhdGlvbigpID4gOTk5OTk5OTk5OTkpID8gdGhpcy5yZWNlbnQoKS5lbmRUaW1lKGZhbHNlKSA6IHRoaXMuX2R1cmF0aW9uOyAvL2luIGNhc2UgdGhlcmUncyBhIGNoaWxkIHRoYXQgaW5maW5pdGVseSByZXBlYXRzLCB1c2VycyBhbG1vc3QgbmV2ZXIgaW50ZW5kIGZvciB0aGUgaW5zZXJ0aW9uIHBvaW50IG9mIGEgbmV3IGNoaWxkIHRvIGJlIGJhc2VkIG9uIGEgU1VQRVIgbG9uZyB2YWx1ZSBsaWtlIHRoYXQgc28gd2UgY2xpcCBpdCBhbmQgYXNzdW1lIHRoZSBtb3N0IHJlY2VudGx5LWFkZGVkIGNoaWxkJ3MgZW5kVGltZSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHRcdFx0aWYgKHR5cGVvZihvZmZzZXRPckxhYmVsKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChvZmZzZXRPckxhYmVsLCAoYXBwZW5kSWZBYnNlbnQgJiYgdHlwZW9mKHRpbWVPckxhYmVsKSA9PT0gXCJudW1iZXJcIiAmJiB0aGlzLl9sYWJlbHNbb2Zmc2V0T3JMYWJlbF0gPT0gbnVsbCkgPyB0aW1lT3JMYWJlbCAtIGNsaXBwZWREdXJhdGlvbiA6IDAsIGFwcGVuZElmQWJzZW50KTtcblx0XHRcdH1cblx0XHRcdG9mZnNldE9yTGFiZWwgPSBvZmZzZXRPckxhYmVsIHx8IDA7XG5cdFx0XHRpZiAodHlwZW9mKHRpbWVPckxhYmVsKSA9PT0gXCJzdHJpbmdcIiAmJiAoaXNOYU4odGltZU9yTGFiZWwpIHx8IHRoaXMuX2xhYmVsc1t0aW1lT3JMYWJlbF0gIT0gbnVsbCkpIHsgLy9pZiB0aGUgc3RyaW5nIGlzIGEgbnVtYmVyIGxpa2UgXCIxXCIsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgbGFiZWwgd2l0aCB0aGF0IG5hbWUsIG90aGVyd2lzZSBpbnRlcnByZXQgaXQgYXMgYSBudW1iZXIgKGFic29sdXRlIHZhbHVlKS5cblx0XHRcdFx0aSA9IHRpbWVPckxhYmVsLmluZGV4T2YoXCI9XCIpO1xuXHRcdFx0XHRpZiAoaSA9PT0gLTEpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fbGFiZWxzW3RpbWVPckxhYmVsXSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYXBwZW5kSWZBYnNlbnQgPyAodGhpcy5fbGFiZWxzW3RpbWVPckxhYmVsXSA9IGNsaXBwZWREdXJhdGlvbiArIG9mZnNldE9yTGFiZWwpIDogb2Zmc2V0T3JMYWJlbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2xhYmVsc1t0aW1lT3JMYWJlbF0gKyBvZmZzZXRPckxhYmVsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9mZnNldE9yTGFiZWwgPSBwYXJzZUludCh0aW1lT3JMYWJlbC5jaGFyQXQoaS0xKSArIFwiMVwiLCAxMCkgKiBOdW1iZXIodGltZU9yTGFiZWwuc3Vic3RyKGkrMSkpO1xuXHRcdFx0XHR0aW1lT3JMYWJlbCA9IChpID4gMSkgPyB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHRpbWVPckxhYmVsLnN1YnN0cigwLCBpLTEpLCAwLCBhcHBlbmRJZkFic2VudCkgOiBjbGlwcGVkRHVyYXRpb247XG5cdFx0XHR9IGVsc2UgaWYgKHRpbWVPckxhYmVsID09IG51bGwpIHtcblx0XHRcdFx0dGltZU9yTGFiZWwgPSBjbGlwcGVkRHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gTnVtYmVyKHRpbWVPckxhYmVsKSArIG9mZnNldE9yTGFiZWw7XG5cdFx0fTtcblxuXHRcdHAuc2VlayA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKCh0eXBlb2YocG9zaXRpb24pID09PSBcIm51bWJlclwiKSA/IHBvc2l0aW9uIDogdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbiksIChzdXBwcmVzc0V2ZW50cyAhPT0gZmFsc2UpKTtcblx0XHR9O1xuXG5cdFx0cC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXVzZWQodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAuZ290b0FuZFBsYXkgPSBmdW5jdGlvbihwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnBsYXkocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC5nb3RvQW5kU3RvcCA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMucGF1c2UocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdGlmICh0aGlzLl9nYykge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdHRvdGFsRHVyID0gKCF0aGlzLl9kaXJ0eSkgPyB0aGlzLl90b3RhbER1cmF0aW9uIDogdGhpcy50b3RhbER1cmF0aW9uKCksXG5cdFx0XHRcdHByZXZTdGFydCA9IHRoaXMuX3N0YXJ0VGltZSxcblx0XHRcdFx0cHJldlRpbWVTY2FsZSA9IHRoaXMuX3RpbWVTY2FsZSxcblx0XHRcdFx0cHJldlBhdXNlZCA9IHRoaXMuX3BhdXNlZCxcblx0XHRcdFx0dHdlZW4sIGlzQ29tcGxldGUsIG5leHQsIGNhbGxiYWNrLCBpbnRlcm5hbEZvcmNlLCBwYXVzZVR3ZWVuLCBjdXJUaW1lO1xuXHRcdFx0aWYgKHByZXZUaW1lICE9PSB0aGlzLl90aW1lKSB7IC8vaWYgdG90YWxEdXJhdGlvbigpIGZpbmRzIGEgY2hpbGQgd2l0aCBhIG5lZ2F0aXZlIHN0YXJ0VGltZSBhbmQgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSwgdGhpbmdzIGdldCBzaGlmdGVkIGFyb3VuZCBpbnRlcm5hbGx5IHNvIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSB0aW1lIGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgYSB0d2VlbiBzdGFydHMgYXQgLTMwIHdlIG11c3Qgc2hpZnQgRVZFUllUSElORyBmb3J3YXJkIDMwIHNlY29uZHMgYW5kIG1vdmUgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSBiYWNrd2FyZCBieSAzMCBzZWNvbmRzIHNvIHRoYXQgdGhpbmdzIGFsaWduIHdpdGggdGhlIHBsYXloZWFkIChubyBqdW1wKS5cblx0XHRcdFx0dGltZSArPSB0aGlzLl90aW1lIC0gcHJldlRpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGltZSA+PSB0b3RhbER1ciAtIDAuMDAwMDAwMSAmJiB0aW1lID49IDApIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdG90YWxEdXI7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV2ZXJzZWQpIGlmICghdGhpcy5faGFzUGF1c2VkQ2hpbGQoKSkge1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvbkNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9ICEhdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuOyAvL290aGVyd2lzZSwgaWYgdGhlIGFuaW1hdGlvbiBpcyB1bnBhdXNlZC9hY3RpdmF0ZWQgYWZ0ZXIgaXQncyBhbHJlYWR5IGZpbmlzaGVkLCBpdCBkb2Vzbid0IGdldCByZW1vdmVkIGZyb20gdGhlIHBhcmVudCB0aW1lbGluZS5cblx0XHRcdFx0XHRpZiAodGhpcy5fZHVyYXRpb24gPT09IDApIGlmICgodGltZSA8PSAwICYmIHRpbWUgPj0gLTAuMDAwMDAwMSkgfHwgdGhpcy5fcmF3UHJldlRpbWUgPCAwIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSBfdGlueU51bSkgaWYgKHRoaXMuX3Jhd1ByZXZUaW1lICE9PSB0aW1lICYmIHRoaXMuX2ZpcnN0KSB7XG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLl9yYXdQcmV2VGltZSA+IF90aW55TnVtKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9ICh0aGlzLl9kdXJhdGlvbiB8fCAhc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCB0aGlzLl9yYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUgb3IgdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdHRpbWUgPSB0b3RhbER1ciArIDAuMDAwMTsgLy90byBhdm9pZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyAtIHNvbWV0aW1lcyBjaGlsZCB0d2VlbnMvdGltZWxpbmVzIHdlcmUgbm90IGJlaW5nIGZ1bGx5IGNvbXBsZXRlZCAodGhlaXIgcHJvZ3Jlc3MgbWlnaHQgYmUgMC45OTk5OTk5OTk5OTk5OTggaW5zdGVhZCBvZiAxIGJlY2F1c2Ugd2hlbiBfdGltZSAtIHR3ZWVuLl9zdGFydFRpbWUgaXMgcGVyZm9ybWVkLCBmbG9hdGluZyBwb2ludCBlcnJvcnMgd291bGQgcmV0dXJuIGEgdmFsdWUgdGhhdCB3YXMgU0xJR0hUTFkgb2ZmKS4gVHJ5ICg5OTk5OTk5OTk5OTkuNyAtIDk5OTk5OTk5OTk5OSkgKiAxID0gMC42OTk5NTExNzE4NzUgaW5zdGVhZCBvZiAwLjcuXG5cblx0XHRcdH0gZWxzZSBpZiAodGltZSA8IDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMsIHJvdW5kIHN1cGVyIHNtYWxsIHZhbHVlcyB0byAwLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gMDtcblx0XHRcdFx0aWYgKHByZXZUaW1lICE9PSAwIHx8ICh0aGlzLl9kdXJhdGlvbiA9PT0gMCAmJiB0aGlzLl9yYXdQcmV2VGltZSAhPT0gX3RpbnlOdW0gJiYgKHRoaXMuX3Jhd1ByZXZUaW1lID4gMCB8fCAodGltZSA8IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgPj0gMCkpKSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGltZSA8IDApIHtcblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuICYmIHRoaXMuX3JldmVyc2VkKSB7IC8vZW5zdXJlcyBwcm9wZXIgR0MgaWYgYSB0aW1lbGluZSBpcyByZXN1bWVkIGFmdGVyIGl0J3MgZmluaXNoZWQgcmV2ZXJzaW5nLlxuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9yYXdQcmV2VGltZSA+PSAwICYmIHRoaXMuX2ZpcnN0KSB7IC8vd2hlbiBnb2luZyBiYWNrIGJleW9uZCB0aGUgc3RhcnQsIGZvcmNlIGEgcmVuZGVyIHNvIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgdGhhdCBzaXQgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIHJlbmRlciB0aGVpciBzdGFydCB2YWx1ZXMgcHJvcGVybHkuIE90aGVyd2lzZSwgaWYgdGhlIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGxhbmRzIGV4YWN0bHkgYXQgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSwgYW5kIHRoZW4gbW92ZXMgYmFja3dhcmRzLCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIGJlZ2lubmluZyB3b3VsZCBzdGlsbCBiZSBhdCB0aGVpciBlbmQgc3RhdGUuXG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSB0aW1lO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKHRoaXMuX2R1cmF0aW9uIHx8ICFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSBvciB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0XHRpZiAodGltZSA9PT0gMCAmJiBpc0NvbXBsZXRlKSB7IC8vaWYgdGhlcmUncyBhIHplcm8tZHVyYXRpb24gdHdlZW4gYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIGEgdGltZWxpbmUgYW5kIHRoZSBwbGF5aGVhZCBsYW5kcyBFWEFDVExZIGF0IHRpbWUgMCwgdGhhdCB0d2VlbiB3aWxsIGNvcnJlY3RseSByZW5kZXIgaXRzIGVuZCB2YWx1ZXMsIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgdGhlIHRpbWVsaW5lIGFsaXZlIGZvciBvbmUgbW9yZSByZW5kZXIgc28gdGhhdCB0aGUgYmVnaW5uaW5nIHZhbHVlcyByZW5kZXIgcHJvcGVybHkgYXMgdGhlIHBhcmVudCdzIHBsYXloZWFkIGtlZXBzIG1vdmluZyBiZXlvbmQgdGhlIGJlZ2luaW5nLiBJbWFnaW5lIG9iai54IHN0YXJ0cyBhdCAwIGFuZCB0aGVuIHdlIGRvIHRsLnNldChvYmosIHt4OjEwMH0pLnRvKG9iaiwgMSwge3g6MjAwfSkgYW5kIHRoZW4gbGF0ZXIgd2UgdGwucmV2ZXJzZSgpLi4udGhlIGdvYWwgaXMgdG8gaGF2ZSBvYmoueCByZXZlcnQgdG8gMC4gSWYgdGhlIHBsYXloZWFkIGhhcHBlbnMgdG8gbGFuZCBvbiBleGFjdGx5IDAsIHdpdGhvdXQgdGhpcyBjaHVuayBvZiBjb2RlLCBpdCdkIGNvbXBsZXRlIHRoZSB0aW1lbGluZSBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIHJlbmRlcmluZyBxdWV1ZSAobm90IGdvb2QpLlxuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0XHRcdHdoaWxlICh0d2VlbiAmJiB0d2Vlbi5fc3RhcnRUaW1lID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdHdlZW4uX2R1cmF0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0aXNDb21wbGV0ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRpbWUgPSAwOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIChjb3VsZCBjYXVzZSBwcm9ibGVtcyBlc3BlY2lhbGx5IHdpdGggemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSlcblx0XHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICh0aGlzLl9oYXNQYXVzZSAmJiAhdGhpcy5fZm9yY2luZ1BsYXloZWFkICYmICFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRcdGlmICh0aW1lID49IHByZXZUaW1lKSB7XG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHRcdFx0d2hpbGUgKHR3ZWVuICYmIHR3ZWVuLl9zdGFydFRpbWUgPD0gdGltZSAmJiAhcGF1c2VUd2Vlbikge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9kdXJhdGlvbikgaWYgKHR3ZWVuLmRhdGEgPT09IFwiaXNQYXVzZVwiICYmICF0d2Vlbi5yYXRpbyAmJiAhKHR3ZWVuLl9zdGFydFRpbWUgPT09IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgPT09IDApKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IHR3ZWVuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHR3ZWVuID0gdGhpcy5fbGFzdDtcblx0XHRcdFx0XHRcdHdoaWxlICh0d2VlbiAmJiB0d2Vlbi5fc3RhcnRUaW1lID49IHRpbWUgJiYgIXBhdXNlVHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fZHVyYXRpb24pIGlmICh0d2Vlbi5kYXRhID09PSBcImlzUGF1c2VcIiAmJiB0d2Vlbi5fcmF3UHJldlRpbWUgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IHR3ZWVuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX3ByZXY7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwYXVzZVR3ZWVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGltZSA9IHBhdXNlVHdlZW4uX3N0YXJ0VGltZTtcblx0XHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRpbWUgKyAodGhpcy5fY3ljbGUgKiAodGhpcy5fdG90YWxEdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdH1cblx0XHRcdGlmICgodGhpcy5fdGltZSA9PT0gcHJldlRpbWUgfHwgIXRoaXMuX2ZpcnN0KSAmJiAhZm9yY2UgJiYgIWludGVybmFsRm9yY2UgJiYgIXBhdXNlVHdlZW4pIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0dGVkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9hY3RpdmUpIGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMuX3RpbWUgIT09IHByZXZUaW1lICYmIHRpbWUgPiAwKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7ICAvL3NvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyB0aGUgdGltZWxpbmUgKGFzIG9wcG9zZWQgdG8gdGhlIHBhcmVudCB0aW1lbGluZSByZW5kZXJpbmcgaXQpLCBpdCBpcyBmb3JjZWQgdG8gcmUtcmVuZGVyIGFuZCBhbGlnbiBpdCB3aXRoIHRoZSBwcm9wZXIgdGltZS9mcmFtZSBvbiB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUuIE1heWJlIHRoZSB0aW1lbGluZSBhbHJlYWR5IGZpbmlzaGVkIGJ1dCB0aGUgdXNlciBtYW51YWxseSByZS1yZW5kZXJzIGl0IGFzIGhhbGZ3YXkgZG9uZSwgZm9yIGV4YW1wbGUuXG5cdFx0XHR9XG5cblx0XHRcdGlmIChwcmV2VGltZSA9PT0gMCkgaWYgKHRoaXMudmFycy5vblN0YXJ0KSBpZiAodGhpcy5fdGltZSAhPT0gMCB8fCAhdGhpcy5fZHVyYXRpb24pIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRjdXJUaW1lID0gdGhpcy5fdGltZTtcblx0XHRcdGlmIChjdXJUaW1lID49IHByZXZUaW1lKSB7XG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdG5leHQgPSB0d2Vlbi5fbmV4dDsgLy9yZWNvcmQgaXQgaGVyZSBiZWNhdXNlIHRoZSB2YWx1ZSBjb3VsZCBjaGFuZ2UgYWZ0ZXIgcmVuZGVyaW5nLi4uXG5cdFx0XHRcdFx0aWYgKGN1clRpbWUgIT09IHRoaXMuX3RpbWUgfHwgKHRoaXMuX3BhdXNlZCAmJiAhcHJldlBhdXNlZCkpIHsgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fYWN0aXZlIHx8ICh0d2Vlbi5fc3RhcnRUaW1lIDw9IGN1clRpbWUgJiYgIXR3ZWVuLl9wYXVzZWQgJiYgIXR3ZWVuLl9nYykpIHtcblx0XHRcdFx0XHRcdGlmIChwYXVzZVR3ZWVuID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBhdXNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4gPSB0aGlzLl9sYXN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRuZXh0ID0gdHdlZW4uX3ByZXY7IC8vcmVjb3JkIGl0IGhlcmUgYmVjYXVzZSB0aGUgdmFsdWUgY291bGQgY2hhbmdlIGFmdGVyIHJlbmRlcmluZy4uLlxuXHRcdFx0XHRcdGlmIChjdXJUaW1lICE9PSB0aGlzLl90aW1lIHx8ICh0aGlzLl9wYXVzZWQgJiYgIXByZXZQYXVzZWQpKSB7IC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4uX2FjdGl2ZSB8fCAodHdlZW4uX3N0YXJ0VGltZSA8PSBwcmV2VGltZSAmJiAhdHdlZW4uX3BhdXNlZCAmJiAhdHdlZW4uX2djKSkge1xuXHRcdFx0XHRcdFx0aWYgKHBhdXNlVHdlZW4gPT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSB0d2Vlbi5fcHJldjsgLy90aGUgbGlua2VkIGxpc3QgaXMgb3JnYW5pemVkIGJ5IF9zdGFydFRpbWUsIHRodXMgaXQncyBwb3NzaWJsZSB0aGF0IGEgdHdlZW4gY291bGQgc3RhcnQgQkVGT1JFIHRoZSBwYXVzZSBhbmQgZW5kIGFmdGVyIGl0LCBpbiB3aGljaCBjYXNlIGl0IHdvdWxkIGJlIHBvc2l0aW9uZWQgYmVmb3JlIHRoZSBwYXVzZSB0d2VlbiBpbiB0aGUgbGlua2VkIGxpc3QsIGJ1dCB3ZSBzaG91bGQgcmVuZGVyIGl0IGJlZm9yZSB3ZSBwYXVzZSgpIHRoZSB0aW1lbGluZSBhbmQgY2Vhc2UgcmVuZGVyaW5nLiBUaGlzIGlzIG9ubHkgYSBjb25jZXJuIHdoZW4gZ29pbmcgaW4gcmV2ZXJzZS5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKHBhdXNlVHdlZW4gJiYgcGF1c2VUd2Vlbi5lbmRUaW1lKCkgPiB0aGlzLl90aW1lKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VUd2Vlbi5yZW5kZXIoIChwYXVzZVR3ZWVuLl9yZXZlcnNlZCA/IHBhdXNlVHdlZW4udG90YWxEdXJhdGlvbigpIC0gKCh0aW1lIC0gcGF1c2VUd2Vlbi5fc3RhcnRUaW1lKSAqIHBhdXNlVHdlZW4uX3RpbWVTY2FsZSkgOiAodGltZSAtIHBhdXNlVHdlZW4uX3N0YXJ0VGltZSkgKiBwYXVzZVR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSBwYXVzZVR3ZWVuLl9wcmV2O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBhdXNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fb25VcGRhdGUpIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gYSB0aW1lbGluZSBmaW5pc2hlcywgdXNlcnMgZXhwZWN0IHRoaW5ncyB0byBoYXZlIHJlbmRlcmVkIGZ1bGx5LiBJbWFnaW5lIGFuIG9uVXBkYXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIik7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjYWxsYmFjaykgaWYgKCF0aGlzLl9nYykgaWYgKHByZXZTdGFydCA9PT0gdGhpcy5fc3RhcnRUaW1lIHx8IHByZXZUaW1lU2NhbGUgIT09IHRoaXMuX3RpbWVTY2FsZSkgaWYgKHRoaXMuX3RpbWUgPT09IDAgfHwgdG90YWxEdXIgPj0gdGhpcy50b3RhbER1cmF0aW9uKCkpIHsgLy9pZiBvbmUgb2YgdGhlIHR3ZWVucyB0aGF0IHdhcyByZW5kZXJlZCBhbHRlcmVkIHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUgKGxpa2UgaWYgYW4gb25Db21wbGV0ZSByZXZlcnNlZCB0aGUgdGltZWxpbmUpLCBpdCBwcm9iYWJseSBpc24ndCBjb21wbGV0ZS4gSWYgaXQgaXMsIGRvbid0IHdvcnJ5LCBiZWNhdXNlIHdoYXRldmVyIGNhbGwgYWx0ZXJlZCB0aGUgc3RhcnRUaW1lIHdvdWxkIGNvbXBsZXRlIGlmIGl0IHdhcyBuZWNlc3NhcnkgYXQgdGhlIG5ldyB0aW1lLiBUaGUgb25seSBleGNlcHRpb24gaXMgdGhlIHRpbWVTY2FsZSBwcm9wZXJ0eS4gQWxzbyBjaGVjayBfZ2MgYmVjYXVzZSB0aGVyZSdzIGEgY2hhbmNlIHRoYXQga2lsbCgpIGNvdWxkIGJlIGNhbGxlZCBpbiBhbiBvblVwZGF0ZVxuXHRcdFx0XHRpZiAoaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvbkNvbXBsZXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblx0XHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnZhcnNbY2FsbGJhY2tdKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soY2FsbGJhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuX2hhc1BhdXNlZENoaWxkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRpZiAodHdlZW4uX3BhdXNlZCB8fCAoKHR3ZWVuIGluc3RhbmNlb2YgVGltZWxpbmVMaXRlKSAmJiB0d2Vlbi5faGFzUGF1c2VkQ2hpbGQoKSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHRwLmdldENoaWxkcmVuID0gZnVuY3Rpb24obmVzdGVkLCB0d2VlbnMsIHRpbWVsaW5lcywgaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0aWdub3JlQmVmb3JlVGltZSA9IGlnbm9yZUJlZm9yZVRpbWUgfHwgLTk5OTk5OTk5OTk7XG5cdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0LFxuXHRcdFx0XHRjbnQgPSAwO1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lIDwgaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0XHRcdC8vZG8gbm90aGluZ1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuIGluc3RhbmNlb2YgVHdlZW5MaXRlKSB7XG5cdFx0XHRcdFx0aWYgKHR3ZWVucyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0aW1lbGluZXMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobmVzdGVkICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0YSA9IGEuY29uY2F0KHR3ZWVuLmdldENoaWxkcmVuKHRydWUsIHR3ZWVucywgdGltZWxpbmVzKSk7XG5cdFx0XHRcdFx0XHRjbnQgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblx0XHRwLmdldFR3ZWVuc09mID0gZnVuY3Rpb24odGFyZ2V0LCBuZXN0ZWQpIHtcblx0XHRcdHZhciBkaXNhYmxlZCA9IHRoaXMuX2djLFxuXHRcdFx0XHRhID0gW10sXG5cdFx0XHRcdGNudCA9IDAsXG5cdFx0XHRcdHR3ZWVucywgaTtcblx0XHRcdGlmIChkaXNhYmxlZCkge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIHRydWUpOyAvL2dldFR3ZWVuc09mKCkgZmlsdGVycyBvdXQgZGlzYWJsZWQgdHdlZW5zLCBhbmQgd2UgaGF2ZSB0byBtYXJrIHRoZW0gYXMgX2djID0gdHJ1ZSB3aGVuIHRoZSB0aW1lbGluZSBjb21wbGV0ZXMgaW4gb3JkZXIgdG8gYWxsb3cgY2xlYW4gZ2FyYmFnZSBjb2xsZWN0aW9uLCBzbyB0ZW1wb3JhcmlseSByZS1lbmFibGUgdGhlIHRpbWVsaW5lIGhlcmUuXG5cdFx0XHR9XG5cdFx0XHR0d2VlbnMgPSBUd2VlbkxpdGUuZ2V0VHdlZW5zT2YodGFyZ2V0KTtcblx0XHRcdGkgPSB0d2VlbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmICh0d2VlbnNbaV0udGltZWxpbmUgPT09IHRoaXMgfHwgKG5lc3RlZCAmJiB0aGlzLl9jb250YWlucyh0d2VlbnNbaV0pKSkge1xuXHRcdFx0XHRcdGFbY250KytdID0gdHdlZW5zW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGlzYWJsZWQpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXG5cdFx0cC5yZWNlbnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZWNlbnQ7XG5cdFx0fTtcblxuXHRcdHAuX2NvbnRhaW5zID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHRcdHZhciB0bCA9IHR3ZWVuLnRpbWVsaW5lO1xuXHRcdFx0d2hpbGUgKHRsKSB7XG5cdFx0XHRcdGlmICh0bCA9PT0gdGhpcykge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRsID0gdGwudGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdHAuc2hpZnRDaGlsZHJlbiA9IGZ1bmN0aW9uKGFtb3VudCwgYWRqdXN0TGFiZWxzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRpZ25vcmVCZWZvcmVUaW1lID0gaWdub3JlQmVmb3JlVGltZSB8fCAwO1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3QsXG5cdFx0XHRcdGxhYmVscyA9IHRoaXMuX2xhYmVscyxcblx0XHRcdFx0cDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRpZiAodHdlZW4uX3N0YXJ0VGltZSA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRcdFx0dHdlZW4uX3N0YXJ0VGltZSArPSBhbW91bnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdH1cblx0XHRcdGlmIChhZGp1c3RMYWJlbHMpIHtcblx0XHRcdFx0Zm9yIChwIGluIGxhYmVscykge1xuXHRcdFx0XHRcdGlmIChsYWJlbHNbcF0gPj0gaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0XHRcdFx0bGFiZWxzW3BdICs9IGFtb3VudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24odmFycywgdGFyZ2V0KSB7XG5cdFx0XHRpZiAoIXZhcnMgJiYgIXRhcmdldCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHR3ZWVucyA9ICghdGFyZ2V0KSA/IHRoaXMuZ2V0Q2hpbGRyZW4odHJ1ZSwgdHJ1ZSwgZmFsc2UpIDogdGhpcy5nZXRUd2VlbnNPZih0YXJnZXQpLFxuXHRcdFx0XHRpID0gdHdlZW5zLmxlbmd0aCxcblx0XHRcdFx0Y2hhbmdlZCA9IGZhbHNlO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmICh0d2VlbnNbaV0uX2tpbGwodmFycywgdGFyZ2V0KSkge1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9O1xuXG5cdFx0cC5jbGVhciA9IGZ1bmN0aW9uKGxhYmVscykge1xuXHRcdFx0dmFyIHR3ZWVucyA9IHRoaXMuZ2V0Q2hpbGRyZW4oZmFsc2UsIHRydWUsIHRydWUpLFxuXHRcdFx0XHRpID0gdHdlZW5zLmxlbmd0aDtcblx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgPSAwO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHR3ZWVuc1tpXS5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxhYmVscyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fbGFiZWxzID0ge307XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5pbnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHR0d2Vlbi5pbnZhbGlkYXRlKCk7XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQW5pbWF0aW9uLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7O1xuXHRcdH07XG5cblx0XHRwLl9lbmFibGVkID0gZnVuY3Rpb24oZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpIHtcblx0XHRcdGlmIChlbmFibGVkID09PSB0aGlzLl9nYykge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0dHdlZW4uX2VuYWJsZWQoZW5hYmxlZCwgdHJ1ZSk7XG5cdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFNpbXBsZVRpbWVsaW5lLnByb3RvdHlwZS5fZW5hYmxlZC5jYWxsKHRoaXMsIGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKTtcblx0XHR9O1xuXG5cdFx0cC50b3RhbFRpbWUgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgdW5jYXBwZWQpIHtcblx0XHRcdHRoaXMuX2ZvcmNpbmdQbGF5aGVhZCA9IHRydWU7XG5cdFx0XHR2YXIgdmFsID0gQW5pbWF0aW9uLnByb3RvdHlwZS50b3RhbFRpbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuX2ZvcmNpbmdQbGF5aGVhZCA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9O1xuXG5cdFx0cC5kdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0dGhpcy50b3RhbER1cmF0aW9uKCk7IC8vanVzdCB0cmlnZ2VycyByZWNhbGN1bGF0aW9uXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuZHVyYXRpb24oKSAhPT0gMCAmJiB2YWx1ZSAhPT0gMCkge1xuXHRcdFx0XHR0aGlzLnRpbWVTY2FsZSh0aGlzLl9kdXJhdGlvbiAvIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHRcdHZhciBtYXggPSAwLFxuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9sYXN0LFxuXHRcdFx0XHRcdFx0cHJldlN0YXJ0ID0gOTk5OTk5OTk5OTk5LFxuXHRcdFx0XHRcdFx0cHJldiwgZW5kO1xuXHRcdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdFx0cHJldiA9IHR3ZWVuLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGluIGNhc2UgdGhlIHR3ZWVuIGNoYW5nZXMgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlLi4uXG5cdFx0XHRcdFx0XHRpZiAodHdlZW4uX2RpcnR5KSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnRvdGFsRHVyYXRpb24oKTsgLy9jb3VsZCBjaGFuZ2UgdGhlIHR3ZWVuLl9zdGFydFRpbWUsIHNvIG1ha2Ugc3VyZSB0aGUgdHdlZW4ncyBjYWNoZSBpcyBjbGVhbiBiZWZvcmUgYW5hbHl6aW5nIGl0LlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPiBwcmV2U3RhcnQgJiYgdGhpcy5fc29ydENoaWxkcmVuICYmICF0d2Vlbi5fcGF1c2VkICYmICF0aGlzLl9jYWxjdWxhdGluZ0R1cmF0aW9uKSB7IC8vaW4gY2FzZSBvbmUgb2YgdGhlIHR3ZWVucyBzaGlmdGVkIG91dCBvZiBvcmRlciwgaXQgbmVlZHMgdG8gYmUgcmUtaW5zZXJ0ZWQgaW50byB0aGUgY29ycmVjdCBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2Vcblx0XHRcdFx0XHRcdFx0dGhpcy5fY2FsY3VsYXRpbmdEdXJhdGlvbiA9IDE7IC8vcHJldmVudCBlbmRsZXNzIHJlY3Vyc2l2ZSBjYWxscyAtIHRoZXJlIGFyZSBtZXRob2RzIHRoYXQgZ2V0IHRyaWdnZXJlZCB0aGF0IGNoZWNrIGR1cmF0aW9uL3RvdGFsRHVyYXRpb24gd2hlbiB3ZSBhZGQoKSwgbGlrZSBfcGFyc2VUaW1lT3JMYWJlbCgpLlxuXHRcdFx0XHRcdFx0XHR0aGlzLmFkZCh0d2VlbiwgdHdlZW4uX3N0YXJ0VGltZSAtIHR3ZWVuLl9kZWxheSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2NhbGN1bGF0aW5nRHVyYXRpb24gPSAwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cHJldlN0YXJ0ID0gdHdlZW4uX3N0YXJ0VGltZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lIDwgMCAmJiAhdHdlZW4uX3BhdXNlZCkgeyAvL2NoaWxkcmVuIGFyZW4ndCBhbGxvd2VkIHRvIGhhdmUgbmVnYXRpdmUgc3RhcnRUaW1lcyB1bmxlc3Mgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSwgc28gYWRqdXN0IGhlcmUgaWYgb25lIGlzIGZvdW5kLlxuXHRcdFx0XHRcdFx0XHRtYXggLT0gdHdlZW4uX3N0YXJ0VGltZTtcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lICs9IHR3ZWVuLl9zdGFydFRpbWUgLyB0aGlzLl90aW1lU2NhbGU7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fdGltZSAtPSB0d2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSAtPSB0d2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lIC09IHR3ZWVuLl9zdGFydFRpbWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGhpcy5zaGlmdENoaWxkcmVuKC10d2Vlbi5fc3RhcnRUaW1lLCBmYWxzZSwgLTk5OTk5OTk5OTkpO1xuXHRcdFx0XHRcdFx0XHRwcmV2U3RhcnQgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZW5kID0gdHdlZW4uX3N0YXJ0VGltZSArICh0d2Vlbi5fdG90YWxEdXJhdGlvbiAvIHR3ZWVuLl90aW1lU2NhbGUpO1xuXHRcdFx0XHRcdFx0aWYgKGVuZCA+IG1heCkge1xuXHRcdFx0XHRcdFx0XHRtYXggPSBlbmQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0d2VlbiA9IHByZXY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbiA9IG1heDtcblx0XHRcdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b3RhbER1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh2YWx1ZSAmJiB0aGlzLnRvdGFsRHVyYXRpb24oKSkgPyB0aGlzLnRpbWVTY2FsZSh0aGlzLl90b3RhbER1cmF0aW9uIC8gdmFsdWUpIDogdGhpcztcblx0XHR9O1xuXG5cdFx0cC5wYXVzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCF2YWx1ZSkgeyAvL2lmIHRoZXJlJ3MgYSBwYXVzZSBkaXJlY3RseSBhdCB0aGUgc3BvdCBmcm9tIHdoZXJlIHdlJ3JlIHVucGF1c2luZywgc2tpcCBpdC5cblx0XHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3QsXG5cdFx0XHRcdFx0dGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lID09PSB0aW1lICYmIHR3ZWVuLmRhdGEgPT09IFwiaXNQYXVzZVwiKSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi5fcmF3UHJldlRpbWUgPSAwOyAvL3JlbWVtYmVyLCBfcmF3UHJldlRpbWUgaXMgaG93IHplcm8tZHVyYXRpb24gdHdlZW5zL2NhbGxiYWNrcyBzZW5zZSBkaXJlY3Rpb25hbGl0eSBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIGZpcmUuIElmIF9yYXdQcmV2VGltZSBpcyB0aGUgc2FtZSBhcyBfc3RhcnRUaW1lIG9uIHRoZSBuZXh0IHJlbmRlciwgaXQgd29uJ3QgZmlyZS5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEFuaW1hdGlvbi5wcm90b3R5cGUucGF1c2VkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudXNlc0ZyYW1lcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRsID0gdGhpcy5fdGltZWxpbmU7XG5cdFx0XHR3aGlsZSAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdHRsID0gdGwuX3RpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0bCA9PT0gQW5pbWF0aW9uLl9yb290RnJhbWVzVGltZWxpbmUpO1xuXHRcdH07XG5cblx0XHRwLnJhd1RpbWUgPSBmdW5jdGlvbih3cmFwUmVwZWF0cykge1xuXHRcdFx0cmV0dXJuICh3cmFwUmVwZWF0cyAmJiAodGhpcy5fcGF1c2VkIHx8ICh0aGlzLl9yZXBlYXQgJiYgdGhpcy50aW1lKCkgPiAwICYmIHRoaXMudG90YWxQcm9ncmVzcygpIDwgMSkpKSA/IHRoaXMuX3RvdGFsVGltZSAlICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KSA6IHRoaXMuX3BhdXNlZCA/IHRoaXMuX3RvdGFsVGltZSA6ICh0aGlzLl90aW1lbGluZS5yYXdUaW1lKHdyYXBSZXBlYXRzKSAtIHRoaXMuX3N0YXJ0VGltZSkgKiB0aGlzLl90aW1lU2NhbGU7XG5cdFx0fTtcblxuXHRcdHJldHVybiBUaW1lbGluZUxpdGU7XG5cblx0fSwgdHJ1ZSk7XG5cbmV4cG9ydCB2YXIgVGltZWxpbmVMaXRlID0gZ2xvYmFscy5UaW1lbGluZUxpdGU7XG5leHBvcnQgeyBUaW1lbGluZUxpdGUgYXMgZGVmYXVsdCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ3NhcC9UaW1lbGluZUxpdGUuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygyMCk7XG59XG5cbkVtaXR0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcbkVtaXR0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRW1pdHRlcjtcblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnModHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXNzZXRzLWxvYWRlci9zcmMvZW1pdHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtYnM6IDAsXG4gICAgc2VjczogMCxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKHJlcXVlc3QsIHN0YXJ0VGltZSwgdXJsLCBsb2cpIHtcbiAgICAgICAgdmFyIGxlbmd0aDtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSByZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuICAgICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gaGVhZGVycy5tYXRjaCgvY29udGVudC1sZW5ndGg6IChcXGQrKS9pKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB2YXIgbGVuZ3RoID0gcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1MZW5ndGgnKTtcbiAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gcGFyc2VJbnQobGVuZ3RoLCAxMCk7XG4gICAgICAgICAgICB2YXIgbWJzID0gbGVuZ3RoIC8gMTAyNCAvIDEwMjQ7XG4gICAgICAgICAgICB2YXIgc2VjcyA9IChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwMDA7XG4gICAgICAgICAgICB0aGlzLnNlY3MgKz0gc2VjcztcbiAgICAgICAgICAgIHRoaXMubWJzICs9IG1icztcbiAgICAgICAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZyh1cmwsIG1icywgc2Vjcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihsb2cpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybi5jYWxsKGNvbnNvbGUsICdDYW5cXCd0IGdldCBDb250ZW50LUxlbmd0aDonLCB1cmwpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBsb2c6IGZ1bmN0aW9uKHVybCwgbWJzLCBzZWNzKSB7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIHZhciBmaWxlID0gJ0ZpbGUgbG9hZGVkOiAnICtcbiAgICAgICAgICAgICAgICB1cmwuc3Vic3RyKHVybC5sYXN0SW5kZXhPZignLycpICsgMSkgK1xuICAgICAgICAgICAgICAgICcgc2l6ZTonICsgbWJzLnRvRml4ZWQoMikgKyAnbWInICtcbiAgICAgICAgICAgICAgICAnIHRpbWU6JyArIHNlY3MudG9GaXhlZCgyKSArICdzJyArXG4gICAgICAgICAgICAgICAgJyBzcGVlZDonICsgKG1icyAvIHNlY3MpLnRvRml4ZWQoMikgKyAnbWJwcyc7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nLmNhbGwoY29uc29sZSwgZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdGFsID0gJ1RvdGFsIGxvYWRlZDogJyArIHRoaXMubWJzLnRvRml4ZWQoMikgKyAnbWInICtcbiAgICAgICAgICAgICcgdGltZTonICsgdGhpcy5zZWNzLnRvRml4ZWQoMikgKyAncycgK1xuICAgICAgICAgICAgJyBzcGVlZDonICsgdGhpcy5nZXRNYnBzKCkudG9GaXhlZCgyKSArICdtYnBzJztcbiAgICAgICAgY29uc29sZS5sb2cuY2FsbChjb25zb2xlLCB0b3RhbCk7XG4gICAgfSxcbiAgICBnZXRNYnBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWJzIC8gdGhpcy5zZWNzO1xuICAgIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hc3NldHMtbG9hZGVyL3NyYy9zdGF0cy5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9zY3NzL2dsb2JhbC5zY3NzJztcbmltcG9ydCBkZWJ1Z1BvbHlmaWxsIGZyb20gJy4vZGVidWcvZGVidWdQb2x5ZmlsbCc7XG5pbXBvcnQgYWxmcmlkLCB7IEdMIH0gZnJvbSAnYWxmcmlkJztcbmltcG9ydCBTY2VuZUFwcCBmcm9tICcuL1NjZW5lQXBwJztcbmltcG9ydCBBc3NldHNMb2FkZXIgZnJvbSAnYXNzZXRzLWxvYWRlcic7XG5pbXBvcnQgTG9hZGluZ0FuaW0gZnJvbSAnLi9Mb2FkaW5nQW5pbSc7XG5cbmltcG9ydCBhc3NldHMgZnJvbSAnLi9hc3NldC1saXN0JztcbmltcG9ydCBBc3NldHMgZnJvbSAnLi9Bc3NldHMnO1xuaW1wb3J0IENvbmZpZyBmcm9tICcuL0NvbmZpZyc7XG5cbmxldCBsb2FkaW5nQW5pbTtcblxuaWYoZG9jdW1lbnQuYm9keSkge1xuXHRfaW5pdCgpO1xufSBlbHNlIHtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBfaW5pdCk7XG59XG5cblxuZnVuY3Rpb24gX2luaXQoKSB7XG5cblx0bG9hZGluZ0FuaW0gPSBuZXcgTG9hZGluZ0FuaW0oKTtcblxuXG5cdC8vXHRMT0FESU5HIEFTU0VUU1xuXHRpZihhc3NldHMubGVuZ3RoID4gMCkge1xuXHRcdGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnaXNMb2FkaW5nJyk7XG5cblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgQXNzZXRzTG9hZGVyKHtcblx0XHRcdGFzc2V0czphc3NldHNcblx0XHR9KVxuXHRcdC5vbignZXJyb3InLCAoZXJyb3IpPT57XG5cdFx0XHRjb25zb2xlLmxvZygnRXJyb3IgOicsIGVycm9yKTtcblx0XHR9KVxuXHRcdC5vbigncHJvZ3Jlc3MnLCAocCkgPT4ge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coJ1Byb2dyZXNzIDogJywgcCk7XG5cdFx0XHRjb25zdCBsb2FkZXIgPSBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3IoJy5Mb2FkaW5nLUJhcicpO1xuXHRcdFx0aWYobG9hZGVyKSBsb2FkZXIuc3R5bGUud2lkdGggPSBgJHsocCAqIDEwMCl9JWA7XG5cdFx0fSlcblx0XHQub24oJ2NvbXBsZXRlJywgX29uSW1hZ2VMb2FkZWQpXG5cdFx0LnN0YXJ0KCk7XG5cblx0fSBlbHNlIHtcblx0XHRfaW5pdDNEKCk7XG5cdH1cbn1cblxuXG5mdW5jdGlvbiBfb25JbWFnZUxvYWRlZChvKSB7XG5cdC8vXHRBU1NFVFNcblx0Y29uc29sZS5sb2coJ0ltYWdlIExvYWRlZCA6ICcsIG8pO1xuXHR3aW5kb3cuYXNzZXRzID0gbztcblx0Y29uc3QgbG9hZGVyID0gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKCcuTG9hZGluZy1CYXInKTtcblx0Y29uc29sZS5sb2coJ0xvYWRlciA6JywgbG9hZGVyKTtcblx0bG9hZGVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXG5cdF9pbml0M0QoKTtcblxuXHRzZXRUaW1lb3V0KCgpPT4ge1xuXHRcdGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnaXNMb2FkaW5nJyk7XG5cdH0sIDI1MCk7XG59XG5cblxuZnVuY3Rpb24gX2luaXQzRCgpIHtcblx0Y29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKCcuY29udGFpbmVyJyk7XG5cdC8vXHRDUkVBVEUgQ0FOVkFTXG5cdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRjYW52YXMuY2xhc3NOYW1lID0gJ01haW4tQ2FudmFzJztcblx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG5cblx0Ly9cdElOSVQgM0QgVE9PTFxuXHRHTC5pbml0KGNhbnZhcywge2lnbm9yZVdlYmdsMjp0cnVlfSk7XG5cdGNvbnNvbGUubG9nKCdpc01vYmllbCA6JywgR0wuaXNNb2JpbGUpO1xuXHRpZihHTC5pc01vYmlsZSkge1xuXG5cdFx0dmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcblx0XHRpZigvQ2hyb21lL2kudGVzdCh1YSkpIHtcblx0XHRcdHNldFRpbWVvdXQoKCk9PiB7XG5cdFx0XHRcdGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnaXNNb2JpbGVDaHJvbWUnKTtcblx0XHRcdH0sIDEwMDApO1x0XG5cdFx0fVxuXG5cblx0XHRzZXRUaW1lb3V0KCgpPT4ge1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdpc01vYmlsZScpO1xuXHRcdH0sIDEwMDApO1x0XG5cdFx0XG5cdH1cblxuXG5cdC8vXHRJTklUIEFTU0VUU1xuXHRBc3NldHMuaW5pdCgpO1xuXG5cdC8vXHRDUkVBVEUgU0NFTkVcblx0Y29uc3Qgc2NlbmUgPSBuZXcgU2NlbmVBcHAoKTtcblxuXHQvL1x0RnVsbHNjcmVlblxuXHRjb25zdCBidG5GUyA9IGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvcignLmZ1bGxzY3JlZW4nKTtcblx0Y29uc3QgYnRuRlNUZXh0ID0gYnRuRlMucXVlcnlTZWxlY3RvcigncCcpO1xuXHRsZXQgaXNJbkZ1bGxTY3JlZW4gPSBmYWxzZTtcblxuXHRidG5GUy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIChlKT0+IHtcblx0XHRjb25zb2xlLmxvZygnZnVsbHNjcmVlbicpO1xuXHRcdGlzSW5GdWxsU2NyZWVuID0gIWlzSW5GdWxsU2NyZWVuO1xuXG5cdFx0aWYoaXNJbkZ1bGxTY3JlZW4pIHtcblx0XHRcdGRvY3VtZW50LmJvZHkud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oRWxlbWVudC5BTExPV19LRVlCT0FSRF9JTlBVVCk7XG5cdFx0XHRidG5GU1RleHQuaW5uZXJIVE1MID0gJ0V4aXQgRnVsbHNjcmVlbic7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKCk7XG5cdFx0XHRidG5GU1RleHQuaW5uZXJIVE1MID0gJ0dvIEZ1bGxzY3JlZW4nO1xuXHRcdH1cblx0fSk7XG5cblxuXHRsb2FkaW5nQW5pbS5vbignb25BbmltQ2xvc2VkJywgKCkgPT4ge1xuXHRcdHNjZW5lLm9wZW4oKTtcblxuXHRcdHNldFRpbWVvdXQoKCk9PiB7XG5cdFx0XHRkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ2lzT3BlbmVkJyk7XG5cdFx0fSwgMTAwMCk7XG5cdH0pO1xuXHRsb2FkaW5nQW5pbS5jbG9zZSgpO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9hcHAuanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/dXJsPWZhbHNlIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vZ2xvYmFsLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3VybD1mYWxzZSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL2dsb2JhbC5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz91cmw9ZmFsc2UhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9nbG9iYWwuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2Nzcy9nbG9iYWwuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdGlmICh0eXBlb2YgbWVtb1tzZWxlY3Rvcl0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdG1lbW9bc2VsZWN0b3JdID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdH07XG59KShmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldClcbn0pO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcblx0aWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBkZWJ1Z1BvbHlmaWxsLmpzXG5cbndpbmRvdy5ndWkgPSB7XG5cdGFkZDooKT0+e1xuXG5cdH1cbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2RlYnVnL2RlYnVnUG9seWZpbGwuanMiLCIvLyBTY2VuZUFwcC5qc1xuXG5pbXBvcnQgYWxmcmlkLCB7IFNjZW5lLCBHTCB9IGZyb20gJ2FsZnJpZCc7XG5pbXBvcnQgQXNzZXRzIGZyb20gJy4vQXNzZXRzJztcbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuL1NldHRpbmdzJztcbmltcG9ydCBDb25maWcgZnJvbSAnLi9Db25maWcnO1xuaW1wb3J0IE5vaXNlM0QgZnJvbSAnLi9Ob2lzZTNEJztcblxuaW1wb3J0IHsgZ2VuZXJhdGVUcmVlcywgZ2VuZXJhdGVIZWlnaHRNYXAgfSBmcm9tICcuL3V0aWxzJztcblxuaW1wb3J0IFZpZXdGbG9vciBmcm9tICcuL1ZpZXdGbG9vcic7XG5pbXBvcnQgVmlld1RyZWVzIGZyb20gJy4vVmlld1RyZWVzJztcbmltcG9ydCBWaWV3QmcgZnJvbSAnLi9WaWV3QmcnO1xuaW1wb3J0IFZpZXdHcm91bmQgZnJvbSAnLi9WaWV3R3JvdW5kJztcbmltcG9ydCBWaWV3Rm9nIGZyb20gJy4vVmlld0ZvZyc7XG5pbXBvcnQgVmlld0ZvZ3MgZnJvbSAnLi9WaWV3Rm9ncyc7XG5pbXBvcnQgVmlld0ZYQUEgZnJvbSAnLi9WaWV3RlhBQSc7XG5pbXBvcnQgVmlld0FuaW1hbCBmcm9tICcuL1ZpZXdBbmltYWwnO1xuaW1wb3J0IFZpZXdTcXVhcmVzIGZyb20gJy4vVmlld1NxdWFyZXMnO1xuaW1wb3J0IFZpZXdDb3ZlciBmcm9tICcuL1ZpZXdDb3Zlcic7XG5pbXBvcnQgVmlld1Nub3cgZnJvbSAnLi9WaWV3U25vdyc7XG5pbXBvcnQgUGFzc0Jsb29tIGZyb20gJy4vUGFzc0Jsb29tJztcbmltcG9ydCBTb3VuZE1hbmFnZXIgZnJvbSAnLi9Tb3VuZE1hbmFnZXInO1xuXG5pbXBvcnQgYWRkQ29udHJvbHMgZnJvbSAnLi9kZWJ1Zy9hZGRDb250cm9scyc7XG5pbXBvcnQgeyBUd2VlbkxpdGUgfSBmcm9tIFwiZ3NhcC9Ud2Vlbk1heFwiO1xuXG5sZXQgZmJvU2NhbGUgPSAxO1xuY29uc3QgaW50ZXJ2YWwgPSAyNTtcblxudmFyIHJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7IHJldHVybiBtaW4gKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbik7XHR9XG5cblxuY2xhc3MgU2NlbmVBcHAgZXh0ZW5kcyBTY2VuZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0aWYoR0wuaXNNb2JpbGUpIHtcblx0XHRcdGZib1NjYWxlID0gMC44O1xuXHRcdH1cblx0XHRTZXR0aW5ncy5pbml0KCk7XG5cblx0XHRDb25maWcuc2hvd1Nub3cgPSBmYWxzZTtcblx0XHRTZXR0aW5ncy5yZWZyZXNoKCk7XG5cblx0XHRzdXBlcigpO1xuXHRcdHRoaXMucmVzaXplKCk7XG5cdFx0R0wuZW5hYmxlQWxwaGFCbGVuZGluZygpO1xuXHRcdHRoaXMub3JiaXRhbENvbnRyb2wucmFkaXVzLnZhbHVlID0gNTtcblx0XHR0aGlzLm9yYml0YWxDb250cm9sLnJhZGl1cy5saW1pdCg1LCA1KTtcblx0XHR0aGlzLm9yYml0YWxDb250cm9sLnJ4LmxpbWl0KC0uMTUsIC4wKTtcblx0XHRjb25zdCBlYXNpbmcgPSAwLjA1O1xuXHRcdHRoaXMub3JiaXRhbENvbnRyb2wucnguZWFzaW5nID0gZWFzaW5nO1xuXHRcdHRoaXMub3JiaXRhbENvbnRyb2wucnkuZWFzaW5nID0gZWFzaW5nO1xuXG5cdFx0dGhpcy5tdHggPSBtYXQ0LmNyZWF0ZSgpO1xuXHRcdG1hdDQudHJhbnNsYXRlKHRoaXMubXR4LCB0aGlzLm10eCwgdmVjMy5mcm9tVmFsdWVzKDAsIC0xLjEsIDApKTtcblxuXHRcdC8vXHRzZXR1cCBmcm9udCBjYW1lcmEgZm9yIHByb2plY3Rpb25cblx0XHR0aGlzLmNhbWVyYUZyb250ID0gbmV3IGFsZnJpZC5DYW1lcmFQZXJzcGVjdGl2ZSgpO1xuXHRcdGNvbnN0IGZvdiA9IDUwICogTWF0aC5QSSAvIDE4MDtcblx0XHRjb25zdCBmYXIgPSAxNTtcblx0XHRjb25zdCBuZWFyID0gMTtcblx0XHR0aGlzLmNhbWVyYS5zZXRQZXJzcGVjdGl2ZShmb3YsIEdMLmFzcGVjdFJhdGlvLCBuZWFyLCBmYXIpO1xuXHRcdHRoaXMuY2FtZXJhRnJvbnQuc2V0UGVyc3BlY3RpdmUoZm92LCBHTC5hc3BlY3RSYXRpbywgbmVhciwgZmFyKTtcblx0XHR0aGlzLmNhbWVyYUZyb250Lmxvb2tBdChbMCwgMCwgNV0sIFswLCAwLCAwXSk7XG5cblx0XHR0aGlzLl9iaWFzTWF0cml4ID0gbWF0NC5mcm9tVmFsdWVzKFxuXHRcdFx0MC41LCAwLjAsIDAuMCwgMC4wLFxuXHRcdFx0MC4wLCAwLjUsIDAuMCwgMC4wLFxuXHRcdFx0MC4wLCAwLjAsIDAuNSwgMC4wLFxuXHRcdFx0MC41LCAwLjUsIDAuNSwgMS4wXG5cdFx0KTtcblxuXHRcdHRoaXMuX210eEZyb250ID0gbWF0NC5jcmVhdGUoKTtcblx0XHRtYXQ0Lm11bCh0aGlzLl9tdHhGcm9udCwgdGhpcy5jYW1lcmFGcm9udC5wcm9qZWN0aW9uLCB0aGlzLmNhbWVyYUZyb250Lm1hdHJpeCk7XG5cdFx0bWF0NC5tdWwodGhpcy5fbXR4RnJvbnQsIHRoaXMuX2JpYXNNYXRyaXgsIHRoaXMuX210eEZyb250KTtcblx0XHR0aGlzLl92U3F1YXJlcy5zZXRNYXRyaWNlcyh0aGlzLmNhbWVyYUZyb250KTtcblxuXHRcdHRoaXMuX2lzSW5UcmFuc2l0aW9uID0gZmFsc2U7XG5cdFx0dGhpcy5faGFzT3BlbmVkID0gZmFsc2U7XG5cdFx0dGhpcy5faGFzUHJvZmlsZWRGb2cgPSBmYWxzZTtcblx0XHR0aGlzLl9yZXNpemVUaW1lb3V0ID0gMDtcblx0XHR0aGlzLl9nb29kRm9nUmVuZGVyQ291bnQgPSAwO1xuXHRcdHRoaXMuX2NvdW50ID0gMDtcblxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpPT4ge1xuXHRcdFx0aWYoZS5rZXlDb2RlID09PSAzMikge1xuXHRcdFx0XHR0aGlzLm5leHQoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXG5cdFx0dGhpcy5faGFzbG9ja2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fYW5nbGVzID0ge1xuXHRcdFx0eDowLCBcblx0XHRcdHk6MFxuXHRcdH1cblxuXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgKCkgPT4ge1xuXHRcdFx0aWYoTWF0aC5yYW5kb20oKSA+IC44ICYmICF0aGlzLl9oYXNsb2NrZWQpIHtcblxuXHRcdFx0XHR0aGlzLm5leHQoKTtcblx0XHRcdFx0dGhpcy5faGFzbG9ja2VkID0gdHJ1ZTtcblxuXHRcdFx0XHRzZXRUaW1lb3V0KCgpPT4ge1xuXHRcdFx0XHRcdHRoaXMuX2hhc2xvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHR9LCAxNTAwMCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhZGRDb250cm9scyh0aGlzKTtcblx0fVxuXG5cdG9wZW4oKSB7XG5cdFx0dGhpcy5fdk9wZW5pbmdDb3Zlci5jbG9zZSgpO1xuXHR9XG5cblx0X2luaXRUZXh0dXJlcygpIHtcblx0XHR0aGlzLl9mYm9DYXB0dXJlID0gbmV3IGFsZnJpZC5GcmFtZUJ1ZmZlcihHTC53aWR0aCwgR0wuaGVpZ2h0LCB7XG5cdFx0XHRtaW5GaWx0ZXI6R0wuTElORUFSLFxuXHRcdFx0bWFnRmlsdGVyOkdMLkxJTkVBUlxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fZmJvUmVuZGVyID0gbmV3IGFsZnJpZC5GcmFtZUJ1ZmZlcihHTC53aWR0aCAqIGZib1NjYWxlLCBHTC5oZWlnaHQgKiBmYm9TY2FsZSk7XG5cdFx0dGhpcy5fZmJvVGVtcCA9IG5ldyBhbGZyaWQuRnJhbWVCdWZmZXIoR0wud2lkdGggKiBmYm9TY2FsZSwgR0wuaGVpZ2h0ICogZmJvU2NhbGUpO1xuXG5cdFx0dGhpcy5fbm9pc2VzID0gbmV3IE5vaXNlM0QoQ29uZmlnLm5vaXNlTnVtLCBDb25maWcubm9pc2VTY2FsZSk7XG5cdH1cblxuXG5cdF9pbml0Vmlld3MoKSB7XG5cdFx0Y29uc29sZS5sb2coJ2luaXQgdmlld3MnKTtcblxuXHRcdHRoaXMuX2JDb3B5ID0gbmV3IGFsZnJpZC5CYXRjaENvcHkoKTtcblx0XHR0aGlzLl9iQmFsbCA9IG5ldyBhbGZyaWQuQmF0Y2hCYWxsKCk7XG5cblx0XHR0aGlzLl92Rmxvb3IgICAgPSBuZXcgVmlld0Zsb29yKCk7XG5cdFx0dGhpcy5fdlRyZWVzICAgID0gbmV3IFZpZXdUcmVlcygpO1xuXHRcdHRoaXMuX3ZCZyAgICAgICA9IG5ldyBWaWV3QmcoKTtcblx0XHR0aGlzLl92QW5pbWFsICAgPSBuZXcgVmlld0FuaW1hbCgpO1xuXHRcdHRoaXMuX3ZTbm93ICAgICA9IG5ldyBWaWV3U25vdygpO1xuXHRcdHRoaXMuX3ZHcm91bmQgICA9IG5ldyBWaWV3R3JvdW5kKCk7XG5cdFx0Ly8gdGhpcy5fdkZvZyAgICAgID0gbmV3IFZpZXdGb2coKTtcblx0XHR0aGlzLl92Rm9nc1x0ICAgID0gbmV3IFZpZXdGb2dzKCk7XG5cdFx0dGhpcy5fdkZ4YWEgICAgID0gbmV3IFZpZXdGWEFBKCk7XG5cdFx0dGhpcy5fdlNxdWFyZXMgID0gbmV3IFZpZXdTcXVhcmVzKCk7XG5cdFx0dGhpcy5fdkNvdmVyICAgID0gbmV3IFZpZXdDb3ZlcigpO1xuXHRcdHRoaXMuX3ZPcGVuaW5nQ292ZXIgPSBuZXcgVmlld0NvdmVyKCk7XG5cdFx0dGhpcy5fdk9wZW5pbmdDb3Zlci5vcGFjaXR5LnNldFRvKDEpO1xuXHRcdHRoaXMuX3Bhc3NCbG9vbSA9IG5ldyBQYXNzQmxvb20oMyk7XG5cblx0XHR0aGlzLl9yZXNldFRyZWVQb3NpdGlvbigpO1xuXHR9XG5cblxuXHRuZXh0KCkge1xuXHRcdGlmKCFkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnaGFzSW50ZXJhY3QnKSkge1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdoYXNJbnRlcmFjdCcpO1xuXHRcdH1cblx0XHQvLyB0aGlzLm9yYml0YWxDb250cm9sLmxvY2sodHJ1ZSk7XG5cdFx0dGhpcy5fYW5nbGVzLnggKj0gMC4xO1xuXHRcdHRoaXMuX2FuZ2xlcy55ICo9IDAuMTtcblxuXHRcdHRoaXMuX2FuZ2xlcy54ICo9IDA7XG5cdFx0dGhpcy5fYW5nbGVzLnkgKj0gMDtcblx0XHRcblx0XHRjb25zdCBhbmltYWxzID0gWydkZWVyJywgJ2xhcHV0YScsICd3aGFsZScsICdiZWFyJ107XG5cdFx0bGV0IGluZGV4ID0gYW5pbWFscy5pbmRleE9mKENvbmZpZy5hbmltYWwpO1xuXHRcdGluZGV4Kys7XG5cdFx0aWYoaW5kZXggPj0gYW5pbWFscy5sZW5ndGgpIHtcblx0XHRcdGluZGV4ID0gMDtcblx0XHR9XG5cblx0XHQvLyBsZXQgZyA9IDAuNTtcblx0XHQvL1x0dGFrZSBzY3JlZW4gc2hvdCBvZiBjdXJyZW50IGZyYW1lXG5cdFx0dGhpcy5fZmJvQ2FwdHVyZS5iaW5kKCk7XG5cdFx0R0wuY2xlYXIoMCwgMCwgMCwgMCk7XG5cdFx0R0wuc2V0TWF0cmljZXModGhpcy5jYW1lcmEpO1xuXHRcdHRoaXMucmVuZGVyU2NlbmUoKTtcblx0XHR0aGlzLl9mYm9DYXB0dXJlLnVuYmluZCgpO1xuXG5cblx0XHQvL1x0c2V0IGZsYWcgdG8gc3RhcnQgcmVuZGVyaW5nIHRoZSBwbGFuZXNcblx0XHR0aGlzLl9oYXNPcGVuZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9pc0luVHJhbnNpdGlvbiA9IHRydWU7XG5cblx0XHQvL1x0c2V0IGNhbWVyYSBwb3NpdGlvbiB0byBmcm9udFxuXHRcdHRoaXMub3JiaXRhbENvbnRyb2wucnguc2V0VG8oMCk7XG5cdFx0dGhpcy5vcmJpdGFsQ29udHJvbC5yeS5zZXRUbygwKTtcblx0XHR0aGlzLm9yYml0YWxDb250cm9sLnJhZGl1cy5zZXRUbyg1KTtcblx0XHR0aGlzLm9yYml0YWxDb250cm9sLl9sb29wKCk7XG5cdFx0dGhpcy5vcmJpdGFsQ29udHJvbC5sb2NrKHRydWUpO1xuXHRcdC8vXHRtb3ZlIGNhbWVyYSB0byBzaWRlIHRvIGhpZGUgdGhlIHBsYW5lc1xuXG5cdFx0Ly9cdHJlc2V0IHBsYW5lcyBwb3NpdGlvblxuXHRcdHRoaXMuX3ZTcXVhcmVzLnJlc2V0KCk7XG5cdFx0dGhpcy5fdlNxdWFyZXMub3BlbigpO1xuXG5cdFx0Q29uZmlnLmFuaW1hbCA9IGFuaW1hbHNbaW5kZXhdO1xuXHRcdC8vIFNldHRpbmdzLnJlZnJlc2goKTtcblx0XHR0aGlzLl92QW5pbWFsLnNldEFuaW1hbChhbmltYWxzW2luZGV4XSk7XG5cblx0XHR0aGlzLl9yZXNldFRyZWVQb3NpdGlvbigpO1xuXHRcdHRoaXMuX2NhcHR1cmUoKTtcblxuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0dGhpcy5fdkNvdmVyLm9wZW4oKTtcblx0XHR9LCAxMDAwKTtcblxuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0VHdlZW5MaXRlLmtpbGxUd2VlbnNPZih0aGlzLl9hbmdsZXMpO1xuXHRcdFx0VHdlZW5MaXRlLnRvKHRoaXMuX2FuZ2xlcywgMywge1wieFwiOi0wLjEsIFwieVwiOnJhbmRvbSgtMC4zLCAwLjMpLCBlYXNlOiBDaXJjLmVhc2VJbk91dH0pO1xuXHRcdFx0XG5cdFx0XHR0aGlzLl92U3F1YXJlcy5jbG9zZSgpO1xuXHRcdFx0dGhpcy5fdkNvdmVyLmNsb3NlKCk7XG5cdFx0XHR0aGlzLl9oYXNPcGVuZWQgPSB0cnVlO1xuXHRcdH0sIDMwMDApO1xuXG5cblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdHRoaXMuX2lzSW5UcmFuc2l0aW9uID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9hbmdsZXMueCA9IHRoaXMuX2FuZ2xlcy55ID0gMDtcblx0XHRcdHRoaXMub3JiaXRhbENvbnRyb2wubG9jayhmYWxzZSk7XG5cdFx0fSwgNjAwMCk7XG5cblx0XHQvL1x0d2hlbiBjYW1lcmEgaW4gcG9zaXRpb24gKCBwbGFuZXMgbm90IHZpc2libGUgKVxuXHRcdC8vXHRkaXNhYmxlIHJlbmRlcmluZyB0aGUgcGxhbmVzXG5cdH1cblxuXG5cdF9jYXB0dXJlKCkge1xuXHRcdHRoaXMuX2Zib1RlbXAuYmluZCgpO1xuXHRcdEdMLmNsZWFyKDAsIDAsIDAsIDEpO1xuXHRcdEdMLnNldE1hdHJpY2VzKHRoaXMuY2FtZXJhKTtcblx0XHR0aGlzLnJlbmRlclNjZW5lKCk7XG5cdFx0dGhpcy5fZmJvVGVtcC51bmJpbmQoKTtcblx0fVxuXG5cdF9yZXNldFRyZWVQb3NpdGlvbigpIHtcblx0XHR0aGlzLl90cmVlcyA9IGdlbmVyYXRlVHJlZXMoKTtcblx0XHR0aGlzLl92VHJlZXMucmVzZXQodGhpcy5fdHJlZXMpO1xuXHRcdHRoaXMuX3RleHR1cmVGbG9vciA9IGdlbmVyYXRlSGVpZ2h0TWFwKHRoaXMuX3RyZWVzKTtcblx0fVxuXG5cblx0cmVzZXRDYW1lcmEoKSB7XG5cdFx0Ly9cdHNldCBjYW1lcmEgcG9zaXRpb24gdG8gZnJvbnRcblx0XHR0aGlzLm9yYml0YWxDb250cm9sLnJ4LnNldFRvKDApO1xuXHRcdHRoaXMub3JiaXRhbENvbnRyb2wucnkuc2V0VG8oMCk7XG5cdH1cblxuXHR1cGRhdGVGb2coKSB7XG5cdFx0dGhpcy5fY291bnQgPSAwO1xuXHRcdHRoaXMuX25vaXNlcy51cGRhdGUoKTtcblx0fVxuXG5cblx0cmVuZGVyKCkge1xuXHRcdHRoaXMuX2hhc1Byb2ZpbGVkRm9nID0gZmFsc2U7XG5cdFx0dGhpcy5fY291bnQgKys7XG5cdFx0aWYodGhpcy5fY291bnQgPj0gaW50ZXJ2YWwpIHtcblx0XHRcdHRoaXMudXBkYXRlRm9nKCk7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5faXNJblRyYW5zaXRpb24pIHtcblx0XHRcdHRoaXMub3JiaXRhbENvbnRyb2wucnguc2V0VG8odGhpcy5fYW5nbGVzLngpO1xuXHRcdFx0dGhpcy5vcmJpdGFsQ29udHJvbC5yeS5zZXRUbyh0aGlzLl9hbmdsZXMueSk7XG5cdFx0fVxuXHRcdEdMLmNsZWFyKDAsIDAsIDAsIDEpO1xuXG5cdFx0aWYodGhpcy5faXNJblRyYW5zaXRpb24gJiYgdGhpcy5faGFzT3BlbmVkKSB7XG5cdFx0XHR0aGlzLl9jYXB0dXJlKCk7XG5cdFx0fVxuXG5cblx0XHR0aGlzLl9mYm9SZW5kZXIuYmluZCgpO1xuXHRcdEdMLmNsZWFyKDAsIDAsIDAsIDEpO1xuXG5cdFxuXHRcdGlmKHRoaXMuX2lzSW5UcmFuc2l0aW9uKSB7XG5cdFx0XHRHTC5kaXNhYmxlKEdMLkRFUFRIX1RFU1QpO1xuXHRcdFx0aWYodGhpcy5faGFzT3BlbmVkKSB7XG5cdFx0XHRcdHRoaXMuX2JDb3B5LmRyYXcodGhpcy5fZmJvVGVtcC5nZXRUZXh0dXJlKCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fYkNvcHkuZHJhdyh0aGlzLl9mYm9DYXB0dXJlLmdldFRleHR1cmUoKSk7XHRcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5fdkNvdmVyLnJlbmRlcigpO1xuXG5cdFx0XHRHTC5lbmFibGUoR0wuREVQVEhfVEVTVCk7XG5cdFx0XHRHTC5yb3RhdGUodGhpcy5tdHgpO1xuXHRcdFx0dGhpcy5fdlNxdWFyZXMucmVuZGVyKHRoaXMuX210eEZyb250LCB0aGlzLl9mYm9DYXB0dXJlLmdldFRleHR1cmUoKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucmVuZGVyU2NlbmUoKTtcdFxuXHRcdH1cblxuXHRcdHRoaXMuX2Zib1JlbmRlci51bmJpbmQoKTtcblxuXHRcdHRoaXMuX3Bhc3NCbG9vbS5yZW5kZXIodGhpcy5fZmJvUmVuZGVyLmdldFRleHR1cmUoKSk7XG5cblx0XHRpZihDb25maWcuZnhhYSkge1xuXHRcdFx0dGhpcy5fdkZ4YWEucmVuZGVyKHRoaXMuX2Zib1JlbmRlci5nZXRUZXh0dXJlKCksIHRoaXMuX3Bhc3NCbG9vbS5nZXRUZXh0dXJlKCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9iQ29weS5kcmF3KHRoaXMuX2Zib1JlbmRlci5nZXRUZXh0dXJlKCkpO1x0XG5cdFx0fVxuXG5cdFx0R0wuZGlzYWJsZShHTC5ERVBUSF9URVNUKTtcblx0XHR0aGlzLl92T3BlbmluZ0NvdmVyLnJlbmRlcigpO1xuXHRcdEdMLmVuYWJsZShHTC5ERVBUSF9URVNUKTtcblx0fVxuXG5cblx0cmVuZGVyU2NlbmUobVJlbmRlckZvZz10cnVlKSB7XG5cdFx0R0wucm90YXRlKHRoaXMubXR4KTtcblxuXHRcdHRoaXMuX3ZCZy5yZW5kZXIoKTtcblx0XHR0aGlzLl92R3JvdW5kLnJlbmRlcigpO1xuXHRcdHRoaXMuX3ZGbG9vci5yZW5kZXIodGhpcy5fdGV4dHVyZUZsb29yKTtcblx0XHRpZihDb25maWcuc2hvd1Nub3cpIHtcblx0XHRcdHRoaXMuX3ZTbm93LnJlbmRlcigpO1x0XG5cdFx0fVxuXHRcdHRoaXMuX3ZUcmVlcy5yZW5kZXIodGhpcy5jYW1lcmEucG9zaXRpb24pO1xuXHRcdHRoaXMuX3ZBbmltYWwucmVuZGVyKCk7XG5cblx0XHRpZighR0wuaXNNb2JpbGUgJiYgbVJlbmRlckZvZykge1xuXHRcdFx0bGV0IHQwICAgICAgICAgID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0XHRsZXQgdHQwICAgICAgICAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHRcdHRoaXMuX3ZGb2dzLnJlbmRlcih0aGlzLl9ub2lzZXMudGV4dHVyZTAsIHRoaXMuX25vaXNlcy50ZXh0dXJlMSwgdGhpcy5fY291bnQgLyBpbnRlcnZhbCk7XHRcblx0XHRcdGxldCB0MSAgICAgICAgICA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0bGV0IHR0MSAgICAgICAgID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0XHRsZXQgcmVuZGVyVGltZSAgPSB0MSAtIHQwO1xuXHRcdFx0bGV0IHJlbmRlclRpbWUwID0gdHQxIC0gdHQwO1xuXHRcdFx0XG5cdFx0XHRpZihNYXRoLnJhbmRvbSgpID4gMC41KSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdGb2cgcmVuZGVyIHRpbWUgOicsIHJlbmRlclRpbWUsIHJlbmRlclRpbWUwKTtcdFxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHR0aGlzLl9oYXNQcm9maWxlZEZvZyA9IHRydWU7XG5cdH1cblxuXG5cdHJlc2l6ZSgpIHtcblx0XHRjb25zdCB7IGlubmVyV2lkdGgsIGlubmVySGVpZ2h0LCBkZXZpY2VQaXhlbFJhdGlvIH0gPSB3aW5kb3c7XG5cdFx0R0wuc2V0U2l6ZShpbm5lcldpZHRoLCBpbm5lckhlaWdodCk7XG5cdFx0dGhpcy5jYW1lcmEuc2V0QXNwZWN0UmF0aW8oR0wuYXNwZWN0UmF0aW8pO1xuXG5cdFx0aWYodGhpcy5jYW1lcmFGcm9udCkge1xuXHRcdFx0dGhpcy5jYW1lcmFGcm9udC5zZXRBc3BlY3RSYXRpbyhHTC5hc3BlY3RSYXRpbyk7XHRcblx0XHRcdG1hdDQuaWRlbnRpdHkodGhpcy5fbXR4RnJvbnQsIHRoaXMuX210eEZyb250KTtcblx0XHRcdG1hdDQubXVsKHRoaXMuX210eEZyb250LCB0aGlzLmNhbWVyYUZyb250LnByb2plY3Rpb24sIHRoaXMuY2FtZXJhRnJvbnQubWF0cml4KTtcblx0XHRcdG1hdDQubXVsKHRoaXMuX210eEZyb250LCB0aGlzLl9iaWFzTWF0cml4LCB0aGlzLl9tdHhGcm9udCk7XG5cdFx0XHR0aGlzLl92U3F1YXJlcy5zZXRNYXRyaWNlcyh0aGlzLmNhbWVyYUZyb250KTtcblx0XHR9XG5cblx0XHRpZih0aGlzLl9yZXNpemVUaW1lb3V0ICE9PSAwKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVzaXplVGltZW91dCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoKCk9PiB7XG5cdFx0XHR0aGlzLl9mYm9DYXB0dXJlID0gbmV3IGFsZnJpZC5GcmFtZUJ1ZmZlcihHTC53aWR0aCwgR0wuaGVpZ2h0LCB7XG5cdFx0XHRcdG1pbkZpbHRlcjpHTC5MSU5FQVIsXG5cdFx0XHRcdG1hZ0ZpbHRlcjpHTC5MSU5FQVJcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLl9mYm9SZW5kZXIgPSBuZXcgYWxmcmlkLkZyYW1lQnVmZmVyKEdMLndpZHRoICogZmJvU2NhbGUsIEdMLmhlaWdodCAqIGZib1NjYWxlKTtcblx0XHRcdHRoaXMuX2Zib1RlbXAgPSBuZXcgYWxmcmlkLkZyYW1lQnVmZmVyKEdMLndpZHRoICogZmJvU2NhbGUsIEdMLmhlaWdodCAqIGZib1NjYWxlKTtcblx0XHR9LCAxMDAwLzYwICogNSlcblx0XHRcblx0fVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFNjZW5lQXBwO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9TY2VuZUFwcC5qcyIsIlwidXNlIHN0cmljdFwiO1xuLypcbkNvcHlyaWdodCAoYykgMjAxNCBQZXRrYSBBbnRvbm92XG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG4qL1xuZnVuY3Rpb24gVXJsKCkge1xuICAgIC8vRm9yIG1vcmUgZWZmaWNpZW50IGludGVybmFsIHJlcHJlc2VudGF0aW9uIGFuZCBsYXppbmVzcy5cbiAgICAvL1RoZSBub24tdW5kZXJzY29yZSB2ZXJzaW9ucyBvZiB0aGVzZSBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NvciBmdW5jdGlvbnNcbiAgICAvL2RlZmluZWQgb24gdGhlIHByb3RvdHlwZS5cbiAgICB0aGlzLl9wcm90b2NvbCA9IG51bGw7XG4gICAgdGhpcy5faHJlZiA9IFwiXCI7XG4gICAgdGhpcy5fcG9ydCA9IC0xO1xuICAgIHRoaXMuX3F1ZXJ5ID0gbnVsbDtcblxuICAgIHRoaXMuYXV0aCA9IG51bGw7XG4gICAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgICB0aGlzLmhvc3QgPSBudWxsO1xuICAgIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICAgIHRoaXMuaGFzaCA9IG51bGw7XG4gICAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICAgIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuXG4gICAgdGhpcy5fcHJlcGVuZFNsYXNoID0gZmFsc2U7XG59XG5cbnZhciBxdWVyeXN0cmluZyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTtcblxuVXJsLnF1ZXJ5U3RyaW5nID0gcXVlcnlzdHJpbmc7XG5cblVybC5wcm90b3R5cGUucGFyc2UgPVxuZnVuY3Rpb24gVXJsJHBhcnNlKHN0ciwgcGFyc2VRdWVyeVN0cmluZywgaG9zdERlbm90ZXNTbGFzaCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycykge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICtcbiAgICAgICAgICAgIHR5cGVvZiBzdHIpO1xuICAgIH1cbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIHZhciBlbmQgPSBzdHIubGVuZ3RoIC0gMTtcblxuICAgIC8vVHJpbSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3c1xuICAgIHdoaWxlIChzdHIuY2hhckNvZGVBdChzdGFydCkgPD0gMHgyMCAvKicgJyovKSBzdGFydCsrO1xuICAgIHdoaWxlIChzdHIuY2hhckNvZGVBdChlbmQpIDw9IDB4MjAgLyonICcqLykgZW5kLS07XG5cbiAgICBzdGFydCA9IHRoaXMuX3BhcnNlUHJvdG9jb2woc3RyLCBzdGFydCwgZW5kKTtcblxuICAgIC8vSmF2YXNjcmlwdCBkb2Vzbid0IGhhdmUgaG9zdFxuICAgIGlmICh0aGlzLl9wcm90b2NvbCAhPT0gXCJqYXZhc2NyaXB0XCIpIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9wYXJzZUhvc3Qoc3RyLCBzdGFydCwgZW5kLCBob3N0RGVub3Rlc1NsYXNoKTtcbiAgICAgICAgdmFyIHByb3RvID0gdGhpcy5fcHJvdG9jb2w7XG4gICAgICAgIGlmICghdGhpcy5ob3N0bmFtZSAmJlxuICAgICAgICAgICAgKHRoaXMuc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoUHJvdG9jb2xzW3Byb3RvXSkpKSB7XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydCA8PSBlbmQpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gICAgICAgIGlmIChjaCA9PT0gMHgyRiAvKicvJyovIHx8IGNoID09PSAweDVDIC8qJ1xcJyovKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVBhdGgoc3RyLCBzdGFydCwgZW5kLCBkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgzRiAvKic/JyovKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVF1ZXJ5KHN0ciwgc3RhcnQsIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4MjMgLyonIycqLykge1xuICAgICAgICAgIHRoaXMuX3BhcnNlSGFzaChzdHIsIHN0YXJ0LCBlbmQsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3Byb3RvY29sICE9PSBcImphdmFzY3JpcHRcIikge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VQYXRoKHN0ciwgc3RhcnQsIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vRm9yIGphdmFzY3JpcHQgdGhlIHBhdGhuYW1lIGlzIGp1c3QgdGhlIHJlc3Qgb2YgaXRcbiAgICAgICAgICAgIHRoaXMucGF0aG5hbWUgPSBzdHIuc2xpY2Uoc3RhcnQsIGVuZCArIDEgKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnBhdGhuYW1lICYmIHRoaXMuaG9zdG5hbWUgJiZcbiAgICAgICAgdGhpcy5fc2xhc2hQcm90b2NvbHNbdGhpcy5fcHJvdG9jb2xdKSB7XG4gICAgICAgIHRoaXMucGF0aG5hbWUgPSBcIi9cIjtcbiAgICB9XG5cbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2g7XG4gICAgICAgIGlmIChzZWFyY2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgc2VhcmNoID0gdGhpcy5zZWFyY2ggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWFyY2guY2hhckNvZGVBdCgwKSA9PT0gMHgzRiAvKic/JyovKSB7XG4gICAgICAgICAgICBzZWFyY2ggPSBzZWFyY2guc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9UaGlzIGNhbGxzIGEgc2V0dGVyIGZ1bmN0aW9uLCB0aGVyZSBpcyBubyAucXVlcnkgZGF0YSBwcm9wZXJ0eVxuICAgICAgICB0aGlzLnF1ZXJ5ID0gVXJsLnF1ZXJ5U3RyaW5nLnBhcnNlKHNlYXJjaCk7XG4gICAgfVxufTtcblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gVXJsJHJlc29sdmUocmVsYXRpdmUpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KFVybC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gVXJsJGZvcm1hdCgpIHtcbiAgICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCBcIlwiO1xuXG4gICAgaWYgKGF1dGgpIHtcbiAgICAgICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICAgICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksIFwiOlwiKTtcbiAgICAgICAgYXV0aCArPSBcIkBcIjtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8IFwiXCI7XG4gICAgdmFyIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCBcIlwiO1xuICAgIHZhciBoYXNoID0gdGhpcy5oYXNoIHx8IFwiXCI7XG4gICAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IFwiXCI7XG4gICAgdmFyIHF1ZXJ5ID0gXCJcIjtcbiAgICB2YXIgaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8IFwiXCI7XG4gICAgdmFyIHBvcnQgPSB0aGlzLnBvcnQgfHwgXCJcIjtcbiAgICB2YXIgaG9zdCA9IGZhbHNlO1xuICAgIHZhciBzY2hlbWUgPSBcIlwiO1xuXG4gICAgLy9DYWNoZSB0aGUgcmVzdWx0IG9mIHRoZSBnZXR0ZXIgZnVuY3Rpb25cbiAgICB2YXIgcSA9IHRoaXMucXVlcnk7XG4gICAgaWYgKHEgJiYgdHlwZW9mIHEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcXVlcnkgPSBVcmwucXVlcnlTdHJpbmcuc3RyaW5naWZ5KHEpO1xuICAgIH1cblxuICAgIGlmICghc2VhcmNoKSB7XG4gICAgICAgIHNlYXJjaCA9IHF1ZXJ5ID8gXCI/XCIgKyBxdWVyeSA6IFwiXCI7XG4gICAgfVxuXG4gICAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLmNoYXJDb2RlQXQocHJvdG9jb2wubGVuZ3RoIC0gMSkgIT09IDB4M0EgLyonOicqLylcbiAgICAgICAgcHJvdG9jb2wgKz0gXCI6XCI7XG5cbiAgICBpZiAodGhpcy5ob3N0KSB7XG4gICAgICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICAgIH1cbiAgICBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgICAgICB2YXIgaXA2ID0gaG9zdG5hbWUuaW5kZXhPZihcIjpcIikgPiAtMTtcbiAgICAgICAgaWYgKGlwNikgaG9zdG5hbWUgPSBcIltcIiArIGhvc3RuYW1lICsgXCJdXCI7XG4gICAgICAgIGhvc3QgPSBhdXRoICsgaG9zdG5hbWUgKyAocG9ydCA/IFwiOlwiICsgcG9ydCA6IFwiXCIpO1xuICAgIH1cblxuICAgIHZhciBzbGFzaGVzID0gdGhpcy5zbGFzaGVzIHx8XG4gICAgICAgICgoIXByb3RvY29sIHx8XG4gICAgICAgIHNsYXNoUHJvdG9jb2xzW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpO1xuXG5cbiAgICBpZiAocHJvdG9jb2wpIHNjaGVtZSA9IHByb3RvY29sICsgKHNsYXNoZXMgPyBcIi8vXCIgOiBcIlwiKTtcbiAgICBlbHNlIGlmIChzbGFzaGVzKSBzY2hlbWUgPSBcIi8vXCI7XG5cbiAgICBpZiAoc2xhc2hlcyAmJiBwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQ29kZUF0KDApICE9PSAweDJGIC8qJy8nKi8pIHtcbiAgICAgICAgcGF0aG5hbWUgPSBcIi9cIiArIHBhdGhuYW1lO1xuICAgIH1cbiAgICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQ29kZUF0KDApICE9PSAweDNGIC8qJz8nKi8pXG4gICAgICAgIHNlYXJjaCA9IFwiP1wiICsgc2VhcmNoO1xuICAgIGlmIChoYXNoICYmIGhhc2guY2hhckNvZGVBdCgwKSAhPT0gMHgyMyAvKicjJyovKVxuICAgICAgICBoYXNoID0gXCIjXCIgKyBoYXNoO1xuXG4gICAgcGF0aG5hbWUgPSBlc2NhcGVQYXRoTmFtZShwYXRobmFtZSk7XG4gICAgc2VhcmNoID0gZXNjYXBlU2VhcmNoKHNlYXJjaCk7XG5cbiAgICByZXR1cm4gc2NoZW1lICsgKGhvc3QgPT09IGZhbHNlID8gXCJcIiA6IGhvc3QpICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24gVXJsJHJlc29sdmVPYmplY3QocmVsYXRpdmUpIHtcbiAgICBpZiAodHlwZW9mIHJlbGF0aXZlID09PSBcInN0cmluZ1wiKVxuICAgICAgICByZWxhdGl2ZSA9IFVybC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Nsb25lKCk7XG5cbiAgICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlXCJzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICAgIGlmICghcmVsYXRpdmUuaHJlZikge1xuICAgICAgICByZXN1bHQuX2hyZWYgPSBcIlwiO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICAgIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5fcHJvdG9jb2wpIHtcbiAgICAgICAgcmVsYXRpdmUuX2NvcHlQcm9wc1RvKHJlc3VsdCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHNsYXNoUHJvdG9jb2xzW3Jlc3VsdC5fcHJvdG9jb2xdICYmXG4gICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Ll9ocmVmID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAocmVsYXRpdmUuX3Byb3RvY29sICYmIHJlbGF0aXZlLl9wcm90b2NvbCAhPT0gcmVzdWx0Ll9wcm90b2NvbCkge1xuICAgICAgICAvLyBpZiBpdFwicyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgICAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAgICAgLy8gZmlyc3QsIGlmIGl0XCJzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgICAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgICAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhhdFwicyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAgICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgICAgICBpZiAoIXNsYXNoUHJvdG9jb2xzW3JlbGF0aXZlLl9wcm90b2NvbF0pIHtcbiAgICAgICAgICAgIHJlbGF0aXZlLl9jb3B5UHJvcHNUbyhyZXN1bHQsIGZhbHNlKTtcbiAgICAgICAgICAgIHJlc3VsdC5faHJlZiA9IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0Ll9wcm90b2NvbCA9IHJlbGF0aXZlLl9wcm90b2NvbDtcbiAgICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmIHJlbGF0aXZlLl9wcm90b2NvbCAhPT0gXCJqYXZhc2NyaXB0XCIpIHtcbiAgICAgICAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8IFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgICAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAocmVsUGF0aFswXSAhPT0gXCJcIikgcmVsUGF0aC51bnNoaWZ0KFwiXCIpO1xuICAgICAgICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KFwiXCIpO1xuICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKFwiL1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8IFwiXCI7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgcmVzdWx0Ll9wb3J0ID0gcmVsYXRpdmUuX3BvcnQ7XG4gICAgICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICAgICAgcmVzdWx0Ll9ocmVmID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgaXNTb3VyY2VBYnMgPVxuICAgICAgICAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQ29kZUF0KDApID09PSAweDJGIC8qJy8nKi8pO1xuICAgIHZhciBpc1JlbEFicyA9IChcbiAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICAgIChyZWxhdGl2ZS5wYXRobmFtZSAmJlxuICAgICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gMHgyRiAvKicvJyovKVxuICAgICAgICApO1xuICAgIHZhciBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKTtcblxuICAgIHZhciByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicztcblxuICAgIHZhciBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdChcIi9cIikgfHwgW107XG4gICAgdmFyIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdChcIi9cIikgfHwgW107XG4gICAgdmFyIHBzeWNob3RpYyA9IHJlc3VsdC5fcHJvdG9jb2wgJiYgIXNsYXNoUHJvdG9jb2xzW3Jlc3VsdC5fcHJvdG9jb2xdO1xuXG4gICAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAgIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gICAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IFwiXCI7XG4gICAgICAgIHJlc3VsdC5fcG9ydCA9IC0xO1xuICAgICAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgICAgICAgIGlmIChzcmNQYXRoWzBdID09PSBcIlwiKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICAgICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lmhvc3QgPSBcIlwiO1xuICAgICAgICBpZiAocmVsYXRpdmUuX3Byb3RvY29sKSB7XG4gICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IFwiXCI7XG4gICAgICAgICAgICByZWxhdGl2ZS5fcG9ydCA9IC0xO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gXCJcIikgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgICAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWxhdGl2ZS5ob3N0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gXCJcIiB8fCBzcmNQYXRoWzBdID09PSBcIlwiKTtcbiAgICB9XG5cbiAgICBpZiAoaXNSZWxBYnMpIHtcbiAgICAgICAgLy8gaXRcInMgYWJzb2x1dGUuXG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCA/XG4gICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lID9cbiAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgICAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAgICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gICAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgICAgICAvLyBpdFwicyByZWxhdGl2ZVxuICAgICAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICAgICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgICAgIHNyY1BhdGgucG9wKCk7XG4gICAgICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICB9IGVsc2UgaWYgKHJlbGF0aXZlLnNlYXJjaCkge1xuICAgICAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgICAgIC8vIGxpa2UgaHJlZj1cIj9mb29cIi5cbiAgICAgICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgICAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoXCJtYWlsdG86bG9jYWwxQGRvbWFpbjFcIiwgXCJsb2NhbDJAZG9tYWluMlwiKVxuICAgICAgICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKFwiQFwiKSA+IDAgP1xuICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KFwiQFwiKSA6IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgICAgICByZXN1bHQuX2hyZWYgPSBcIlwiO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgICAgICAvLyB3ZVwidmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAgICAgcmVzdWx0Ll9ocmVmID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gICAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gXCIuXCIgfHwgbGFzdCA9PT0gXCIuLlwiKSB8fFxuICAgICAgICBsYXN0ID09PSBcIlwiKTtcblxuICAgIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICAgIHZhciB1cCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICAgICAgaWYgKGxhc3QgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0ID09PSBcIi4uXCIpIHtcbiAgICAgICAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdXArKztcbiAgICAgICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB1cC0tO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICAgIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgICAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgICAgICAgIHNyY1BhdGgudW5zaGlmdChcIi4uXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gXCJcIiAmJlxuICAgICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQ29kZUF0KDApICE9PSAweDJGIC8qJy8nKi8pKSB7XG4gICAgICAgIHNyY1BhdGgudW5zaGlmdChcIlwiKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKFwiL1wiKS5zdWJzdHIoLTEpICE9PSBcIi9cIikpIHtcbiAgICAgICAgc3JjUGF0aC5wdXNoKFwiXCIpO1xuICAgIH1cblxuICAgIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gXCJcIiB8fFxuICAgICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJDb2RlQXQoMCkgPT09IDB4MkYgLyonLycqLyk7XG5cbiAgICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gXCJcIiA6XG4gICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6IFwiXCI7XG4gICAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgICAgLy91cmwucmVzb2x2ZU9iamVjdChcIm1haWx0bzpsb2NhbDFAZG9tYWluMVwiLCBcImxvY2FsMkBkb21haW4yXCIpXG4gICAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZihcIkBcIikgPiAwID9cbiAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KFwiQFwiKSA6IGZhbHNlO1xuICAgICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgICAgICBzcmNQYXRoLnVuc2hpZnQoXCJcIik7XG4gICAgfVxuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5sZW5ndGggPT09IDAgPyBudWxsIDogc3JjUGF0aC5qb2luKFwiL1wiKTtcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5faHJlZiA9IFwiXCI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoXCJwdW55Y29kZVwiKTtcblVybC5wcm90b3R5cGUuX2hvc3RJZG5hID0gZnVuY3Rpb24gVXJsJF9ob3N0SWRuYShob3N0bmFtZSkge1xuICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICByZXR1cm4gcHVueWNvZGUudG9BU0NJSShob3N0bmFtZSk7XG59O1xuXG52YXIgZXNjYXBlUGF0aE5hbWUgPSBVcmwucHJvdG90eXBlLl9lc2NhcGVQYXRoTmFtZSA9XG5mdW5jdGlvbiBVcmwkX2VzY2FwZVBhdGhOYW1lKHBhdGhuYW1lKSB7XG4gICAgaWYgKCFjb250YWluc0NoYXJhY3RlcjIocGF0aG5hbWUsIDB4MjMgLyonIycqLywgMHgzRiAvKic/JyovKSkge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWU7XG4gICAgfVxuICAgIC8vQXZvaWQgY2xvc3VyZSBjcmVhdGlvbiB0byBrZWVwIHRoaXMgaW5saW5hYmxlXG4gICAgcmV0dXJuIF9lc2NhcGVQYXRoKHBhdGhuYW1lKTtcbn07XG5cbnZhciBlc2NhcGVTZWFyY2ggPSBVcmwucHJvdG90eXBlLl9lc2NhcGVTZWFyY2ggPVxuZnVuY3Rpb24gVXJsJF9lc2NhcGVTZWFyY2goc2VhcmNoKSB7XG4gICAgaWYgKCFjb250YWluc0NoYXJhY3RlcjIoc2VhcmNoLCAweDIzIC8qJyMnKi8sIC0xKSkgcmV0dXJuIHNlYXJjaDtcbiAgICAvL0F2b2lkIGNsb3N1cmUgY3JlYXRpb24gdG8ga2VlcCB0aGlzIGlubGluYWJsZVxuICAgIHJldHVybiBfZXNjYXBlU2VhcmNoKHNlYXJjaCk7XG59O1xuXG5VcmwucHJvdG90eXBlLl9wYXJzZVByb3RvY29sID0gZnVuY3Rpb24gVXJsJF9wYXJzZVByb3RvY29sKHN0ciwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBkb0xvd2VyQ2FzZSA9IGZhbHNlO1xuICAgIHZhciBwcm90b2NvbENoYXJhY3RlcnMgPSB0aGlzLl9wcm90b2NvbENoYXJhY3RlcnM7XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGNoID09PSAweDNBIC8qJzonKi8pIHtcbiAgICAgICAgICAgIHZhciBwcm90b2NvbCA9IHN0ci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgICAgICBpZiAoZG9Mb3dlckNhc2UpIHByb3RvY29sID0gcHJvdG9jb2wudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sID0gcHJvdG9jb2w7XG4gICAgICAgICAgICByZXR1cm4gaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdG9jb2xDaGFyYWN0ZXJzW2NoXSA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGNoIDwgMHg2MSAvKidhJyovKVxuICAgICAgICAgICAgICAgIGRvTG93ZXJDYXNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgfVxuICAgIHJldHVybiBzdGFydDtcbn07XG5cblVybC5wcm90b3R5cGUuX3BhcnNlQXV0aCA9IGZ1bmN0aW9uIFVybCRfcGFyc2VBdXRoKHN0ciwgc3RhcnQsIGVuZCwgZGVjb2RlKSB7XG4gICAgdmFyIGF1dGggPSBzdHIuc2xpY2Uoc3RhcnQsIGVuZCArIDEpO1xuICAgIGlmIChkZWNvZGUpIHtcbiAgICAgICAgYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG4gICAgdGhpcy5hdXRoID0gYXV0aDtcbn07XG5cblVybC5wcm90b3R5cGUuX3BhcnNlUG9ydCA9IGZ1bmN0aW9uIFVybCRfcGFyc2VQb3J0KHN0ciwgc3RhcnQsIGVuZCkge1xuICAgIC8vSW50ZXJuYWwgZm9ybWF0IGlzIGludGVnZXIgZm9yIG1vcmUgZWZmaWNpZW50IHBhcnNpbmdcbiAgICAvL2FuZCBmb3IgZWZmaWNpZW50IHRyaW1taW5nIG9mIGxlYWRpbmcgemVyb3NcbiAgICB2YXIgcG9ydCA9IDA7XG4gICAgLy9EaXN0aW5ndWlzaCBiZXR3ZWVuIDowIGFuZCA6IChubyBwb3J0IG51bWJlciBhdCBhbGwpXG4gICAgdmFyIGhhZENoYXJzID0gZmFsc2U7XG4gICAgdmFyIHZhbGlkUG9ydCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKDB4MzAgLyonMCcqLyA8PSBjaCAmJiBjaCA8PSAweDM5IC8qJzknKi8pIHtcbiAgICAgICAgICAgIHBvcnQgPSAoMTAgKiBwb3J0KSArIChjaCAtIDB4MzAgLyonMCcqLyk7XG4gICAgICAgICAgICBoYWRDaGFycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZFBvcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qy8qJ1xcJyovIHx8IGNoID09PSAweDJGLyonLycqLykge1xuICAgICAgICAgICAgICAgIHZhbGlkUG9ydCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgfVxuICAgIGlmICgocG9ydCA9PT0gMCAmJiAhaGFkQ2hhcnMpIHx8ICF2YWxpZFBvcnQpIHtcbiAgICAgICAgaWYgKCF2YWxpZFBvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcnQgPSAtMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB0aGlzLl9wb3J0ID0gcG9ydDtcbiAgICByZXR1cm4gaSAtIHN0YXJ0O1xufTtcblxuVXJsLnByb3RvdHlwZS5fcGFyc2VIb3N0ID1cbmZ1bmN0aW9uIFVybCRfcGFyc2VIb3N0KHN0ciwgc3RhcnQsIGVuZCwgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgICB2YXIgaG9zdEVuZGluZ0NoYXJhY3RlcnMgPSB0aGlzLl9ob3N0RW5kaW5nQ2hhcmFjdGVycztcbiAgICB2YXIgZmlyc3QgPSBzdHIuY2hhckNvZGVBdChzdGFydCk7XG4gICAgdmFyIHNlY29uZCA9IHN0ci5jaGFyQ29kZUF0KHN0YXJ0ICsgMSk7XG4gICAgaWYgKChmaXJzdCA9PT0gMHgyRiAvKicvJyovIHx8IGZpcnN0ID09PSAweDVDIC8qJ1xcJyovKSAmJlxuICAgICAgICAoc2Vjb25kID09PSAweDJGIC8qJy8nKi8gfHwgc2Vjb25kID09PSAweDVDIC8qJ1xcJyovKSkge1xuICAgICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuXG4gICAgICAgIC8vVGhlIHN0cmluZyBzdGFydHMgd2l0aCAvL1xuICAgICAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgICAgICAgIC8vVGhlIHN0cmluZyBpcyBqdXN0IFwiLy9cIlxuICAgICAgICAgICAgaWYgKGVuZCA8IDIpIHJldHVybiBzdGFydDtcbiAgICAgICAgICAgIC8vSWYgc2xhc2hlcyBkbyBub3QgZGVub3RlIGhvc3QgYW5kIHRoZXJlIGlzIG5vIGF1dGgsXG4gICAgICAgICAgICAvL3RoZXJlIGlzIG5vIGhvc3Qgd2hlbiB0aGUgc3RyaW5nIHN0YXJ0cyB3aXRoIC8vXG4gICAgICAgICAgICB2YXIgaGFzQXV0aCA9XG4gICAgICAgICAgICAgICAgY29udGFpbnNDaGFyYWN0ZXIoc3RyLCAweDQwIC8qJ0AnKi8sIDIsIGhvc3RFbmRpbmdDaGFyYWN0ZXJzKTtcbiAgICAgICAgICAgIGlmICghaGFzQXV0aCAmJiAhc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL1RoZXJlIGlzIGEgaG9zdCB0aGF0IHN0YXJ0cyBhZnRlciB0aGUgLy9cbiAgICAgICAgc3RhcnQgKz0gMjtcbiAgICB9XG4gICAgLy9JZiB0aGVyZSBpcyBubyBzbGFzaGVzLCB0aGVyZSBpcyBubyBob3N0bmFtZSBpZlxuICAgIC8vMS4gdGhlcmUgd2FzIG5vIHByb3RvY29sIGF0IGFsbFxuICAgIGVsc2UgaWYgKCF0aGlzLl9wcm90b2NvbCB8fFxuICAgICAgICAvLzIuIHRoZXJlIHdhcyBhIHByb3RvY29sIHRoYXQgcmVxdWlyZXMgc2xhc2hlc1xuICAgICAgICAvL2UuZy4gaW4gJ2h0dHA6YXNkJyAnYXNkJyBpcyBub3QgYSBob3N0bmFtZVxuICAgICAgICBzbGFzaFByb3RvY29sc1t0aGlzLl9wcm90b2NvbF1cbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cblxuICAgIHZhciBkb0xvd2VyQ2FzZSA9IGZhbHNlO1xuICAgIHZhciBpZG5hID0gZmFsc2U7XG4gICAgdmFyIGhvc3ROYW1lU3RhcnQgPSBzdGFydDtcbiAgICB2YXIgaG9zdE5hbWVFbmQgPSBlbmQ7XG4gICAgdmFyIGxhc3RDaCA9IC0xO1xuICAgIHZhciBwb3J0TGVuZ3RoID0gMDtcbiAgICB2YXIgY2hhcnNBZnRlckRvdCA9IDA7XG4gICAgdmFyIGF1dGhOZWVkc0RlY29kaW5nID0gZmFsc2U7XG5cbiAgICB2YXIgaiA9IC0xO1xuXG4gICAgLy9GaW5kIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgYW4gQC1zaWduIHVudGlsIGhvc3RlbmRpbmcgY2hhcmFjdGVyIGlzIG1ldFxuICAgIC8vYWxzbyBtYXJrIGlmIGRlY29kaW5nIGlzIG5lZWRlZCBmb3IgdGhlIGF1dGggcG9ydGlvblxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoY2ggPT09IDB4NDAgLyonQCcqLykge1xuICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgLy9UaGlzIGNoZWNrIGlzIHZlcnksIHZlcnkgY2hlYXAuIFVubmVlZGVkIGRlY29kZVVSSUNvbXBvbmVudCBpcyB2ZXJ5XG4gICAgICAgIC8vdmVyeSBleHBlbnNpdmVcbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4MjUgLyonJScqLykge1xuICAgICAgICAgICAgYXV0aE5lZWRzRGVjb2RpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhvc3RFbmRpbmdDaGFyYWN0ZXJzW2NoXSA9PT0gMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL0Atc2lnbiB3YXMgZm91bmQgYXQgaW5kZXggaiwgZXZlcnl0aGluZyB0byB0aGUgbGVmdCBmcm9tIGl0XG4gICAgLy9pcyBhdXRoIHBhcnRcbiAgICBpZiAoaiA+IC0xKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlQXV0aChzdHIsIHN0YXJ0LCBqIC0gMSwgYXV0aE5lZWRzRGVjb2RpbmcpO1xuICAgICAgICAvL2hvc3RuYW1lIHN0YXJ0cyBhZnRlciB0aGUgbGFzdCBALXNpZ25cbiAgICAgICAgc3RhcnQgPSBob3N0TmFtZVN0YXJ0ID0gaiArIDE7XG4gICAgfVxuXG4gICAgLy9Ib3N0IG5hbWUgaXMgc3RhcnRpbmcgd2l0aCBhIFtcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoc3RhcnQpID09PSAweDVCIC8qJ1snKi8pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0ICsgMTsgaSA8PSBlbmQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgICAgIC8vQXNzdW1lIHZhbGlkIElQNiBpcyBiZXR3ZWVuIHRoZSBicmFja2V0c1xuICAgICAgICAgICAgaWYgKGNoID09PSAweDVEIC8qJ10nKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSArIDEpID09PSAweDNBIC8qJzonKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcG9ydExlbmd0aCA9IHRoaXMuX3BhcnNlUG9ydChzdHIsIGkgKyAyLCBlbmQpICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGhvc3RuYW1lID0gc3RyLnNsaWNlKHN0YXJ0ICsgMSwgaSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gaG9zdG5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0ID0gdGhpcy5fcG9ydCA+IDAgP1xuICAgICAgICAgICAgICAgICAgICBcIltcIiArIGhvc3RuYW1lICsgXCJdOlwiICsgdGhpcy5fcG9ydCA6XG4gICAgICAgICAgICAgICAgICAgIFwiW1wiICsgaG9zdG5hbWUgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhuYW1lID0gXCIvXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKyBwb3J0TGVuZ3RoICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL0VtcHR5IGhvc3RuYW1lLCBbIHN0YXJ0cyBhIHBhdGhcbiAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgICAgICBpZiAoY2hhcnNBZnRlckRvdCA+IDYyKSB7XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0ID0gc3RyLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChjaCA9PT0gMHgzQSAvKic6JyovKSB7XG4gICAgICAgICAgICBwb3J0TGVuZ3RoID0gdGhpcy5fcGFyc2VQb3J0KHN0ciwgaSArIDEsIGVuZCkgKyAxO1xuICAgICAgICAgICAgaG9zdE5hbWVFbmQgPSBpIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoIDwgMHg2MSAvKidhJyovKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDB4MkUgLyonLicqLykge1xuICAgICAgICAgICAgICAgIC8vTm9kZS5qcyBpZ25vcmVzIHRoaXMgZXJyb3JcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIGlmIChsYXN0Q2ggPT09IERPVCB8fCBsYXN0Q2ggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3QgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2hhcnNBZnRlckRvdCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoMHg0MSAvKidBJyovIDw9IGNoICYmIGNoIDw9IDB4NUEgLyonWicqLykge1xuICAgICAgICAgICAgICAgIGRvTG93ZXJDYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vVmFsaWQgY2hhcmFjdGVycyBvdGhlciB0aGFuIEFTQ0lJIGxldHRlcnMgLSwgXywgKywgMC05XG4gICAgICAgICAgICBlbHNlIGlmICghKGNoID09PSAweDJEIC8qJy0nKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgY2ggPT09IDB4NUYgLyonXycqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICBjaCA9PT0gMHgyQiAvKicrJyovIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICgweDMwIC8qJzAnKi8gPD0gY2ggJiYgY2ggPD0gMHgzOSAvKic5JyovKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoaG9zdEVuZGluZ0NoYXJhY3RlcnNbY2hdID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25vUHJlcGVuZFNsYXNoSG9zdEVuZGVyc1tjaF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlcGVuZFNsYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaG9zdE5hbWVFbmQgPSBpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA+PSAweDdCIC8qJ3snKi8pIHtcbiAgICAgICAgICAgIGlmIChjaCA8PSAweDdFIC8qJ34nKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbm9QcmVwZW5kU2xhc2hIb3N0RW5kZXJzW2NoXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmVwZW5kU2xhc2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBob3N0TmFtZUVuZCA9IGkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWRuYSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdENoID0gY2g7XG4gICAgICAgIGNoYXJzQWZ0ZXJEb3QrKztcbiAgICB9XG5cbiAgICAvL05vZGUuanMgaWdub3JlcyB0aGlzIGVycm9yXG4gICAgLypcbiAgICBpZiAobGFzdENoID09PSBET1QpIHtcbiAgICAgICAgaG9zdE5hbWVFbmQtLTtcbiAgICB9XG4gICAgKi9cblxuICAgIGlmIChob3N0TmFtZUVuZCArIDEgIT09IHN0YXJ0ICYmXG4gICAgICAgIGhvc3ROYW1lRW5kIC0gaG9zdE5hbWVTdGFydCA8PSAyNTYpIHtcbiAgICAgICAgdmFyIGhvc3RuYW1lID0gc3RyLnNsaWNlKGhvc3ROYW1lU3RhcnQsIGhvc3ROYW1lRW5kICsgMSk7XG4gICAgICAgIGlmIChkb0xvd2VyQ2FzZSkgaG9zdG5hbWUgPSBob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoaWRuYSkgaG9zdG5hbWUgPSB0aGlzLl9ob3N0SWRuYShob3N0bmFtZSk7XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgPSBob3N0bmFtZTtcbiAgICAgICAgdGhpcy5ob3N0ID0gdGhpcy5fcG9ydCA+IDAgPyBob3N0bmFtZSArIFwiOlwiICsgdGhpcy5fcG9ydCA6IGhvc3RuYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBob3N0TmFtZUVuZCArIDEgKyBwb3J0TGVuZ3RoO1xuXG59O1xuXG5VcmwucHJvdG90eXBlLl9jb3B5UHJvcHNUbyA9IGZ1bmN0aW9uIFVybCRfY29weVByb3BzVG8oaW5wdXQsIG5vUHJvdG9jb2wpIHtcbiAgICBpZiAoIW5vUHJvdG9jb2wpIHtcbiAgICAgICAgaW5wdXQuX3Byb3RvY29sID0gdGhpcy5fcHJvdG9jb2w7XG4gICAgfVxuICAgIGlucHV0Ll9ocmVmID0gdGhpcy5faHJlZjtcbiAgICBpbnB1dC5fcG9ydCA9IHRoaXMuX3BvcnQ7XG4gICAgaW5wdXQuX3ByZXBlbmRTbGFzaCA9IHRoaXMuX3ByZXBlbmRTbGFzaDtcbiAgICBpbnB1dC5hdXRoID0gdGhpcy5hdXRoO1xuICAgIGlucHV0LnNsYXNoZXMgPSB0aGlzLnNsYXNoZXM7XG4gICAgaW5wdXQuaG9zdCA9IHRoaXMuaG9zdDtcbiAgICBpbnB1dC5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWU7XG4gICAgaW5wdXQuaGFzaCA9IHRoaXMuaGFzaDtcbiAgICBpbnB1dC5zZWFyY2ggPSB0aGlzLnNlYXJjaDtcbiAgICBpbnB1dC5wYXRobmFtZSA9IHRoaXMucGF0aG5hbWU7XG59O1xuXG5VcmwucHJvdG90eXBlLl9jbG9uZSA9IGZ1bmN0aW9uIFVybCRfY2xvbmUoKSB7XG4gICAgdmFyIHJldCA9IG5ldyBVcmwoKTtcbiAgICByZXQuX3Byb3RvY29sID0gdGhpcy5fcHJvdG9jb2w7XG4gICAgcmV0Ll9ocmVmID0gdGhpcy5faHJlZjtcbiAgICByZXQuX3BvcnQgPSB0aGlzLl9wb3J0O1xuICAgIHJldC5fcHJlcGVuZFNsYXNoID0gdGhpcy5fcHJlcGVuZFNsYXNoO1xuICAgIHJldC5hdXRoID0gdGhpcy5hdXRoO1xuICAgIHJldC5zbGFzaGVzID0gdGhpcy5zbGFzaGVzO1xuICAgIHJldC5ob3N0ID0gdGhpcy5ob3N0O1xuICAgIHJldC5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWU7XG4gICAgcmV0Lmhhc2ggPSB0aGlzLmhhc2g7XG4gICAgcmV0LnNlYXJjaCA9IHRoaXMuc2VhcmNoO1xuICAgIHJldC5wYXRobmFtZSA9IHRoaXMucGF0aG5hbWU7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblVybC5wcm90b3R5cGUuX2dldENvbXBvbmVudEVzY2FwZWQgPVxuZnVuY3Rpb24gVXJsJF9nZXRDb21wb25lbnRFc2NhcGVkKHN0ciwgc3RhcnQsIGVuZCwgaXNBZnRlclF1ZXJ5KSB7XG4gICAgdmFyIGN1ciA9IHN0YXJ0O1xuICAgIHZhciBpID0gc3RhcnQ7XG4gICAgdmFyIHJldCA9IFwiXCI7XG4gICAgdmFyIGF1dG9Fc2NhcGVNYXAgPSBpc0FmdGVyUXVlcnkgP1xuICAgICAgICB0aGlzLl9hZnRlclF1ZXJ5QXV0b0VzY2FwZU1hcCA6IHRoaXMuX2F1dG9Fc2NhcGVNYXA7XG4gICAgZm9yICg7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBlc2NhcGVkID0gYXV0b0VzY2FwZU1hcFtjaF07XG5cbiAgICAgICAgaWYgKGVzY2FwZWQgIT09IFwiXCIgJiYgZXNjYXBlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoY3VyIDwgaSkgcmV0ICs9IHN0ci5zbGljZShjdXIsIGkpO1xuICAgICAgICAgICAgcmV0ICs9IGVzY2FwZWQ7XG4gICAgICAgICAgICBjdXIgPSBpICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VyIDwgaSArIDEpIHJldCArPSBzdHIuc2xpY2UoY3VyLCBpKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuVXJsLnByb3RvdHlwZS5fcGFyc2VQYXRoID1cbmZ1bmN0aW9uIFVybCRfcGFyc2VQYXRoKHN0ciwgc3RhcnQsIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycykge1xuICAgIHZhciBwYXRoU3RhcnQgPSBzdGFydDtcbiAgICB2YXIgcGF0aEVuZCA9IGVuZDtcbiAgICB2YXIgZXNjYXBlID0gZmFsc2U7XG4gICAgdmFyIGF1dG9Fc2NhcGVDaGFyYWN0ZXJzID0gdGhpcy5fYXV0b0VzY2FwZUNoYXJhY3RlcnM7XG4gICAgdmFyIHByZVBhdGggPSB0aGlzLl9wb3J0ID09PSAtMiA/IFwiLzpcIiA6IFwiXCI7XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjaCA9PT0gMHgyMyAvKicjJyovKSB7XG4gICAgICAgICAgdGhpcy5fcGFyc2VIYXNoKHN0ciwgaSwgZW5kLCBkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKTtcbiAgICAgICAgICAgIHBhdGhFbmQgPSBpIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAweDNGIC8qJz8nKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlUXVlcnkoc3RyLCBpLCBlbmQsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpO1xuICAgICAgICAgICAgcGF0aEVuZCA9IGkgLSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRpc2FibGVBdXRvRXNjYXBlQ2hhcnMgJiYgIWVzY2FwZSAmJiBhdXRvRXNjYXBlQ2hhcmFjdGVyc1tjaF0gPT09IDEpIHtcbiAgICAgICAgICAgIGVzY2FwZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF0aFN0YXJ0ID4gcGF0aEVuZCkge1xuICAgICAgICB0aGlzLnBhdGhuYW1lID0gcHJlUGF0aCA9PT0gXCJcIiA/IFwiL1wiIDogcHJlUGF0aDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoO1xuICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgcGF0aCA9IHRoaXMuX2dldENvbXBvbmVudEVzY2FwZWQoc3RyLCBwYXRoU3RhcnQsIHBhdGhFbmQsIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhdGggPSBzdHIuc2xpY2UocGF0aFN0YXJ0LCBwYXRoRW5kICsgMSk7XG4gICAgfVxuICAgIHRoaXMucGF0aG5hbWUgPSBwcmVQYXRoID09PSBcIlwiXG4gICAgICAgID8gKHRoaXMuX3ByZXBlbmRTbGFzaCA/IFwiL1wiICsgcGF0aCA6IHBhdGgpXG4gICAgICAgIDogcHJlUGF0aCArIHBhdGg7XG59O1xuXG5VcmwucHJvdG90eXBlLl9wYXJzZVF1ZXJ5ID0gZnVuY3Rpb24gVXJsJF9wYXJzZVF1ZXJ5KHN0ciwgc3RhcnQsIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycykge1xuICAgIHZhciBxdWVyeVN0YXJ0ID0gc3RhcnQ7XG4gICAgdmFyIHF1ZXJ5RW5kID0gZW5kO1xuICAgIHZhciBlc2NhcGUgPSBmYWxzZTtcbiAgICB2YXIgYXV0b0VzY2FwZUNoYXJhY3RlcnMgPSB0aGlzLl9hdXRvRXNjYXBlQ2hhcmFjdGVycztcblxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoY2ggPT09IDB4MjMgLyonIycqLykge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VIYXNoKHN0ciwgaSwgZW5kLCBkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKTtcbiAgICAgICAgICAgIHF1ZXJ5RW5kID0gaSAtIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyAmJiAhZXNjYXBlICYmIGF1dG9Fc2NhcGVDaGFyYWN0ZXJzW2NoXSA9PT0gMSkge1xuICAgICAgICAgICAgZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChxdWVyeVN0YXJ0ID4gcXVlcnlFbmQpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBcIlwiO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHF1ZXJ5O1xuICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgcXVlcnkgPSB0aGlzLl9nZXRDb21wb25lbnRFc2NhcGVkKHN0ciwgcXVlcnlTdGFydCwgcXVlcnlFbmQsIHRydWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcXVlcnkgPSBzdHIuc2xpY2UocXVlcnlTdGFydCwgcXVlcnlFbmQgKyAxKTtcbiAgICB9XG4gICAgdGhpcy5zZWFyY2ggPSBxdWVyeTtcbn07XG5cblVybC5wcm90b3R5cGUuX3BhcnNlSGFzaCA9IGZ1bmN0aW9uIFVybCRfcGFyc2VIYXNoKHN0ciwgc3RhcnQsIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycykge1xuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICB0aGlzLmhhc2ggPSBcIlwiO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5oYXNoID0gZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyA/XG4gICAgICAgIHN0ci5zbGljZShzdGFydCwgZW5kICsgMSkgOiB0aGlzLl9nZXRDb21wb25lbnRFc2NhcGVkKHN0ciwgc3RhcnQsIGVuZCwgdHJ1ZSk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVXJsLnByb3RvdHlwZSwgXCJwb3J0XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fcG9ydCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gKFwiXCIgKyB0aGlzLl9wb3J0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0ID0gcGFyc2VJbnQodiwgMTApO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVcmwucHJvdG90eXBlLCBcInF1ZXJ5XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLl9xdWVyeTtcbiAgICAgICAgaWYgKHF1ZXJ5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2g7XG5cbiAgICAgICAgaWYgKHNlYXJjaCkge1xuICAgICAgICAgICAgaWYgKHNlYXJjaC5jaGFyQ29kZUF0KDApID09PSAweDNGIC8qJz8nKi8pIHtcbiAgICAgICAgICAgICAgICBzZWFyY2ggPSBzZWFyY2guc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VhcmNoICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVlcnkgPSBzZWFyY2g7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VhcmNoO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXMuX3F1ZXJ5ID0gdjtcbiAgICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVybC5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8IFwiXCI7XG4gICAgICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgXCJcIjtcbiAgICAgICAgaWYgKHAgfHwgcykge1xuICAgICAgICAgICAgcmV0dXJuIHAgKyBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocCA9PSBudWxsICYmIHMpID8gKFwiL1wiICsgcykgOiBudWxsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbigpIHt9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVybC5wcm90b3R5cGUsIFwicHJvdG9jb2xcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcm90byA9IHRoaXMuX3Byb3RvY29sO1xuICAgICAgICByZXR1cm4gcHJvdG8gPyBwcm90byArIFwiOlwiIDogcHJvdG87XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgZW5kID0gdi5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKHYuY2hhckNvZGVBdChlbmQpID09PSAweDNBIC8qJzonKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm90b2NvbCA9IHYuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVXJsLnByb3RvdHlwZSwgXCJocmVmXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHJlZiA9IHRoaXMuX2hyZWY7XG4gICAgICAgIGlmICghaHJlZikge1xuICAgICAgICAgICAgaHJlZiA9IHRoaXMuX2hyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBocmVmO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXMuX2hyZWYgPSB2O1xuICAgIH1cbn0pO1xuXG5VcmwucGFyc2UgPSBmdW5jdGlvbiBVcmwkUGFyc2Uoc3RyLCBwYXJzZVF1ZXJ5U3RyaW5nLCBob3N0RGVub3Rlc1NsYXNoLCBkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKSB7XG4gICAgaWYgKHN0ciBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHN0cjtcbiAgICB2YXIgcmV0ID0gbmV3IFVybCgpO1xuICAgIHJldC5wYXJzZShzdHIsICEhcGFyc2VRdWVyeVN0cmluZywgISFob3N0RGVub3Rlc1NsYXNoLCAhIWRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5VcmwuZm9ybWF0ID0gZnVuY3Rpb24gVXJsJEZvcm1hdChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvYmogPSBVcmwucGFyc2Uob2JqKTtcbiAgICB9XG4gICAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkge1xuICAgICAgICByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICAgIH1cbiAgICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufTtcblxuVXJsLnJlc29sdmUgPSBmdW5jdGlvbiBVcmwkUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gICAgcmV0dXJuIFVybC5wYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn07XG5cblVybC5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24gVXJsJFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICAgIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gICAgcmV0dXJuIFVybC5wYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn07XG5cbmZ1bmN0aW9uIF9lc2NhcGVQYXRoKHBhdGhuYW1lKSB7XG4gICAgcmV0dXJuIHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9lc2NhcGVTZWFyY2goc2VhcmNoKSB7XG4gICAgcmV0dXJuIHNlYXJjaC5yZXBsYWNlKC8jL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICAgIH0pO1xufVxuXG4vL1NlYXJjaCBgY2hhcjFgIChpbnRlZ2VyIGNvZGUgZm9yIGEgY2hhcmFjdGVyKSBpbiBgc3RyaW5nYFxuLy9zdGFydGluZyBmcm9tIGBmcm9tSW5kZXhgIGFuZCBlbmRpbmcgYXQgYHN0cmluZy5sZW5ndGggLSAxYFxuLy9vciB3aGVuIGEgc3RvcCBjaGFyYWN0ZXIgaXMgZm91bmRcbmZ1bmN0aW9uIGNvbnRhaW5zQ2hhcmFjdGVyKHN0cmluZywgY2hhcjEsIGZyb21JbmRleCwgc3RvcENoYXJhY3RlclRhYmxlKSB7XG4gICAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IGZyb21JbmRleDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChjaCA9PT0gY2hhcjEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0b3BDaGFyYWN0ZXJUYWJsZVtjaF0gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vU2VlIGlmIGBjaGFyMWAgb3IgYGNoYXIyYCAoaW50ZWdlciBjb2RlcyBmb3IgY2hhcmFjdGVycylcbi8vaXMgY29udGFpbmVkIGluIGBzdHJpbmdgXG5mdW5jdGlvbiBjb250YWluc0NoYXJhY3RlcjIoc3RyaW5nLCBjaGFyMSwgY2hhcjIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2ggPT09IGNoYXIxIHx8IGNoID09PSBjaGFyMikgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy9NYWtlcyBhbiBhcnJheSBvZiAxMjggdWludDgncyB3aGljaCByZXByZXNlbnQgYm9vbGVhbiB2YWx1ZXMuXG4vL1NwZWMgaXMgYW4gYXJyYXkgb2YgYXNjaWkgY29kZSBwb2ludHMgb3IgYXNjaWkgY29kZSBwb2ludCByYW5nZXNcbi8vcmFuZ2VzIGFyZSBleHByZXNzZWQgYXMgW3N0YXJ0LCBlbmRdXG5cbi8vQ3JlYXRlIGEgdGFibGUgd2l0aCB0aGUgY2hhcmFjdGVycyAweDMwLTB4MzkgKGRlY2ltYWxzICcwJyAtICc5JykgYW5kXG4vLzB4N0EgKGxvd2VyY2FzZWxldHRlciAneicpIGFzIGB0cnVlYDpcbi8vXG4vL3ZhciBhID0gbWFrZUFzY2lpVGFibGUoW1sweDMwLCAweDM5XSwgMHg3QV0pO1xuLy9hWzB4MzBdOyAvLzFcbi8vYVsweDE1XTsgLy8wXG4vL2FbMHgzNV07IC8vMVxuZnVuY3Rpb24gbWFrZUFzY2lpVGFibGUoc3BlYykge1xuICAgIHZhciByZXQgPSBuZXcgVWludDhBcnJheSgxMjgpO1xuICAgIHNwZWMuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXRbaXRlbV0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaXRlbVswXTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBpdGVtWzFdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0OyBqIDw9IGVuZDsgKytqKSB7XG4gICAgICAgICAgICAgICAgcmV0W2pdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuXG52YXIgYXV0b0VzY2FwZSA9IFtcIjxcIiwgXCI+XCIsIFwiXFxcIlwiLCBcImBcIiwgXCIgXCIsIFwiXFxyXCIsIFwiXFxuXCIsXG4gICAgXCJcXHRcIiwgXCJ7XCIsIFwifVwiLCBcInxcIiwgXCJcXFxcXCIsIFwiXlwiLCBcImBcIiwgXCInXCJdO1xuXG52YXIgYXV0b0VzY2FwZU1hcCA9IG5ldyBBcnJheSgxMjgpO1xuXG5cblxuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGF1dG9Fc2NhcGVNYXAubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBhdXRvRXNjYXBlTWFwW2ldID0gXCJcIjtcbn1cblxuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgYyA9IGF1dG9Fc2NhcGVbaV07XG4gICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChjKTtcbiAgICBpZiAoZXNjID09PSBjKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShjKTtcbiAgICB9XG4gICAgYXV0b0VzY2FwZU1hcFtjLmNoYXJDb2RlQXQoMCldID0gZXNjO1xufVxudmFyIGFmdGVyUXVlcnlBdXRvRXNjYXBlTWFwID0gYXV0b0VzY2FwZU1hcC5zbGljZSgpO1xuYXV0b0VzY2FwZU1hcFsweDVDIC8qJ1xcJyovXSA9IFwiL1wiO1xuXG52YXIgc2xhc2hQcm90b2NvbHMgPSBVcmwucHJvdG90eXBlLl9zbGFzaFByb3RvY29scyA9IHtcbiAgICBodHRwOiB0cnVlLFxuICAgIGh0dHBzOiB0cnVlLFxuICAgIGdvcGhlcjogdHJ1ZSxcbiAgICBmaWxlOiB0cnVlLFxuICAgIGZ0cDogdHJ1ZSxcblxuICAgIFwiaHR0cDpcIjogdHJ1ZSxcbiAgICBcImh0dHBzOlwiOiB0cnVlLFxuICAgIFwiZ29waGVyOlwiOiB0cnVlLFxuICAgIFwiZmlsZTpcIjogdHJ1ZSxcbiAgICBcImZ0cDpcIjogdHJ1ZVxufTtcblxuLy9PcHRpbWl6ZSBiYWNrIGZyb20gbm9ybWFsaXplZCBvYmplY3QgY2F1c2VkIGJ5IG5vbi1pZGVudGlmaWVyIGtleXNcbmZ1bmN0aW9uIGYoKXt9XG5mLnByb3RvdHlwZSA9IHNsYXNoUHJvdG9jb2xzO1xuXG5VcmwucHJvdG90eXBlLl9wcm90b2NvbENoYXJhY3RlcnMgPSBtYWtlQXNjaWlUYWJsZShbXG4gICAgWzB4NjEgLyonYScqLywgMHg3QSAvKid6JyovXSxcbiAgICBbMHg0MSAvKidBJyovLCAweDVBIC8qJ1onKi9dLFxuICAgIDB4MkUgLyonLicqLywgMHgyQiAvKicrJyovLCAweDJEIC8qJy0nKi9cbl0pO1xuXG5VcmwucHJvdG90eXBlLl9ob3N0RW5kaW5nQ2hhcmFjdGVycyA9IG1ha2VBc2NpaVRhYmxlKFtcbiAgICAweDIzIC8qJyMnKi8sIDB4M0YgLyonPycqLywgMHgyRiAvKicvJyovLCAweDVDIC8qJ1xcJyovXG5dKTtcblxuVXJsLnByb3RvdHlwZS5fYXV0b0VzY2FwZUNoYXJhY3RlcnMgPSBtYWtlQXNjaWlUYWJsZShcbiAgICBhdXRvRXNjYXBlLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2LmNoYXJDb2RlQXQoMCk7XG4gICAgfSlcbik7XG5cbi8vSWYgdGhlc2UgY2hhcmFjdGVycyBlbmQgYSBob3N0IG5hbWUsIHRoZSBwYXRoIHdpbGwgbm90IGJlIHByZXBlbmRlZCBhIC9cblVybC5wcm90b3R5cGUuX25vUHJlcGVuZFNsYXNoSG9zdEVuZGVycyA9IG1ha2VBc2NpaVRhYmxlKFxuICAgIFtcbiAgICAgICAgXCI8XCIsIFwiPlwiLCBcIidcIiwgXCJgXCIsIFwiIFwiLCBcIlxcclwiLFxuICAgICAgICBcIlxcblwiLCBcIlxcdFwiLCBcIntcIiwgXCJ9XCIsIFwifFwiLFxuICAgICAgICBcIl5cIiwgXCJgXCIsIFwiXFxcIlwiLCBcIiVcIiwgXCI7XCJcbiAgICBdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2LmNoYXJDb2RlQXQoMCk7XG4gICAgfSlcbik7XG5cblVybC5wcm90b3R5cGUuX2F1dG9Fc2NhcGVNYXAgPSBhdXRvRXNjYXBlTWFwO1xuVXJsLnByb3RvdHlwZS5fYWZ0ZXJRdWVyeUF1dG9Fc2NhcGVNYXAgPSBhZnRlclF1ZXJ5QXV0b0VzY2FwZU1hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBVcmw7XG5cblVybC5yZXBsYWNlID0gZnVuY3Rpb24gVXJsJFJlcGxhY2UoKSB7XG4gICAgcmVxdWlyZS5jYWNoZS51cmwgPSB7XG4gICAgICAgIGV4cG9ydHM6IFVybFxuICAgIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmFzdC11cmwtcGFyc2VyL3NyYy91cmxwYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgUGV0a2EgQW50b25vdlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6PC9wPlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgUXVlcnlTdHJpbmdTZXJpYWxpemVyID0gcmVxdWlyZShcIi4vcXVlcnlzdHJpbmdzZXJpYWxpemVyLmpzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBRdWVyeVN0cmluZ1BhcnNlcjtcblxudmFyIHJwbHVzID0gL1xcKy9nO1xudmFyIHJpbnQgPSAvXlswLTldKyQvO1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xudmFyIGhhdmVQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIFF1ZXJ5U3RyaW5nUGFyc2VyKCkge1xuICAgIHRoaXMuY29udGFpbnNTcGFyc2UgPSBmYWxzZTtcbiAgICB0aGlzLmNhY2hlS2V5ID0gXCJcIjtcbiAgICB0aGlzLmNhY2hlVmFsID0gbnVsbDtcbn1cblxuUXVlcnlTdHJpbmdQYXJzZXIubWF4TGVuZ3RoID0gMzI3Njg7XG5RdWVyeVN0cmluZ1BhcnNlci5tYXhEZXB0aCA9IDQ7XG5RdWVyeVN0cmluZ1BhcnNlci5tYXhLZXlzID0gMjU2O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wYXJzZSA9IGZ1bmN0aW9uIFF1ZXJ5U3RyaW5nUGFyc2VyJFBhcnNlKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBtYXhMZW5ndGggPSBRdWVyeVN0cmluZ1BhcnNlci5tYXhMZW5ndGg7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgICAgICAgICBcInN0ciBpcyB0b28gbGFyZ2UgKFwiICtcbiAgICAgICAgICAgICAgICBcIlF1ZXJ5U3RyaW5nUGFyc2VyLm1heExlbmd0aD1cIiArIG1heExlbmd0aCArIFwiKVwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJzZXIgPSBuZXcgUXVlcnlTdHJpbmdQYXJzZXIoKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZVN0cmluZyhzdHIsIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RyICE9PSBudWxsICYmIHR5cGVvZiBzdHIgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBRdWVyeVN0cmluZ1BhcnNlcigpO1xuICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlT2JqZWN0KHN0cik7XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn07XG5cblF1ZXJ5U3RyaW5nUGFyc2VyLnN0cmluZ2lmeSA9XG5mdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlciRTdHJpbmdpZnkodmFsdWUpIHtcbiAgICB2YXIgc2VyaWFsaXplciA9IG5ldyBRdWVyeVN0cmluZ1NlcmlhbGl6ZXIoKTtcbiAgICByZXR1cm4gc2VyaWFsaXplci5zZXJpYWxpemUodmFsdWUpO1xufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLmRlY29kZSA9XG5mdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlciRkZWNvZGUoc3RyLCBzaG91bGREZWNvZGUsIGNvbnRhaW5zUGx1cykge1xuICAgIGlmIChzaG91bGREZWNvZGUgPT09IGZhbHNlKSByZXR1cm4gc3RyO1xuICAgIGlmIChjb250YWluc1BsdXMgPT09IHRydWUpIHN0ciA9IHN0ci5yZXBsYWNlKHJwbHVzLCBcIiBcIik7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn07XG5cblF1ZXJ5U3RyaW5nUGFyc2VyLnByb3RvdHlwZS5tYXliZUFycmF5SW5kZXggPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkbWF5YmVBcnJheUluZGV4KHN0ciwgYXJyYXlMZW5ndGgpIHtcbiAgICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgIHJldHVybiBhcnJheUxlbmd0aDtcbiAgICB9XG4gICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoMCk7XG5cbiAgICBpZiAoY2ggPT09IDQ4KSB7XG4gICAgICAgIHJldHVybiBsZW4gPiAxID8gLTEgOiAwO1xuICAgIH1cbiAgICBlbHNlIGlmICg0OCA8PSBjaCAmJiBjaCA8PSA1Nykge1xuICAgICAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY2ggLSA0ODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyaW50LnRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgdmFyIHYgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgICAgICAgICAgIGlmICgwIDwgdiAmJiB2IDw9IDEwNzM3NDE4MjIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wcm90b3R5cGUuZ2V0U2xvdCA9XG5mdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlciRnZXRTbG90KGRpY3Rpb25hcnksIHByZXZLZXksIGN1cktleSkge1xuICAgIHZhciBzbG90O1xuICAgIGlmICghKGhhdmVQcm9wLmNhbGwoZGljdGlvbmFyeSwgcHJldktleSkpKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMubWF5YmVBcnJheUluZGV4KGN1cktleSwgMCk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBzbG90ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzbG90ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZGljdGlvbmFyeVtwcmV2S2V5XSA9IHNsb3Q7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzbG90ID0gZGljdGlvbmFyeVtwcmV2S2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHNsb3Q7XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wcm90b3R5cGUucGxhY2VOZXN0ZWRWYWx1ZSA9XG5mdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlciRwbGFjZU5lc3RlZFZhbHVlXG4oZGljdGlvbmFyeSwga2V5LCB2YWx1ZSwgaSwgcHJldktleSwgY3VyS2V5KSB7XG4gICAgdmFyIHNsb3QgPSB0aGlzLmdldFNsb3QoZGljdGlvbmFyeSwgcHJldktleSwgY3VyS2V5KTtcbiAgICB2YXIgaW5kZXggPSAtMTtcblxuICAgIGlmIChpc0FycmF5KHNsb3QpKSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5tYXliZUFycmF5SW5kZXgoY3VyS2V5LCBzbG90Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IGtleS5sZW5ndGg7XG4gICAgdmFyIGRlcHRoID0gMjtcbiAgICB2YXIgbWF4RGVwdGggPSBRdWVyeVN0cmluZ1BhcnNlci5tYXhEZXB0aDtcbiAgICB2YXIgc3RhcnQgPSAtMTtcbiAgICBmb3IgKDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IGtleS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2ggPT09IDkxKSB7XG4gICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSA5MyAmJlxuICAgICAgICAgICAgICAgIHN0YXJ0ID4gLTEpIHtcbiAgICAgICAgICAgIHByZXZLZXkgPSBjdXJLZXk7XG4gICAgICAgICAgICBjdXJLZXkgPSBzdGFydCA9PT0gaSA/IFwiXCIgOiBrZXkuc3Vic3RyaW5nKHN0YXJ0LCBpKTtcbiAgICAgICAgICAgIHN0YXJ0ID0gLTE7XG4gICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgaWYgKGRlcHRoID4gbWF4RGVwdGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5lc3RpbmcgZGVwdGggb2Yga2V5cyBpcyB0b28gbGFyZ2UgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIihRdWVyeVN0cmluZ1BhcnNlci5tYXhEZXB0aD1cIittYXhEZXB0aCtcIilcIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2xvdCA9IHRoaXMuZ2V0U2xvdChzbG90LCBwcmV2S2V5LCBjdXJLZXkpO1xuXG4gICAgICAgICAgICBpbmRleCA9IGlzQXJyYXkoc2xvdClcbiAgICAgICAgICAgICAgICA/IHRoaXMubWF5YmVBcnJheUluZGV4KGN1cktleSwgc2xvdC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgOiAtMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGluZGV4ID4gLTEpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHNsb3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2xvdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbnNTcGFyc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNsb3RbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0KHNsb3QsIGN1cktleSwgdmFsdWUpO1xuICAgIH1cbn07XG5cblF1ZXJ5U3RyaW5nUGFyc2VyLnByb3RvdHlwZS5pbnNlcnQgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkaW5zZXJ0KGRpY3Rpb25hcnksIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgcmV0ID0gbnVsbDtcbiAgICBpZiAoaGF2ZVByb3AuY2FsbChkaWN0aW9uYXJ5LCBrZXkpKSB7XG4gICAgICAgIHZhciBwcmV2ID0gZGljdGlvbmFyeVtrZXldO1xuICAgICAgICBpZiggaXNBcnJheShwcmV2KSApIHtcbiAgICAgICAgICAgIHByZXYucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXQgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gW3ByZXYsIHZhbHVlXTtcbiAgICAgICAgICAgIGRpY3Rpb25hcnlba2V5XSA9IHJldDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGljdGlvbmFyeVtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wcm90b3R5cGUucHVzaCA9XG5mdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlciRwdXNoKGRpY3Rpb25hcnksIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgcmV0ID0gbnVsbDtcbiAgICBpZiAoaGF2ZVByb3AuY2FsbChkaWN0aW9uYXJ5LCBrZXkpKSB7XG4gICAgICAgIHZhciBwcmV2ID0gZGljdGlvbmFyeVtrZXldO1xuICAgICAgICBwcmV2LnB1c2godmFsdWUpO1xuICAgICAgICByZXQgPSBwcmV2O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0ID0gW3ZhbHVlXTtcbiAgICAgICAgZGljdGlvbmFyeVtrZXldID0gcmV0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLm1heWJlUGxhY2VOZXN0ZWRWYWx1ZSA9XG5mdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlciRtYXliZVBsYWNlTmVzdGVkVmFsdWUoZGljdGlvbmFyeSwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIGlmIChrZXkuY2hhckNvZGVBdChsZW4gLSAxKSAhPT0gOTMpIHtcbiAgICAgICAgdGhpcy5wbGFjZVZhbHVlKGRpY3Rpb25hcnksIGtleSwgdmFsdWUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3RhcnQgPSAtMTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgY3VyS2V5O1xuICAgIHZhciBwcmV2S2V5O1xuXG4gICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBrZXkuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoY2ggPT09IDkxKSB7XG4gICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgcHJldktleSA9IGtleS5zbGljZSgwLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gOTMpIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYWNlVmFsdWUoZGljdGlvbmFyeSwga2V5LCB2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cktleSA9IHN0YXJ0ID09PSBpID8gXCJcIiA6IGtleS5zbGljZShzdGFydCwgaSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJLZXkgPT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLnBsYWNlVmFsdWUoZGljdGlvbmFyeSwga2V5LCB2YWx1ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN1cktleSA9PT0gXCJcIiAmJiB2YWx1ZSAhPT0gXCJcIiAmJiBpID09PSBsZW4pIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdGhpcy5jYWNoZUtleSkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZVZhbC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVLZXkgPSBrZXk7XG4gICAgICAgICAgICB0aGlzLmNhY2hlVmFsID0gdGhpcy5wdXNoKGRpY3Rpb25hcnksIHByZXZLZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5wbGFjZU5lc3RlZFZhbHVlKGRpY3Rpb25hcnksIGtleSwgdmFsdWUsIGksIHByZXZLZXksIGN1cktleSk7XG4gICAgfVxufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLnBsYWNlVmFsdWUgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkcGxhY2VWYWx1ZShkaWN0aW9uYXJ5LCBrZXksIHZhbHVlLCBwb3NzaWJseU5lc3RlZCkge1xuICAgIGlmIChwb3NzaWJseU5lc3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUGxhY2VOZXN0ZWRWYWx1ZShkaWN0aW9uYXJ5LCBrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSB0aGlzLmNhY2hlS2V5KSB7XG4gICAgICAgIHRoaXMuY2FjaGVWYWwucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNhY2hlID0gdGhpcy5pbnNlcnQoZGljdGlvbmFyeSwga2V5LCB2YWx1ZSk7XG4gICAgaWYgKGNhY2hlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2FjaGVLZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuY2FjaGVWYWwgPSBjYWNoZTtcbiAgICB9XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wcm90b3R5cGUuY29tcGFjdCA9XG5mdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlciRjb21wYWN0KG9iaikge1xuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGZvciggdmFyIGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpICkge1xuICAgICAgICAgICAgcmV0LnB1c2gob2JqW2tleXNbaV1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyArK2kgKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIG9ialtrZXldID0gdGhpcy5jb21wYWN0KG9ialtrZXldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VPYmplY3QgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkcGFyc2VPYmplY3Qob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgbGVuLS07XG4gICAgdmFyIHJldCA9IFwiXCI7XG4gICAgdmFyIGtleTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxlbjsgKytpICkge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXQgKz0ga2V5ICsgXCI9XCIgKyBvYmpba2V5XSArIFwiJlwiO1xuICAgIH1cbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHJldCArPSBrZXkgKyBcIj1cIiArIG9ialtrZXldO1xuICAgIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nKHJldCwgdHJ1ZSk7XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VTdHJpbmcgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkcGFyc2VTdHJpbmcoc3RyLCBub0RlY29kZSkge1xuICAgIHZhciBtYXhLZXlzID0gUXVlcnlTdHJpbmdQYXJzZXIubWF4S2V5cztcbiAgICB2YXIga2V5cyA9IDA7XG4gICAgdmFyIGRlY29kZUtleSA9IGZhbHNlO1xuICAgIHZhciBkZWNvZGVWYWx1ZSA9IGZhbHNlO1xuICAgIHZhciBwb3NzaWJseU5lc3RlZCA9IGZhbHNlO1xuICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgZGljdGlvbmFyeSA9IHt9O1xuICAgIHZhciBrZXlTdGFydCA9IDA7XG4gICAgdmFyIGtleUVuZCA9IDA7XG4gICAgdmFyIHZhbHVlU3RhcnQgPSAwO1xuICAgIHZhciB2YWx1ZUVuZCA9IDA7XG4gICAgdmFyIGxlZnQgPSAwO1xuICAgIHZhciBsYXN0SW5kZXggPSBsZW4gLSAxO1xuICAgIHZhciBjb250YWluc1BsdXMgPSBmYWxzZTtcblxuXG4gICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoY2ggPT09IDkxKSB7XG4gICAgICAgICAgICBsZWZ0Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVmdCA+IDAgJiYgY2ggPT09IDkzKSB7XG4gICAgICAgICAgICBwb3NzaWJseU5lc3RlZCA9IHRydWU7XG4gICAgICAgICAgICBsZWZ0LS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVmdCA9PT0gMCAmJiBjaCA9PT0gNjEpIHtcbiAgICAgICAgICAgIHZhciBqID0gaSArIDE7XG5cbiAgICAgICAgICAgIGtleUVuZCA9IGkgLSAxO1xuICAgICAgICAgICAgdmFsdWVFbmQgPSB2YWx1ZVN0YXJ0ID0gajtcbiAgICAgICAgICAgIHZhciBrZXkgPSBzdHIuc2xpY2Uoa2V5U3RhcnQsIGtleUVuZCArIDEpO1xuICAgICAgICAgICAga2V5ID0gdGhpcy5kZWNvZGUoa2V5LCBkZWNvZGVLZXksIGNvbnRhaW5zUGx1cyk7XG4gICAgICAgICAgICBkZWNvZGVLZXkgPSBmYWxzZTtcblxuICAgICAgICAgICAgZm9yICg7IGogPCBsZW47ICsraikge1xuICAgICAgICAgICAgICAgIGNoID0gc3RyLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgICAgICAgaWYgKChjaCA9PT0gNDMgfHwgY2ggPT09IDM3KSAmJiAhbm9EZWNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA0MykgY29udGFpbnNQbHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDM4IHx8IGogPT09IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUVuZCA9IGo7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBqO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMzgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlRW5kLS07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHIuc2xpY2UodmFsdWVTdGFydCwgdmFsdWVFbmQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmRlY29kZSh2YWx1ZSwgZGVjb2RlVmFsdWUsIGNvbnRhaW5zUGx1cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGFjZVZhbHVlKGRpY3Rpb25hcnksIGtleSwgdmFsdWUsIHBvc3NpYmx5TmVzdGVkKTtcblxuICAgICAgICAgICAgICAgICAgICBjb250YWluc1BsdXMgPSBkZWNvZGVWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBwb3NzaWJseU5lc3RlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGtleVN0YXJ0ID0gaiArIDE7XG4gICAgICAgICAgICAgICAgICAgIGtleXMrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleXMgPiBtYXhLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFtb3VudCBvZiBrZXlzIGlzIHRvbyBsYXJnZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoUXVlcnlTdHJpbmdQYXJzZXIubWF4S2V5cz1cIiArIG1heEtleXMgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjaCA9PT0gNDMgfHwgY2ggPT09IDM3KSAmJiAhbm9EZWNvZGUpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gNDMpIGNvbnRhaW5zUGx1cyA9IHRydWU7XG4gICAgICAgICAgICBkZWNvZGVLZXkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlTdGFydCAhPT0gbGVuKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIHZhciBrZXkgPSBzdHIuc2xpY2Uoa2V5U3RhcnQsIGxlbik7XG4gICAgICAgIGtleSA9IHRoaXMuZGVjb2RlKGtleSwgZGVjb2RlS2V5LCBjb250YWluc1BsdXMpO1xuICAgICAgICB0aGlzLnBsYWNlVmFsdWUoZGljdGlvbmFyeSwga2V5LCB2YWx1ZSwgcG9zc2libHlOZXN0ZWQpO1xuICAgIH1cblxuXG4gICAgaWYgKHRoaXMuY29udGFpbnNTcGFyc2UpIHtcbiAgICAgICAgdGhpcy5jb21wYWN0KGRpY3Rpb25hcnkpO1xuICAgIH1cblxuICAgIHJldHVybiBkaWN0aW9uYXJ5O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5ncGFyc2VyL2pzL3F1ZXJ5c3RyaW5ncGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMyBQZXRrYSBBbnRvbm92XG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczo8L3A+XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUXVlcnlTdHJpbmdTZXJpYWxpemVyO1xudmFyIGVuYyA9IGVuY29kZVVSSUNvbXBvbmVudDtcbnZhciBBUlJBWSA9IFtdO1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIG9Qcm90byA9IGdldFByb3RvKHt9KTtcblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHByb3RvID0gZ2V0UHJvdG8ob2JqKTtcblxuICAgIHJldHVybiBwcm90byA9PT0gb1Byb3RvIHx8IHByb3RvID09PSBudWxsO1xufVxuXG5mdW5jdGlvbiBRdWVyeVN0cmluZ1NlcmlhbGl6ZXIoKSB7XG5cbn1cblxuUXVlcnlTdHJpbmdTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemUgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdTZXJpYWxpemVyJHNlcmlhbGl6ZShvYmopIHtcbiAgICBpZiAob2JqID09PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoZSBvYmogdG8gc3RyaW5naWZ5IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgIH1cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBhcnJheSA9IEFSUkFZO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICB2YXIgY3VyID0gb2JqO1xuICAgIHZhciBrZXlQcmVmaXggPSBcIlwiO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cyA9PT0gYXJyYXkgPyBpIDoga2V5c1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gY3VyW2tleV07XG4gICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goa2V5UHJlZml4LCBjdXIsIGtleXMsIGxlbiwgaSk7XG5cbiAgICAgICAgICAgIGlmIChrZXlQcmVmaXggPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBrZXlQcmVmaXggPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXlQcmVmaXggPSBrZXlQcmVmaXggKyBcIltcIiArIGVuYyhrZXkpICsgXCJdXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGtleXMgPSBhcnJheTtcbiAgICAgICAgICAgICAgICBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgICAgICAgICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9IC0xO1xuICAgICAgICAgICAgY3VyID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZXJpYWxpemVkS2V5ID0ga2V5UHJlZml4ID09PSBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZW5jKGtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBrZXlQcmVmaXggKyBcIltcIiArIGVuYyhrZXkpICsgXCJdXCI7XG4gICAgICAgICAgICByZXQucHVzaChzZXJpYWxpemVkS2V5ICsgXCI9XCIgKyBlbmModmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGkgPT09IGxlbiAtIDEgJiYgc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgbGVuID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBrZXlzID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBjdXIgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGtleVByZWZpeCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldC5qb2luKFwiJlwiKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZ3BhcnNlci9qcy9xdWVyeXN0cmluZ3NlcmlhbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIE5vaXNlM0QuanNcblxuaW1wb3J0IE5vaXNlM0RUZXh0dXJlIGZyb20gJy4vTm9pc2UzRFRleHR1cmUnO1xuaW1wb3J0IENvbmZpZyBmcm9tICcuL0NvbmZpZyc7XG5cbmNsYXNzIE5vaXNlM0Qge1xuXHRjb25zdHJ1Y3RvcihtTnVtID0gOC4wLCBtTm9pc2VTY2FsZSA9IDEuMCkge1xuXHRcdHRoaXMuX3NlZWQgPSBNYXRoLnJhbmRvbSgpICogMHhGRjtcblx0XHR0aGlzLnNwZWVkID0gMC4wMztcblxuXHRcdGNvbnN0IGEgPSBuZXcgTm9pc2UzRFRleHR1cmUobU51bSwgbU5vaXNlU2NhbGUpO1xuXHRcdGNvbnN0IGIgPSBuZXcgTm9pc2UzRFRleHR1cmUobU51bSwgbU5vaXNlU2NhbGUpO1xuXG5cdFx0YS5yZW5kZXIodGhpcy5fc2VlZCk7XG5cdFx0dGhpcy5fc2VlZCArPSB0aGlzLnNwZWVkICogQ29uZmlnLmZvZ01vdmluZ1NwZWVkO1xuXHRcdGIucmVuZGVyKHRoaXMuX3NlZWQpO1xuXHRcdHRoaXMuX25vaXNlcyA9IFthLCBiXTtcblx0fVxuXG5cblx0dXBkYXRlKCkge1xuXHRcdHRoaXMuc3dhcCgpO1xuXHRcdHRoaXMuX3NlZWQgKz0gdGhpcy5zcGVlZCAqIENvbmZpZy5mb2dNb3ZpbmdTcGVlZDtcblx0XHR0aGlzLm5vaXNlMS5yZW5kZXIodGhpcy5fc2VlZCk7XG5cdH1cblxuXG5cdHN3YXAoKSB7XG5cdFx0dGhpcy5fbm9pc2VzID0gdGhpcy5fbm9pc2VzLnJldmVyc2UoKTtcblx0fVxuXG5cblx0Z2V0IG5vaXNlMCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbm9pc2VzWzBdO1xuXHR9XG5cblx0Z2V0IG5vaXNlMSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbm9pc2VzWzFdO1xuXHR9XG5cblxuXHRnZXQgdGV4dHVyZTAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX25vaXNlc1swXS5nZXRUZXh0dXJlKClcblx0fVxuXG5cdGdldCB0ZXh0dXJlMSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbm9pc2VzWzFdLmdldFRleHR1cmUoKVxuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5vaXNlM0Q7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL05vaXNlM0QuanMiLCIvLyBOb2lzZTNEVGV4dHVyZS5qc1xuXG5pbXBvcnQgYWxmcmlkLCB7IEdMLCBHTFNoYWRlciwgR2VvbSB9IGZyb20gJ2FsZnJpZCc7XG5pbXBvcnQgZnMgZnJvbSAnLi4vc2hhZGVycy9ub2lzZS5mcmFnJztcblxuY2xhc3MgTm9pc2UzRFRleHR1cmUge1xuXHRjb25zdHJ1Y3RvcihtTnVtID0gOC4wLCBtTm9pc2VTY2FsZSA9IDEuMCwgbVNlZWQgPSBNYXRoLnJhbmRvbSgpICogMHhGRikge1xuXHRcdHRoaXMuX251bSA9IG1OdW07XG5cdFx0dGhpcy5ub2lzZVNjYWxlID0gbU5vaXNlU2NhbGU7XG5cdFx0dGhpcy5fc2VlZCA9IG1TZWVkO1xuXG5cdFx0dGhpcy5faW5pdCgpO1xuXHR9XG5cblxuXHRfaW5pdCgpIHtcblx0XHR0aGlzLm1lc2ggPSBHZW9tLmJpZ1RyaWFuZ2xlKCk7XG5cdFx0dGhpcy5zaGFkZXIgPSBuZXcgR0xTaGFkZXIoYWxmcmlkLlNoYWRlckxpYnMuYmlnVHJpYW5nbGVWZXJ0LCBmcyk7XG5cblxuXHRcdHRoaXMuX25vaXNlU2l6ZSA9IHRoaXMuX251bSAqIHRoaXMuX251bTtcblx0XHRjb25zdCBmYm9TaXplID0gTWF0aC5wb3codGhpcy5fbnVtLCAzKTtcblxuXHRcdHRoaXMuX2Zib05vaXNlID0gbmV3IGFsZnJpZC5GcmFtZUJ1ZmZlcihmYm9TaXplLCBmYm9TaXplLCB7XG5cdFx0XHRtaW5GaWx0ZXI6R0wuTElORUFSLFxuXHRcdFx0bWFnRmlsdGVyOkdMLkxJTkVBUixcblx0XHRcdHdyYXBTOkdMLk1JUlJPUkVEX1JFUEVBVCxcblx0XHRcdHdyYXBUOkdMLk1JUlJPUkVEX1JFUEVBVCxcblx0XHR9KTtcblxuXHR9XG5cblxuXHRyZW5kZXIobVNlZWQpIHtcblx0XHR0aGlzLl9zZWVkICs9IDAuMDAzO1xuXHRcdHRoaXMuX2Zib05vaXNlLmJpbmQoKTtcblx0XHRHTC5jbGVhcigwLCAwLCAwLCAwKTtcblx0XHRjb25zdCBzaXplID0gdGhpcy5fbm9pc2VTaXplO1xuXHRcdGxldCBpbmRleDtcblx0XHRmb3IobGV0IGk9MDsgaTx0aGlzLl9udW07IGkrKykge1xuXHRcdFx0Zm9yKGxldCBqPTA7IGo8dGhpcy5fbnVtOyBqKyspIHtcblx0XHRcdFx0R0wudmlld3BvcnQoaSAqIHNpemUsIGogKiBzaXplLCBzaXplLCBzaXplKTtcblx0XHRcdFx0aW5kZXggPSAoaSArIGogKiB0aGlzLl9udW0pIC8gdGhpcy5fbm9pc2VTaXplO1xuXG5cdFx0XHRcdHRoaXMuc2hhZGVyLmJpbmQoKTtcblx0XHRcdFx0dGhpcy5zaGFkZXIudW5pZm9ybShcInVOb2lzZVNjYWxlXCIsIFwiZmxvYXRcIiwgdGhpcy5ub2lzZVNjYWxlKTtcblx0XHRcdFx0dGhpcy5zaGFkZXIudW5pZm9ybShcInVaXCIsIFwiZmxvYXRcIiwgaW5kZXgpO1xuXHRcdFx0XHR0aGlzLnNoYWRlci51bmlmb3JtKFwidVNlZWRcIiwgXCJmbG9hdFwiLCBtU2VlZCB8fCB0aGlzLl9zZWVkKTtcblx0XHRcdFx0R0wuZHJhdyh0aGlzLm1lc2gpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2Zib05vaXNlLnVuYmluZCgpO1xuXHR9XG5cblxuXHRnZXRUZXh0dXJlKCkge1x0cmV0dXJuIHRoaXMuX2Zib05vaXNlLmdldFRleHR1cmUoKTtcdH1cblxuXHRnZXQgbnVtKCkge1x0cmV0dXJuIHRoaXMuX251bTtcdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBOb2lzZTNEVGV4dHVyZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvTm9pc2UzRFRleHR1cmUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gbm9pc2UuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgU0lNUExFX1RFWFRVUkVcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIGZsb2F0IHVaO1xcbnVuaWZvcm0gZmxvYXQgdVNlZWQ7XFxudW5pZm9ybSBmbG9hdCB1Tm9pc2VTY2FsZTtcXG5cXG5cXG52ZWMzIG1vZDI4OSh2ZWMzIHgpIHtcXHRyZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wO1xcdH1cXG5cXG52ZWM0IG1vZDI4OSh2ZWM0IHgpIHtcXHRyZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wO1xcdH1cXG5cXG52ZWM0IHBlcm11dGUodmVjNCB4KSB7XFx0cmV0dXJuIG1vZDI4OSgoKHgqMzQuMCkrMS4wKSp4KTtcXHR9XFxuXFxudmVjNCB0YXlsb3JJbnZTcXJ0KHZlYzQgcikge1xcdHJldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7fVxcblxcbmZsb2F0IHNub2lzZSh2ZWMzIHYpIHsgXFxuXFx0Y29uc3QgdmVjMiAgQyA9IHZlYzIoMS4wLzYuMCwgMS4wLzMuMCkgO1xcblxcdGNvbnN0IHZlYzQgIEQgPSB2ZWM0KDAuMCwgMC41LCAxLjAsIDIuMCk7XFxuXFxuXFx0dmVjMyBpICA9IGZsb29yKHYgKyBkb3QodiwgQy55eXkpICk7XFxuXFx0dmVjMyB4MCA9ICAgdiAtIGkgKyBkb3QoaSwgQy54eHgpIDtcXG5cXG5cXHR2ZWMzIGcgPSBzdGVwKHgwLnl6eCwgeDAueHl6KTtcXG5cXHR2ZWMzIGwgPSAxLjAgLSBnO1xcblxcdHZlYzMgaTEgPSBtaW4oIGcueHl6LCBsLnp4eSApO1xcblxcdHZlYzMgaTIgPSBtYXgoIGcueHl6LCBsLnp4eSApO1xcblxcblxcdHZlYzMgeDEgPSB4MCAtIGkxICsgQy54eHg7XFxuXFx0dmVjMyB4MiA9IHgwIC0gaTIgKyBDLnl5eTsgLy8gMi4wKkMueCA9IDEvMyA9IEMueVxcblxcdHZlYzMgeDMgPSB4MCAtIEQueXl5OyAgICAgIC8vIC0xLjArMy4wKkMueCA9IC0wLjUgPSAtRC55XFxuXFxuXFx0aSA9IG1vZDI4OShpKTsgXFxuXFx0dmVjNCBwID0gcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZSggXFxuXFx0XFx0XFx0XFx0XFx0XFx0IGkueiArIHZlYzQoMC4wLCBpMS56LCBpMi56LCAxLjAgKSlcXG5cXHRcXHRcXHRcXHRcXHQgKyBpLnkgKyB2ZWM0KDAuMCwgaTEueSwgaTIueSwgMS4wICkpIFxcblxcdFxcdFxcdFxcdFxcdCArIGkueCArIHZlYzQoMC4wLCBpMS54LCBpMi54LCAxLjAgKSk7XFxuXFxuXFx0ZmxvYXQgbl8gPSAwLjE0Mjg1NzE0Mjg1NzsgLy8gMS4wLzcuMFxcblxcdHZlYzMgIG5zID0gbl8gKiBELnd5eiAtIEQueHp4O1xcblxcblxcdHZlYzQgaiA9IHAgLSA0OS4wICogZmxvb3IocCAqIG5zLnogKiBucy56KTsgIC8vICBtb2QocCw3KjcpXFxuXFxuXFx0dmVjNCB4XyA9IGZsb29yKGogKiBucy56KTtcXG5cXHR2ZWM0IHlfID0gZmxvb3IoaiAtIDcuMCAqIHhfICk7ICAgIC8vIG1vZChqLE4pXFxuXFxuXFx0dmVjNCB4ID0geF8gKm5zLnggKyBucy55eXl5O1xcblxcdHZlYzQgeSA9IHlfICpucy54ICsgbnMueXl5eTtcXG5cXHR2ZWM0IGggPSAxLjAgLSBhYnMoeCkgLSBhYnMoeSk7XFxuXFxuXFx0dmVjNCBiMCA9IHZlYzQoIHgueHksIHkueHkgKTtcXG5cXHR2ZWM0IGIxID0gdmVjNCggeC56dywgeS56dyApO1xcblxcblxcdHZlYzQgczAgPSBmbG9vcihiMCkqMi4wICsgMS4wO1xcblxcdHZlYzQgczEgPSBmbG9vcihiMSkqMi4wICsgMS4wO1xcblxcdHZlYzQgc2ggPSAtc3RlcChoLCB2ZWM0KDAuMCkpO1xcblxcblxcdHZlYzQgYTAgPSBiMC54enl3ICsgczAueHp5dypzaC54eHl5IDtcXG5cXHR2ZWM0IGExID0gYjEueHp5dyArIHMxLnh6eXcqc2guenp3dyA7XFxuXFxuXFx0dmVjMyBwMCA9IHZlYzMoYTAueHksaC54KTtcXG5cXHR2ZWMzIHAxID0gdmVjMyhhMC56dyxoLnkpO1xcblxcdHZlYzMgcDIgPSB2ZWMzKGExLnh5LGgueik7XFxuXFx0dmVjMyBwMyA9IHZlYzMoYTEuencsaC53KTtcXG5cXG5cXHR2ZWM0IG5vcm0gPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSwgZG90KHAxLHAxKSwgZG90KHAyLCBwMiksIGRvdChwMyxwMykpKTtcXG5cXHRwMCAqPSBub3JtLng7XFxuXFx0cDEgKj0gbm9ybS55O1xcblxcdHAyICo9IG5vcm0uejtcXG5cXHRwMyAqPSBub3JtLnc7XFxuXFxuXFx0dmVjNCBtID0gbWF4KDAuNiAtIHZlYzQoZG90KHgwLHgwKSwgZG90KHgxLHgxKSwgZG90KHgyLHgyKSwgZG90KHgzLHgzKSksIDAuMCk7XFxuXFx0bSA9IG0gKiBtO1xcblxcdHJldHVybiA0Mi4wICogZG90KCBtKm0sIHZlYzQoIGRvdChwMCx4MCksIGRvdChwMSx4MSksIFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRvdChwMix4MiksIGRvdChwMyx4MykgKSApO1xcbn1cXG5cXG52ZWMzIHNub2lzZVZlYzMoIHZlYzMgeCApe1xcblxcblxcdGZsb2F0IHMgID0gc25vaXNlKHZlYzMoIHggKSk7XFxuXFx0ZmxvYXQgczEgPSBzbm9pc2UodmVjMyggeC55IC0gMTkuMSAsIHgueiArIDMzLjQgLCB4LnggKyA0Ny4yICkpO1xcblxcdGZsb2F0IHMyID0gc25vaXNlKHZlYzMoIHgueiArIDc0LjIgLCB4LnggLSAxMjQuNSAsIHgueSArIDk5LjQgKSk7XFxuXFx0dmVjMyBjID0gdmVjMyggcyAsIHMxICwgczIgKTtcXG5cXHRyZXR1cm4gYztcXG59XFxuXFxudmVjMyBjdXJsTm9pc2UoIHZlYzMgcCApe1xcblxcdFxcblxcdGNvbnN0IGZsb2F0IGUgPSAuMTtcXG5cXHR2ZWMzIGR4ID0gdmVjMyggZSAgICwgMC4wICwgMC4wICk7XFxuXFx0dmVjMyBkeSA9IHZlYzMoIDAuMCAsIGUgICAsIDAuMCApO1xcblxcdHZlYzMgZHogPSB2ZWMzKCAwLjAgLCAwLjAgLCBlICAgKTtcXG5cXG5cXHR2ZWMzIHBfeDAgPSBzbm9pc2VWZWMzKCBwIC0gZHggKTtcXG5cXHR2ZWMzIHBfeDEgPSBzbm9pc2VWZWMzKCBwICsgZHggKTtcXG5cXHR2ZWMzIHBfeTAgPSBzbm9pc2VWZWMzKCBwIC0gZHkgKTtcXG5cXHR2ZWMzIHBfeTEgPSBzbm9pc2VWZWMzKCBwICsgZHkgKTtcXG5cXHR2ZWMzIHBfejAgPSBzbm9pc2VWZWMzKCBwIC0gZHogKTtcXG5cXHR2ZWMzIHBfejEgPSBzbm9pc2VWZWMzKCBwICsgZHogKTtcXG5cXG5cXHRmbG9hdCB4ID0gcF95MS56IC0gcF95MC56IC0gcF96MS55ICsgcF96MC55O1xcblxcdGZsb2F0IHkgPSBwX3oxLnggLSBwX3owLnggLSBwX3gxLnogKyBwX3gwLno7XFxuXFx0ZmxvYXQgeiA9IHBfeDEueSAtIHBfeDAueSAtIHBfeTEueCArIHBfeTAueDtcXG5cXG5cXHRjb25zdCBmbG9hdCBkaXZpc29yID0gMS4wIC8gKCAyLjAgKiBlICk7XFxuXFx0cmV0dXJuIG5vcm1hbGl6ZSggdmVjMyggeCAsIHkgLCB6ICkgKiBkaXZpc29yICk7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFx0dmVjMyBvZmZzZXQgPSBjdXJsTm9pc2UodmVjMyh2VGV4dHVyZUNvb3JkLCB1U2VlZCkgKSAqIC41ICsgLjU7XFxuXFx0b2Zmc2V0ICAgICAgPSBtaXgob2Zmc2V0LCB2ZWMzKDEuMCksIC41KTtcXG5cXHRvZmZzZXQgICAgICArPSAwLjU7XFxuXFx0dmVjMyBub2lzZSAgPSBjdXJsTm9pc2UodmVjMyh2VGV4dHVyZUNvb3JkLCB1WiApICogdU5vaXNlU2NhbGUgKiBvZmZzZXQpO1xcblxcdG5vaXNlICAgICAgID0gbm9pc2UgKiAuNSArIC41O1xcblxcblxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQobm9pc2UsIDEuMCk7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2hhZGVycy9ub2lzZS5mcmFnXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBnZW5lcmF0ZVRyZWVzLmpzXG5cbmltcG9ydCBDb25maWcgZnJvbSAnLi4vQ29uZmlnJztcbmltcG9ydCBBc3NldHMgZnJvbSAnLi4vQXNzZXRzJztcbmltcG9ydCB7IGdldEJvdW5kaW5nQm94IH0gZnJvbSAnLi8nO1xuXG52YXIgcmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHsgcmV0dXJuIG1pbiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKTtcdH1cblxuY29uc3QgY2hlY2tCb3ggPSAoYm94LCBhLCByLCBtYXJnaW49MCkgPT4ge1xuXHRsZXQgeCA9IE1hdGguY29zKGEpICogcjtcblx0bGV0IHogPSBNYXRoLnNpbihhKSAqIHI7XG5cdGNvbnN0IHsgbGVmdCwgcmlnaHQsIGZyb250LCBiYWNrIH0gPSBib3g7XG5cblx0bGV0IGhpdCA9IGZhbHNlO1xuXG5cdGlmKFx0eCA+IChsZWZ0IC0gbWFyZ2luKSBcblx0XHQmJiB4IDwgKHJpZ2h0ICsgbWFyZ2luKSBcblx0XHQmJiB6IDwgKGZyb250ICsgbWFyZ2luKSBcblx0XHQmJiB6ID4gKGJhY2sgLSBtYXJnaW4pKSB7XG5cdFx0aGl0ID0gdHJ1ZTtcblx0fSBcblxuXHRyZXR1cm4gaGl0O1xufVxuXG5cbmNvbnN0IG1hcmdpbnMgPSB7XG5cdGRlZXI6MC44LFxuXHRsYXB1dGE6MC44LFxuXHR3aGFsZTowLjEsXG5cdGJlYXI6MC44LFxuXHRidWxsOjAuOFxufVxuXG5cbmNvbnN0IGdlbmVyYXRlVHJlZXMgPSAoKSA9PiB7XG5cdGNvbnN0IG1lc2ggPSBBc3NldHMuZ2V0KENvbmZpZy5hbmltYWwpO1xuXHRjb25zdCBib3ggPSBnZXRCb3VuZGluZ0JveChtZXNoLCBDb25maWcuYW5pbWFsKTtcblx0Y29uc3QgcG9zaXRpb25zID0gW107XG5cdGNvbnN0IHIgPSBDb25maWcuZmxvb3JSYWRpdXMgKiAxLjA1O1xuXHRsZXQgaSA9IENvbmZpZy5udW1UcmVlcztcblxuXHRjb25zdCBtYXJnaW4gPSBtYXJnaW5zW0NvbmZpZy5hbmltYWxdIHx8IDAuMTtcblxuXHR3aGlsZShpLS0pIHtcblx0XHRsZXQgcnIgPSAwO1xuXHRcdGxldCBhID0gMDtcblx0XHRsZXQgY291bnQgPSAwO1xuXHRcdGRvIHtcblx0XHRcdHJyID0gTWF0aC5zcXJ0KE1hdGgucmFuZG9tKCkpICogcjtcblx0XHRcdGEgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIuMDtcblx0XHR9IHdoaWxlKGNoZWNrQm94KGJveCwgYSwgcnIsIG1hcmdpbikgJiYgY291bnQgKysgPCAxMDApO1xuXG5cdFx0cG9zaXRpb25zLnB1c2goW01hdGguY29zKGEpICogcnIsIDAsIE1hdGguc2luKGEpICogcnJdKTtcdFxuXHR9XG5cblx0cmV0dXJuIHBvc2l0aW9ucztcblxufVxuXG5leHBvcnQgeyBnZW5lcmF0ZVRyZWVzIH07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3V0aWxzL2dlbmVyYXRlVHJlZXMuanMiLCIvLyBnZW5lcmF0ZUhlaWdodE1hcC5qc1xuXG5pbXBvcnQgYWxmcmlkIGZyb20gJ2FsZnJpZCc7XG5pbXBvcnQgQ29uZmlnIGZyb20gJy4uL0NvbmZpZyc7XG5pbXBvcnQgRmJvUGluZ1BvbmcgZnJvbSAnLi9GYm9QaW5nUG9uZyc7XG5pbXBvcnQgQXNzZXRzIGZyb20gJy4uL0Fzc2V0cyc7XG5cbmltcG9ydCBmcyBmcm9tICdzaGFkZXJzL3RyZWVIZWlnaHQuZnJhZyc7XG5pbXBvcnQgZnNIaWxsIGZyb20gJ3NoYWRlcnMvaGlsbC5mcmFnJztcblxudmFyIHJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7IHJldHVybiBtaW4gKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbik7XHR9XG5sZXQgZmJvLCBzaGFkZXIsIHNoYWRlckhpbGwsIG1lc2g7XG5cblxuY29uc3QgZ2VuZXJhdGVIZWlnaHRNYXAgPSAodHJlZXMpID0+IHtcblx0bGV0IHNpemUgPSAxMDI0O1xuXHRpZighZmJvKSB7XG5cdFx0ZmJvICAgICAgICA9IG5ldyBGYm9QaW5nUG9uZyhzaXplLCBzaXplLCB7bWluRmlsdGVyOkdMLkxJTkVBUl9NSVBNQVBfTkVBUkVTVH0pO1x0XG5cdFx0c2hhZGVyICAgICA9IG5ldyBhbGZyaWQuR0xTaGFkZXIoYWxmcmlkLlNoYWRlckxpYnMuYmlnVHJpYW5nbGVWZXJ0LCBmcyk7XG5cdFx0c2hhZGVySGlsbCA9IG5ldyBhbGZyaWQuR0xTaGFkZXIoYWxmcmlkLlNoYWRlckxpYnMuYmlnVHJpYW5nbGVWZXJ0LCBmc0hpbGwpO1xuXHRcdG1lc2ggICAgICAgPSBhbGZyaWQuR2VvbS5iaWdUcmlhbmdsZSgpO1xuXHR9XG5cdFxuXHQgXG5cdGNvbnN0IGZsb29yU2l6ZSA9IENvbmZpZy5mbG9vclJhZGl1cztcblxuXHRmYm8ucmVhZC5iaW5kKCk7XG5cdEdMLmNsZWFyKDAsIDAsIDAsIDEpO1xuXHRmYm8ucmVhZC51bmJpbmQoKTtcblxuXHQvL1x0Z2VuZXJhdGUgaGVpZ2h0XG5cdGZiby53cml0ZS5iaW5kKCk7XG5cdEdMLmNsZWFyKDAsIDAsIDAsIDEpO1xuXHRzaGFkZXJIaWxsLmJpbmQoKTtcblx0c2hhZGVySGlsbC51bmlmb3JtKFwidVNlZWRcIiwgXCJmbG9hdFwiLCBNYXRoLnJhbmRvbSgpICogMHhGRik7XG5cdHNoYWRlckhpbGwudW5pZm9ybShcInVOb2lzZVNjYWxlXCIsIFwiZmxvYXRcIiwgcmFuZG9tKDIsIDUpKTtcblx0R0wuZHJhdyhtZXNoKTtcblx0ZmJvLndyaXRlLnVuYmluZCgpO1xuXG5cdGZiby5zd2FwKCk7XG5cdFxuXG5cblx0bGV0IGkgPSB0cmVlcy5sZW5ndGg7XG5cdHdoaWxlKGkgLS0pIHtcblx0XHRsZXQgcG9zID0gdHJlZXNbaV07XG5cdFx0bGV0IHUgPSBwb3NbMF0gLyBmbG9vclNpemUgKiAuNSArIC41O1xuXHRcdGxldCB2ID0gMS4wIC0gKHBvc1syXSAvIGZsb29yU2l6ZSAqIC41ICsgLjUpO1xuXG5cblx0XHRmYm8ud3JpdGUuYmluZCgpO1xuXHRcdEdMLmNsZWFyKDAsIDAsIDAsIDApO1xuXHRcdHNoYWRlci5iaW5kKCk7XG5cdFx0c2hhZGVyLnVuaWZvcm0oXCJ0ZXh0dXJlXCIsIFwidW5pZm9ybTFpXCIsIDApO1xuXHRcdGZiby5yZWFkVGV4dHVyZS5iaW5kKDApO1xuXHRcdHNoYWRlci51bmlmb3JtKFwidVBvc1wiLCBcInZlYzJcIiwgW3UsIHZdKTtcblx0XHRzaGFkZXIudW5pZm9ybShcInVIZWlnaHRcIiwgXCJmbG9hdFwiLCBNYXRoLnJhbmRvbSgpKTtcblx0XHRzaGFkZXIudW5pZm9ybShcInVSYW5nZVwiLCBcImZsb2F0XCIsIHJhbmRvbSgwLjA1LCAwLjEpKTtcblx0XHRzaGFkZXIudW5pZm9ybShcInVQb3dlclwiLCBcImZsb2F0XCIsIHJhbmRvbSgyLCAzKSk7XG5cdFx0c2hhZGVyLnVuaWZvcm0oXCJ1QnVtcEhlaWdodFwiLCBcImZsb2F0XCIsIENvbmZpZy50cmVlQnVtcEhlaWdodCk7XG5cdFx0R0wuZHJhdyhtZXNoKTtcblx0XHRmYm8ud3JpdGUudW5iaW5kKCk7XG5cblx0XHRmYm8uc3dhcCgpO1xuXHR9XG5cblx0cmV0dXJuIGZiby5yZWFkVGV4dHVyZTtcbn1cblxuXG5leHBvcnQgeyBnZW5lcmF0ZUhlaWdodE1hcCB9O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy91dGlscy9nZW5lcmF0ZUhlaWdodE1hcC5qcyIsIi8vIEZib1BpbmdQb25nLmpzXG5pbXBvcnQgYWxmcmlkIGZyb20gJ2FsZnJpZCc7XG5cbmNsYXNzIEZib1BpbmdQb25nIHtcblx0Y29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgc2V0dGluZ3MpIHtcblx0XHRjb25zdCBhID0gbmV3IGFsZnJpZC5GcmFtZUJ1ZmZlcih3aWR0aCwgaGVpZ2h0LCBzZXR0aW5ncyk7XG5cdFx0Y29uc3QgYiA9IG5ldyBhbGZyaWQuRnJhbWVCdWZmZXIod2lkdGgsIGhlaWdodCwgc2V0dGluZ3MpO1xuXHRcdHRoaXMuX2Zib3MgPSBbYSwgYl07XG5cdH1cblxuXG5cdHN3YXAoKSB7XG5cdFx0dGhpcy5fZmJvcy5yZXZlcnNlKCk7XG5cdH1cblxuXG5cdGdldCByZWFkKCkge1xuXHRcdHJldHVybiB0aGlzLl9mYm9zWzBdO1xuXHR9XG5cblx0Z2V0IHdyaXRlKCkge1xuXHRcdHJldHVybiB0aGlzLl9mYm9zWzFdO1xuXHR9XG5cblxuXHRnZXQgcmVhZFRleHR1cmUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Zib3NbMF0uZ2V0VGV4dHVyZSgpO1xuXHR9XG5cblxuXHRnZXQgd3JpdGVUZXh0dXJlKCkge1xuXHRcdHJldHVybiB0aGlzLl9mYm9zWzFdLmdldFRleHR1cmUoKTtcblx0fVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEZib1BpbmdQb25nO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy91dGlscy9GYm9QaW5nUG9uZy5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBjb3B5LmZyYWdcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIFNJTVBMRV9URVhUVVJFXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG51bmlmb3JtIGZsb2F0IHVIZWlnaHQ7XFxudW5pZm9ybSBmbG9hdCB1UmFuZ2U7XFxudW5pZm9ybSBmbG9hdCB1UG93ZXI7XFxudW5pZm9ybSBmbG9hdCB1QnVtcEhlaWdodDtcXG51bmlmb3JtIHZlYzIgdVBvcztcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdGZsb2F0IGQgPSBkaXN0YW5jZSh1UG9zLCB2VGV4dHVyZUNvb3JkKTtcXG5cXHRkID0gc21vb3Roc3RlcCh1UmFuZ2UsIDAuMCwgZCk7XFxuXFx0ZCA9IHBvdyhkLCB1UG93ZXIpO1xcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleHR1cmVDb29yZCk7XFxuICAgIGdsX0ZyYWdDb2xvci5yZ2IgKz0gdmVjMyhkICogbWl4KHVIZWlnaHQsIDEuMCwgMC41KSAqIHVCdW1wSGVpZ2h0KTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zaGFkZXJzL3RyZWVIZWlnaHQuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGNvcHkuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgU0lNUExFX1RFWFRVUkVcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcbnVuaWZvcm0gZmxvYXQgdVNlZWQ7XFxudW5pZm9ybSBmbG9hdCB1Tm9pc2VTY2FsZTtcXG5cXG52ZWM0IHBlcm11dGUodmVjNCB4KSB7ICByZXR1cm4gbW9kKCgoeCozNC4wKSsxLjApKngsIDI4OS4wKTsgICAgfVxcbnZlYzQgdGF5bG9ySW52U3FydCh2ZWM0IHIpIHsgICAgcmV0dXJuIDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogcjsgfVxcblxcbmZsb2F0IHNub2lzZSh2ZWMzIHYpe1xcbiAgICBjb25zdCB2ZWMyICBDID0gdmVjMigxLjAvNi4wLCAxLjAvMy4wKSA7XFxuICAgIGNvbnN0IHZlYzQgIEQgPSB2ZWM0KDAuMCwgMC41LCAxLjAsIDIuMCk7XFxuICAgIFxcbiAgICB2ZWMzIGkgID0gZmxvb3IodiArIGRvdCh2LCBDLnl5eSkgKTtcXG4gICAgdmVjMyB4MCA9IHYgLSBpICsgZG90KGksIEMueHh4KSA7XFxuICAgIFxcbiAgICB2ZWMzIGcgPSBzdGVwKHgwLnl6eCwgeDAueHl6KTtcXG4gICAgdmVjMyBsID0gMS4wIC0gZztcXG4gICAgdmVjMyBpMSA9IG1pbiggZy54eXosIGwuenh5ICk7XFxuICAgIHZlYzMgaTIgPSBtYXgoIGcueHl6LCBsLnp4eSApO1xcbiAgICBcXG4gICAgdmVjMyB4MSA9IHgwIC0gaTEgKyAxLjAgKiBDLnh4eDtcXG4gICAgdmVjMyB4MiA9IHgwIC0gaTIgKyAyLjAgKiBDLnh4eDtcXG4gICAgdmVjMyB4MyA9IHgwIC0gMS4gKyAzLjAgKiBDLnh4eDtcXG4gICAgXFxuICAgIGkgPSBtb2QoaSwgMjg5LjAgKTtcXG4gICAgdmVjNCBwID0gcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZSggaS56ICsgdmVjNCgwLjAsIGkxLnosIGkyLnosIDEuMCApKSArIGkueSArIHZlYzQoMC4wLCBpMS55LCBpMi55LCAxLjAgKSkgKyBpLnggKyB2ZWM0KDAuMCwgaTEueCwgaTIueCwgMS4wICkpO1xcbiAgICBcXG4gICAgZmxvYXQgbl8gPSAxLjAvNy4wO1xcbiAgICB2ZWMzICBucyA9IG5fICogRC53eXogLSBELnh6eDtcXG4gICAgXFxuICAgIHZlYzQgaiA9IHAgLSA0OS4wICogZmxvb3IocCAqIG5zLnogKm5zLnopO1xcbiAgICBcXG4gICAgdmVjNCB4XyA9IGZsb29yKGogKiBucy56KTtcXG4gICAgdmVjNCB5XyA9IGZsb29yKGogLSA3LjAgKiB4XyApO1xcbiAgICBcXG4gICAgdmVjNCB4ID0geF8gKm5zLnggKyBucy55eXl5O1xcbiAgICB2ZWM0IHkgPSB5XyAqbnMueCArIG5zLnl5eXk7XFxuICAgIHZlYzQgaCA9IDEuMCAtIGFicyh4KSAtIGFicyh5KTtcXG4gICAgXFxuICAgIHZlYzQgYjAgPSB2ZWM0KCB4Lnh5LCB5Lnh5ICk7XFxuICAgIHZlYzQgYjEgPSB2ZWM0KCB4Lnp3LCB5Lnp3ICk7XFxuICAgIFxcbiAgICB2ZWM0IHMwID0gZmxvb3IoYjApKjIuMCArIDEuMDtcXG4gICAgdmVjNCBzMSA9IGZsb29yKGIxKSoyLjAgKyAxLjA7XFxuICAgIHZlYzQgc2ggPSAtc3RlcChoLCB2ZWM0KDAuMCkpO1xcbiAgICBcXG4gICAgdmVjNCBhMCA9IGIwLnh6eXcgKyBzMC54enl3KnNoLnh4eXkgO1xcbiAgICB2ZWM0IGExID0gYjEueHp5dyArIHMxLnh6eXcqc2guenp3dyA7XFxuICAgIFxcbiAgICB2ZWMzIHAwID0gdmVjMyhhMC54eSxoLngpO1xcbiAgICB2ZWMzIHAxID0gdmVjMyhhMC56dyxoLnkpO1xcbiAgICB2ZWMzIHAyID0gdmVjMyhhMS54eSxoLnopO1xcbiAgICB2ZWMzIHAzID0gdmVjMyhhMS56dyxoLncpO1xcbiAgICBcXG4gICAgdmVjNCBub3JtID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChwMCxwMCksIGRvdChwMSxwMSksIGRvdChwMiwgcDIpLCBkb3QocDMscDMpKSk7XFxuICAgIHAwICo9IG5vcm0ueDtcXG4gICAgcDEgKj0gbm9ybS55O1xcbiAgICBwMiAqPSBub3JtLno7XFxuICAgIHAzICo9IG5vcm0udztcXG4gICAgXFxuICAgIHZlYzQgbSA9IG1heCgwLjYgLSB2ZWM0KGRvdCh4MCx4MCksIGRvdCh4MSx4MSksIGRvdCh4Mix4MiksIGRvdCh4Myx4MykpLCAwLjApO1xcbiAgICBtID0gbSAqIG07XFxuICAgIHJldHVybiA0Mi4wICogZG90KCBtKm0sIHZlYzQoIGRvdChwMCx4MCksIGRvdChwMSx4MSksIGRvdChwMix4MiksIGRvdChwMyx4MykgKSApO1xcbn1cXG5cXG5mbG9hdCBzbm9pc2UoZmxvYXQgeCwgZmxvYXQgeSwgZmxvYXQgeil7XFxuICAgIHJldHVybiBzbm9pc2UodmVjMyh4LCB5LCB6KSk7XFxufVxcblxcblxcbiNkZWZpbmUgUEkgMy4xNDE1OTI2NTNcXG5cXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdGZsb2F0IGQgPSBkaXN0YW5jZSh2VGV4dHVyZUNvb3JkLCB2ZWMyKC41KSk7XFxuXFx0ZCA9IHNtb290aHN0ZXAoMC41LCAwLjAsIGQpO1xcblxcdGQgPSBzaW4oZCAqIFBJICogMC41KTtcXG5cXG5cXHRmbG9hdCBub2lzZSA9IHNub2lzZSh2ZWMzKHZUZXh0dXJlQ29vcmQgKiB1Tm9pc2VTY2FsZSwgdVNlZWQpKSAqIC41ICsgLjU7XFxuXFxuXFx0ZCA9IG1peCgwLjAsIG5vaXNlLCBkKTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKGQpLCAxLjApO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NoYWRlcnMvaGlsbC5mcmFnXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBnZXRCb3VuZGluZ0JveC5qc1xuXG5jb25zdCBjYWNoZXMgPSB7fVxuXG5jb25zdCBnZXRCb3VuZGluZ0JveCA9IChtZXNoLCBpZCkgPT4ge1xuXHRpZihjYWNoZXNbaWRdKSB7IHJldHVybiBjYWNoZXNbaWRdOyB9XG5cblxuXHRjb25zdCB7IG1pbiwgbWF4IH0gPSBNYXRoO1xuXHRsZXQgcmlnaHQgPSAtOTk5O1xuXHRsZXQgbGVmdCA9IDk5OTtcblx0bGV0IGZyb250ID0gLTk5OTtcblx0bGV0IGJhY2sgPSA5OTk7XG5cblx0Y29uc3QgeyB2ZXJ0aWNlcyB9ID0gbWVzaDtcblxuXHR2ZXJ0aWNlcy5mb3JFYWNoKCB2ID0+IHtcblx0XHRsZWZ0ID0gbWluKHZbMF0sIGxlZnQpO1xuXHRcdHJpZ2h0ID0gbWF4KHZbMF0sIHJpZ2h0KTtcblxuXHRcdGZyb250ID0gbWF4KHZbMl0sIGZyb250KTtcblx0XHRiYWNrID0gbWluKHZbMl0sIGJhY2spO1xuXHR9KTtcblxuXG5cdGNhY2hlc1tpZF0gPSB7bGVmdCwgcmlnaHQsIGZyb250LCBiYWNrfTtcblxuXHRyZXR1cm4gY2FjaGVzW2lkXTtcbn1cblxuXG5leHBvcnQgeyBnZXRCb3VuZGluZ0JveCB9O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy91dGlscy9nZXRCb3VuZGluZ0JveC5qcyIsIi8vIHNhdmVKc29uLmpzXG5cbnZhciBzYXZlSnNvbiA9IGZ1bmN0aW9uKG9iaiwgbmFtZT0nZGF0YScpIHtcblx0dmFyIHN0ciA9IEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgNCk7XG5cdHZhciBkYXRhID0gZW5jb2RlKCBzdHIgKTtcblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKCBbIGRhdGEgXSwge1xuXHRcdHR5cGU6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG5cdH0pO1xuXHRcblx0dmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoIGJsb2IgKTtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnYScgKTtcblx0bGluay5zZXRBdHRyaWJ1dGUoICdocmVmJywgdXJsICk7XG5cdGxpbmsuc2V0QXR0cmlidXRlKCAnZG93bmxvYWQnLCBgJHtuYW1lfS5qc29uYCApO1xuXHR2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCggJ01vdXNlRXZlbnRzJyApO1xuXHRldmVudC5pbml0TW91c2VFdmVudCggJ2NsaWNrJywgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAxLCAwLCAwLCAwLCAwLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG5cdGxpbmsuZGlzcGF0Y2hFdmVudCggZXZlbnQgKTtcbn1cblxuXG52YXIgZW5jb2RlID0gZnVuY3Rpb24oIHMgKSB7XG5cdHZhciBvdXQgPSBbXTtcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKyApIHtcblx0XHRvdXRbaV0gPSBzLmNoYXJDb2RlQXQoaSk7XG5cdH1cblx0cmV0dXJuIG5ldyBVaW50OEFycmF5KCBvdXQgKTtcbn1cblxuXG5leHBvcnQgeyBzYXZlSnNvbiB9O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy91dGlscy9zYXZlSnNvbi5qcyIsIi8vIFZpZXdGbG9vci5qc1xuXG5pbXBvcnQgYWxmcmlkLCB7IEdMIH0gZnJvbSAnYWxmcmlkJztcbmltcG9ydCBBc3NldHMgZnJvbSAnLi9Bc3NldHMnO1xuaW1wb3J0IENvbmZpZyBmcm9tICcuL0NvbmZpZyc7XG5pbXBvcnQgdnMgZnJvbSAnc2hhZGVycy9mbG9vci52ZXJ0JztcbmltcG9ydCBmcyBmcm9tICdzaGFkZXJzL2RlcHRoLmZyYWcnO1xuXG5jbGFzcyBWaWV3Rmxvb3IgZXh0ZW5kcyBhbGZyaWQuVmlldyB7XG5cdFxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcih2cywgZnMpO1xuXHR9XG5cblxuXHRfaW5pdCgpIHtcblx0XHRjb25zdCB7IGZsb29yUmFkaXVzIH0gPSBDb25maWc7XG5cdFx0dGhpcy5tZXNoID0gYWxmcmlkLkdlb20ucGxhbmUoZmxvb3JSYWRpdXMgKiAyLCBmbG9vclJhZGl1cyAqIDIsIDEwMCwgJ3h6Jyk7XG5cdH1cblxuXG5cdHJlbmRlcih0ZXh0dXJlKSB7XG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oXCJ0ZXh0dXJlXCIsIFwidW5pZm9ybTFpXCIsIDApO1xuXHRcdHRleHR1cmUuYmluZCgwKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKFwidUZsb29ySGVpZ2h0XCIsIFwiZmxvYXRcIiwgQ29uZmlnLm1heEZsb29ySGVpZ2h0KTtcblx0XHRHTC5kcmF3KHRoaXMubWVzaCk7XG5cdH1cblxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXdGbG9vcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvVmlld0Zsb29yLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGJhc2ljLnZlcnRcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVGbG9vckhlaWdodDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbnZhcnlpbmcgdmVjNCB2U2NyZWVuUG9zaXRpb247XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXHR2ZWMzIHBvcyAgICAgICAgPSBhVmVydGV4UG9zaXRpb247XFxuXFx0ZmxvYXQgaCAgICAgICAgID0gdGV4dHVyZTJEKHRleHR1cmUsIGFUZXh0dXJlQ29vcmQpLnI7XFxuXFx0cG9zLnkgICAgICAgICAgID0gaCAqIHVGbG9vckhlaWdodDtcXG5cXHR2U2NyZWVuUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVWaWV3TWF0cml4ICogdU1vZGVsTWF0cml4ICogdmVjNChwb3MsIDEuMCk7XFxuXFx0Z2xfUG9zaXRpb24gICAgID0gdlNjcmVlblBvc2l0aW9uO1xcblxcdHZUZXh0dXJlQ29vcmQgICA9IGFUZXh0dXJlQ29vcmQ7XFxuXFx0dk5vcm1hbCAgICAgICAgID0gYU5vcm1hbDtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zaGFkZXJzL2Zsb29yLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFZpZXdUcmVlcy5qc1xuXG5pbXBvcnQgYWxmcmlkLCB7IEdMIH0gZnJvbSAnYWxmcmlkJztcbmltcG9ydCBBc3NldHMgZnJvbSAnLi9Bc3NldHMnO1xuaW1wb3J0IENvbmZpZyBmcm9tICcuL0NvbmZpZyc7XG5pbXBvcnQgdnMgZnJvbSAnc2hhZGVycy90cmVlcy52ZXJ0JztcbmltcG9ydCBmcyBmcm9tICdzaGFkZXJzL2RlcHRoLmZyYWcnO1xuXG5jbGFzcyBWaWV3VHJlZXMgZXh0ZW5kcyBhbGZyaWQuVmlldyB7XG5cdFxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcih2cywgZnMpO1xuXHR9XG5cblxuXHRfaW5pdCgpIHtcblx0XHQvLyB0aGlzLm1lc2ggPSBBc3NldHMuZ2V0KCdwaWxsYXInKTtcblx0XHR0aGlzLm1lc2gxID0gQXNzZXRzLmdldCgndHJlZTEnKTtcblx0XHR0aGlzLm1lc2gyID0gQXNzZXRzLmdldCgndHJlZTInKTtcblxuXHRcdHRoaXMubWVzaCA9IFt0aGlzLm1lc2gxLCB0aGlzLm1lc2gyXTtcblx0fVxuXG5cdHJlc2V0KHRyZWVzKSB7XG5cblx0XHRsZXQgaSA9IHRyZWVzLmxlbmd0aDtcblx0XHRsZXQgaGFsZiA9IGkvMjtcblxuXHRcdGNvbnN0IGRhdGExID0gW107XG5cdFx0Y29uc3QgZGF0YTIgPSBbXTtcblxuXHRcdHdoaWxlKGktLSkge1xuXHRcdFx0bGV0IHBvcyA9IHRyZWVzW2ldO1xuXHRcdFx0aWYoaTxoYWxmKSB7XG5cdFx0XHRcdGRhdGExLnB1c2goW3Bvc1swXSwgcG9zWzJdLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDJdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGEyLnB1c2goW3Bvc1swXSwgcG9zWzJdLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDJdKTtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdHRoaXMubWVzaDEuYnVmZmVySW5zdGFuY2UoZGF0YTEsICdhUG9zT2Zmc2V0Jyk7XG5cdFx0dGhpcy5tZXNoMi5idWZmZXJJbnN0YW5jZShkYXRhMiwgJ2FQb3NPZmZzZXQnKTtcblx0fVxuXG5cblx0cmVuZGVyKG1DYW1Qb3MpIHtcblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybShcInVUcmVlU2NhbGVcIiwgXCJmbG9hdFwiLCBDb25maWcudHJlZVNjYWxlKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKFwidUNhbVBvc1wiLCBcInZlYzNcIiwgbUNhbVBvcyk7XG5cdFx0R0wuZHJhdyh0aGlzLm1lc2gpO1xuXHR9XG5cblxufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3VHJlZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL1ZpZXdUcmVlcy5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBiYXNpYy52ZXJ0XFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzMgYU5vcm1hbDtcXG5hdHRyaWJ1dGUgdmVjNCBhUG9zT2Zmc2V0O1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVUcmVlU2NhbGU7XFxudW5pZm9ybSB2ZWMzIHVDYW1Qb3M7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxudmFyeWluZyB2ZWM0IHZTY3JlZW5Qb3NpdGlvbjtcXG5cXG52ZWMyIHJvdGF0ZSh2ZWMyIHYsIGZsb2F0IGEpIHtcXG5cXHRmbG9hdCBzID0gc2luKGEpO1xcblxcdGZsb2F0IGMgPSBjb3MoYSk7XFxuXFx0bWF0MiBtID0gbWF0MihjLCAtcywgcywgYyk7XFxuXFx0cmV0dXJuIG0gKiB2O1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdGZsb2F0IGQgPSBkaXN0YW5jZSh1Q2FtUG9zLnh6LCBhUG9zT2Zmc2V0Lnh5KTtcXG5cXHRmbG9hdCB0ID0gc21vb3Roc3RlcCgxLjAsIDIuNSwgZCk7XFxuXFx0dCA9IG1peCgxLjAsIHQsIC41KTtcXG5cXG5cXHRcXG5cXHR2ZWMzIHBvcyAgICAgICAgPSBhVmVydGV4UG9zaXRpb247XFxuXFx0ZmxvYXQgc2NhbGUgICAgID0gbWl4KGFQb3NPZmZzZXQueiwgMS4wLCAuMyk7XFxuXFx0cG9zLnh6ICAgICAgICAgID0gcm90YXRlKHBvcy54eiwgYVBvc09mZnNldC53KTtcXG5cXHRwb3MueHogXFx0XFx0XFx0Kj0gdDtcXG5cXHRwb3MueSAgICAgICAgICAgKj0gMy4wO1xcblxcdHBvcy55ICAgICAgICAgICAtPSAzLjA7XFxuXFx0cG9zICAgICAgICAgICAgICo9IHNjYWxlICogdVRyZWVTY2FsZTtcXG5cXG5cXHRwb3MueHogICAgICAgICAgKz0gYVBvc09mZnNldC54eTtcXG5cXG5cXG5cXG5cXHRcXG5cXHR2U2NyZWVuUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVWaWV3TWF0cml4ICogdU1vZGVsTWF0cml4ICogdmVjNChwb3MsIDEuMCk7XFxuXFx0Z2xfUG9zaXRpb24gICAgID0gdlNjcmVlblBvc2l0aW9uO1xcblxcdHZUZXh0dXJlQ29vcmQgICA9IGFUZXh0dXJlQ29vcmQ7XFxuXFx0dk5vcm1hbCAgICAgICAgID0gYU5vcm1hbDtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zaGFkZXJzL3RyZWVzLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFZpZXdCZy5qc1xuXG5pbXBvcnQgYWxmcmlkLCB7IEdMIH0gZnJvbSAnYWxmcmlkJztcbmltcG9ydCBDb25maWcgZnJvbSAnLi9Db25maWcnO1xuaW1wb3J0IHZzIGZyb20gJ3NoYWRlcnMvYmcudmVydCc7XG5pbXBvcnQgZnMgZnJvbSAnc2hhZGVycy9iZy5mcmFnJztcblxuY2xhc3MgVmlld0JnIGV4dGVuZHMgYWxmcmlkLlZpZXcge1xuXHRcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIodnMsIGZzKTtcblx0fVxuXG5cblx0X2luaXQoKSB7XG5cdFx0Ly8gY29uc3QgcmFkaXVzID0gQ29uZmlnLmZsb29yUmFkaXVzICogTWF0aC5zcXJ0KDIpO1xuXHRcdGNvbnN0IHJhZGl1cyA9IENvbmZpZy5mbG9vclJhZGl1cyAqIDIuNTtcblx0XHR0aGlzLm1lc2ggPSBhbGZyaWQuR2VvbS5zcGhlcmUocmFkaXVzLCAxMiwgdHJ1ZSk7XG5cdH1cblxuXG5cdHJlbmRlcigpIHtcblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cdFx0R0wuZHJhdyh0aGlzLm1lc2gpO1xuXHR9XG5cblxufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3Qmc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL1ZpZXdCZy5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBiYXNpYy52ZXJ0XFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzMgYU5vcm1hbDtcXG5cXG51bmlmb3JtIG1hdDQgdU1vZGVsTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1Vmlld01hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQzIHVOb3JtYWxNYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXHRnbF9Qb3NpdGlvbiAgID0gdVByb2plY3Rpb25NYXRyaXggKiB1Vmlld01hdHJpeCAqIHVNb2RlbE1hdHJpeCAqIHZlYzQoYVZlcnRleFBvc2l0aW9uLCAxLjApO1xcblxcdHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcblxcdHZOb3JtYWwgICAgICAgPSB1Tm9ybWFsTWF0cml4ICogYU5vcm1hbDtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zaGFkZXJzL2JnLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBjb3B5LmZyYWdcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIFNJTVBMRV9URVhUVVJFXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuLy8gdW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG5cXG5mbG9hdCBkaWZmdXNlKHZlYzMgTiwgdmVjMyBMKSB7XFxuXFx0cmV0dXJuIG1heChkb3QoTiwgbm9ybWFsaXplKEwpKSwgMC4wKTtcXG59XFxuXFxuXFxudmVjMyBkaWZmdXNlKHZlYzMgTiwgdmVjMyBMLCB2ZWMzIEMpIHtcXG5cXHRyZXR1cm4gZGlmZnVzZShOLCBMKSAqIEM7XFxufVxcblxcblxcbiNkZWZpbmUgRlJPTlQgdmVjMygwLjAsIDAuMCwgLTEuMClcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdGZsb2F0IGQgPSBkaWZmdXNlKHZOb3JtYWwsIEZST05UKTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKGQpLCAxLjApO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NoYWRlcnMvYmcuZnJhZ1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVmlld0dyb3VuZC5qc1xuXG5pbXBvcnQgYWxmcmlkLCB7IEdMIH0gZnJvbSAnYWxmcmlkJztcbmltcG9ydCBDb25maWcgZnJvbSAnLi9Db25maWcnO1xuaW1wb3J0IHZzIGZyb20gJ3NoYWRlcnMvZ3JvdW5kLnZlcnQnO1xuaW1wb3J0IGZzIGZyb20gJ3NoYWRlcnMvZ3JvdW5kLmZyYWcnO1xuXG5jbGFzcyBWaWV3R3JvdW5kIGV4dGVuZHMgYWxmcmlkLlZpZXcge1xuXHRcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIodnMsIGZzKTtcblx0fVxuXG5cblx0X2luaXQoKSB7XG5cdFx0Y29uc3QgciA9IENvbmZpZy5mbG9vclJhZGl1cyAqIDQ7XG5cdFx0dGhpcy5tZXNoID0gYWxmcmlkLkdlb20ucGxhbmUociwgciwgMSwgJ3h6Jyk7XG5cdH1cblxuXG5cdHJlbmRlcigpIHtcblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cdFx0R0wuZHJhdyh0aGlzLm1lc2gpO1xuXHR9XG5cblxufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3R3JvdW5kO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9WaWV3R3JvdW5kLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGJhc2ljLnZlcnRcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG52YXJ5aW5nIHZlYzQgdlNjcmVlblBvc2l0aW9uO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFx0dmVjMyBwb3MgICAgICAgID0gYVZlcnRleFBvc2l0aW9uO1xcblxcdHBvcy55ICAgICAgICAgICAtPSAwLjAxO1xcblxcdHZTY3JlZW5Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdVZpZXdNYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KHBvcywgMS4wKTtcXG5cXHRnbF9Qb3NpdGlvbiAgICAgPSB2U2NyZWVuUG9zaXRpb247XFxuXFx0dlRleHR1cmVDb29yZCAgID0gYVRleHR1cmVDb29yZDtcXG5cXHR2Tm9ybWFsICAgICAgICAgPSBhTm9ybWFsO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NoYWRlcnMvZ3JvdW5kLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBjb3B5LmZyYWdcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIFNJTVBMRV9URVhUVVJFXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG5cXG52YXJ5aW5nIHZlYzQgdlNjcmVlblBvc2l0aW9uO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFxuXFx0ZmxvYXQgZCA9IGRpc3RhbmNlKHZUZXh0dXJlQ29vcmQsIHZlYzIoLjUpKTtcXG5cXHRkID0gc21vb3Roc3RlcCgwLjUsIDAuMzUsIGQpO1xcblxcbiAgICBmbG9hdCB6ID0gdlNjcmVlblBvc2l0aW9uLnogLyB2U2NyZWVuUG9zaXRpb24udztcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKHogKiAwLjI1KSwgZCk7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2hhZGVycy9ncm91bmQuZnJhZ1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGJhc2ljLnZlcnRcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcbmF0dHJpYnV0ZSB2ZWMzIGFQb3NPZmZzZXQ7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1TG9jYWxNYXRyaXg7XFxudW5pZm9ybSBtYXQzIHVNb2RlbFZpZXdNYXRyaXhJbnZlcnNlO1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbnZhcnlpbmcgdmVjMyB2UG9zaXRpb247XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXHQvLyB2ZWMzIHBvc2l0aW9uID0gdU1vZGVsVmlld01hdHJpeEludmVyc2UgKiAodU1vZGVsTWF0cml4ICogdUxvY2FsTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5ejtcXG5cXHR2ZWMzIHBvc2l0aW9uID0gKHVNb2RlbE1hdHJpeCAqIHZlYzQoYVZlcnRleFBvc2l0aW9uICsgYVBvc09mZnNldCwgMS4wKSkueHl6O1xcblxcdHBvc2l0aW9uIFxcdCAgPSB1TW9kZWxWaWV3TWF0cml4SW52ZXJzZSAqIHBvc2l0aW9uO1xcblxcdGdsX1Bvc2l0aW9uICAgPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG5cXHR2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG5cXHR2Tm9ybWFsICAgICAgID0gYU5vcm1hbDtcXG5cXG5cXHR2UG9zaXRpb24gXFx0ICA9IHBvc2l0aW9uO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NoYWRlcnMvZm9nLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmUwO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmUxO1xcbnVuaWZvcm0gZmxvYXQgdVBlcmNlbnQ7XFxudW5pZm9ybSBmbG9hdCB1TnVtO1xcbnVuaWZvcm0gZmxvYXQgdU51bVNsaWNlcztcXG51bmlmb3JtIGZsb2F0IHVPZmZzZXQ7XFxudW5pZm9ybSBmbG9hdCB1U2l6ZTtcXG5cXG5cXG52ZWMyIGdldFVWT2Zmc2V0KGZsb2F0IGluZGV4KSB7XFxuXFx0ZmxvYXQgeCA9IG1vZChpbmRleCwgdU51bSk7XFxuXFx0ZmxvYXQgeSA9IGZsb29yKGluZGV4L3VOdW0pO1xcblxcdHJldHVybiB2ZWMyKHgsIHkpIC8gdU51bTtcXG59XFxuXFxudmVjMyB0ZXh0dXJlM0QodmVjMyBwb3MsIHNhbXBsZXIyRCB0ZXh0dXJlKSB7XFxuXFx0dmVjMyBwb3NBZGogPSAocG9zICogLjI1ICsgLjUpO1xcblxcdFxcblxcdGZsb2F0IHR6ICAgID0gcG9zQWRqLno7XFxuXFx0ZmxvYXQgbnVtICAgPSB1TnVtICogdU51bTtcXG5cXHRcXG5cXHRmbG9hdCBpMCAgICA9IGZsb29yKHR6ICogbnVtKTtcXG5cXHRmbG9hdCBpMSAgICA9IGNlaWwodHogKiBudW0pO1xcblxcdHZlYzIgdXYwICAgID0gcG9zQWRqLnh5IC8gdU51bSArIGdldFVWT2Zmc2V0KGkwKTtcXG5cXHR2ZWMyIHV2MSAgICA9IHBvc0Fkai54eSAvIHVOdW0gKyBnZXRVVk9mZnNldChpMSk7XFxuXFx0dmVjMyBjb2xvcjAgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdXYwKS54eXo7XFxuXFx0dmVjMyBjb2xvcjEgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdXYxKS54eXo7XFxuXFx0ZmxvYXQgcCAgICAgPSBtb2QodHogKiBudW0gLSBpMCwgMS4wKTtcXG5cXHR2ZWMzIGNvbG9yICA9IG1peChjb2xvcjAsIGNvbG9yMSwgcCk7XFxuXFx0XFxuXFx0Y29sb3IgICAgICAgLz0gdU51bVNsaWNlcztcXG5cXHRyZXR1cm4gY29sb3I7XFxufVxcblxcblxcbnZlYzMgcG93ZXIodmVjMyB2LCBmbG9hdCBwKSB7XFxuXFx0cmV0dXJuIHZlYzMoXFxuXFx0XFx0XFx0cG93KHYueCwgcCksXFxuXFx0XFx0XFx0cG93KHYueSwgcCksXFxuXFx0XFx0XFx0cG93KHYueiwgcClcXG5cXHRcXHQpO1xcbn1cXG5cXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdGZsb2F0IHNjYWxlID0gMi4wO1xcblxcdHZlYzMgcG9zID0gdlBvc2l0aW9uIC8gdVNpemU7XFxuXFxuXFx0dmVjMyBjb2xvcjAgPSB0ZXh0dXJlM0QocG9zLCB0ZXh0dXJlMCk7XFxuXFx0dmVjMyBjb2xvcjEgPSB0ZXh0dXJlM0QocG9zLCB0ZXh0dXJlMSk7XFxuXFxuXFx0dmVjMyBjb2xvciA9IG1peChjb2xvcjAsIGNvbG9yMSwgdVBlcmNlbnQpO1xcblxcblxcdGZsb2F0IGEgPSBzbW9vdGhzdGVwKC0wLjUsIC0wLjIsIHZQb3NpdGlvbi55KTtcXG4gICAgLy8gZ2xfRnJhZ0NvbG9yID0gdmVjNCggcG93KGNvbG9yLnIsIDEuMCArIHVPZmZzZXQpICogMi4wKTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggcG93ZXIoY29sb3IucnJyLCAxLjAgKyB1T2Zmc2V0KSAqIDIuMCwgMS4wICk7XFxuICAgIC8vIGdsX0ZyYWdDb2xvciA9IHZlYzQoIHBvd2VyKGNvbG9yLnJyciwgMS4wICsgdU9mZnNldCkgKiAyLjAgKiBhLCAxLjAgKTtcXG5cXG4gICAgLy8gZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvci5yZ2IsIDEuMCk7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2hhZGVycy9mb2cuZnJhZ1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVmlld0ZvZ3MuanNcblxuaW1wb3J0IFZpZXdGb2cgZnJvbSAnLi9WaWV3Rm9nJztcblxuY2xhc3MgVmlld0ZvZ3Mge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLl92aWV3cyA9IFtuZXcgVmlld0ZvZygpLCBuZXcgVmlld0ZvZ107XG5cdH1cblxuXG5cdHJlc2V0KG1OdW1TbGlkZXMpIHtcblx0XHRjb25zb2xlLmxvZygncmVzZXQnKTtcblx0XHR0aGlzLm5leHRWaWV3LnJlc2V0KG1OdW1TbGlkZXMpO1xuXHR9XG5cblxuXHRzd2FwKCkge1xuXHRcdHRoaXMuX3ZpZXdzID0gdGhpcy5fdmlld3MucmV2ZXJzZSgpO1xuXHR9XG5cblxuXHRyZW5kZXIodGV4dHVyZTAsIHRleHR1cmUxLCBwZXJjZW50KSB7XG5cdFx0dGhpcy5jdXJyZW50Vmlldy5yZW5kZXIodGV4dHVyZTAsIHRleHR1cmUxLCBwZXJjZW50KTtcblx0fVxuXG5cblx0Z2V0IGN1cnJlbnRWaWV3KCkge1xuXHRcdHJldHVybiB0aGlzLl92aWV3c1swXTtcblx0fVxuXG5cblx0Z2V0IG5leHRWaWV3KCkge1xuXHRcdHJldHVybiB0aGlzLl92aWV3c1sxXTtcblx0fVxuXG5cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFZpZXdGb2dzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9WaWV3Rm9ncy5qcyIsIi8vIFZpZXdGWEFBLmpzXG5cbmltcG9ydCBhbGZyaWQsIHsgR0wgfSBmcm9tICdhbGZyaWQnO1xuXG5pbXBvcnQgQXNzZXRzIGZyb20gJy4vQXNzZXRzJztcbmltcG9ydCBDb25maWcgZnJvbSAnLi9Db25maWcnO1xuaW1wb3J0IGZzIGZyb20gJ3NoYWRlcnMvZnhhYS5mcmFnJztcblxuY2xhc3MgVmlld0ZYQUEgZXh0ZW5kcyBhbGZyaWQuVmlldyB7XG5cdFxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcihhbGZyaWQuU2hhZGVyTGlicy5iaWdUcmlhbmdsZVZlcnQsIGZzKTtcblx0fVxuXG5cblx0X2luaXQoKSB7XG5cdFx0dGhpcy5tZXNoID0gYWxmcmlkLkdlb20uYmlnVHJpYW5nbGUoKTtcblx0XHR0aGlzLnRleHR1cmVOb2lzZSA9IEFzc2V0cy5nZXQoJ25vaXNlJyk7XG5cdFx0dGhpcy50ZXh0dXJlTm9pc2Uud3JhcFMgPSB0aGlzLnRleHR1cmVOb2lzZS53cmFwVCA9IEdMLlJFUEVBVDtcblx0XHR0aGlzLnRleHR1cmVOb2lzZS5taW5GaWx0ZXIgPSB0aGlzLnRleHR1cmVOb2lzZS5tYWdGaWx0ZXIgPSBHTC5ORUFSRVNUO1xuXG5cdFx0dGhpcy50ZXh0dXJlTWFwID0gQXNzZXRzLmdldCgnZ3JhZGllbnRNYXAnKTtcblx0XHR0aGlzLnRleHR1cmVNYXAubWluRmlsdGVyID0gdGhpcy50ZXh0dXJlTWFwLm1hZ0ZpbHRlciA9IEdMLk5FQVJFU1Q7XG5cdH1cblxuXG5cdHJlbmRlcih0ZXh0dXJlLCB0ZXh0dXJlQmxvb20pIHtcblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybShcInRleHR1cmVcIiwgXCJ1bmlmb3JtMWlcIiwgMCk7XG5cdFx0dGV4dHVyZS5iaW5kKDApO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oXCJ0ZXh0dXJlTm9pc2VcIiwgXCJ1bmlmb3JtMWlcIiwgMSk7XG5cdFx0dGhpcy50ZXh0dXJlTm9pc2UuYmluZCgxKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKFwidGV4dHVyZUJsb29tXCIsIFwidW5pZm9ybTFpXCIsIDIpO1xuXHRcdHRleHR1cmVCbG9vbS5iaW5kKDIpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oXCJ0ZXh0dXJlTWFwXCIsIFwidW5pZm9ybTFpXCIsIDMpO1xuXHRcdHRoaXMudGV4dHVyZU1hcC5iaW5kKDMpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oXCJ1UmVzb2x1dGlvblwiLCBcInZlYzJcIiwgWzEvR0wud2lkdGgsIDEvR0wuaGVpZ2h0XSk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybShcInVPdmVybGF5XCIsIFwiZmxvYXRcIiwgQ29uZmlnLm92ZXJsYXlPcGFjaXR5KTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKFwidUJsb29tU3RyZW5ndGhcIiwgXCJmbG9hdFwiLCBDb25maWcuYmxvb21TdHJlbmd0aCk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybShcInVHcmFkaWVudE1hcFwiLCBcImZsb2F0XCIsIENvbmZpZy5ncmFkaWVudE1hcCk7XG5cdFx0R0wuZHJhdyh0aGlzLm1lc2gpO1xuXHR9XG5cblxufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3RlhBQTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvVmlld0ZYQUEuanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gZnhhYS5mcmFnXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBGWEFBXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlTm9pc2U7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZUJsb29tO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVNYXA7XFxudW5pZm9ybSB2ZWMyIHVSZXNvbHV0aW9uO1xcbnVuaWZvcm0gZmxvYXQgdUJsb29tU3RyZW5ndGg7XFxudW5pZm9ybSBmbG9hdCB1T3ZlcmxheTtcXG51bmlmb3JtIGZsb2F0IHVHcmFkaWVudE1hcDtcXG5cXG5cXG5mbG9hdCBGWEFBX1NVQlBJWF9TSElGVCA9IDEuMC80LjA7XFxuI2RlZmluZSBGWEFBX1JFRFVDRV9NSU4gICAoMS4wLyAxMjguMClcXG4jZGVmaW5lIEZYQUFfUkVEVUNFX01VTCAgICgxLjAgLyA4LjApXFxuI2RlZmluZSBGWEFBX1NQQU5fTUFYICAgICA4LjBcXG5cXG5cXG52ZWM0IGFwcGx5RlhBQShzYW1wbGVyMkQgdGV4KSB7XFxuICAgIHZlYzQgY29sb3I7XFxuICAgIHZlYzIgZnJhZ0Nvb3JkID0gZ2xfRnJhZ0Nvb3JkLnh5O1xcbiAgICB2ZWMzIHJnYk5XID0gdGV4dHVyZTJEKHRleCwgKGZyYWdDb29yZCArIHZlYzIoLTEuMCwgLTEuMCkpICogdVJlc29sdXRpb24pLnh5ejtcXG4gICAgdmVjMyByZ2JORSA9IHRleHR1cmUyRCh0ZXgsIChmcmFnQ29vcmQgKyB2ZWMyKDEuMCwgLTEuMCkpICogdVJlc29sdXRpb24pLnh5ejtcXG4gICAgdmVjMyByZ2JTVyA9IHRleHR1cmUyRCh0ZXgsIChmcmFnQ29vcmQgKyB2ZWMyKC0xLjAsIDEuMCkpICogdVJlc29sdXRpb24pLnh5ejtcXG4gICAgdmVjMyByZ2JTRSA9IHRleHR1cmUyRCh0ZXgsIChmcmFnQ29vcmQgKyB2ZWMyKDEuMCwgMS4wKSkgKiB1UmVzb2x1dGlvbikueHl6O1xcbiAgICB2ZWMzIHJnYk0gID0gdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICAqIHVSZXNvbHV0aW9uKS54eXo7XFxuICAgIHZlYzMgbHVtYSA9IHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCk7XFxuICAgIGZsb2F0IGx1bWFOVyA9IGRvdChyZ2JOVywgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFORSA9IGRvdChyZ2JORSwgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFTVyA9IGRvdChyZ2JTVywgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFTRSA9IGRvdChyZ2JTRSwgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFNICA9IGRvdChyZ2JNLCAgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFNaW4gPSBtaW4obHVtYU0sIG1pbihtaW4obHVtYU5XLCBsdW1hTkUpLCBtaW4obHVtYVNXLCBsdW1hU0UpKSk7XFxuICAgIGZsb2F0IGx1bWFNYXggPSBtYXgobHVtYU0sIG1heChtYXgobHVtYU5XLCBsdW1hTkUpLCBtYXgobHVtYVNXLCBsdW1hU0UpKSk7XFxuXFxuICAgIHZlYzIgZGlyO1xcbiAgICBkaXIueCA9IC0oKGx1bWFOVyArIGx1bWFORSkgLSAobHVtYVNXICsgbHVtYVNFKSk7XFxuICAgIGRpci55ID0gICgobHVtYU5XICsgbHVtYVNXKSAtIChsdW1hTkUgKyBsdW1hU0UpKTtcXG5cXG4gICAgZmxvYXQgZGlyUmVkdWNlID0gbWF4KChsdW1hTlcgKyBsdW1hTkUgKyBsdW1hU1cgKyBsdW1hU0UpICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgwLjI1ICogRlhBQV9SRURVQ0VfTVVMKSwgRlhBQV9SRURVQ0VfTUlOKTtcXG5cXG4gICAgZmxvYXQgcmNwRGlyTWluID0gMS4wIC8gKG1pbihhYnMoZGlyLngpLCBhYnMoZGlyLnkpKSArIGRpclJlZHVjZSk7XFxuICAgIGRpciA9IG1pbih2ZWMyKEZYQUFfU1BBTl9NQVgsIEZYQUFfU1BBTl9NQVgpLFxcbiAgICAgICAgICAgICAgbWF4KHZlYzIoLUZYQUFfU1BBTl9NQVgsIC1GWEFBX1NQQU5fTUFYKSxcXG4gICAgICAgICAgICAgIGRpciAqIHJjcERpck1pbikpICogdVJlc29sdXRpb247XFxuXFxuICAgIHZlYzMgcmdiQSA9IDAuNSAqIChcXG4gICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIHVSZXNvbHV0aW9uICsgZGlyICogKDEuMCAvIDMuMCAtIDAuNSkpLnh5eiArXFxuICAgICAgICB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiB1UmVzb2x1dGlvbiArIGRpciAqICgyLjAgLyAzLjAgLSAwLjUpKS54eXopO1xcbiAgICB2ZWMzIHJnYkIgPSByZ2JBICogMC41ICsgMC4yNSAqIChcXG4gICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIHVSZXNvbHV0aW9uICsgZGlyICogLTAuNSkueHl6ICtcXG4gICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIHVSZXNvbHV0aW9uICsgZGlyICogMC41KS54eXopO1xcblxcbiAgICBmbG9hdCBsdW1hQiA9IGRvdChyZ2JCLCBsdW1hKTtcXG4gICAgaWYgKChsdW1hQiA8IGx1bWFNaW4pIHx8IChsdW1hQiA+IGx1bWFNYXgpKVxcbiAgICAgICAgY29sb3IgPSB2ZWM0KHJnYkEsIDEuMCk7XFxuICAgIGVsc2VcXG4gICAgICAgIGNvbG9yID0gdmVjNChyZ2JCLCAxLjApO1xcbiAgICByZXR1cm4gY29sb3I7XFxufVxcblxcbnZlYzMgYmxlbmRPdmVybGF5KHZlYzMgYmFzZSwgdmVjMyBibGVuZCkge1xcbiAgICByZXR1cm4gbWl4KDEuMCAtIDIuMCAqICgxLjAgLSBiYXNlKSAqICgxLjAgLSBibGVuZCksIDIuMCAqIGJhc2UgKiBibGVuZCwgc3RlcChiYXNlLCB2ZWMzKDAuNSkpKTtcXG59XFxuXFxudmVjMyBibGVuZE92ZXJsYXkodmVjMyBiYXNlLCB2ZWMzIGJsZW5kLCBmbG9hdCBvcGFjaXR5KSB7XFxuXFx0dmVjMyBibGVuZGVkID0gbWl4KDEuMCAtIDIuMCAqICgxLjAgLSBiYXNlKSAqICgxLjAgLSBibGVuZCksIDIuMCAqIGJhc2UgKiBibGVuZCwgc3RlcChiYXNlLCB2ZWMzKDAuNSkpKTtcXG5cXHRyZXR1cm4gbWl4KGJhc2UsIGJsZW5kZWQsIG9wYWNpdHkpO1xcbn1cXG5cXG5mbG9hdCBsdW1hKHZlYzMgY29sb3IpIHtcXG4gIHJldHVybiBkb3QoY29sb3IsIHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCkpO1xcbn1cXG5cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBmbG9hdCB0ID0gYWJzKHZUZXh0dXJlQ29vcmQueCAtIC41KTtcXG4gICAgdCA9IHNtb290aHN0ZXAoMC4zLCAwLjAsIHQpO1xcblxcblxcdHZlYzQgY29sb3IgPSBhcHBseUZYQUEodGV4dHVyZSk7XFxuICAgIHZlYzMgYmxvb20gPSB0ZXh0dXJlMkQodGV4dHVyZUJsb29tLCB2VGV4dHVyZUNvb3JkKS5yZ2I7XFxuICAgIGNvbG9yLnJnYiArPSBibG9vbS5yZ2IgKiB1Qmxvb21TdHJlbmd0aCAqIHQ7XFxuXFxuICAgIGZsb2F0IGwgPSBsdW1hKGNvbG9yLnJnYik7XFxuICAgIHZlYzIgdXZHcmFkaWVudCA9IHZlYzIobCwgLjUpO1xcbiAgICB2ZWMzIGNvbG9yR3JhZGVkID0gdGV4dHVyZTJEKHRleHR1cmVNYXAsIHV2R3JhZGllbnQpLnJnYjsgICAgXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIGNvbG9yR3JhZGVkLCB1R3JhZGllbnRNYXApO1xcblxcblxcdHZlYzIgdXYgPSB2VGV4dHVyZUNvb3JkICogNS4wO1xcblxcdHZlYzMgbm9pc2UgPSB0ZXh0dXJlMkQodGV4dHVyZU5vaXNlLCB1dikucmdiO1xcblxcdGNvbG9yLnJnYiA9IGJsZW5kT3ZlcmxheShjb2xvci5yZ2IsIG5vaXNlLCB1T3ZlcmxheSk7XFxuXFxuICAgIFxcbiAgICBcXG5cXG5cXHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zaGFkZXJzL2Z4YWEuZnJhZ1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVmlld0FuaW1hbC5qc1xuXG5pbXBvcnQgYWxmcmlkLCB7IEdMIH0gZnJvbSAnYWxmcmlkJztcbmltcG9ydCBDb25maWcgZnJvbSAnLi9Db25maWcnO1xuaW1wb3J0IEFzc2V0cyBmcm9tICcuL0Fzc2V0cyc7XG5pbXBvcnQgdnMgZnJvbSAnc2hhZGVycy9hbmltYWwudmVydCc7XG5pbXBvcnQgZnMgZnJvbSAnc2hhZGVycy9hbmltYWwuZnJhZyc7XG5cbmNsYXNzIFZpZXdBbmltYWwgZXh0ZW5kcyBhbGZyaWQuVmlldyB7XG5cdFxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcih2cywgZnMpO1xuXHR9XG5cblxuXHRfaW5pdCgpIHtcblx0XHR0aGlzLm1lc2ggPSBBc3NldHMuZ2V0KENvbmZpZy5hbmltYWwpO1xuXHR9XG5cblxuXHRzZXRBbmltYWwobUlkKSB7XG5cdFx0dGhpcy5tZXNoID0gQXNzZXRzLmdldChtSWQpO1xuXHR9XG5cblxuXHRyZW5kZXIoKSB7XG5cdFx0R0wuZGlzYWJsZShHTC5DVUxMX0ZBQ0UpO1xuXHRcdHRoaXMuc2hhZGVyLmJpbmQoKTtcblx0XHRHTC5kcmF3KHRoaXMubWVzaCk7XG5cdFx0R0wuZW5hYmxlKEdMLkNVTExfRkFDRSk7XG5cdH1cblxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXdBbmltYWw7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL1ZpZXdBbmltYWwuanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYmFzaWMudmVydFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyB1Tm9ybWFsTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbnZhcnlpbmcgdmVjNCB2U2NyZWVuUG9zaXRpb247XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXHR2ZWMzIHBvcyAgICAgICAgPSBhVmVydGV4UG9zaXRpb247XFxuXFx0cG9zLnkgICAgICAgICAgICs9IDAuMjtcXG5cXHR2U2NyZWVuUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVWaWV3TWF0cml4ICogdU1vZGVsTWF0cml4ICogdmVjNChwb3MsIDEuMCk7XFxuXFx0Z2xfUG9zaXRpb24gICAgID0gdlNjcmVlblBvc2l0aW9uO1xcblxcdHZUZXh0dXJlQ29vcmQgICA9IGFUZXh0dXJlQ29vcmQ7XFxuXFx0dk5vcm1hbCAgICAgICAgID0gdU5vcm1hbE1hdHJpeCAqIGFOb3JtYWw7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2hhZGVycy9hbmltYWwudmVydFxuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbnZhcnlpbmcgdmVjNCB2U2NyZWVuUG9zaXRpb247XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxuXFxuI2RlZmluZSBMSUdIVCB2ZWMzKDAuMCwgMC4wLCAxLjApXFxuXFxuZmxvYXQgZGlmZnVzZSh2ZWMzIE4sIHZlYzMgTCkge1xcblxcdHJldHVybiBtYXgoZG90KE4sIG5vcm1hbGl6ZShMKSksIDAuMCk7XFxufVxcblxcblxcbnZlYzMgZGlmZnVzZSh2ZWMzIE4sIHZlYzMgTCwgdmVjMyBDKSB7XFxuXFx0cmV0dXJuIGRpZmZ1c2UoTiwgTCkgKiBDO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdGZsb2F0IHogPSB2U2NyZWVuUG9zaXRpb24ueiAvIHZTY3JlZW5Qb3NpdGlvbi53O1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzMoeiAqIDAuMjUpLCAxLjApO1xcblxcblxcbiAgICBmbG9hdCBkID0gZGlmZnVzZSh2Tm9ybWFsLCBMSUdIVCk7XFxuICAgIGdsX0ZyYWdDb2xvci5yZ2IgKz0gcG93KDEuMCAtIGQsIDIuMCkgKiAuMTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zaGFkZXJzL2FuaW1hbC5mcmFnXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBWaWV3U3F1YXJlcy5qc1xuXG5pbXBvcnQgYWxmcmlkLCB7IEdMIH0gZnJvbSAnYWxmcmlkJztcbmltcG9ydCBDb25maWcgZnJvbSAnLi9Db25maWcnO1xuaW1wb3J0IHZzIGZyb20gJ3NoYWRlcnMvc3F1YXJlcy52ZXJ0JztcbmltcG9ydCBmcyBmcm9tICdzaGFkZXJzL3NxdWFyZXMuZnJhZyc7XG5cbnZhciByYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkgeyByZXR1cm4gbWluICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pO1x0fVxuXG5jbGFzcyBWaWV3U3F1YXJlcyBleHRlbmRzIGFsZnJpZC5WaWV3IHtcblx0XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKHZzLCBmcyk7XG5cdH1cblxuXG5cdF9pbml0KCkge1xuXHRcdGxldCBzaXplID0gLjE1O1xuXHRcdHRoaXMubWVzaCA9IGFsZnJpZC5HZW9tLnBsYW5lKHNpemUsIHNpemUsIDEpO1xuXHRcdHRoaXMub2Zmc2V0ID0gbmV3IGFsZnJpZC5Ud2Vlbk51bWJlcigwLCAnbGluZWFyJywgMC4wMDUpO1xuXG5cdFx0dGhpcy52aWV3SW52ZXJ0ID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLnByb2pJbnZlcnQgPSBtYXQ0LmNyZWF0ZSgpO1xuXHRcdHRoaXMucmVzZXQoKTtcblx0fVxuXG5cblx0c2V0TWF0cmljZXMoY2FtZXJhKSB7XG5cdFx0bWF0NC5pbnZlcnQodGhpcy5wcm9qSW52ZXJ0LCBjYW1lcmEucHJvamVjdGlvbik7XG5cdFx0bWF0NC5pbnZlcnQodGhpcy52aWV3SW52ZXJ0LCBjYW1lcmEubWF0cml4KTtcblx0fVxuXG5cblx0cmVzZXQoKSB7XG5cdFx0bGV0IGkgPSAyMDAwMDtcblx0XHRsZXQgcG9zaXRpb25zID0gW107XG5cdFx0bGV0IGV4dHJhcyA9IFtdO1xuXHRcdGxldCByID0gMy41O1xuXG5cdFx0d2hpbGUoaS0tKSB7XG5cdFx0XHRwb3NpdGlvbnMucHVzaChbcmFuZG9tKC1yLCByKSwgcmFuZG9tKC1yLzIsIHIpLCByYW5kb20oLXIsIHIpXSlcblx0XHRcdGV4dHJhcy5wdXNoKFtNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5tZXNoLmJ1ZmZlckluc3RhbmNlKHBvc2l0aW9ucywgJ2FQb3NPZmZzZXQnKTtcblx0XHR0aGlzLm1lc2guYnVmZmVySW5zdGFuY2UoZXh0cmFzLCAnYUV4dHJhJyk7XG5cdH1cblxuXG5cdG9wZW4oKSB7XG5cdFx0dGhpcy5vZmZzZXQuc3BlZWQgPSAwLjAxO1xuXHRcdHRoaXMub2Zmc2V0LnZhbHVlID0gMTtcblx0fVxuXG5cblx0Y2xvc2UoKSB7XG5cdFx0dGhpcy5vZmZzZXQuc3BlZWQgPSAwLjAwNTtcblx0XHR0aGlzLm9mZnNldC52YWx1ZSA9IDA7XG5cdH1cblxuXG5cdHJlbmRlcihtTWF0cml4LCBtVGV4dHVyZSkge1xuXHRcdHRoaXMuc2hhZGVyLmJpbmQoKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKFwidGV4dHVyZVwiLCBcInVuaWZvcm0xaVwiLCAwKTtcblx0XHRtVGV4dHVyZS5iaW5kKDApO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oXCJ1TWF0cml4XCIsIFwibWF0NFwiLCBtTWF0cml4KTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKFwidU9mZnNldFwiLCBcImZsb2F0XCIsIHRoaXMub2Zmc2V0LnZhbHVlKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKFwidU1peGluZ1wiLCBcImZsb2F0XCIsIENvbmZpZy5waXhlbGF0ZU1peGluZyk7XG5cdFx0R0wuZHJhdyh0aGlzLm1lc2gpO1xuXHR9XG5cblxufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3U3F1YXJlcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvVmlld1NxdWFyZXMuanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYmFzaWMudmVydFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuYXR0cmlidXRlIHZlYzMgYVBvc09mZnNldDtcXG5hdHRyaWJ1dGUgdmVjMyBhRXh0cmE7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1Vmlld0ludmVydDtcXG51bmlmb3JtIG1hdDQgdVByb2pJbnZlcnQ7XFxudW5pZm9ybSBmbG9hdCB1T2Zmc2V0O1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVEZXB0aDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnZhcnlpbmcgdmVjMiB2VVZDZW50ZXI7XFxudmFyeWluZyB2ZWM0IHZTY3JlZW5Qb3NpdGlvbjtcXG52YXJ5aW5nIHZlYzMgdkV4dHJhO1xcbnZhcnlpbmcgdmVjMyB2RGVidWc7XFxuXFxuZmxvYXQgY3ViaWNJbk91dChmbG9hdCB0KSB7XFxuICByZXR1cm4gdCA8IDAuNVxcbiAgICA/IDQuMCAqIHQgKiB0ICogdFxcbiAgICA6IDAuNSAqIHBvdygyLjAgKiB0IC0gMi4wLCAzLjApICsgMS4wO1xcbn1cXG5cXG5mbG9hdCBjaXJjdWxhckluKGZsb2F0IHQpIHtcXG4gIHJldHVybiAxLjAgLSBzcXJ0KDEuMCAtIHQgKiB0KTtcXG59XFxuXFxuXFxuXFxuZmxvYXQgY2lyY3VsYXJPdXQoZmxvYXQgdCkge1xcbiAgcmV0dXJuIHNxcnQoKDIuMCAtIHQpICogdCk7XFxufVxcblxcbmZsb2F0IGNpcmN1bGFySW5PdXQoZmxvYXQgdCkge1xcbiAgcmV0dXJuIHQgPCAwLjVcXG4gICAgPyAwLjUgKiAoMS4wIC0gc3FydCgxLjAgLSA0LjAgKiB0ICogdCkpXFxuICAgIDogMC41ICogKHNxcnQoKDMuMCAtIDIuMCAqIHQpICogKDIuMCAqIHQgLSAxLjApKSArIDEuMCk7XFxufVxcblxcbmZsb2F0IGN1YmljT3V0KGZsb2F0IHQpIHtcXG4gIGZsb2F0IGYgPSB0IC0gMS4wO1xcbiAgcmV0dXJuIGYgKiBmICogZiArIDEuMDtcXG59XFxuXFxuXFxuZmxvYXQgZ2V0U3VyZmFjZVBvc2l0aW9uKG1hdDQgc2hhZG93TWF0cml4LCB2ZWMzIHBvc2l0aW9uLCBtYXQ0IGludmVydFByb2osIG1hdDQgaW52ZXJ0Vmlldywgc2FtcGxlcjJEIHRleHR1cmVEZXB0aCkge1xcbiAgICBcXG4gICAgLy8gIGdldCB0aGUgc2hhZG93IGNvb3JkXFxuXFx0dmVjNCB2U2hhZG93Q29vcmQgPSBzaGFkb3dNYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcblxcdHZlYzQgc2hhZG93Q29vcmQgID0gdlNoYWRvd0Nvb3JkIC8gdlNoYWRvd0Nvb3JkLnc7XFxuXFx0dmVjMiB1diAgICAgICAgICAgPSBzaGFkb3dDb29yZC54eTtcXG5cXG4gICAgLy8gIHJlY29uc3RydWN0IHdvcmxkIHBvc2l0aW9uIGZyb20gZGVwdGggYnVmZmVyXFxuXFx0ZmxvYXQgZGVwdGggICAgICAgICAgICAgPSB0ZXh0dXJlMkQodGV4dHVyZURlcHRoLCB1dikucjtcXG5cXHRmbG9hdCB6ICAgICAgICAgICAgICAgICA9IGRlcHRoICogMi4wIC0gMS4wO1xcblxcdHZlYzQgY2xpcFNwYWNlUG9zaXRpb24gID0gdmVjNCh1diAqIDIuMCAtIDEuMCwgeiwgMS4wKTtcXG5cXHR2ZWM0IHZpZXdTcGFjZVBvc2l0aW9uICA9IGludmVydFByb2ogKiBjbGlwU3BhY2VQb3NpdGlvbjtcXG5cXHR2aWV3U3BhY2VQb3NpdGlvbiAgICAgICAvPSB2aWV3U3BhY2VQb3NpdGlvbi53O1xcblxcdHZlYzQgd29ybGRTcGFjZVBvc2l0aW9uID0gaW52ZXJ0VmlldyAqIHZpZXdTcGFjZVBvc2l0aW9uO1xcbiAgICByZXR1cm4gd29ybGRTcGFjZVBvc2l0aW9uLnogKiAwLjU7XFxufVxcblxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFx0ZmxvYXQgc2NhbGUgICAgID0gLWFFeHRyYS56ICsgdU9mZnNldCAqIDIuMDtcXG5cXHRzY2FsZSAgICAgICAgICAgPSBzbW9vdGhzdGVwKDAuMCwgMS4wLCBzY2FsZSk7XFxuXFx0c2NhbGUgICAgICAgICAgID0gY2lyY3VsYXJJbk91dChzY2FsZSk7XFxuXFx0XFxuXFx0dmVjMyBwb3MgICAgICAgID0gYVZlcnRleFBvc2l0aW9uO1xcblxcdHBvcyAgICAgICAgICAgICAqPSBtaXgoYUV4dHJhLngsIDEuMCwgLjUpICogc2NhbGU7IFxcblxcdHBvcyAgICAgICAgICAgICArPSBhUG9zT2Zmc2V0O1xcblxcdFxcblxcdHZTY3JlZW5Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdVZpZXdNYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KHBvcywgMS4wKTtcXG5cXHRnbF9Qb3NpdGlvbiAgICAgPSB2U2NyZWVuUG9zaXRpb247XFxuXFx0dlRleHR1cmVDb29yZCAgID0gYVRleHR1cmVDb29yZDtcXG5cXHR2Tm9ybWFsICAgICAgICAgPSBhTm9ybWFsO1xcblxcdFxcblxcdHZlYzQgY29vcmQgICAgICA9IHVNYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KHBvcywgMS4wKTtcXG5cXHR2VVYgICAgICAgICAgICAgPSBjb29yZC54eSAvIGNvb3JkLnc7XFxuXFx0Y29vcmQgICAgICAgICAgID0gdU1hdHJpeCAqIHVNb2RlbE1hdHJpeCAqIHZlYzQoYVBvc09mZnNldCwgMS4wKTtcXG5cXHR2VVZDZW50ZXIgICAgICAgPSBjb29yZC54eSAvIGNvb3JkLnc7XFxuXFx0XFxuXFx0dkV4dHJhICAgICAgICAgID0gYUV4dHJhO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NoYWRlcnMvc3F1YXJlcy52ZXJ0XG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gY29weS5mcmFnXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBTSU1QTEVfVEVYVFVSRVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMiB2VVY7XFxudmFyeWluZyB2ZWMyIHZVVkNlbnRlcjtcXG52YXJ5aW5nIHZlYzMgdkV4dHJhO1xcbnZhcnlpbmcgdmVjMyB2RGVidWc7XFxudmFyeWluZyB2ZWM0IHZTY3JlZW5Qb3NpdGlvbjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVEZXB0aDtcXG51bmlmb3JtIGZsb2F0IHVNaXhpbmc7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjNCBjb2xvcjAgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlVWKTtcXG4gICAgdmVjNCBjb2xvcjEgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlVWQ2VudGVyKTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gbWl4KGNvbG9yMCwgY29sb3IxLCAoMC41ICsgdkV4dHJhLnkgKiAuNSkgKiB1TWl4aW5nICk7XFxuXFxuICAgIGZsb2F0IHogPSB2U2NyZWVuUG9zaXRpb24ueiAvIHZTY3JlZW5Qb3NpdGlvbi53O1xcbiAgICBnbF9GcmFnQ29sb3IucmdiICo9ICgxLjAgLSB6ICogMC4yNSk7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2hhZGVycy9zcXVhcmVzLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFZpZXdDb3Zlci5qc1xuXG5pbXBvcnQgYWxmcmlkLCB7IEdMIH0gZnJvbSAnYWxmcmlkJztcblxuY2xhc3MgVmlld0NvdmVyIGV4dGVuZHMgYWxmcmlkLlZpZXcge1xuXHRcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoYWxmcmlkLlNoYWRlckxpYnMuYmlnVHJpYW5nbGVWZXJ0LCBhbGZyaWQuU2hhZGVyTGlicy5zaW1wbGVDb2xvckZyYWcpO1xuXHR9XG5cblxuXHRfaW5pdCgpIHtcblx0XHR0aGlzLm1lc2ggPSBhbGZyaWQuR2VvbS5iaWdUcmlhbmdsZSgpO1xuXHRcdHRoaXMub3BhY2l0eSA9IG5ldyBhbGZyaWQuRWFzZU51bWJlcigwLCAwLjAyKTtcblx0fVxuXG5cblx0b3BlbigpIHtcblx0XHR0aGlzLm9wYWNpdHkudmFsdWUgPSAxO1xuXHR9XG5cblxuXHRjbG9zZSgpIHtcblx0XHR0aGlzLm9wYWNpdHkudmFsdWUgPSAwO1xuXHR9XG5cblxuXHRyZW5kZXIoKSB7XG5cdFx0aWYodGhpcy5vcGFjaXR5LnZhbHVlIDw9IDAuMDAxKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuc2hhZGVyLmJpbmQoKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKFwiY29sb3JcIiwgXCJ2ZWMzXCIsIFswLCAwLCAwXSk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybShcIm9wYWNpdHlcIiwgXCJmbG9hdFwiLCB0aGlzLm9wYWNpdHkudmFsdWUpO1xuXHRcdEdMLmRyYXcodGhpcy5tZXNoKTtcblx0fVxuXG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmlld0NvdmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9WaWV3Q292ZXIuanMiLCIvLyBWaWV3U25vdy5qc1xuXG5pbXBvcnQgYWxmcmlkLCB7IEdMIH0gZnJvbSAnYWxmcmlkJztcbmltcG9ydCBBc3NldHMgZnJvbSAnLi9Bc3NldHMnO1xuaW1wb3J0IENvbmZpZyBmcm9tICcuL0NvbmZpZyc7XG5pbXBvcnQgdnMgZnJvbSAnc2hhZGVycy9zbm93LnZlcnQnO1xuXG52YXIgcmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHsgcmV0dXJuIG1pbiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKTtcdH1cblxuY2xhc3MgVmlld1Nub3cgZXh0ZW5kcyBhbGZyaWQuVmlldyB7XG5cdFxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcih2cywgYWxmcmlkLlNoYWRlckxpYnMuc2ltcGxlQ29sb3JGcmFnKTtcblx0fVxuXG5cblx0X2luaXQoKSB7XG5cdFx0dGhpcy5tZXNoID0gQXNzZXRzLmdldCgncm9jaycpO1xuXG5cdFx0bGV0IG51bSA9IDUwMDtcblx0XHRjb25zdCBwb3NpdGlvbnMgPSBbXTtcblx0XHRjb25zdCBleHRyYSA9IFtdO1xuXHRcdGxldCByID0gQ29uZmlnLmZsb29yUmFkaXVzO1xuXG5cdFx0d2hpbGUobnVtLS0pIHtcblx0XHRcdHBvc2l0aW9ucy5wdXNoKFtyYW5kb20oLXIsIHIpLCByYW5kb20oMCwgciksIHJhbmRvbSgtciwgcildKTtcblx0XHRcdGV4dHJhLnB1c2goW01hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCldKTtcblx0XHR9XG5cblx0XHR0aGlzLm1lc2guYnVmZmVySW5zdGFuY2UocG9zaXRpb25zLCAnYVBvc09mZnNldCcpO1xuXHRcdHRoaXMubWVzaC5idWZmZXJJbnN0YW5jZShleHRyYSwgJ2FFeHRyYScpO1xuXG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oXCJjb2xvclwiLCBcInZlYzNcIiwgWzEsIDEsIDFdKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKFwib3BhY2l0eVwiLCBcImZsb2F0XCIsIDEpO1xuXHR9XG5cblxuXHRyZW5kZXIoKSB7XG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oXCJ1VGltZVwiLCBcImZsb2F0XCIsIGFsZnJpZC5TY2hlZHVsZXIuZGVsdGFUaW1lKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKFwidVJhZGl1c1wiLCBcImZsb2F0XCIsIENvbmZpZy5mbG9vclJhZGl1cyk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybShcInVTcGVlZFwiLCBcImZsb2F0XCIsIENvbmZpZy5zbm93U3BlZWQpO1xuXHRcdEdMLmRyYXcodGhpcy5tZXNoKTtcblx0fVxuXG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmlld1Nub3c7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL1ZpZXdTbm93LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGJhc2ljLnZlcnRcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcbmF0dHJpYnV0ZSB2ZWMzIGFFeHRyYTtcXG5hdHRyaWJ1dGUgdmVjMyBhUG9zT2Zmc2V0O1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVUaW1lO1xcbnVuaWZvcm0gZmxvYXQgdVJhZGl1cztcXG51bmlmb3JtIGZsb2F0IHVTcGVlZDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG5tYXQ0IHJvdGF0aW9uTWF0cml4KHZlYzMgYXhpcywgZmxvYXQgYW5nbGUpIHtcXG4gICAgYXhpcyA9IG5vcm1hbGl6ZShheGlzKTtcXG4gICAgZmxvYXQgcyA9IHNpbihhbmdsZSk7XFxuICAgIGZsb2F0IGMgPSBjb3MoYW5nbGUpO1xcbiAgICBmbG9hdCBvYyA9IDEuMCAtIGM7XFxuICAgIFxcbiAgICByZXR1cm4gbWF0NChvYyAqIGF4aXMueCAqIGF4aXMueCArIGMsICAgICAgICAgICBvYyAqIGF4aXMueCAqIGF4aXMueSAtIGF4aXMueiAqIHMsICBvYyAqIGF4aXMueiAqIGF4aXMueCArIGF4aXMueSAqIHMsICAwLjAsXFxuICAgICAgICAgICAgICAgIG9jICogYXhpcy54ICogYXhpcy55ICsgYXhpcy56ICogcywgIG9jICogYXhpcy55ICogYXhpcy55ICsgYywgICAgICAgICAgIG9jICogYXhpcy55ICogYXhpcy56IC0gYXhpcy54ICogcywgIDAuMCxcXG4gICAgICAgICAgICAgICAgb2MgKiBheGlzLnogKiBheGlzLnggLSBheGlzLnkgKiBzLCAgb2MgKiBheGlzLnkgKiBheGlzLnogKyBheGlzLnggKiBzLCAgb2MgKiBheGlzLnogKiBheGlzLnogKyBjLCAgICAgICAgICAgMC4wLFxcbiAgICAgICAgICAgICAgICAwLjAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLjApO1xcbn1cXG5cXG52ZWMzIHJvdGF0ZSh2ZWMzIHYsIHZlYzMgYXhpcywgZmxvYXQgYW5nbGUpIHtcXG5cXHRtYXQ0IG0gPSByb3RhdGlvbk1hdHJpeChheGlzLCBhbmdsZSk7XFxuXFx0cmV0dXJuIChtICogdmVjNCh2LCAxLjApKS54eXo7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFx0dmVjMyBzY2FsZSAgICAgPSBtaXgoYUV4dHJhLCB2ZWMzKDEuMCksIC43NSk7XFxuXFx0dmVjMyBheGlzICAgICAgPSBub3JtYWxpemUoYUV4dHJhKTtcXG5cXHRmbG9hdCBhbmdsZSAgICA9IGFFeHRyYS55ICsgbWl4KGFFeHRyYS56LCAxLjAsIC41KSAqIHVUaW1lO1xcblxcdHZlYzMgcG9zICAgICAgID0gcm90YXRlKGFWZXJ0ZXhQb3NpdGlvbiwgYXhpcywgYW5nbGUpO1xcblxcdHBvcyAgICAgICAgICAgID0gcG9zICogc2NhbGUgKiAuMDAwNjtcXG5cXHRcXG5cXHR2ZWMzIGRpciAgICAgICA9IHZlYzMoYUV4dHJhLngsIGFFeHRyYS55ICogLjUgKyAuNSwgYUV4dHJhLnopO1xcblxcdGRpci55ICAgICAgICAgICo9IC0xLjA7XFxuXFx0dmVjMyBwb3NPZmZzZXQgPSBhUG9zT2Zmc2V0ICsgZGlyICogdVRpbWUgKiAwLjEgKiB1U3BlZWQ7XFxuXFx0cG9zT2Zmc2V0LnkgICAgPSBtb2QocG9zT2Zmc2V0LnksIHVSYWRpdXMpO1xcblxcdHBvc09mZnNldC54ICAgID0gbW9kKHBvc09mZnNldC54ICsgdVJhZGl1cywgdVJhZGl1cyAqIDIuMCkgLSB1UmFkaXVzO1xcblxcdHBvc09mZnNldC56ICAgID0gbW9kKHBvc09mZnNldC56ICsgdVJhZGl1cywgdVJhZGl1cyAqIDIuMCkgLSB1UmFkaXVzO1xcblxcdHBvcyAgICAgICAgICAgICs9IHBvc09mZnNldDtcXG5cXHRcXG5cXHRnbF9Qb3NpdGlvbiAgICA9IHVQcm9qZWN0aW9uTWF0cml4ICogdVZpZXdNYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KHBvcywgMS4wKTtcXG5cXHR2VGV4dHVyZUNvb3JkICA9IGFUZXh0dXJlQ29vcmQ7XFxuXFx0dk5vcm1hbCAgICAgICAgPSBhTm9ybWFsO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NoYWRlcnMvc25vdy52ZXJ0XG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBQYXNzQmxvb20uanNcblxuaW1wb3J0IGFsZnJpZCwgeyBHTCB9IGZyb20gJ2FsZnJpZCc7XG5pbXBvcnQgZnNUcmVzaG9sZCBmcm9tICcuLi9zaGFkZXJzL3RocmVzaG9sZC5mcmFnJztcbmltcG9ydCBmc0Jsb29tIGZyb20gJy4uL3NoYWRlcnMvYmxvb20uZnJhZyc7XG5pbXBvcnQgZnNDb21wb3NlIGZyb20gJy4uL3NoYWRlcnMvYmxvb21Db21wb3NlLmZyYWcnO1xuXG5jbGFzcyBQYXNzQmxvb20ge1xuXG5cdGNvbnN0cnVjdG9yKG1OdW1NaXBzID0gNSwgbVN0YXJ0aW5nU2NhbGUgPSAwLjUpIHtcblx0XHR0aGlzLl9udW1NaXBzID0gTWF0aC5taW4obU51bU1pcHMsIDUpO1xuXHRcdHRoaXMuX3N0YXJ0aW5nU2NhbGUgPSBtU3RhcnRpbmdTY2FsZTtcblx0XHR0aGlzLl9pbml0VGV4dHVyZXMoKTtcblx0XHR0aGlzLl9pbml0Vmlld3MoKTtcblx0fVxuXG5cblx0X2luaXRUZXh0dXJlcygpe1xuXHRcdGxldCB3aWR0aCA9IE1hdGgucm91bmQoR0wud2lkdGgqdGhpcy5fc3RhcnRpbmdTY2FsZSk7XG5cdFx0bGV0IGhlaWdodCA9IE1hdGgucm91bmQoR0wuaGVpZ2h0KnRoaXMuX3N0YXJ0aW5nU2NhbGUpO1xuXG5cdFx0dGhpcy5fZmJvcyA9IFtdO1xuXHRcdGZvcihsZXQgaT0wOyBpPHRoaXMuX251bU1pcHM7IGkrKykge1xuXHRcdFx0Y29uc3QgZmJvViA9IG5ldyBhbGZyaWQuRnJhbWVCdWZmZXIod2lkdGgsIGhlaWdodCk7XG5cdFx0XHRjb25zdCBmYm9IID0gbmV3IGFsZnJpZC5GcmFtZUJ1ZmZlcih3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdHRoaXMuX2Zib3MucHVzaCh7ZmJvViwgZmJvSH0pO1xuXG5cdFx0XHR3aWR0aCA9IE1hdGgucm91bmQod2lkdGgvMik7XG5cdFx0XHRoZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodC8yKTtcblx0XHR9XG5cblx0XHQvLyBjb25zdCBzY2FsZSA9IDAuNTtcblx0XHQvLyB0aGlzLl9mYm9UaHJlc2hvbGQgPSBuZXcgYWxmcmlkLkZyYW1lQnVmZmVyKEdMLndpZHRoICogc2NhbGUsIEdMLmhlaWdodCAqIHNjYWxlKTtcblx0XHQvLyB0aGlzLl9mYm9Db21wb3NlID0gbmV3IGFsZnJpZC5GcmFtZUJ1ZmZlcihHTC53aWR0aCAqIHNjYWxlLCBHTC5oZWlnaHQgKiBzY2FsZSk7XG5cblx0XHQvLyBjb25zdCBvU2V0dGluZ3MgPSB7XG5cdFx0Ly8gXHRtaW5GaWx0ZXI6R0wuTkVBUkVTVF9NSVBNQVBfTElORUFSLFxuXHRcdC8vIFx0bWFnRmlsdGVyOkdMLk5FQVJFU1RfTUlQTUFQX0xJTkVBUixcblx0XHQvLyB9XG5cblx0XHRjb25zdCBvU2V0dGluZ3MgPSB7XG5cdFx0XHRtaW5GaWx0ZXI6R0wuTElORUFSLFxuXHRcdFx0bWFnRmlsdGVyOkdMLkxJTkVBUixcblx0XHR9XG5cblx0XHR3aW5kb3cuR0wgPSBHTDtcblxuXHRcdGNvbnN0IHMgPSA1MTI7XG5cdFx0dGhpcy5fZmJvVGhyZXNob2xkID0gbmV3IGFsZnJpZC5GcmFtZUJ1ZmZlcihzLCBzLCBvU2V0dGluZ3MpO1xuXHRcdHRoaXMuX2Zib0NvbXBvc2UgPSBuZXcgYWxmcmlkLkZyYW1lQnVmZmVyKHMsIHMsIG9TZXR0aW5ncyk7XG5cdH1cblxuXHRfaW5pdFZpZXdzKCkge1xuXHRcdC8vXHRtZXNoXG5cdFx0dGhpcy5tZXNoID0gYWxmcmlkLkdlb20uYmlnVHJpYW5nbGUoKTtcblxuXHRcdGNvbnN0IHZzVHJpID0gYWxmcmlkLlNoYWRlckxpYnMuYmlnVHJpYW5nbGVWZXJ0O1xuXG5cdFx0Ly8gXHRzaGFkZXJzIC0gdGhyZXNob2xkXG5cdFx0dGhpcy5zaGFkZXJUaHJlc2hvbGQgPSBuZXcgYWxmcmlkLkdMU2hhZGVyKHZzVHJpLCBmc1RyZXNob2xkKTtcblx0XHR0aGlzLnVuaWZvcm1zVGhyZXNob2xkID0ge1xuXHRcdFx0bHVtaW5vc2l0eVRocmVzaG9sZDowLjUsXG5cdFx0XHRzbW9vdGhXaWR0aDowLjAxLFxuXHRcdFx0ZGVmYXVsdE9wYWNpdHk6MCxcblx0XHRcdGRlZmF1bHRDb2xvcjpbMCwgMCwgMF1cblx0XHR9XG5cblx0XHR0aGlzLnNoYWRlclRocmVzaG9sZC5iaW5kKCk7XG5cdFx0dGhpcy5zaGFkZXJUaHJlc2hvbGQudW5pZm9ybShcInRleHR1cmVcIiwgXCJ1bmlmb3JtMWlcIiwgMCk7XG5cdFx0dGhpcy5zaGFkZXJUaHJlc2hvbGQudW5pZm9ybSh0aGlzLnVuaWZvcm1zVGhyZXNob2xkKTtcblxuXHRcdC8vXHRzaGFkZXJzIC0gbWlwIGJsb29tXG5cdFx0Y29uc3Qga2VybmVsU2l6ZUFycmF5ID0gWzMsIDUsIDcsIDksIDExXTtcblx0XHRsZXQgd2lkdGggPSBNYXRoLnJvdW5kKEdMLndpZHRoKnRoaXMuX3N0YXJ0aW5nU2NhbGUpO1xuXHRcdGxldCBoZWlnaHQgPSBNYXRoLnJvdW5kKEdMLmhlaWdodCp0aGlzLl9zdGFydGluZ1NjYWxlKTtcblxuXHRcdHRoaXMuX3NoYWRlcnNCbG9vbSA9IFtdO1xuXHRcdGZvcihsZXQgaT0wOyBpPHRoaXMuX251bU1pcHM7IGkrKykge1xuXHRcdFx0bGV0IGtlcm5lbFNpemUgPSBrZXJuZWxTaXplQXJyYXlbaV07XG5cdFx0XHRsZXQgZnMgPSBmc0Jsb29tLnJlcGxhY2UoL1xcJHtrZXJuZWxSYWRpdXN9L2csIGtlcm5lbFNpemUpO1xuXHRcdFx0Y29uc3Qgc2hhZGVyID0gbmV3IGFsZnJpZC5HTFNoYWRlcih2c1RyaSwgZnMpO1xuXHRcdFx0c2hhZGVyLmJpbmQoKTtcblx0XHRcdHNoYWRlci51bmlmb3JtKFwidGV4U2l6ZVwiLCBcInZlYzJcIiwgW3dpZHRoLCBoZWlnaHRdKTtcblx0XHRcdHRoaXMuX3NoYWRlcnNCbG9vbS5wdXNoKHNoYWRlcik7XG5cblx0XHRcdHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aC8yKTtcblx0XHRcdGhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0LzIpO1xuXHRcdH1cblxuXHRcdC8vXHRzaGFkZXIgLSBjb21wb3NlXG5cblx0XHR0aGlzLnVuaWZvcm1zQ29tcG9zZSA9IHtcblx0XHRcdGJsb29tU3RyZW5ndGg6MS4sXG5cdFx0XHRibG9vbVJhZGl1czowLjRcblx0XHR9XG5cblx0XHRsZXQgZnMgPSBmc0NvbXBvc2UucmVwbGFjZSgvXFwke05VTV9NSVBTfS9nLCB0aGlzLl9udW1NaXBzKTtcblxuXHRcdGxldCBzdHJCbG9vbSA9ICcnO1xuXHRcdGZvcihsZXQgaT0wOyBpPHRoaXMuX251bU1pcHM7IGkrKykge1xuXHRcdFx0c3RyQmxvb20gKz0gYFxcdGNvbG9yICs9IGxlcnBCbG9vbUZhY3RvcihibG9vbVRpbnRDb2xvcnNbJHtpfV0uYSkgKiB2ZWM0KGJsb29tVGludENvbG9yc1ske2l9XS5yZ2IsIDEuMCkgKiB0ZXh0dXJlMkQoYmx1clRleHR1cmUke2krMX0sIHZUZXh0dXJlQ29vcmQpO2A7XG5cdFx0fVxuXG5cdFx0ZnMgPSBmcy5yZXBsYWNlKC9cXCR7QkxPT01TfS9nLCBzdHJCbG9vbSk7XG5cblx0XHRsZXQgdGludENvbG9yID0gW107XG5cdFx0dGhpcy5zaGFkZXJDb21wb3NlID0gbmV3IGFsZnJpZC5HTFNoYWRlcih2c1RyaSwgZnMpO1xuXHRcdHRoaXMuc2hhZGVyQ29tcG9zZS5iaW5kKCk7XG5cdFx0Zm9yKGxldCBpPTA7IGk8dGhpcy5fbnVtTWlwczsgaSsrKSB7XG5cdFx0XHR0aGlzLnNoYWRlckNvbXBvc2UudW5pZm9ybShgYmx1clRleHR1cmUke2krMX1gLCBcInVuaWZvcm0xaVwiLCBpKTtcblx0XHRcdHRpbnRDb2xvciA9IHRpbnRDb2xvci5jb25jYXQoWzEsIDEsIDEsIDEuMC0wLjIqaV0pO1xuXHRcdH1cblxuXHRcdHRoaXMuc2hhZGVyQ29tcG9zZS51bmlmb3JtKCdibG9vbVRpbnRDb2xvcnMnLCAndmVjNCcsIHRpbnRDb2xvcik7XG5cdFx0dGhpcy5zaGFkZXJDb21wb3NlLnVuaWZvcm0odGhpcy51bmlmb3Jtc0NvbXBvc2UpO1xuXHR9XG5cblx0cmVuZGVyKHRleHR1cmUpIHtcblx0XHR0aGlzLl9mYm9UaHJlc2hvbGQuYmluZCgpO1xuXHRcdEdMLmNsZWFyKDAsIDAsIDAsIDApO1xuXHRcdHRoaXMuc2hhZGVyVGhyZXNob2xkLmJpbmQoKTtcblx0XHRcblx0XHR0aGlzLnNoYWRlclRocmVzaG9sZC51bmlmb3JtKHRoaXMudW5pZm9ybXNUaHJlc2hvbGQpO1xuXHRcdHRleHR1cmUuYmluZCgwKTtcblx0XHRHTC5kcmF3KHRoaXMubWVzaCk7XG5cdFx0dGhpcy5fZmJvVGhyZXNob2xkLnVuYmluZCgpO1xuXG5cdFx0bGV0IGlucHV0VGV4dHVyZSA9IHRoaXMuX2Zib1RocmVzaG9sZC5nZXRUZXh0dXJlKCk7XG5cblx0XHRmb3IobGV0IGk9MDsgaTx0aGlzLl9udW1NaXBzOyBpKyspIHtcblx0XHRcdGNvbnN0IHtmYm9WLCBmYm9IfSA9IHRoaXMuX2Zib3NbaV07XG5cdFx0XHRjb25zdCBzaGFkZXIgPSB0aGlzLl9zaGFkZXJzQmxvb21baV07XG5cblx0XHRcdHNoYWRlci5iaW5kKCk7XG5cdFx0XHRzaGFkZXIudW5pZm9ybShcInRleHR1cmVcIiwgXCJ1bmlmb3JtMWlcIiwgMCk7XG5cblx0XHRcdC8vXHRibG9vbSBWXG5cdFx0XHRmYm9WLmJpbmQoKTtcblx0XHRcdEdMLmNsZWFyKDAsIDAsIDAsIDApO1xuXHRcdFx0c2hhZGVyLnVuaWZvcm0oXCJkaXJlY3Rpb25cIiwgXCJ2ZWMyXCIsIFswLCAxXSk7XG5cdFx0XHRpbnB1dFRleHR1cmUuYmluZCgwKTtcblx0XHRcdEdMLmRyYXcodGhpcy5tZXNoKTtcblx0XHRcdGZib1YudW5iaW5kKCk7XG5cblx0XHRcdC8vXHRibG9vbSBIXG5cdFx0XHRmYm9ILmJpbmQoKTtcblx0XHRcdEdMLmNsZWFyKDAsIDAsIDAsIDApO1xuXHRcdFx0c2hhZGVyLnVuaWZvcm0oXCJkaXJlY3Rpb25cIiwgXCJ2ZWMyXCIsIFsxLCAwXSk7XG5cdFx0XHRmYm9WLmdldFRleHR1cmUoKS5iaW5kKDApO1xuXHRcdFx0R0wuZHJhdyh0aGlzLm1lc2gpO1xuXHRcdFx0ZmJvSC51bmJpbmQoKTtcblxuXHRcdFx0aW5wdXRUZXh0dXJlID0gZmJvSC5nZXRUZXh0dXJlKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmJvQ29tcG9zZS5iaW5kKCk7XG5cdFx0R0wuY2xlYXIoMCwgMCwgMCwgMCk7XG5cdFx0dGhpcy5zaGFkZXJDb21wb3NlLmJpbmQoKTtcblx0XHRmb3IobGV0IGk9MDsgaTx0aGlzLl9udW1NaXBzOyBpKyspIHtcblx0XHRcdGNvbnN0IHsgZmJvSCB9ID0gdGhpcy5fZmJvc1tpXTtcblx0XHRcdGZib0guZ2V0VGV4dHVyZSgpLmJpbmQoaSk7XG5cdFx0fVxuXHRcdHRoaXMuc2hhZGVyQ29tcG9zZS51bmlmb3JtKHRoaXMudW5pZm9ybXNDb21wb3NlKTtcblx0XHRHTC5kcmF3KHRoaXMubWVzaCk7XG5cdFx0dGhpcy5fZmJvQ29tcG9zZS51bmJpbmQoKTtcblx0fVxuXG5cdGdldCBmYm9zKCkge1xuXHRcdHJldHVybiB0aGlzLl9mYm9zO1xuXHR9XG5cblx0Z2V0VGV4dHVyZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZmJvQ29tcG9zZS5nZXRUZXh0dXJlKCk7XG5cdH1cblxuXHRyZXNpemUoKSB7XG5cdFx0XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFzc0Jsb29tO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9QYXNzQmxvb20uanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gY29weS5mcmFnXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBTSU1QTEVfVEVYVFVSRVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XFxudW5pZm9ybSB2ZWMzIGRlZmF1bHRDb2xvcjtcXG51bmlmb3JtIGZsb2F0IGRlZmF1bHRPcGFjaXR5O1xcbnVuaWZvcm0gZmxvYXQgbHVtaW5vc2l0eVRocmVzaG9sZDtcXG51bmlmb3JtIGZsb2F0IHNtb290aFdpZHRoO1xcblxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFxuXFx0dmVjNCB0ZXhlbCAgICAgICA9IHRleHR1cmUyRCggdGV4dHVyZSwgdlRleHR1cmVDb29yZCApO1xcblxcdFxcblxcdHZlYzMgbHVtYSAgICAgICAgPSB2ZWMzKCAwLjI5OSwgMC41ODcsIDAuMTE0ICk7XFxuXFx0ZmxvYXQgdiAgICAgICAgICA9IGRvdCggdGV4ZWwueHl6LCBsdW1hICk7XFxuXFx0dmVjNCBvdXRwdXRDb2xvciA9IHZlYzQoIGRlZmF1bHRDb2xvci5yZ2IsIGRlZmF1bHRPcGFjaXR5ICk7XFxuXFx0ZmxvYXQgYWxwaGEgICAgICA9IHNtb290aHN0ZXAoIGx1bWlub3NpdHlUaHJlc2hvbGQsIGx1bWlub3NpdHlUaHJlc2hvbGQgKyBzbW9vdGhXaWR0aCwgdiApO1xcblxcblxcdGdsX0ZyYWdDb2xvciA9IG1peCggb3V0cHV0Q29sb3IsIHRleGVsLCBhbHBoYSApO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NoYWRlcnMvdGhyZXNob2xkLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBibG9vbS5mcmFnXFxuXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuI2RlZmluZSBLRVJORUxfUkFESVVTICR7a2VybmVsUmFkaXVzfVxcbiNkZWZpbmUgU0lHTUEgJHtrZXJuZWxSYWRpdXN9XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG51bmlmb3JtIHZlYzIgdGV4U2l6ZTtcXG51bmlmb3JtIHZlYzIgZGlyZWN0aW9uO1xcblxcbmZsb2F0IGdhdXNzaWFuUGRmKGluIGZsb2F0IHgsIGluIGZsb2F0IHNpZ21hKSB7XFxuXFx0cmV0dXJuIDAuMzk4OTQgKiBleHAoIC0wLjUgKiB4ICogeC8oIHNpZ21hICogc2lnbWEpKS9zaWdtYTtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcblxcdHZlYzIgaW52U2l6ZSA9IDEuMCAvIHRleFNpemU7XFxuXFx0ZmxvYXQgZlNpZ21hID0gZmxvYXQoU0lHTUEpO1xcblxcdGZsb2F0IHdlaWdodFN1bSA9IGdhdXNzaWFuUGRmKDAuMCwgZlNpZ21hKTtcXG5cXHR2ZWMzIGRpZmZ1c2VTdW0gPSB0ZXh0dXJlMkQoIHRleHR1cmUsIHZUZXh0dXJlQ29vcmQpLnJnYiAqIHdlaWdodFN1bTtcXG5cXHRmb3IoIGludCBpID0gMTsgaSA8IEtFUk5FTF9SQURJVVM7IGkgKysgKSB7XFxuXFx0XFx0ZmxvYXQgeCA9IGZsb2F0KGkpO1xcblxcdFxcdGZsb2F0IHcgPSBnYXVzc2lhblBkZih4LCBmU2lnbWEpO1xcblxcdFxcdHZlYzIgdXZPZmZzZXQgPSBkaXJlY3Rpb24gKiBpbnZTaXplICogeDtcXG5cXHRcXHR2ZWMzIHNhbXBsZTEgPSB0ZXh0dXJlMkQoIHRleHR1cmUsIHZUZXh0dXJlQ29vcmQgKyB1dk9mZnNldCkucmdiO1xcblxcdFxcdHZlYzMgc2FtcGxlMiA9IHRleHR1cmUyRCggdGV4dHVyZSwgdlRleHR1cmVDb29yZCAtIHV2T2Zmc2V0KS5yZ2I7XFxuXFx0XFx0ZGlmZnVzZVN1bSArPSAoc2FtcGxlMSArIHNhbXBsZTIpICogdztcXG5cXHRcXHR3ZWlnaHRTdW0gKz0gMi4wICogdztcXG5cXHR9XFxuXFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChkaWZmdXNlU3VtL3dlaWdodFN1bSwgMS4wKTtcXG5cXHQvLyBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleHR1cmVDb29yZCk7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2hhZGVycy9ibG9vbS5mcmFnXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gY29weS5mcmFnXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBTSU1QTEVfVEVYVFVSRVxcblxcbiNkZWZpbmUgTlVNX01JUFMgJHtOVU1fTUlQU31cXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCBibHVyVGV4dHVyZTE7XFxudW5pZm9ybSBzYW1wbGVyMkQgYmx1clRleHR1cmUyO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGJsdXJUZXh0dXJlMztcXG51bmlmb3JtIHNhbXBsZXIyRCBibHVyVGV4dHVyZTQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgYmx1clRleHR1cmU1O1xcblxcbnVuaWZvcm0gZmxvYXQgYmxvb21TdHJlbmd0aDtcXG51bmlmb3JtIGZsb2F0IGJsb29tUmFkaXVzO1xcbnVuaWZvcm0gdmVjNCBibG9vbVRpbnRDb2xvcnNbTlVNX01JUFNdO1xcblxcbmZsb2F0IGxlcnBCbG9vbUZhY3Rvcihjb25zdCBpbiBmbG9hdCBmYWN0b3IpIHsgXFxuXFx0ZmxvYXQgbWlycm9yRmFjdG9yID0gMS4yIC0gZmFjdG9yO1xcblxcdHJldHVybiBtaXgoZmFjdG9yLCBtaXJyb3JGYWN0b3IsIGJsb29tUmFkaXVzKTtcXG59XFxuXFxudmVjNCBnZXRCbG9vbSgpIHtcXG5cXHR2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcblxcdCR7QkxPT01TfVxcblxcdHJldHVybiBjb2xvcjtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IGJsb29tU3RyZW5ndGggKiBnZXRCbG9vbSgpO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NoYWRlcnMvYmxvb21Db21wb3NlLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFNvdW5kTWFuYWdlci5qc1xuaW1wb3J0IHNvbm8gZnJvbSAnbGlicy9zb25vJztcblxuY2xhc3MgU291bmRNYW5hZ2VyIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5faGFzU3RhcnRlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fYnRuID0gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKCcuYXVkaW8tdG9nZ2xlJyk7XG5cdFx0dGhpcy5fYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCk9PnRoaXMudG9nZ2xlKCkpO1xuXHR9XG5cblxuXHRmYWRlT3V0KCkge1xuXG5cdH1cblxuXG5cdGZhc2VJbigpIHtcblxuXHR9XG5cblxuXHR0b2dnbGUoKSB7XG5cdFx0Y29uc29sZS5sb2coJ1RvZ2dsZSBtdXNpYycpO1xuXG5cdFx0aWYoIXRoaXMuX2hhc1N0YXJ0ZWQpIHtcblx0XHRcdHRoaXMuX3NvdW5kID0gc29uby5jcmVhdGVTb3VuZCh7XG5cdFx0XHRcdHNyYzonLi9hc3NldHMvYXVkaW8vbXVzaWMubXAzJyxcblx0XHRcdFx0bG9vcDogdHJ1ZSxcblx0XHRcdFx0dm9sdW1lOiAwLjI1XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuX2hhc1N0YXJ0ZWQgPSB0cnVlO1xuXHRcdH0gXG5cblx0XHRpZih0aGlzLl9pc1BsYXlpbmcpIHtcblx0XHRcdHRoaXMuX3NvdW5kLnBhdXNlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3NvdW5kLnBsYXkoKTtcblx0XHR9XG5cblx0XHRpZih0aGlzLl9idG4uY2xhc3NMaXN0LmNvbnRhaW5zKCdpc1NvdW5kT24nKSkge1xuXHRcdFx0dGhpcy5fYnRuLmNsYXNzTGlzdC5yZW1vdmUoJ2lzU291bmRPbicpO1xuXHRcdH1cblx0XHR0aGlzLl9idG4uY2xhc3NcblxuXHRcdHRoaXMuX2lzUGxheWluZyA9ICF0aGlzLl9pc1BsYXlpbmc7XG5cdFx0aWYodGhpcy5faXNQbGF5aW5nKSB7XG5cdFx0XHR0aGlzLl9idG4uY2xhc3NMaXN0LmFkZCgnaXNTb3VuZE9uJyk7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBTb3VuZE1hbmFnZXIoKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvU291bmRNYW5hZ2VyLmpzIiwiIWZ1bmN0aW9uKGUsbil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9bigpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUobik6ZS5zb25vPW4oKX0odGhpcyxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUoZSl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUpcmV0dXJuXCJcIjtpZihcImRhdGE6XCI9PT1lLnNsaWNlKDAsNSkpe3ZhciBuPWUubWF0Y2goL2RhdGE6YXVkaW9cXC8ob2dnfG1wM3xvcHVzfHdhdnxtNGEpL2kpO2lmKG4mJm4ubGVuZ3RoPjEpcmV0dXJuIG5bMV0udG9Mb3dlckNhc2UoKX1lPWUuc3BsaXQoXCI/XCIpWzBdLGU9ZS5zbGljZShlLmxhc3RJbmRleE9mKFwiL1wiKSsxKTt2YXIgdD1lLnNwbGl0KFwiLlwiKTtyZXR1cm4gMT09PXQubGVuZ3RofHxcIlwiPT09dFswXSYmMj09PXQubGVuZ3RoP1wiXCI6dC5wb3AoKS50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIG4obil7dmFyIHQ9dm9pZCAwO2lmKEFycmF5LmlzQXJyYXkobikpZm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspe3Q9bltyXTt2YXIgbz1lKHQpO2lmKG5lLmluZGV4T2Yobyk+LTEpYnJlYWt9ZWxzZVwib2JqZWN0XCI9PT0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIG4/XCJ1bmRlZmluZWRcIjpKKG4pKSYmT2JqZWN0LmtleXMobikuc29tZShmdW5jdGlvbihyKXt0PW5bcl07dmFyIG89ZSh0KTtyZXR1cm4gbmUuaW5kZXhPZihvKT4tMX0pO3JldHVybiB0fHxufWZ1bmN0aW9uIHQoZSl7cmV0dXJuISEoZSYmd2luZG93LkF1ZGlvQnVmZmVyJiZlIGluc3RhbmNlb2Ygd2luZG93LkF1ZGlvQnVmZmVyKX1mdW5jdGlvbiByKGUpe3JldHVybiEhKGUmJndpbmRvdy5BcnJheUJ1ZmZlciYmZSBpbnN0YW5jZW9mIHdpbmRvdy5BcnJheUJ1ZmZlcil9ZnVuY3Rpb24gbyhlKXtyZXR1cm4hIShlJiZ3aW5kb3cuSFRNTE1lZGlhRWxlbWVudCYmZSBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MTWVkaWFFbGVtZW50KX1mdW5jdGlvbiBpKGUpe3JldHVybiEhKGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZ2V0QXVkaW9UcmFja3MmJmUuZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGgmJndpbmRvdy5NZWRpYVN0cmVhbVRyYWNrJiZlLmdldEF1ZGlvVHJhY2tzKClbMF1pbnN0YW5jZW9mIHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrKX1mdW5jdGlvbiB1KGUpe3JldHVybiEoIWV8fFwic3RyaW5nXCIhPXR5cGVvZiBlfHxcInNpbmVcIiE9PWUmJlwic3F1YXJlXCIhPT1lJiZcInNhd3Rvb3RoXCIhPT1lJiZcInRyaWFuZ2xlXCIhPT1lKX1mdW5jdGlvbiBhKGUpe3JldHVybiEhKGUmJlwib2JqZWN0XCI9PT0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIGU/XCJ1bmRlZmluZWRcIjpKKGUpKSYmZS5idWZmZXJTaXplJiZlLmNoYW5uZWxzJiZlLmNhbGxiYWNrKX1mdW5jdGlvbiBjKGUpe3JldHVybiEoIWV8fFwic3RyaW5nXCIhPXR5cGVvZiBlfHwhKGUuaW5kZXhPZihcIi5cIik+LTF8fFwiZGF0YTpcIj09PWUuc2xpY2UoMCw1KSkpfWZ1bmN0aW9uIHMoZSl7aWYoIWV8fG8oZSkpcmV0dXJuITE7dmFyIG49ZS5zcmN8fGUudXJsfHxlLmRhdGF8fGU7cmV0dXJuIGMobil8fHIobil8fEFycmF5LmlzQXJyYXkobikmJmMoblswXSl9ZnVuY3Rpb24gZihlLG4pe2Z1bmN0aW9uIHQoZSl7dmFyIG49MTIqKE1hdGgubG9nKGUvNDQwKS9NYXRoLmxvZygyKSk7cmV0dXJuIE1hdGgucm91bmQobikrNjl9ZnVuY3Rpb24gcihlKXtyZXR1cm4gNDQwKk1hdGgucG93KDIsKGUtNjkpLzEyKX1mdW5jdGlvbiBvKGUsbil7cmV0dXJuIE1hdGguZmxvb3IoMTIwMCpNYXRoLmxvZyhlL3IobikpL01hdGgubG9nKDIpKX1mdW5jdGlvbiBpKGUsbil7cmV0dXJuIWV8fChhLmZmdFNpemUhPT1jfHwoISEobiYmZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpfHwhbiYmZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpfWZ1bmN0aW9uIHUoZSxuKXtyZXR1cm4gZT9uZXcgRmxvYXQzMkFycmF5KG4pOm5ldyBVaW50OEFycmF5KG4pfW49bnx8e307dmFyIGE9ZS5jcmVhdGVBbmFseXNlcigpLGM9bi5mZnRTaXplfHw1MTIscz0hIW4uZmxvYXQsZj0hIW4uZmxvYXQsbD12b2lkIDAsZD12b2lkIDA7YS5mZnRTaXplPWMsYS5zbW9vdGhpbmdUaW1lQ29uc3RhbnQ9bi5zbW9vdGhpbmd8fG4uc21vb3RoaW5nVGltZUNvbnN0YW50fHxhLnNtb290aGluZ1RpbWVDb25zdGFudCxhLm1pbkRlY2liZWxzPW4ubWluRGVjaWJlbHN8fGEubWluRGVjaWJlbHMsYS5tYXhEZWNpYmVscz1uLm1heERlY2liZWxzfHxhLm1heERlY2liZWxzO3ZhciB2PW5ldyBCbG9iKFtcIm9ubWVzc2FnZT1mdW5jdGlvbihlKXt2YXIgZGF0YT1lLmRhdGE7dmFyIGY9bmV3IEZsb2F0MzJBcnJheShkYXRhLmIpO2Zvcih2YXIgaT0wO2k8Zi5sZW5ndGg7aSsrKXtkYXRhLnN1bSs9ZltpXX1kYXRhLnN1bS89Zi5sZW5ndGg7cG9zdE1lc3NhZ2UoTWF0aC5tYXgoMS4wLShkYXRhLnN1bS9kYXRhLm51bVNhbXBsZXMqLTEuMCksMCkpfTtcIl0pLHA9bmV3IEJsb2IoW1wib25tZXNzYWdlPWZ1bmN0aW9uKGUpe3ZhciBkYXRhPWUuZGF0YTt2YXIgc2FtcGxlUmF0ZT1kYXRhLnNhbXBsZVJhdGU7dmFyIGJ1Zj1uZXcgRmxvYXQzMkFycmF5KGRhdGEuYik7dmFyIFNJWkU9YnVmLmxlbmd0aDt2YXIgTUFYX1NBTVBMRVM9TWF0aC5mbG9vcihTSVpFLzIpO3ZhciBiZXN0X29mZnNldD0tMTt2YXIgYmVzdF9jb3JyZWxhdGlvbj0wO3ZhciBybXM9MDt2YXIgZm91bmRHb29kQ29ycmVsYXRpb249ZmFsc2U7dmFyIGNvcnJlbGF0aW9ucz1uZXcgQXJyYXkoTUFYX1NBTVBMRVMpO2Zvcih2YXIgaT0wO2k8U0laRTtpKyspe3ZhciB2YWw9YnVmW2ldO3Jtcys9dmFsKnZhbH1ybXM9TWF0aC5zcXJ0KHJtcy9TSVpFKTtpZiAocm1zPDAuMDEpe3Bvc3RNZXNzYWdlKC0xKX1lbHNle3ZhciBsYXN0Q29ycmVsYXRpb249MTtmb3IodmFyIG9mZnNldD0wO29mZnNldDxNQVhfU0FNUExFUztvZmZzZXQrKyl7dmFyIGNvcnJlbGF0aW9uPTA7Zm9yKHZhciBpPTA7aTxNQVhfU0FNUExFUztpKyspe2NvcnJlbGF0aW9uKz1NYXRoLmFicygoYnVmW2ldKS0oYnVmW2krb2Zmc2V0XSkpfWNvcnJlbGF0aW9uPTEtKGNvcnJlbGF0aW9uL01BWF9TQU1QTEVTKTtjb3JyZWxhdGlvbnNbb2Zmc2V0XT1jb3JyZWxhdGlvbjtpZiAoKGNvcnJlbGF0aW9uPjAuOSkmJihjb3JyZWxhdGlvbj5sYXN0Q29ycmVsYXRpb24pKXtmb3VuZEdvb2RDb3JyZWxhdGlvbj10cnVlO2lmIChjb3JyZWxhdGlvbj5iZXN0X2NvcnJlbGF0aW9uKXtiZXN0X2NvcnJlbGF0aW9uPWNvcnJlbGF0aW9uO2Jlc3Rfb2Zmc2V0PW9mZnNldH19ZWxzZSBpZiAoZm91bmRHb29kQ29ycmVsYXRpb24pe3ZhciBzaGlmdD0oY29ycmVsYXRpb25zW2Jlc3Rfb2Zmc2V0KzFdLWNvcnJlbGF0aW9uc1tiZXN0X29mZnNldC0xXSkvY29ycmVsYXRpb25zW2Jlc3Rfb2Zmc2V0XTtwb3N0TWVzc2FnZShzYW1wbGVSYXRlLyhiZXN0X29mZnNldCsoOCpzaGlmdCkpKX1sYXN0Q29ycmVsYXRpb249Y29ycmVsYXRpb259aWYgKGJlc3RfY29ycmVsYXRpb24+MC4wMSl7cG9zdE1lc3NhZ2Uoc2FtcGxlUmF0ZS9iZXN0X29mZnNldCl9ZWxzZXtwb3N0TWVzc2FnZSgtMSl9fX07XCJdKSxnPVVSTC5jcmVhdGVPYmplY3RVUkwodiksaD1uZXcgV29ya2VyKGcpLG09VVJMLmNyZWF0ZU9iamVjdFVSTChwKSx5PW5ldyBXb3JrZXIobSksYj1udWxsLHc9W1wiQ1wiLFwiQyNcIixcIkRcIixcIkQjXCIsXCJFXCIsXCJGXCIsXCJGI1wiLFwiR1wiLFwiRyNcIixcIkFcIixcIkEjXCIsXCJCXCJdLFQ9bnVsbCxNPXtoZXJ0ejpudWxsLG5vdGU6bnVsbCxub3RlSW5kZXg6bnVsbCxkZXR1bmVDZW50czpudWxsLGRldHVuZTpudWxsfTtyZXR1cm4gaC5vbm1lc3NhZ2U9ZnVuY3Rpb24oZSl7YiYmYihlLmRhdGEpfSx5Lm9ubWVzc2FnZT1mdW5jdGlvbihlKXtpZihUKXt2YXIgbj1lLmRhdGE7aWYobiE9PS0xKXt2YXIgcj10KG4pLGk9byhuLHIpO00uaGVydHo9bixNLm5vdGVJbmRleD1yJTEyLE0ubm90ZT13W3IlMTJdLE0uZGV0dW5lQ2VudHM9aSwwPT09aT9NLmRldHVuZT1cIlwiOmk8MD9NLmRldHVuZT1cImZsYXRcIjpNLmRldHVuZT1cInNoYXJwXCJ9VChNKX19LGEuZ2V0V2F2ZWZvcm09ZnVuY3Rpb24oZSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGh8fChlPWYpLGkobCxlKSYmKGM9YS5mZnRTaXplLGY9ZSxsPXUoZSxjKSksZSYmdGhpcy5nZXRGbG9hdFRpbWVEb21haW5EYXRhP3RoaXMuZ2V0RmxvYXRUaW1lRG9tYWluRGF0YShsKTp0aGlzLmdldEJ5dGVUaW1lRG9tYWluRGF0YShsKSxsfSxhLmdldFBpdGNoPWZ1bmN0aW9uKG4pe1Q9VHx8bjt2YXIgdD1uZXcgRmxvYXQzMkFycmF5KGEuZmZ0U2l6ZSk7dC5zZXQoYS5nZXRXYXZlZm9ybSghMCkpLHkucG9zdE1lc3NhZ2Uoe3NhbXBsZVJhdGU6ZS5zYW1wbGVSYXRlLGI6dC5idWZmZXJ9LFt0LmJ1ZmZlcl0pfSxhLmdldEZyZXF1ZW5jaWVzPWZ1bmN0aW9uKGUpe3JldHVybiBhcmd1bWVudHMubGVuZ3RofHwoZT1zKSxpKGQsZSkmJihjPWEuZmZ0U2l6ZSxzPWUsZD11KGUsYS5mcmVxdWVuY3lCaW5Db3VudCkpLGU/dGhpcy5nZXRGbG9hdEZyZXF1ZW5jeURhdGEoZCk6dGhpcy5nZXRCeXRlRnJlcXVlbmN5RGF0YShkKSxkfSxhLmdldEFtcGxpdHVkZT1mdW5jdGlvbihlKXtiPWJ8fGU7dmFyIG49bmV3IEZsb2F0MzJBcnJheShhLmZmdFNpemUpO24uc2V0KGEuZ2V0RnJlcXVlbmNpZXMoITApKSxoLnBvc3RNZXNzYWdlKHtzdW06MCxsZW5ndGg6bi5ieXRlTGVuZ3RoLG51bVNhbXBsZXM6YS5mZnRTaXplLzIsYjpuLmJ1ZmZlcn0sW24uYnVmZmVyXSl9LGEudXBkYXRlPWZ1bmN0aW9uKCl7YS5nZXRXYXZlZm9ybSgpLGEuZ2V0RnJlcXVlbmNpZXMoKX0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYSx7c21vb3RoaW5nOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYS5zbW9vdGhpbmdUaW1lQ29uc3RhbnR9LHNldDpmdW5jdGlvbihlKXthLnNtb290aGluZ1RpbWVDb25zdGFudD1lfX19KSxhfWZ1bmN0aW9uIGwoZSxuKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aDwyJiYobj0wKSxcIm51bWJlclwiIT10eXBlb2YgZXx8aXNOYU4oZSk/bjplfWZ1bmN0aW9uIGQoZSxuKXtuPWwobiwxKTt2YXIgdD1lLmNyZWF0ZVdhdmVTaGFwZXIoKSxyPW5ldyBGbG9hdDMyQXJyYXkodWUpO3JldHVybiB0LnVwZGF0ZT1mdW5jdGlvbihlKXtpZihuPWUsbjw9MClyZXR1cm4gbj0wLHZvaWQodGhpcy5jdXJ2ZT1udWxsKTtmb3IodmFyIHQ9MTAwKmUsbz1NYXRoLlBJLzE4MCxpPXZvaWQgMCx1PTA7dTx1ZTt1KyspaT0yKnUvdWUtMSxyW3VdPSgzK3QpKmkqMjAqby8oTWF0aC5QSSt0Kk1hdGguYWJzKGkpKTt0aGlzLmN1cnZlPXJ9LE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQse2Ftb3VudDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG59LHNldDpmdW5jdGlvbihlKXt0aGlzLnVwZGF0ZShlKX19fSksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG4mJnQudXBkYXRlKG4pLHR9ZnVuY3Rpb24gdihlLG4pe249bnx8e307dmFyIHQ9ZS5jcmVhdGVHYWluKCkscj1lLmNyZWF0ZURlbGF5KCksbz1lLmNyZWF0ZUdhaW4oKSxpPWUuY3JlYXRlR2FpbigpO3IuZGVsYXlUaW1lLnZhbHVlPWwobi5kZWxheVRpbWUsLjUpLG8uZ2Fpbi52YWx1ZT1sKG4uZmVlZGJhY2ssLjUpLHQuY29ubmVjdChyKSx0LmNvbm5lY3QoaSksci5jb25uZWN0KG8pLG8uY29ubmVjdChyKSxvLmNvbm5lY3QoaSk7dmFyIHU9dDtyZXR1cm4gdS5uYW1lPVwiRWNob1wiLHUuX291dHB1dD1pLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHUse2RlbGF5OntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gci5kZWxheVRpbWUudmFsdWV9LHNldDpmdW5jdGlvbihlKXtyLmRlbGF5VGltZS52YWx1ZT1lfX0sZmVlZGJhY2s6e2dldDpmdW5jdGlvbigpe3JldHVybiBvLmdhaW4udmFsdWV9LHNldDpmdW5jdGlvbihlKXtvLmdhaW4udmFsdWU9ZX19fSksdX1mdW5jdGlvbiBwKCl7ZnVuY3Rpb24gZSgpe31mdW5jdGlvbiBuKCl7cmV0dXJue3ZhbHVlOjEsZGVmYXVsdFZhbHVlOjEsbGluZWFyUmFtcFRvVmFsdWVBdFRpbWU6ZSxzZXRWYWx1ZUF0VGltZTplLGV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWU6ZSxzZXRUYXJnZXRBdFRpbWU6ZSxzZXRWYWx1ZUN1cnZlQXRUaW1lOmUsY2FuY2VsU2NoZWR1bGVkVmFsdWVzOmV9fWZ1bmN0aW9uIHQoKXtyZXR1cm57Y29ubmVjdDplLGRpc2Nvbm5lY3Q6ZSxmcmVxdWVuY3lCaW5Db3VudDowLHNtb290aGluZ1RpbWVDb25zdGFudDowLGZmdFNpemU6MCxtaW5EZWNpYmVsczowLG1heERlY2liZWxzOjAsZ2V0Qnl0ZVRpbWVEb21haW5EYXRhOmUsZ2V0Qnl0ZUZyZXF1ZW5jeURhdGE6ZSxnZXRGbG9hdFRpbWVEb21haW5EYXRhOmUsZ2V0RmxvYXRGcmVxdWVuY3lEYXRhOmUsZ2FpbjpuKCkscGFubmluZ01vZGVsOjAsc2V0UG9zaXRpb246ZSxzZXRPcmllbnRhdGlvbjplLHNldFZlbG9jaXR5OmUsZGlzdGFuY2VNb2RlbDowLHJlZkRpc3RhbmNlOjAsbWF4RGlzdGFuY2U6MCxyb2xsb2ZmRmFjdG9yOjAsY29uZUlubmVyQW5nbGU6MzYwLGNvbmVPdXRlckFuZ2xlOjM2MCxjb25lT3V0ZXJHYWluOjAsdHlwZTowLGZyZXF1ZW5jeTpuKCksUTpuKCksZGV0dW5lOm4oKSxkZWxheVRpbWU6bigpLGJ1ZmZlcjowLHRocmVzaG9sZDpuKCksa25lZTpuKCkscmF0aW86bigpLGF0dGFjazpuKCkscmVsZWFzZTpuKCkscmVkdWN0aW9uOm4oKSxvdmVyc2FtcGxlOjAsY3VydmU6MCxzYW1wbGVSYXRlOjEsbGVuZ3RoOjAsZHVyYXRpb246MCxudW1iZXJPZkNoYW5uZWxzOjAsZ2V0Q2hhbm5lbERhdGE6ZnVuY3Rpb24oKXtyZXR1cm5bXX0sY29weUZyb21DaGFubmVsOmUsY29weVRvQ2hhbm5lbDplLGRvcHBsZXJGYWN0b3I6MCxzcGVlZE9mU291bmQ6MCxzdGFydDplfX12YXIgcj1EYXRlLm5vdygpO3JldHVybiB3aW5kb3cuVWludDhBcnJheXx8KHdpbmRvdy5VaW50OEFycmF5PXdpbmRvdy5GbG9hdDMyQXJyYXk9QXJyYXkpLHtjcmVhdGVBbmFseXNlcjp0LGNyZWF0ZUJ1ZmZlcjp0LGNyZWF0ZUJpcXVhZEZpbHRlcjp0LGNyZWF0ZUNoYW5uZWxNZXJnZXI6dCxjcmVhdGVDaGFubmVsU3BsaXR0ZXI6dCxjcmVhdGVEeW5hbWljc0NvbXByZXNzb3I6dCxjcmVhdGVDb252b2x2ZXI6dCxjcmVhdGVEZWxheTp0LGNyZWF0ZUdhaW46dCxjcmVhdGVPc2NpbGxhdG9yOnQsY3JlYXRlUGFubmVyOnQsY3JlYXRlU2NyaXB0UHJvY2Vzc29yOnQsY3JlYXRlV2F2ZVNoYXBlcjp0LGxpc3RlbmVyOnQoKSxnZXQgY3VycmVudFRpbWUoKXtyZXR1cm4oRGF0ZS5ub3coKS1yKS8xZTN9fX1mdW5jdGlvbiBnKGUpe2Z1bmN0aW9uIG4oZSl7dmFyIG49TWF0aC5sb2coby9yKS9NYXRoLkxOMix0PU1hdGgucG93KDIsbiooZS0xKSk7cmV0dXJuIG8qdH12YXIgdD1hcmd1bWVudHMubGVuZ3RoPD0xfHx2b2lkIDA9PT1hcmd1bWVudHNbMV0/e306YXJndW1lbnRzWzFdLHI9NDAsbz1lLnNhbXBsZVJhdGUvMixpPWUuY3JlYXRlQmlxdWFkRmlsdGVyKCk7cmV0dXJuIGkudHlwZT10LnR5cGUsaS5zZXQ9ZnVuY3Rpb24oZSxuLHQpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBlJiZcIm51bWJlclwiPT10eXBlb2YgZSYmKGkuZnJlcXVlbmN5LnZhbHVlPWUpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBuJiZcIm51bWJlclwiPT10eXBlb2YgbiYmKGkuUS52YWx1ZT1uKSxcInVuZGVmaW5lZFwiIT10eXBlb2YgdCYmXCJudW1iZXJcIj09dHlwZW9mIHQmJihpLmdhaW4udmFsdWU9dCksaX0saS5zZXRCeVBlcmNlbnQ9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBpLnNldChuKGUpLHQscil9LGkuc2V0KHQuZnJlcXVlbmN5LHQucSx0LmdhaW4pfWZ1bmN0aW9uIGgoZSxuKXt2YXIgdD1lLmNyZWF0ZUdhaW4oKSxyPWUuY3JlYXRlRGVsYXkoKSxvPWUuY3JlYXRlR2FpbigpLGk9ZS5jcmVhdGVPc2NpbGxhdG9yKCksdT1lLmNyZWF0ZUdhaW4oKSxhPWUuY3JlYXRlR2FpbigpO3IuZGVsYXlUaW1lLnZhbHVlPWwobi5kZWxheSwuMDA1KSxvLmdhaW4udmFsdWU9bChuLmZlZWRiYWNrLC41KSxpLnR5cGU9XCJzaW5lXCIsaS5mcmVxdWVuY3kudmFsdWU9bChuLmZyZXF1ZW5jeSwuMDAyKSx1LmdhaW4udmFsdWU9bChuLmdhaW4sLjI1KSx0LmNvbm5lY3QoYSksdC5jb25uZWN0KHIpLHIuY29ubmVjdChhKSxyLmNvbm5lY3Qobyksby5jb25uZWN0KHQpLGkuY29ubmVjdCh1KSx1LmNvbm5lY3Qoci5kZWxheVRpbWUpLGkuc3RhcnQoMCk7dmFyIGM9dDtyZXR1cm4gYy5uYW1lPVwiRmxhbmdlclwiLGMuX291dHB1dD1hLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGMse2RlbGF5OntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gci5kZWxheVRpbWUudmFsdWV9LHNldDpmdW5jdGlvbihlKXtyLmRlbGF5VGltZS52YWx1ZT1lfX0sbGZvRnJlcXVlbmN5OntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaS5mcmVxdWVuY3kudmFsdWV9LHNldDpmdW5jdGlvbihlKXtpLmZyZXF1ZW5jeS52YWx1ZT1lfX0sbGZvR2Fpbjp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHUuZ2Fpbi52YWx1ZX0sc2V0OmZ1bmN0aW9uKGUpe3UuZ2Fpbi52YWx1ZT1lfX0sZmVlZGJhY2s6e2dldDpmdW5jdGlvbigpe3JldHVybiBvLmdhaW4udmFsdWV9LHNldDpmdW5jdGlvbihlKXtvLmdhaW4udmFsdWU9ZX19fSksY31mdW5jdGlvbiBtKGUsbil7dmFyIHQ9ZS5jcmVhdGVHYWluKCkscj1lLmNyZWF0ZUNoYW5uZWxTcGxpdHRlcigyKSxvPWUuY3JlYXRlQ2hhbm5lbE1lcmdlcigyKSxpPWUuY3JlYXRlR2FpbigpLHU9ZS5jcmVhdGVHYWluKCksYT1lLmNyZWF0ZU9zY2lsbGF0b3IoKSxjPWUuY3JlYXRlR2FpbigpLHM9ZS5jcmVhdGVHYWluKCksZj1lLmNyZWF0ZURlbGF5KCksZD1lLmNyZWF0ZURlbGF5KCksdj1lLmNyZWF0ZUdhaW4oKTtpLmdhaW4udmFsdWU9dS5nYWluLnZhbHVlPWwobi5mZWVkYmFjaywuNSksZi5kZWxheVRpbWUudmFsdWU9ZC5kZWxheVRpbWUudmFsdWU9bChuLmRlbGF5LC4wMDMpLGEudHlwZT1cInNpbmVcIixhLmZyZXF1ZW5jeS52YWx1ZT1sKG4uZnJlcXVlbmN5LC41KSxjLmdhaW4udmFsdWU9bChuLmdhaW4sLjAwNSkscy5nYWluLnZhbHVlPTAtYy5nYWluLnZhbHVlLHQuY29ubmVjdChyKSxyLmNvbm5lY3QoZiwwKSxyLmNvbm5lY3QoZCwxKSxmLmNvbm5lY3QoaSksZC5jb25uZWN0KHUpLGkuY29ubmVjdChkKSx1LmNvbm5lY3QoZiksZi5jb25uZWN0KG8sMCwwKSxkLmNvbm5lY3QobywwLDEpLG8uY29ubmVjdCh2KSx0LmNvbm5lY3QodiksYS5jb25uZWN0KGMpLGEuY29ubmVjdChzKSxjLmNvbm5lY3QoZi5kZWxheVRpbWUpLHMuY29ubmVjdChkLmRlbGF5VGltZSksYS5zdGFydCgwKTt2YXIgcD10O3JldHVybiBwLm5hbWU9XCJTdGVyZW9GbGFuZ2VyXCIscC5fb3V0cHV0PXYsT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCx7ZGVsYXk6e2dldDpmdW5jdGlvbigpe3JldHVybiBmLmRlbGF5VGltZS52YWx1ZX0sc2V0OmZ1bmN0aW9uKGUpe2YuZGVsYXlUaW1lLnZhbHVlPWQuZGVsYXlUaW1lLnZhbHVlPWV9fSxsZm9GcmVxdWVuY3k6e2dldDpmdW5jdGlvbigpe3JldHVybiBhLmZyZXF1ZW5jeS52YWx1ZX0sc2V0OmZ1bmN0aW9uKGUpe2EuZnJlcXVlbmN5LnZhbHVlPWV9fSxsZm9HYWluOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5nYWluLnZhbHVlfSxzZXQ6ZnVuY3Rpb24oZSl7Yy5nYWluLnZhbHVlPXMuZ2Fpbi52YWx1ZT1lfX0sZmVlZGJhY2s6e2dldDpmdW5jdGlvbigpe3JldHVybiBpLmdhaW4udmFsdWV9LHNldDpmdW5jdGlvbihlKXtpLmdhaW4udmFsdWU9dS5nYWluLnZhbHVlPWV9fX0pLHB9ZnVuY3Rpb24geShlLG4pe3JldHVybiBuPW58fHt9LG4uc3RlcmVvP25ldyBtKGUsbik6bmV3IGgoZSxuKX1mdW5jdGlvbiBiKGUpe2Z1bmN0aW9uIG4oZSxuKXt2YXIgdD1lLngscj1lLnksbz1lLnosaT1uLngsdT1uLnksYT1uLno7ZS54PXIqYS1vKnUsZS55PW8qaS10KmEsZS56PXQqdS1yKml9ZnVuY3Rpb24gdChlKXtpZigwPT09ZS54JiYwPT09ZS55JiYwPT09ZS56KXJldHVybiBlO3ZhciBuPU1hdGguc3FydChlLngqZS54K2UueSplLnkrZS56KmUueiksdD0xL247cmV0dXJuIGUueCo9dCxlLnkqPXQsZS56Kj10LGV9ZnVuY3Rpb24gcihlLHIpe3ZhciBvPXUuZ2V0KHIueCxyLnksci56KTtuKG8sYSksbihvLHIpLHQobyksdChyKSxlLnNldE9yaWVudGF0aW9uKHIueCxyLnksci56LG8ueCxvLnksby56KSx1LmRpc3Bvc2UociksdS5kaXNwb3NlKG8pfWZ1bmN0aW9uIG8oZSxuKXtlLnNldFBvc2l0aW9uKG4ueCxuLnksbi56KSx1LmRpc3Bvc2Uobil9dmFyIGk9ZS5jcmVhdGVQYW5uZXIoKTtpLnBhbm5pbmdNb2RlbD1iLmRlZmF1bHRzLnBhbm5pbmdNb2RlbCxpLmRpc3RhbmNlTW9kZWw9Yi5kZWZhdWx0cy5kaXN0YW5jZU1vZGVsLGkucmVmRGlzdGFuY2U9Yi5kZWZhdWx0cy5yZWZEaXN0YW5jZSxpLm1heERpc3RhbmNlPWIuZGVmYXVsdHMubWF4RGlzdGFuY2UsaS5yb2xsb2ZmRmFjdG9yPWIuZGVmYXVsdHMucm9sbG9mZkZhY3RvcixpLmNvbmVJbm5lckFuZ2xlPWIuZGVmYXVsdHMuY29uZUlubmVyQW5nbGUsaS5jb25lT3V0ZXJBbmdsZT1iLmRlZmF1bHRzLmNvbmVPdXRlckFuZ2xlLGkuY29uZU91dGVyR2Fpbj1iLmRlZmF1bHRzLmNvbmVPdXRlckdhaW4saS5zZXRQb3NpdGlvbigwLDAsMSksaS5zZXRPcmllbnRhdGlvbigwLDAsMCk7dmFyIHU9e3Bvb2w6W10sZ2V0OmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzLnBvb2wubGVuZ3RoP3RoaXMucG9vbC5wb3AoKTp7eDowLHk6MCx6OjB9O3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBlJiZpc05hTihlKSYmXCJ4XCJpbiBlJiZcInlcImluIGUmJlwielwiaW4gZT8oci54PWwoZS54KSxyLnk9bChlLnkpLHIuej1sKGUueikpOihyLng9bChlKSxyLnk9bChuKSxyLno9bCh0KSkscn0sZGlzcG9zZTpmdW5jdGlvbihlKXt0aGlzLnBvb2wucHVzaChlKX19LGE9dS5nZXQoMCwxLDApLGM9TWF0aC5QSS80LHM9TWF0aC5QSS8yO3JldHVybiBpLnNldD1mdW5jdGlvbihlLG4sdCl7dmFyIHI9dS5nZXQoZSxuLHQpOzE9PT1hcmd1bWVudHMubGVuZ3RoJiZyLngmJihlPXIueCxlPjEmJihlPTEpLGU8LTEmJihlPS0xKSxlKj1jLHQ9ZStzLHQ+cyYmKHQ9TWF0aC5QSS10KSxyLng9TWF0aC5zaW4oZSksci56PU1hdGguc2luKHQpKSxvKGkscil9LGkuc2V0U291cmNlUG9zaXRpb249ZnVuY3Rpb24oZSxuLHQpe28oaSx1LmdldChlLG4sdCkpfSxpLnNldFNvdXJjZU9yaWVudGF0aW9uPWZ1bmN0aW9uKGUsbix0KXtyKGksdS5nZXQoZSxuLHQpKX0saS5zZXRMaXN0ZW5lclBvc2l0aW9uPWZ1bmN0aW9uKG4sdCxyKXtvKGUubGlzdGVuZXIsdS5nZXQobix0LHIpKX0saS5zZXRMaXN0ZW5lck9yaWVudGF0aW9uPWZ1bmN0aW9uKG4sdCxvKXtyKGUubGlzdGVuZXIsdS5nZXQobix0LG8pKX0saS5nZXREZWZhdWx0cz1mdW5jdGlvbigpe3JldHVybiBiLmRlZmF1bHRzfSxpLnNldERlZmF1bHRzPWZ1bmN0aW9uKGUpe09iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24obil7Yi5kZWZhdWx0c1tuXT1lW25dfSl9LGl9ZnVuY3Rpb24gdyhlKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPD0xfHx2b2lkIDA9PT1hcmd1bWVudHNbMV0/e306YXJndW1lbnRzWzFdLHQ9bChuLnN0YWdlcyw4KSxyPVtdLG89dm9pZCAwLGk9ZS5jcmVhdGVHYWluKCksdT1lLmNyZWF0ZUdhaW4oKSxhPWUuY3JlYXRlT3NjaWxsYXRvcigpLGM9ZS5jcmVhdGVHYWluKCkscz1lLmNyZWF0ZUdhaW4oKTt1LmdhaW4udmFsdWU9bChuLmZlZWRiYWNrLC41KSxhLnR5cGU9XCJzaW5lXCIsYS5mcmVxdWVuY3kudmFsdWU9bChuLmZyZXF1ZW5jeSwuNSksYy5nYWluLnZhbHVlPWwobi5nYWluLDMwMCk7Zm9yKHZhciBmPTA7Zjx0O2YrKylvPWUuY3JlYXRlQmlxdWFkRmlsdGVyKCksby50eXBlPVwiYWxscGFzc1wiLG8uZnJlcXVlbmN5LnZhbHVlPTFlMypmLGY+MCYmcltmLTFdLmNvbm5lY3QobyksYy5jb25uZWN0KG8uZnJlcXVlbmN5KSxyLnB1c2gobyk7dmFyIGQ9clswXSx2PXJbci5sZW5ndGgtMV07aS5jb25uZWN0KGQpLGkuY29ubmVjdChzKSx2LmNvbm5lY3Qocyksdi5jb25uZWN0KHUpLHUuY29ubmVjdChkKSxhLmNvbm5lY3QoYyksYS5zdGFydCgwKTt2YXIgcD1pO3JldHVybiBwLm5hbWU9XCJQaGFzZXJcIixwLl9vdXRwdXQ9cyxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLHtsZm9GcmVxdWVuY3k6e2dldDpmdW5jdGlvbigpe3JldHVybiBhLmZyZXF1ZW5jeS52YWx1ZX0sc2V0OmZ1bmN0aW9uKGUpe2EuZnJlcXVlbmN5LnZhbHVlPWV9fSxsZm9HYWluOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5nYWluLnZhbHVlfSxzZXQ6ZnVuY3Rpb24oZSl7Yy5nYWluLnZhbHVlPWV9fSxmZWVkYmFjazp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHUuZ2Fpbi52YWx1ZX0sc2V0OmZ1bmN0aW9uKGUpe3UuZ2Fpbi52YWx1ZT1lfX19KSxwfWZ1bmN0aW9uIFQoZSxuKXtmdW5jdGlvbiB0KGUsbil7Zm9yKHZhciB0PW5ldyBGbG9hdDMyQXJyYXkobikscj0wLG89MDtvPGUubGVuZ3RoO28rKyl0LnNldChlW29dLHIpLHIrPWVbb10ubGVuZ3RoO3JldHVybiB0fWZ1bmN0aW9uIHIoKXtpZighYS5sZW5ndGgpcmV0dXJuIGUuY3JlYXRlQnVmZmVyKDIsdSxlLnNhbXBsZVJhdGUpO3ZhciBuPWEubGVuZ3RoKnUscj1lLmNyZWF0ZUJ1ZmZlcigyLG4sZS5zYW1wbGVSYXRlKTtyZXR1cm4gci5nZXRDaGFubmVsRGF0YSgwKS5zZXQodChhLG4pKSxyLmdldENoYW5uZWxEYXRhKDEpLnNldCh0KGMsbikpLHJ9ZnVuY3Rpb24gbygpe3YmJih2Lm9uYXVkaW9wcm9jZXNzPW51bGwsbC5kaXNjb25uZWN0KCksdi5kaXNjb25uZWN0KCkpfWZ1bmN0aW9uIGkoKXtvKCksdj1lLmNyZWF0ZVNjcmlwdFByb2Nlc3Nvcih1LDIsMiksbC5jb25uZWN0KHYpLHYuY29ubmVjdChlLmRlc3RpbmF0aW9uKSx2LmNvbm5lY3QoZCksdi5vbmF1ZGlvcHJvY2Vzcz1mdW5jdGlvbihlKXt2YXIgdD1lLmlucHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKDApLHI9ZS5pbnB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YSgxKTtpZihuKXt2YXIgbz1lLm91dHB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKSxpPWUub3V0cHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKDEpO28uc2V0KHQpLGkuc2V0KHIpfXAuaXNSZWNvcmRpbmcmJihhLnB1c2gobmV3IEZsb2F0MzJBcnJheSh0KSksYy5wdXNoKG5ldyBGbG9hdDMyQXJyYXkocikpKX19dmFyIHU9NDA5NixhPVtdLGM9W10scz0wLGY9MCxsPWUuY3JlYXRlR2FpbigpLGQ9ZS5jcmVhdGVHYWluKCksdj12b2lkIDAscD1sO3JldHVybiBwLm5hbWU9XCJSZWNvcmRlclwiLHAuX291dHB1dD1kLHAuaXNSZWNvcmRpbmc9ITEscC5zdGFydD1mdW5jdGlvbigpe2koKSxhLmxlbmd0aD0wLGMubGVuZ3RoPTAscz1lLmN1cnJlbnRUaW1lLGY9MCx0aGlzLmlzUmVjb3JkaW5nPSEwfSxwLnN0b3A9ZnVuY3Rpb24oKXtyZXR1cm4gZj1lLmN1cnJlbnRUaW1lLHRoaXMuaXNSZWNvcmRpbmc9ITEsbygpLHIoKX0scC5nZXREdXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzUmVjb3JkaW5nP2UuY3VycmVudFRpbWUtczpmLXN9LHB9ZnVuY3Rpb24gTShlKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPD0xfHx2b2lkIDA9PT1hcmd1bWVudHNbMV0/e306YXJndW1lbnRzWzFdLHQ9ZS5zYW1wbGVSYXRlLHI9bChuLnRpbWUsMSksbz1sKG4uZGVjYXksNSksaT0hIW4ucmV2ZXJzZSx1PXZvaWQgMCxhPXZvaWQgMCxjPWUuY3JlYXRlR2FpbigpLHM9ZS5jcmVhdGVDb252b2x2ZXIoKSxmPWUuY3JlYXRlR2FpbigpO2MuY29ubmVjdChzKSxjLmNvbm5lY3QoZikscy5jb25uZWN0KGYpO3ZhciBkPWM7cmV0dXJuIGQubmFtZT1cIlJldmVyYlwiLGQuX291dHB1dD1mLGQudXBkYXRlPWZ1bmN0aW9uKG4pe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBuLnRpbWUmJihyPW4udGltZSx1PU1hdGguZmxvb3IodCpyKSxhPXU/ZS5jcmVhdGVCdWZmZXIoMix1LHQpOm51bGwpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBuLmRlY2F5JiYobz1uLmRlY2F5KSxcInVuZGVmaW5lZFwiIT10eXBlb2Ygbi5yZXZlcnNlJiYoaT1uLnJldmVyc2UpLCFhKXJldHVybiB2b2lkKHMuYnVmZmVyPW51bGwpO2Zvcih2YXIgYz1hLmdldENoYW5uZWxEYXRhKDApLGY9YS5nZXRDaGFubmVsRGF0YSgxKSxsPXZvaWQgMCxkPXZvaWQgMCx2PTA7djx1O3YrKylsPWk/dS12OnYsZD1NYXRoLnBvdygxLWwvdSxvKSxjW3ZdPSgyKk1hdGgucmFuZG9tKCktMSkqZCxmW3ZdPSgyKk1hdGgucmFuZG9tKCktMSkqZDtzLmJ1ZmZlcj1hfSxkLnVwZGF0ZSh7dGltZTpyLGRlY2F5Om8scmV2ZXJzZTppfSksT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZCx7dGltZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9LHNldDpmdW5jdGlvbihlKXtlIT09ciYmdGhpcy51cGRhdGUoe3RpbWU6ZX0pfX0sZGVjYXk6e2dldDpmdW5jdGlvbigpe3JldHVybiBvfSxzZXQ6ZnVuY3Rpb24oZSl7ZSE9PW8mJnRoaXMudXBkYXRlKHtkZWNheTplfSl9fSxyZXZlcnNlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaX0sc2V0OmZ1bmN0aW9uKGUpe2UhPT1pJiZ0aGlzLnVwZGF0ZSh7cmV2ZXJzZTohIWV9KX19fSksZH1mdW5jdGlvbiBBKGUpe2Z1bmN0aW9uIG4oZSxuKXt2YXIgdD1lLl9vdXRwdXR8fGU7dC5kaXNjb25uZWN0KCksdC5jb25uZWN0KG4pfWZ1bmN0aW9uIHQoZSl7dmFyIHQ9WC5sZW5ndGgscj10P1hbdC0xXTpaO3ImJm4ocixlKSxIPWV9ZnVuY3Rpb24gcigpe2lmKFope2Zvcih2YXIgZT12b2lkIDAscj12b2lkIDAsbz0wO288WC5sZW5ndGg7bysrKWU9WFtvXSxyPTA9PT1vP1o6WFtvLTFdLG4ocixlKTtIJiZ0KEgpfX1mdW5jdGlvbiBvKGUpe3JldHVybiEhZSYmWC5pbmRleE9mKGUpPi0xfWZ1bmN0aW9uIGkoZSl7cmV0dXJuIGU/byhlKT9lOihYLnB1c2goZSkscigpLGUpOm51bGx9ZnVuY3Rpb24gdShlKXtpZighZSlyZXR1cm4gbnVsbDtpZighbyhlKSlyZXR1cm4gZTtmb3IodmFyIG49WC5sZW5ndGgsdD0wO3Q8bjt0KyspaWYoZT09PVhbdF0pe1guc3BsaWNlKHQsMSk7YnJlYWt9dmFyIGk9ZS5fb3V0cHV0fHxlO3JldHVybiBpLmRpc2Nvbm5lY3QoKSxyKCksZX1mdW5jdGlvbiBhKGUsbil7bj0hIW47dmFyIHQ9byhlKTtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD4xJiZ0PT09bj9XOih0P3UoZSk6aShlKSxXKX1mdW5jdGlvbiBjKCl7Zm9yKDtYLmxlbmd0aDspWC5wb3AoKS5kaXNjb25uZWN0KCk7cmV0dXJuIHIoKSxXfWZ1bmN0aW9uIHMoKXtjKCksZT1udWxsLEg9bnVsbCxYPVtdLFomJlouZGlzY29ubmVjdCgpLFo9bnVsbH1mdW5jdGlvbiBsKG4pe3JldHVybiBpKG5ldyBmKGUsbikpfWZ1bmN0aW9uIGgobil7dmFyIHQ9ZS5jcmVhdGVEeW5hbWljc0NvbXByZXNzb3IoKTtyZXR1cm4gdC51cGRhdGU9ZnVuY3Rpb24oZSl7dC50aHJlc2hvbGQudmFsdWU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGUudGhyZXNob2xkP2UudGhyZXNob2xkOi0yNCx0LmtuZWUudmFsdWU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGUua25lZT9lLmtuZWU6MzAsdC5yYXRpby52YWx1ZT1cInVuZGVmaW5lZFwiIT10eXBlb2YgZS5yYXRpbz9lLnJhdGlvOjEyLHQuYXR0YWNrLnZhbHVlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBlLmF0dGFjaz9lLmF0dGFjazozZS00LHQucmVsZWFzZS52YWx1ZT1cInVuZGVmaW5lZFwiIT10eXBlb2YgZS5yZWxlYXNlP2UucmVsZWFzZTouMjV9LHQudXBkYXRlKG58fHt9KSxpKHQpfWZ1bmN0aW9uIG0obil7dmFyIHQ9ZS5jcmVhdGVDb252b2x2ZXIoKTtyZXR1cm4gdC5idWZmZXI9bixpKHQpfWZ1bmN0aW9uIEEobil7dmFyIHQ9ZS5jcmVhdGVEZWxheSgpO3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBuJiYodC5kZWxheVRpbWUudmFsdWU9biksaSh0KX1mdW5jdGlvbiBPKG4pe3JldHVybiBpKG5ldyB2KGUsbikpfWZ1bmN0aW9uIEUobil7cmV0dXJuIGkobmV3IGQoZSxuKSl9ZnVuY3Rpb24gUyhuLHQscixvKXtyZXR1cm4gaShuZXcgZyhlLHt0eXBlOm4sZnJlcXVlbmN5OnQscTpyLGdhaW46b30pKX1mdW5jdGlvbiB4KGUsbil7cmV0dXJuIFMoXCJsb3dwYXNzXCIse2ZyZXF1ZW5jeTplLHE6bn0pfWZ1bmN0aW9uIEwoZSxuKXtyZXR1cm4gUyhcImhpZ2hwYXNzXCIse2ZyZXF1ZW5jeTplLHE6bn0pfWZ1bmN0aW9uIF8oZSxuKXtyZXR1cm4gUyhcImJhbmRwYXNzXCIse2ZyZXF1ZW5jeTplLHE6bn0pfWZ1bmN0aW9uIEMoZSxuKXtyZXR1cm4gUyhcImxvd3NoZWxmXCIse2ZyZXF1ZW5jeTplLHE6MCxnYWluOm59KX1mdW5jdGlvbiBrKGUsbil7cmV0dXJuIFMoXCJoaWdoc2hlbGZcIix7ZnJlcXVlbmN5OmUscTowLGdhaW46bn0pfWZ1bmN0aW9uIEQoZSxuLHQpe3JldHVybiBTKFwicGVha2luZ1wiLHtmcmVxdWVuY3k6ZSxxOm4sZ2Fpbjp0fSl9ZnVuY3Rpb24gUChlLG4sdCl7cmV0dXJuIFMoXCJub3RjaFwiLHtmcmVxdWVuY3k6ZSxxOm4sZ2Fpbjp0fSl9ZnVuY3Rpb24gUihlLG4pe3JldHVybiBTKFwiYWxscGFzc1wiLHtmcmVxdWVuY3k6ZSxxOm59KX1mdW5jdGlvbiBxKG4pe3JldHVybiBpKG5ldyB5KGUsbikpfWZ1bmN0aW9uIEYobil7dmFyIHQ9ZS5jcmVhdGVHYWluKCk7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG4mJih0LmdhaW4udmFsdWU9biksdH1mdW5jdGlvbiB6KCl7cmV0dXJuIGkobmV3IGIoZSkpfWZ1bmN0aW9uIGoobil7cmV0dXJuIGkobmV3IHcoZSxuKSl9ZnVuY3Rpb24gRyhuKXtyZXR1cm4gaShuZXcgVChlLG4pKX1mdW5jdGlvbiBCKG4sdCxyKXtyZXR1cm4gaShuZXcgTShlLG4sdCxyKSl9ZnVuY3Rpb24gVigpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg8PTB8fHZvaWQgMD09PWFyZ3VtZW50c1swXT97fTphcmd1bWVudHNbMF0sdD1uLmJ1ZmZlclNpemV8fDEwMjQscj1cInVuZGVmaW5lZFwiPT10eXBlb2Ygbi5pbnB1dENoYW5uZWxzPzA6bi5pbnB1dENoYW5uZWxzLG89XCJ1bmRlZmluZWRcIj09dHlwZW9mIG4ub3V0cHV0Q2hhbm5lbHM/MTpuLm91dHB1dENoYW5uZWxzLHU9ZS5jcmVhdGVTY3JpcHRQcm9jZXNzb3IodCxyLG8pLGE9bi50aGlzQXJnfHxuLmNvbnRleHR8fHUsYz1uLmNhbGxiYWNrfHxmdW5jdGlvbigpe307cmV0dXJuIHUub25hdWRpb3Byb2Nlc3M9Yy5iaW5kKGEpLGkodSl9ZnVuY3Rpb24gTihlKXtyZXR1cm4gWj1lLHIoKSxlfWZ1bmN0aW9uIEkoZSl7cmV0dXJuIHQoZSksZX1lPWV8fG5ldyBwO3ZhciBVPW5ldyBiKGUpLFc9bnVsbCxIPXZvaWQgMCxYPVtdLFo9dm9pZCAwO3JldHVybiBXPXtjb250ZXh0OmUsbm9kZUxpc3Q6WCxwYW5uaW5nOlUsaGFzOm8sYWRkOmkscmVtb3ZlOnUsdG9nZ2xlOmEscmVtb3ZlQWxsOmMsZGVzdHJveTpzLHNldFNvdXJjZTpOLHNldERlc3RpbmF0aW9uOkksYW5hbHlzZXI6bCxjb21wcmVzc29yOmgsY29udm9sdmVyOm0sZGVsYXk6QSxlY2hvOk8sZGlzdG9ydGlvbjpFLGZpbHRlcjpTLGxvd3Bhc3M6eCxoaWdocGFzczpMLGJhbmRwYXNzOl8sbG93c2hlbGY6QyxoaWdoc2hlbGY6ayxwZWFraW5nOkQsbm90Y2g6UCxhbGxwYXNzOlIsZmxhbmdlcjpxLGdhaW46RixwYW5uZXI6eixwaGFzZXI6aixyZWNvcmRlcjpHLHJldmVyYjpCLHNjcmlwdDpWfSxPYmplY3QuZnJlZXplKFcpfWZ1bmN0aW9uIE8oZSxuKXtmdW5jdGlvbiB0KGUsbil7dmFyIHQ9dm9pZCAwO3JldHVybiBlfHwwPT09ZT8oZy5zb21lKGZ1bmN0aW9uKG4pe3JldHVybihuPT09ZXx8bi5pZD09PWUpJiYodD1uLCEwKX0pLHQmJm4/bih0KTp0KTp0fWZ1bmN0aW9uIHIoZSl7cmV0dXJuIHQoZSxmdW5jdGlvbihlKXtyZXR1cm4gZy5zcGxpY2UoZy5pbmRleE9mKGUpLDEpfSksYn1mdW5jdGlvbiBvKGUpe3JldHVybiBlLmdhaW4uZGlzY29ubmVjdCgpLGUuZ2Fpbi5jb25uZWN0KG0pLGcucHVzaChlKSxlLm9uY2UoXCJkZXN0cm95XCIsciksYn1mdW5jdGlvbiBpKGUsbil7cmV0dXJuIGcuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gdC5wbGF5KGUsbil9KSxifWZ1bmN0aW9uIHUoKXtyZXR1cm4gZy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UucGxheWluZyYmZS5wYXVzZSgpfSksYn1mdW5jdGlvbiBhKCl7cmV0dXJuIGcuZm9yRWFjaChmdW5jdGlvbihlKXtlLnBhdXNlZCYmZS5wbGF5KCl9KSxifWZ1bmN0aW9uIGMoKXtyZXR1cm4gZy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnN0b3AoKX0pLGJ9ZnVuY3Rpb24gcyhlKXtyZXR1cm4gZy5mb3JFYWNoKGZ1bmN0aW9uKG4pe3JldHVybiBuLnNlZWsoZSl9KSxifWZ1bmN0aW9uIGYoKXtyZXR1cm4geT1iLnZvbHVtZSxiLnZvbHVtZT0wLGJ9ZnVuY3Rpb24gbCgpe3JldHVybiBiLnZvbHVtZT15fHwxLGJ9ZnVuY3Rpb24gZChlKXtyZXR1cm4gYi52b2x1bWU9ZSxifWZ1bmN0aW9uIHYobix0KXtpZihlKXt2YXIgcj1tLmdhaW4sbz1lLmN1cnJlbnRUaW1lO3IuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKG8pLHIuc2V0VmFsdWVBdFRpbWUoci52YWx1ZSxvKSxyLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKG4sbyt0KX1lbHNlIGcuZm9yRWFjaChmdW5jdGlvbihlKXtlLmZhZGUobix0KX0pO3JldHVybiBifWZ1bmN0aW9uIHAoKXtmb3IoO2cubGVuZ3RoOylnLnBvcCgpLmRlc3Ryb3koKX12YXIgZz1bXSxoPW5ldyBBKGUpLG09aC5nYWluKCkseT0xLGI9bnVsbDtyZXR1cm4gZSYmKGguc2V0U291cmNlKG0pLGguc2V0RGVzdGluYXRpb24obnx8ZS5kZXN0aW5hdGlvbikpLGI9e2FkZDpvLGZpbmQ6dCxyZW1vdmU6cixwbGF5OmkscGF1c2U6dSxyZXN1bWU6YSxzdG9wOmMsc2VlazpzLHNldFZvbHVtZTpkLG11dGU6Zix1bk11dGU6bCxmYWRlOnYsZGVzdHJveTpwfSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhiLHtlZmZlY3Q6e3ZhbHVlOmh9LGdhaW46e3ZhbHVlOm19LHNvdW5kczp7dmFsdWU6Z30sdm9sdW1lOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbS5nYWluLnZhbHVlfSxzZXQ6ZnVuY3Rpb24obil7aXNOYU4obil8fChlPyhtLmdhaW4uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKGUuY3VycmVudFRpbWUpLG0uZ2Fpbi52YWx1ZT1uLG0uZ2Fpbi5zZXRWYWx1ZUF0VGltZShuLGUuY3VycmVudFRpbWUpKTptLmdhaW4udmFsdWU9bixnLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5jb250ZXh0fHwoZS5ncm91cFZvbHVtZT1uKX0pKX19fSksYn1mdW5jdGlvbiBFKCl7dGhpcy5fZXZlbnRzPXRoaXMuX2V2ZW50c3x8e30sdGhpcy5fbWF4TGlzdGVuZXJzPXRoaXMuX21heExpc3RlbmVyc3x8dm9pZCAwfWZ1bmN0aW9uIFMoZSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZX1mdW5jdGlvbiB4KGUpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBlfWZ1bmN0aW9uIEwoZSl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lfWZ1bmN0aW9uIF8oZSl7cmV0dXJuIHZvaWQgMD09PWV9ZnVuY3Rpb24gQyhlKXtmdW5jdGlvbiBuKCl7Zy5vZmYoXCJlcnJvclwiKSxnLm9mZihcInByb2dyZXNzXCIpLGcub2ZmKFwiY29tcGxldGVcIiksZy5vZmYoXCJsb2FkZWRcIiksVCYmXCJmdW5jdGlvblwiPT10eXBlb2YgVC5yZW1vdmVFdmVudExpc3RlbmVyJiYoVC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIixhKSxULnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLG8pKSxiJiYoYi5yZW1vdmVFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIixyKSxiLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsdSksYi5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIixvKSl9ZnVuY3Rpb24gdChlKXtnLmVtaXQoXCJwcm9ncmVzc1wiLDEpLGcuZW1pdChcImxvYWRlZFwiLGUpLGcuZW1pdChcImNvbXBsZXRlXCIsZSksbigpfWZ1bmN0aW9uIHIoZSl7ZS5sZW5ndGhDb21wdXRhYmxlJiYoaD1lLmxvYWRlZC9lLnRvdGFsLGcuZW1pdChcInByb2dyZXNzXCIsaCkpfWZ1bmN0aW9uIG8odCl7d2luZG93LmNsZWFyVGltZW91dCh3KTt2YXIgcj10O1QmJlQuZXJyb3ImJihyPVwiTWVkaWEgRXJyb3I6IFwiK3BbVC5lcnJvci5jb2RlXStcIiBcIitlKSxiJiYocj1cIlhIUiBFcnJvcjogXCIrYi5zdGF0dXMrXCIgXCIrYi5zdGF0dXNUZXh0K1wiIFwiK2UpLGcuZW1pdChcImVycm9yXCIsciksbigpfWZ1bmN0aW9uIGkoZSl7bS5kZWNvZGVBdWRpb0RhdGEoZSxmdW5jdGlvbihlKXtUPWUsYj1udWxsLGg9MSx0KGUpfSxvKX1mdW5jdGlvbiB1KCl7aShiLnJlc3BvbnNlKX1mdW5jdGlvbiBhKCl7d2luZG93LmNsZWFyVGltZW91dCh3KSxUJiYoaD0xLHQoVCkpfWZ1bmN0aW9uIGMoKXtuKCksYiYmNCE9PWIucmVhZHlTdGF0ZSYmYi5hYm9ydCgpLGI9bnVsbCx3aW5kb3cuY2xlYXJUaW1lb3V0KHcpfWZ1bmN0aW9uIHMoKXtjKCksYj1udWxsLFQ9bnVsbCxtPW51bGx9ZnVuY3Rpb24gZigpe3JldHVybiBlIGluc3RhbmNlb2Ygd2luZG93LkFycmF5QnVmZmVyP3ZvaWQgaShlKTooYj1uZXcgWE1MSHR0cFJlcXVlc3QsYi5vcGVuKFwiR0VUXCIsZSwhMCksYi5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGIuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsciksYi5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLHUpLGIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsbyksdm9pZCBiLnNlbmQoKSl9ZnVuY3Rpb24gbCgpe1QmJlQudGFnTmFtZXx8KFQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImF1ZGlvXCIpKSx5fHwod2luZG93LmNsZWFyVGltZW91dCh3KSx3PXdpbmRvdy5zZXRUaW1lb3V0KGEsMmUzKSxULmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLGEsITEpKSxULmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLG8sITEpLFQucHJlbG9hZD1cImF1dG9cIixULnNyYz1lLFQubG9hZCgpLHkmJnQoVCl9ZnVuY3Rpb24gZCgpe20/ZigpOmwoKX1mdW5jdGlvbiB2KG4pe2U9bixkKCl9dmFyIHA9W1wiXCIsXCJBQk9SVEVEXCIsXCJORVRXT1JLXCIsXCJERUNPREVcIixcIlNSQ19OT1RfU1VQUE9SVEVEXCJdLGc9bmV3IHNlLGg9MCxtPXZvaWQgMCx5PXZvaWQgMCxiPXZvaWQgMCx3PXZvaWQgMCxUPXZvaWQgMCxNPXtvbjpnLm9uLmJpbmQoZyksb25jZTpnLm9uY2UuYmluZChnKSxvZmY6Zy5vZmYuYmluZChnKSxsb2FkOnYsc3RhcnQ6ZCxjYW5jZWw6YyxkZXN0cm95OnN9O3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhNLHtkYXRhOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gVH19LHByb2dyZXNzOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaH19LGF1ZGlvQ29udGV4dDp7c2V0OmZ1bmN0aW9uKGUpe209ZX19LGlzVG91Y2hMb2NrZWQ6e3NldDpmdW5jdGlvbihlKXt5PWV9fX0pLE9iamVjdC5mcmVlemUoTSl9ZnVuY3Rpb24gayhlLG4sdCl7ZnVuY3Rpb24gcigpe3JldHVybiFtJiZuJiYobT1uLmNyZWF0ZUJ1ZmZlclNvdXJjZSgpLG0uYnVmZmVyPWUpLG19ZnVuY3Rpb24gbygpe2lmKG0pe20ub25lbmRlZD1udWxsO3RyeXttLmRpc2Nvbm5lY3QoKSxtLnN0b3AoMCl9Y2F0Y2goZSl7fW09bnVsbH12PSExLHA9MCxoPSExLHk9MH1mdW5jdGlvbiBpKCl7dmFyIGU9bi5jdXJyZW50VGltZS15O28oKSxwPWUsaD0hMSx2PSEwfWZ1bmN0aW9uIHUoKXtvKCksZj0hMCxcImZ1bmN0aW9uXCI9PXR5cGVvZiBsJiZsKHMpfWZ1bmN0aW9uIGEoZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aDw9MXx8dm9pZCAwPT09YXJndW1lbnRzWzFdPzA6YXJndW1lbnRzWzFdO2lmKCFoKXtmb3IoZT1lP24uY3VycmVudFRpbWUrZTowLHQmJihwPTApLHAmJih0PXApO3Q+cy5kdXJhdGlvbjspdCU9cy5kdXJhdGlvbjtyKCksbS5vbmVuZGVkPXUsbS5zdGFydChlLHQpLG0ubG9vcD1kLG0ucGxheWJhY2tSYXRlLnZhbHVlPWcseT1uLmN1cnJlbnRUaW1lLXQsZj0hMSx2PSExLHA9MCxoPSEwfX1mdW5jdGlvbiBjKCl7bygpLGU9bnVsbCxuPW51bGwsbD1udWxsLG09bnVsbH12YXIgcz17fSxmPSExLGw9dCxkPSExLHY9ITEscD0wLGc9MSxoPSExLG09bnVsbCx5PTA7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHMse3BsYXk6e3ZhbHVlOmF9LHBhdXNlOnt2YWx1ZTppfSxzdG9wOnt2YWx1ZTpvfSxkZXN0cm95Ont2YWx1ZTpjfSxjdXJyZW50VGltZTp7Z2V0OmZ1bmN0aW9uKCl7aWYocClyZXR1cm4gcDtpZih5KXt2YXIgZT1uLmN1cnJlbnRUaW1lLXk7cmV0dXJuIGU+cy5kdXJhdGlvbiYmKGUlPXMuZHVyYXRpb24pLGV9cmV0dXJuIDB9fSxkdXJhdGlvbjp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGU/ZS5kdXJhdGlvbjowfX0sZW5kZWQ6e2dldDpmdW5jdGlvbigpe3JldHVybiBmfX0sbG9vcDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGR9LHNldDpmdW5jdGlvbihlKXtkPSEhZSxtJiYobS5sb29wPWQpfX0scGF1c2VkOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdn19LHBsYXliYWNrUmF0ZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGd9LHNldDpmdW5jdGlvbihlKXtnPWUsbSYmKG0ucGxheWJhY2tSYXRlLnZhbHVlPWcpfX0scGxheWluZzp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGh9fSxwcm9ncmVzczp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuZHVyYXRpb24/cy5jdXJyZW50VGltZS9zLmR1cmF0aW9uOjB9fSxzb3VyY2VOb2RlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcigpfX19KSxPYmplY3QuZnJlZXplKHMpfWZ1bmN0aW9uIEQoZSxuLHQpe2Z1bmN0aW9uIHIoKXtyZXR1cm4hVCYmbiYmKFQ9bi5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UoZSkpLFR9ZnVuY3Rpb24gbyhuKXtlLnNyYz1uLGUubG9hZCgpLHY9ITEseT0hMSx3PSExfWZ1bmN0aW9uIGkoKXtlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLGkpLHcmJmUucGxheSgpfWZ1bmN0aW9uIHUoKXtyZXR1cm4gbT8oZS5jdXJyZW50VGltZT0wLGUuY3VycmVudFRpbWU+MCYmZS5sb2FkKCksdm9pZCBlLnBsYXkoKSk6KHY9ITAseT0hMSx3PSExLHZvaWQoXCJmdW5jdGlvblwiPT10eXBlb2YgcCYmcChkKSkpfWZ1bmN0aW9uIGEobix0KXtjbGVhclRpbWVvdXQoZyksZS52b2x1bWU9QSpNLGUucGxheWJhY2tSYXRlPWIsdCYmKGUuY3VycmVudFRpbWU9dCksbj9nPXNldFRpbWVvdXQoYSxuKTplLnBsYXkoKSx2PSExLHk9ITEsdz0hMCxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlbmRlZFwiLHUpLGUuYWRkRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsdSwhMSksZS5yZWFkeVN0YXRlPDEmJihlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLGkpLGUuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsaSwhMSksZS5sb2FkKCksZS5wbGF5KCkpfWZ1bmN0aW9uIGMoKXtjbGVhclRpbWVvdXQoZyksZSYmKGUucGF1c2UoKSx3PSExLHk9ITApfWZ1bmN0aW9uIHMoKXtpZihjbGVhclRpbWVvdXQoZyksZSl7ZS5wYXVzZSgpO3RyeXtlLmN1cnJlbnRUaW1lPTAsZS5jdXJyZW50VGltZT4wJiZlLmxvYWQoKX1jYXRjaChlKXt9dz0hMSx5PSExfX1mdW5jdGlvbiBmKGUsdCl7ZnVuY3Rpb24gcihlLG4pe2g9d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gZC52b2x1bWU9ZC52b2x1bWUrLjIqKGUtZC52b2x1bWUpLE1hdGguYWJzKGQudm9sdW1lLWUpPi4wNT92b2lkIHIoZSxuKTp2b2lkKGQudm9sdW1lPWUpfSwxZTMqbil9cmV0dXJuIG4/ZDood2luZG93LmNsZWFyVGltZW91dChoKSxyKGUsdC8xMCksZCl9ZnVuY3Rpb24gbCgpe2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsdSksZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIixpKSxzKCksZT1udWxsLG49bnVsbCxwPW51bGwsVD1udWxsfXZhciBkPXt9LHY9ITEscD10LGc9dm9pZCAwLGg9dm9pZCAwLG09ITEseT0hMSxiPTEsdz0hMSxUPW51bGwsTT0xLEE9MTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZCx7cGxheTp7dmFsdWU6YX0scGF1c2U6e3ZhbHVlOmN9LHN0b3A6e3ZhbHVlOnN9LGxvYWQ6e3ZhbHVlOm99LGZhZGU6e3ZhbHVlOmZ9LGRlc3Ryb3k6e3ZhbHVlOmx9LGN1cnJlbnRUaW1lOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZT9lLmN1cnJlbnRUaW1lOjB9fSxkdXJhdGlvbjp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGU/ZS5kdXJhdGlvbjowfX0sZW5kZWQ6e2dldDpmdW5jdGlvbigpe3JldHVybiB2fX0sbG9vcDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG19LHNldDpmdW5jdGlvbihlKXttPSEhZX19LHBhdXNlZDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHl9fSxwbGF5YmFja1JhdGU6e2dldDpmdW5jdGlvbigpe3JldHVybiBifSxzZXQ6ZnVuY3Rpb24obil7Yj1uLGUmJihlLnBsYXliYWNrUmF0ZT1iKX19LHBsYXlpbmc6e2dldDpmdW5jdGlvbigpe3JldHVybiB3fX0scHJvZ3Jlc3M6e2dldDpmdW5jdGlvbigpe3JldHVybiBlJiZlLmR1cmF0aW9uP2UuY3VycmVudFRpbWUvZS5kdXJhdGlvbjowfX0sc291cmNlTm9kZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHIoKX19LHZvbHVtZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEF9LHNldDpmdW5jdGlvbihuKXt3aW5kb3cuY2xlYXJUaW1lb3V0KGgpLEE9bixlJiYoZS52b2x1bWU9QSpNKX19LGdyb3VwVm9sdW1lOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gTX0sc2V0OmZ1bmN0aW9uKG4pe009bixlJiYoZS52b2x1bWU9QSpNKX19fSksT2JqZWN0LmZyZWV6ZShkKX1mdW5jdGlvbiBQKGUsbil7ZnVuY3Rpb24gdCgpe3JldHVybiFsJiZuJiYobD1uLmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKGUpLG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEmJih3aW5kb3cubW96SGFjaz1sKSksbH1mdW5jdGlvbiByKGUpe2U9ZT9uLmN1cnJlbnRUaW1lK2U6MCx0KCksbC5zdGFydChlKSxkPW4uY3VycmVudFRpbWUtcyxhPSExLGY9ITAsYz0hMSxzPTB9ZnVuY3Rpb24gbygpe2lmKGwpe3RyeXtsLnN0b3AoMCl9Y2F0Y2goZSl7fWw9bnVsbH1hPSEwLGM9ITEscz0wLGY9ITEsZD0wfWZ1bmN0aW9uIGkoKXt2YXIgZT1uLmN1cnJlbnRUaW1lLWQ7bygpLHM9ZSxmPSExLGM9ITB9ZnVuY3Rpb24gdSgpe28oKSxuPW51bGwsbD1udWxsLGU9bnVsbCx3aW5kb3cubW96SGFjaz1udWxsfXZhciBhPSExLGM9ITEscz0wLGY9ITEsbD1udWxsLGQ9MCx2PXtwbGF5OnIscGF1c2U6aSxzdG9wOm8sZGVzdHJveTp1LGR1cmF0aW9uOjAscHJvZ3Jlc3M6MH07cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHYse2N1cnJlbnRUaW1lOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcz9zOmQ/bi5jdXJyZW50VGltZS1kOjB9fSxlbmRlZDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGF9fSxwYXVzZWQ6e2dldDpmdW5jdGlvbigpe3JldHVybiBjfX0scGxheWluZzp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGZ9fSxzb3VyY2VOb2RlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdCgpfX19KSxPYmplY3QuZnJlZXplKHYpfWZ1bmN0aW9uIFIoZSxuKXtmdW5jdGlvbiB0KCl7cmV0dXJuIWwmJm4mJihsPW4uY3JlYXRlT3NjaWxsYXRvcigpLGwudHlwZT1lLGwuZnJlcXVlbmN5LnZhbHVlPXYpLGx9ZnVuY3Rpb24gcihlKXtlPWV8fDAsZSYmKGU9bi5jdXJyZW50VGltZStlKSx0KCksbC5zdGFydChlKSxkPXM/bi5jdXJyZW50VGltZS1zOm4uY3VycmVudFRpbWUsYT0hMSxmPSEwLGM9ITEscz0wfWZ1bmN0aW9uIG8oKXtpZihsKXt0cnl7bC5zdG9wKDApfWNhdGNoKGUpe31sPW51bGx9YT0hMCxjPSExLHM9MCxmPSExLGQ9MH1mdW5jdGlvbiBpKCl7dmFyIGU9bi5jdXJyZW50VGltZS1kO28oKSxzPWUsZj0hMSxjPSEwfWZ1bmN0aW9uIHUoKXtvKCksbj1udWxsLGw9bnVsbH12YXIgYT0hMSxjPSExLHM9MCxmPSExLGw9bnVsbCxkPTAsdj0yMDAscD1udWxsO3JldHVybiBwPXtwbGF5OnIscGF1c2U6aSxzdG9wOm8sZGVzdHJveTp1fSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLHtjdXJyZW50VGltZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHM/czpkP24uY3VycmVudFRpbWUtZDowfX0sZHVyYXRpb246e3ZhbHVlOjB9LGVuZGVkOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYX19LGZyZXF1ZW5jeTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHZ9LHNldDpmdW5jdGlvbihlKXt2PWUsbCYmKGwuZnJlcXVlbmN5LnZhbHVlPWUpfX0scGF1c2VkOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gY319LHBsYXlpbmc6e2dldDpmdW5jdGlvbigpe3JldHVybiBmfX0scHJvZ3Jlc3M6e3ZhbHVlOjB9LHNvdXJjZU5vZGU6e2dldDpmdW5jdGlvbigpe3JldHVybiB0KCl9fX0pLE9iamVjdC5mcmVlemUocCl9ZnVuY3Rpb24gcShlLG4pe2Z1bmN0aW9uIHQoKXtyZXR1cm4hZyYmbiYmKGc9bi5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoYywwLHMpKSxnfWZ1bmN0aW9uIHIoKXt0KCksZy5vbmF1ZGlvcHJvY2Vzcz1sLGg9bi5jdXJyZW50VGltZS12LGY9ITEsZD0hMSx2PTAscD0hMH1mdW5jdGlvbiBvKGUpe2Zvcih2YXIgbj1lLm91dHB1dEJ1ZmZlcix0PTA7dDxuLm51bWJlck9mQ2hhbm5lbHM7dCsrKWZvcih2YXIgcj1uLmdldENoYW5uZWxEYXRhKHQpLG89MDtvPHIubGVuZ3RoO28rKylyW29dPTB9ZnVuY3Rpb24gaSgpe2cmJihnLm9uYXVkaW9wcm9jZXNzPW8pLGY9ITAsZD0hMSx2PTAscD0hMSxoPTB9ZnVuY3Rpb24gdSgpe3ZhciBlPW4uY3VycmVudFRpbWUtaDtpKCksdj1lLHA9ITEsZD0hMH1mdW5jdGlvbiBhKCl7aSgpLG49bnVsbCxsPW51bGwsZz1udWxsfXZhciBjPWUuYnVmZmVyU2l6ZXx8MTAyNCxzPWUuY2hhbm5lbHN8fDEsZj0hMSxsPWUuY2FsbGJhY2suYmluZChlLnRoaXNBcmd8fHRoaXMpLGQ9ITEsdj0wLHA9ITEsZz1udWxsLGg9MCxtPW51bGw7cmV0dXJuIG09e3BsYXk6cixwYXVzZTp1LHN0b3A6aSxkZXN0cm95OmEsZHVyYXRpb246MCxwcm9ncmVzczowfSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhtLHtjdXJyZW50VGltZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHY/djpoP24uY3VycmVudFRpbWUtaDowfX0sZW5kZWQ6e2dldDpmdW5jdGlvbigpe3JldHVybiBmfX0scGF1c2VkOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZH19LHBsYXlpbmc6e2dldDpmdW5jdGlvbigpe3JldHVybiBwfX0sc291cmNlTm9kZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHQoKX19fSksT2JqZWN0LmZyZWV6ZShtKX1mdW5jdGlvbiBGKCl7dmFyIGU9dm9pZCAwLG49dm9pZCAwO3JldHVybiBmdW5jdGlvbih0LHIpe2lmKCF3aW5kb3cuRmxvYXQzMkFycmF5fHwhd2luZG93LkF1ZGlvQnVmZmVyKXJldHVybltdO3ZhciBvPWU9PT10LGk9biYmbi5sZW5ndGg9PT1yO2lmKG8mJmkpcmV0dXJuIG47aWYobiYmbi5sZW5ndGg9PT1yfHwobj1uZXcgRmxvYXQzMkFycmF5KHIpKSwhdClyZXR1cm4gbjtlPXQ7Zm9yKHZhciB1PU1hdGguZmxvb3IoZS5sZW5ndGgvciksYT01LGM9TWF0aC5tYXgoTWF0aC5mbG9vcih1L2EpLDEpLHM9MCxmPTA7ZjxlLm51bWJlck9mQ2hhbm5lbHM7ZisrKWZvcih2YXIgbD1lLmdldENoYW5uZWxEYXRhKGYpLGQ9MDtkPHI7ZCsrKWZvcih2YXIgdj1kKnUscD12K3U7djxwO3YrPWMpe3ZhciBnPWxbdl07ZzwwJiYoZz0tZyksZz5uW2RdJiYobltkXT1nKSxnPnMmJihzPWcpfWZvcih2YXIgaD0xL3MsbT0wO208bi5sZW5ndGg7bSsrKW5bbV0qPWg7cmV0dXJuIG59fWZ1bmN0aW9uIHooZSxuKXtmdW5jdGlvbiB0KG4pe2lmKGw9bixpZS5pc0F1ZGlvQnVmZmVyKGwpKXc9bmV3IGsobCxlLGZ1bmN0aW9uKCl7cmV0dXJuIFQuZW1pdChcImVuZGVkXCIsVCl9KTtlbHNlIGlmKGllLmlzTWVkaWFFbGVtZW50KGwpKXc9bmV3IEQobCxlLGZ1bmN0aW9uKCl7cmV0dXJuIFQuZW1pdChcImVuZGVkXCIsVCl9KTtlbHNlIGlmKGllLmlzTWVkaWFTdHJlYW0obCkpdz1uZXcgUChsLGUpO2Vsc2UgaWYoaWUuaXNPc2NpbGxhdG9yVHlwZShsJiZsLnR5cGV8fGwpKXc9bmV3IFIobC50eXBlfHxsLGUpO2Vsc2V7aWYoIWllLmlzU2NyaXB0Q29uZmlnKGwpKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkZXRlY3QgZGF0YSB0eXBlOiBcIitsKTt3PW5ldyBxKGwsZSl9ZC5zZXRTb3VyY2Uody5zb3VyY2VOb2RlKSxULmVtaXQoXCJyZWFkeVwiLFQpLGImJmIoKX1mdW5jdGlvbiByKG4pe3ZhciByPWllLmdldFN1cHBvcnRlZEZpbGUobi5zcmN8fG4udXJsfHxuLmRhdGF8fG4pO3JldHVybiB3JiZsJiZsLnRhZ05hbWU/dy5sb2FkKHIpOihoPWh8fG5ldyBDKHIpLGguYXVkaW9Db250ZXh0PW4uYXNNZWRpYUVsZW1lbnQ/bnVsbDplLGguaXNUb3VjaExvY2tlZD1nLGgub25jZShcImxvYWRlZFwiLGZ1bmN0aW9uKGUpe3QoZSksVC5lbWl0KFwibG9hZGVkXCIsVCl9KSksVH1mdW5jdGlvbiBvKG4sdCl7cmV0dXJuIXd8fGc/KGI9ZnVuY3Rpb24oKXt3JiZvKG4sdCl9LFQpOihiPW51bGwsZC5zZXRTb3VyY2Uody5zb3VyY2VOb2RlKSxlfHwoVC52b2x1bWU9di5nYWluLnZhbHVlKSx3LnBsYXkobix0KSx3Lmhhc093blByb3BlcnR5KFwibG9vcFwiKSYmKHcubG9vcD1tKSxULmVtaXQoXCJwbGF5XCIsVCksVCl9ZnVuY3Rpb24gaSgpe3JldHVybiB3JiZ3LnBhdXNlKCksVC5lbWl0KFwicGF1c2VcIixUKSxUfWZ1bmN0aW9uIHUoZSl7cmV0dXJuIHcmJncuc3RvcChlfHwwKSxULmVtaXQoXCJzdG9wXCIsVCksVH1mdW5jdGlvbiBhKGUpe3JldHVybiB3JiYody5zdG9wKCksbygwLHcuZHVyYXRpb24qZSkpLFR9ZnVuY3Rpb24gYyhuLHQpe2lmKCF3KXJldHVybiBUO3ZhciByPXYuZ2FpbjtpZihlKXt2YXIgbz1lLmN1cnJlbnRUaW1lO3IuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKG8pLHIuc2V0VmFsdWVBdFRpbWUoci52YWx1ZSxvKSxyLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKG4sbyt0KX1lbHNlXCJmdW5jdGlvblwiPT10eXBlb2Ygdy5mYWRlJiYody5mYWRlKG4sdCksci52YWx1ZT1uKTtyZXR1cm4gVH1mdW5jdGlvbiBzKCl7dyYmdy5kZXN0cm95KCksZCYmZC5kZXN0cm95KCksdiYmdi5kaXNjb25uZWN0KCksaCYmaC5kZXN0cm95KCksVC5vZmYoXCJsb2FkZWRcIiksVC5vZmYoXCJlbmRlZFwiKSx2PW51bGwsZT1udWxsLGw9bnVsbCxiPW51bGwsdz1udWxsLGQ9bnVsbCxoPW51bGwscD1udWxsLFQuZW1pdChcImRlc3Ryb3lcIixUKSxULm9mZihcImRlc3Ryb3lcIil9dmFyIGY9dm9pZCAwLGw9dm9pZCAwLGQ9bmV3IEEoZSksdj1kLmdhaW4oKSxwPUYoKSxnPSExLGg9dm9pZCAwLG09ITEseT0xLGI9dm9pZCAwLHc9dm9pZCAwLFQ9bnVsbDtyZXR1cm4gZSYmKGQuc2V0RGVzdGluYXRpb24odiksdi5jb25uZWN0KG58fGUuZGVzdGluYXRpb24pKSxUPU9iamVjdC5jcmVhdGUoc2UucHJvdG90eXBlLHtfZXZlbnRzOnt2YWx1ZTp7fX0sY29uc3RydWN0b3I6e3ZhbHVlOnp9LHBsYXk6e3ZhbHVlOm99LHBhdXNlOnt2YWx1ZTppfSxsb2FkOnt2YWx1ZTpyfSxzZWVrOnt2YWx1ZTphfSxzdG9wOnt2YWx1ZTp1fSxmYWRlOnt2YWx1ZTpjfSxkZXN0cm95Ont2YWx1ZTpzfSxjb250ZXh0Ont2YWx1ZTplfSxjdXJyZW50VGltZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHc/dy5jdXJyZW50VGltZTowfSxzZXQ6ZnVuY3Rpb24oZSl7dyYmdy5zdG9wKCksbygwLGUpfX0sZGF0YTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGx9LHNldDpmdW5jdGlvbihlKXtlJiZ0KGUpfX0sZHVyYXRpb246e2dldDpmdW5jdGlvbigpe3JldHVybiB3P3cuZHVyYXRpb246MH19LGVmZmVjdDp7dmFsdWU6ZH0sZW5kZWQ6e2dldDpmdW5jdGlvbigpe3JldHVybiEhdyYmdy5lbmRlZH19LGZyZXF1ZW5jeTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHc/dy5mcmVxdWVuY3k6MH0sc2V0OmZ1bmN0aW9uKGUpe3cmJncuaGFzT3duUHJvcGVydHkoXCJmcmVxdWVuY3lcIikmJih3LmZyZXF1ZW5jeT1lKX19LGdhaW46e3ZhbHVlOnZ9LGlkOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZn0sc2V0OmZ1bmN0aW9uKGUpe2Y9ZX19LGlzVG91Y2hMb2NrZWQ6e3NldDpmdW5jdGlvbihlKXtnPWUsaCYmKGguaXNUb3VjaExvY2tlZD1lKSwhZSYmYiYmYigpfX0sbG9hZGVyOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaH19LGxvb3A6e2dldDpmdW5jdGlvbigpe3JldHVybiBtfSxzZXQ6ZnVuY3Rpb24oZSl7bT0hIWUsdyYmdy5oYXNPd25Qcm9wZXJ0eShcImxvb3BcIikmJncubG9vcCE9PW0mJih3Lmxvb3A9bSl9fSxwYXVzZWQ6e2dldDpmdW5jdGlvbigpe3JldHVybiEhdyYmdy5wYXVzZWR9fSxwbGF5aW5nOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4hIXcmJncucGxheWluZ319LHBsYXliYWNrUmF0ZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHl9LHNldDpmdW5jdGlvbihlKXt5PWUsdyYmKHcucGxheWJhY2tSYXRlPXkpfX0scHJvZ3Jlc3M6e2dldDpmdW5jdGlvbigpe3JldHVybiB3P3cucHJvZ3Jlc3M6MH19LHNvdXJjZU5vZGU6e2dldDpmdW5jdGlvbigpe3JldHVybiB3P3cuc291cmNlTm9kZTpudWxsfX0sdm9sdW1lOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZT92LmdhaW4udmFsdWU6dyYmdy5oYXNPd25Qcm9wZXJ0eShcInZvbHVtZVwiKT93LnZvbHVtZToxfSxzZXQ6ZnVuY3Rpb24obil7aWYoIWlzTmFOKG4pKXt2YXIgdD12LmdhaW47aWYoZSl7dmFyIHI9ZS5jdXJyZW50VGltZTt0LmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhyKSx0LnZhbHVlPW4sdC5zZXRWYWx1ZUF0VGltZShuLHIpfWVsc2UgdC52YWx1ZT1uLHcmJncuaGFzT3duUHJvcGVydHkoXCJ2b2x1bWVcIikmJih3LnZvbHVtZT1uKX19fSxncm91cFZvbHVtZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHcuZ3JvdXBWb2x1bWV9LHNldDpmdW5jdGlvbihlKXt3JiZ3Lmhhc093blByb3BlcnR5KFwiZ3JvdXBWb2x1bWVcIikmJih3Lmdyb3VwVm9sdW1lPWUpfX0sd2F2ZWZvcm06e3ZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBsfHxULm9uY2UoXCJyZWFkeVwiLGZ1bmN0aW9uKCl7cmV0dXJuIHAobCxlKX0pLHAobCxlKX19LHVzZXJEYXRhOnt2YWx1ZTp7fX19KSxPYmplY3QuZnJlZXplKFQpfWZ1bmN0aW9uIGooZSxuKXtmdW5jdGlvbiB0KCl7by5sZW5ndGgmJihhPW8uc2xpY2UoMCkuc29ydChmdW5jdGlvbihlLG4pe3JldHVybiBuLmR1cmF0aW9uLWUuZHVyYXRpb259KVswXSl9dmFyIHI9bmV3IE8oZSxuKSxvPXIuc291bmRzLGk9MSx1PSExLGE9dm9pZCAwLGM9ci5hZGQ7ci5hZGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGMoZSksdCgpLHJ9O3ZhciBzPXIucm1lb3ZlO3JldHVybiByLnJlbW92ZT1mdW5jdGlvbihlKXtyZXR1cm4gcyhlKSx0KCkscn0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocix7Y3VycmVudFRpbWU6e2dldDpmdW5jdGlvbigpe3JldHVybiBhP2EuY3VycmVudFRpbWU6MH0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuc3RvcCgpLHRoaXMucGxheSgwLGUpfX0sZHVyYXRpb246e2dldDpmdW5jdGlvbigpe3JldHVybiBhP2EuZHVyYXRpb246MH19LGxvb3A6e2dldDpmdW5jdGlvbigpe3JldHVybiB1fSxzZXQ6ZnVuY3Rpb24oZSl7dT0hIWUsby5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UubG9vcD11fSl9fSxwYXVzZWQ6e2dldDpmdW5jdGlvbigpe3JldHVybiEhYSYmYS5wYXVzZWR9fSxwcm9ncmVzczp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGE/YS5wcm9ncmVzczowfX0scGxheWJhY2tSYXRlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaX0sc2V0OmZ1bmN0aW9uKGUpe2k9ZSxvLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5wbGF5YmFja1JhdGU9aX0pfX0scGxheWluZzp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuISFhJiZhLnBsYXlpbmd9fX0pLHJ9ZnVuY3Rpb24gRyhlLG4sdCl7ZnVuY3Rpb24gcigpe3JldHVybiBpPyhuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhKHthdWRpbzohMH0sZnVuY3Rpb24obil7YT1uLGUoYSl9LGZ1bmN0aW9uKGUpe24mJlwiUGVybWlzc2lvbkRlbmllZEVycm9yXCI9PT1lLm5hbWV8fFwiUEVSTUlTU0lPTl9ERU5JRURcIj09PWU/bigpOnQoZS5tZXNzYWdlfHxlKX0pLHUpOnV9ZnVuY3Rpb24gbygpe3JldHVybiBhJiYoYS5zdG9wKCksYT1udWxsKSx1fW5hdmlnYXRvci5nZXRVc2VyTWVkaWE9bmF2aWdhdG9yLmdldFVzZXJNZWRpYXx8bmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYXx8bmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYXx8bmF2aWdhdG9yLm1zR2V0VXNlck1lZGlhLHQ9dHx8ZnVuY3Rpb24oKXt9O3ZhciBpPSEhbmF2aWdhdG9yLmdldFVzZXJNZWRpYSx1PXt9LGE9bnVsbDtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModSx7Y29ubmVjdDp7dmFsdWU6cn0sZGlzY29ubmVjdDp7dmFsdWU6b30saXNTdXBwb3J0ZWQ6e3ZhbHVlOml9LHN0cmVhbTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGF9fX0pLE9iamVjdC5mcmVlemUodSl9ZnVuY3Rpb24gQihlKXtmdW5jdGlvbiBuKCl7cz8oeS5maWxsU3R5bGU9cyx5LmZpbGxSZWN0KGQsdixoLG0pKTp5LmNsZWFyUmVjdChkLHYsaCxtKSx5LmxpbmVXaWR0aD1mLGI9bnVsbCxcImZ1bmN0aW9uXCIhPXR5cGVvZiBjJiYoeS5zdHJva2VTdHlsZT1jLHkuYmVnaW5QYXRoKCkpfWZ1bmN0aW9uIHQoZSxuLHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGMpe3ZhciByPWMoZSxuLHQpO3IhPT1iJiYoYj1yLHkuc3Ryb2tlKCkseS5zdHJva2VTdHlsZT1iLHkuYmVnaW5QYXRoKCkpfX1mdW5jdGlvbiByKGUsbix0KXtcbnJldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHA/cChlLG4sdCk6ZX1mdW5jdGlvbiBvKG4sdCl7cmV0dXJuIG4mJlwiZnVuY3Rpb25cIj09dHlwZW9mIG4ud2F2ZWZvcm0/bi53YXZlZm9ybSh0KTpuP246ZS53YXZlZm9ybT9lLndhdmVmb3JtOmUuc291bmQ/ZS5zb3VuZC53YXZlZm9ybSh0KTpudWxsfWZ1bmN0aW9uIGkoZSl7aWYobigpLFwiY2lyY3VsYXJcIj09PWEpe3ZhciBpPW8oZSwzNjApLGM9TWF0aC5mbG9vcihpLmxlbmd0aCpsKSxzPWxlL2MscD12b2lkIDAsZz12b2lkIDAsYj12b2lkIDAseD12b2lkIDA7Zm9yKHc9MDt3PGM7dysrKXt2YXIgTD1yKGlbd10sdyxjKTt0KHcsYyxMKSxwPXcqcy1mZSx4PU1hdGguY29zKHApLGI9TWF0aC5zaW4ocCksXCJmaWxsXCI9PT11JiYoVD1FK08qeCxNPVMrTypiLHkubW92ZVRvKFQsTSkpLGc9TysoQS1PKSpMLFQ9RStnKngsTT1TK2cqYixcImxpbmVcIj09PXUmJjA9PT13JiZ5Lm1vdmVUbyhULE0pLHkubGluZVRvKFQsTSl9XCJsaW5lXCI9PT11JiZ5LmNsb3NlUGF0aCgpfWVsc2V7dmFyIF89byhlLGgpLEM9TWF0aC5taW4oXy5sZW5ndGgsaC1mLzIpO2ZvcihDPU1hdGguZmxvb3IoQypsKSx3PTA7dzxDO3crKyl7dmFyIGs9cihfW3ddLHcsQyk7dCh3LEMsayksXCJsaW5lXCI9PT11JiZ3PjAmJnkubGluZVRvKFQsTSksVD1kK3csTT12K20tTWF0aC5yb3VuZChtKmspLE09TWF0aC5mbG9vcihNYXRoLm1pbihNLHYrbS1mLzIpKSxcImZpbGxcIj09PXU/KHkubW92ZVRvKFQsTSkseS5saW5lVG8oVCx2K20pKTp5LmxpbmVUbyhULE0pfX15LnN0cm9rZSgpfXZhciB1PWUuc3R5bGV8fFwiZmlsbFwiLGE9ZS5zaGFwZXx8XCJsaW5lYXJcIixjPWUuY29sb3J8fDAscz1lLmJnQ29sb3IsZj1lLmxpbmVXaWR0aHx8MSxsPWUucGVyY2VudHx8MSxkPWUueHx8MCx2PWUueXx8MCxwPWUudHJhbnNmb3JtLGc9ZS5jYW52YXMsaD1lLndpZHRofHxnJiZnLndpZHRoLG09ZS5oZWlnaHR8fGcmJmcuaGVpZ2h0LHk9bnVsbCxiPXZvaWQgMCx3PXZvaWQgMCxUPXZvaWQgMCxNPXZvaWQgMCxBPXZvaWQgMCxPPXZvaWQgMCxFPXZvaWQgMCxTPXZvaWQgMDtyZXR1cm4gZ3x8ZS5jb250ZXh0fHwoZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLGg9aHx8Zy53aWR0aCxtPW18fGcuaGVpZ2h0LGcud2lkdGg9bSxnLmhlaWdodD1tKSxcImNpcmN1bGFyXCI9PT1hJiYoQT1lLnJhZGl1c3x8TWF0aC5taW4obS8yLGgvMiksTz1lLmlubmVyUmFkaXVzfHxBLzIsRT1kK2gvMixTPXYrbS8yKSx5PWUuY29udGV4dHx8Zy5nZXRDb250ZXh0KFwiMmRcIiksaS5jYW52YXM9ZywoZS53YXZlZm9ybXx8ZS5zb3VuZCkmJmkoKSxpfWZ1bmN0aW9uIFYoKXtpZihkZSlyZXR1cm4gZGU7dmFyIGU9d2luZG93LkF1ZGlvQ29udGV4dHx8d2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtkZT1lP25ldyBlOm51bGw7dmFyIG49ZGUmJlwic3VzcGVuZGVkXCI9PT1kZS5zdGF0ZTtyZXR1cm4gbiYmXCJmdW5jdGlvblwiPT10eXBlb2YgZGUucmVzdW1lJiZ3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe2RlLnJlc3VtZSgpfSwxZTMpLGRlfWZ1bmN0aW9uIE4oZSxuLHQpe2lmKHZlKXJldHVybiB2ZTtlPWV8fDIsdD10fHw0NDEwMCxuPXR8fGU7dmFyIHI9d2luZG93Lk9mZmxpbmVBdWRpb0NvbnRleHR8fHdpbmRvdy53ZWJraXRPZmZsaW5lQXVkaW9Db250ZXh0O3JldHVybiB2ZT1yP25ldyByKGUsbix0KTpudWxsfWZ1bmN0aW9uIEkoZSl7aWYoIWRlKXJldHVybiBlO2Zvcih2YXIgbj1lLm51bWJlck9mQ2hhbm5lbHMsdD1kZS5jcmVhdGVCdWZmZXIobixlLmxlbmd0aCxlLnNhbXBsZVJhdGUpLHI9MDtyPG47cisrKXQuZ2V0Q2hhbm5lbERhdGEocikuc2V0KGUuZ2V0Q2hhbm5lbERhdGEocikpO3JldHVybiB0fWZ1bmN0aW9uIFUoZSl7Zm9yKHZhciBuPWUubnVtYmVyT2ZDaGFubmVscyx0PTA7dDxuO3QrKylBcnJheS5wcm90b3R5cGUucmV2ZXJzZS5jYWxsKGUuZ2V0Q2hhbm5lbERhdGEodCkpO3JldHVybiBlfWZ1bmN0aW9uIFcoZSxuLHQscixvKXtkZSYmKGUuc2V0VmFsdWVBdFRpbWUobixkZS5jdXJyZW50VGltZSksbz9lLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHQsZGUuY3VycmVudFRpbWUrcik6ZS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHQsZGUuY3VycmVudFRpbWUrcikpfWZ1bmN0aW9uIEgoZSl7aWYoIWRlKXJldHVybiAwO3ZhciBuPTQwLHQ9ZGUuc2FtcGxlUmF0ZS8yLHI9TWF0aC5sb2codC9uKS9NYXRoLkxOMixvPU1hdGgucG93KDIsciooZS0xKSk7cmV0dXJuIHQqb31mdW5jdGlvbiBYKGUsbix0KXtyZXR1cm4gbmV3IEcoZSxuLHQpfWZ1bmN0aW9uIFooZSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aDw9MXx8dm9pZCAwPT09YXJndW1lbnRzWzFdP1wiOlwiOmFyZ3VtZW50c1sxXSx0PU1hdGguZmxvb3IoZS82MCkscj1NYXRoLmZsb29yKGUlMzYwMCU2MCksbz0odDwxMD9cIjBcIit0OnQpK24saT1yPDEwP1wiMFwiK3I6cjtyZXR1cm4gbytpfWZ1bmN0aW9uIFEoKXtmdW5jdGlvbiBlKGUpe3JldHVybiBULmZpbmQoZSl9ZnVuY3Rpb24gbihlKXt2YXIgbj1uZXcgaihiLFQuZ2Fpbik7cmV0dXJuIGUmJmUuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gbi5hZGQoZSl9KSxufWZ1bmN0aW9uIHQoZSl7dmFyIG49ZSYmZS53ZWJBdWRpbz09PSExP251bGw6Yix0PW5ldyB6KG4sVC5nYWluKTtyZXR1cm4gdC5pc1RvdWNoTG9ja2VkPUEsZSYmKHQuaWQ9ZS5pZHx8ZS5uYW1lfHxcIlwiLHQubG9vcD0hIWUubG9vcCx0LnZvbHVtZT1lLnZvbHVtZSksVC5hZGQodCksdH1mdW5jdGlvbiByKGUsbil7dmFyIHI9dChlKS5sb2FkKGUpO3JldHVybiBuJiZuLmFkZChyLmxvYWRlcikscn1mdW5jdGlvbiBvKGUpe3ZhciBuPWUuc3JjfHxlLnVybHx8ZS5kYXRhfHxlLHQ9dm9pZCAwLG89dm9pZCAwO2lmKGllLmNvbnRhaW5zVVJMKG4pKXQ9cihlKSxvPXQubG9hZGVyO2Vsc2V7aWYoIUFycmF5LmlzQXJyYXkobil8fCFpZS5jb250YWluc1VSTChuWzBdLnNyY3x8blswXS51cmwpKXt2YXIgaT1cInNvbm8ubG9hZDogTm8gYXVkaW8gZmlsZSBVUkxzIGZvdW5kIGluIGNvbmZpZy5cIjtpZighZS5vbkVycm9yKXRocm93IG5ldyBFcnJvcihpKTtyZXR1cm4gZS5vbkVycm9yKFwiW0VSUk9SXSBcIitpKSxudWxsfXQ9W10sbz1uZXcgQy5Hcm91cCxuLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQucHVzaChyKGUsbykpfSl9cmV0dXJuIGUub25Qcm9ncmVzcyYmby5vbihcInByb2dyZXNzXCIsZnVuY3Rpb24obil7cmV0dXJuIGUub25Qcm9ncmVzcyhuKX0pLGUub25Db21wbGV0ZSYmby5vbmNlKFwiY29tcGxldGVcIixmdW5jdGlvbigpe28ub2ZmKFwicHJvZ3Jlc3NcIiksZS5vbkNvbXBsZXRlKHQpfSksby5vbmNlKFwiZXJyb3JcIixmdW5jdGlvbihuKXtvLm9mZihcImVycm9yXCIpLGUub25FcnJvcj9lLm9uRXJyb3Iobik6Y29uc29sZS5lcnJvci5jYWxsKGNvbnNvbGUsXCJbRVJST1JdIHNvbm8ubG9hZDogXCIrbil9KSxvLnN0YXJ0KCksdH1mdW5jdGlvbiBpKGUpe2lmKGllLmNvbnRhaW5zVVJMKGUpKXJldHVybiBvKGUpO3ZhciBuPXQoZSk7cmV0dXJuIG4uZGF0YT1lLmRhdGF8fGUsbn1mdW5jdGlvbiB1KGUpe3JldHVybiBULmZpbmQoZSxmdW5jdGlvbihlKXtyZXR1cm4gZS5kZXN0cm95KCl9KSxNfWZ1bmN0aW9uIGEoKXtyZXR1cm4gVC5kZXN0cm95KCksTX1mdW5jdGlvbiBjKCl7cmV0dXJuIFQubXV0ZSgpLE19ZnVuY3Rpb24gcygpe3JldHVybiBULnVuTXV0ZSgpLE19ZnVuY3Rpb24gZihlLG4pe3JldHVybiBULmZhZGUoZSxuKSxNfWZ1bmN0aW9uIGwoKXtyZXR1cm4gVC5wYXVzZSgpLE19ZnVuY3Rpb24gZCgpe3JldHVybiBULnJlc3VtZSgpLE19ZnVuY3Rpb24gdigpe3JldHVybiBULnN0b3AoKSxNfWZ1bmN0aW9uIHAoZSxuLHQpe3JldHVybiBULmZpbmQoZSxmdW5jdGlvbihlKXtyZXR1cm4gZS5wbGF5KG4sdCl9KSxNfWZ1bmN0aW9uIGcoZSl7cmV0dXJuIFQuZmluZChlLGZ1bmN0aW9uKGUpe3JldHVybiBlLnBhdXNlKCl9KSxNfWZ1bmN0aW9uIGgoZSl7cmV0dXJuIFQuZmluZChlLGZ1bmN0aW9uKGUpe3JldHVybiBlLnN0b3AoKX0pLE19ZnVuY3Rpb24gbSgpe3ZhciBlPVwic29ubyBcIit5LG49XCJTdXBwb3J0ZWQ6XCIrTS5pc1N1cHBvcnRlZCtcIiBXZWJBdWRpb0FQSTpcIitNLmhhc1dlYkF1ZGlvK1wiIFRvdWNoTG9ja2VkOlwiK0ErXCIgU3RhdGU6XCIrKGImJmIuc3RhdGUpK1wiIEV4dGVuc2lvbnM6XCIraWUuZXh0ZW5zaW9ucztpZihuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJDaHJvbWVcIik+LTEpe3ZhciB0PVtcIiVjIOKZqyBcIitlK1wiIOKZqyAlYyBcIituK1wiIFwiLFwiY29sb3I6ICNGRkZGRkY7IGJhY2tncm91bmQ6ICMzNzlGN0FcIixcImNvbG9yOiAjMUYxQzBEOyBiYWNrZ3JvdW5kOiAjRTBGQkFDXCJdO2NvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsdCl9ZWxzZSB3aW5kb3cuY29uc29sZSYmd2luZG93LmNvbnNvbGUubG9nLmNhbGwmJmNvbnNvbGUubG9nLmNhbGwoY29uc29sZSxlK1wiIFwiK24pfXZhciB5PVwiMC4xLjhcIixiPXBlLmdldENvbnRleHQoKSx3PWI/Yi5kZXN0aW5hdGlvbjpudWxsLFQ9bmV3IE8oYix3KSxNPW51bGwsQT0hMTtyZXR1cm4gQT1LLmhhbmRsZVRvdWNoTG9jayhiLGZ1bmN0aW9uKCl7QT0hMSxULnNvdW5kcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlzVG91Y2hMb2NrZWQ9ITF9KX0pLGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe1Quc291bmRzLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5wbGF5aW5nJiYoZS5wYXVzZSgpLHQucHVzaChlKSl9KX1mdW5jdGlvbiBuKCl7Zm9yKDt0Lmxlbmd0aDspdC5wb3AoKS5wbGF5KCl9dmFyIHQ9W107Sy5oYW5kbGVQYWdlVmlzaWJpbGl0eShlLG4pfSgpLE09e2NyZWF0ZVNvdW5kOmksZGVzdHJveVNvdW5kOnUsZGVzdHJveUFsbDphLGdldFNvdW5kOmUsY3JlYXRlR3JvdXA6bixmaWxlOmllLGxvYWQ6byxtdXRlOmMsdW5NdXRlOnMsZmFkZTpmLHBhdXNlQWxsOmwscmVzdW1lQWxsOmQsc3RvcEFsbDp2LHBsYXk6cCxwYXVzZTpnLHN0b3A6aCxsb2c6bSxjYW5QbGF5OmllLmNhblBsYXksY29udGV4dDpiLGdldE9mZmxpbmVDb250ZXh0OnBlLmdldE9mZmxpbmVDb250ZXh0LGVmZmVjdDpULmVmZmVjdCxleHRlbnNpb25zOmllLmV4dGVuc2lvbnMsaGFzV2ViQXVkaW86ISFiLGlzU3VwcG9ydGVkOmllLmV4dGVuc2lvbnMubGVuZ3RoPjAsZ2FpbjpULmdhaW4sdXRpbHM6cGUsVkVSU0lPTjp5LFNvdW5kOnosR3JvdXA6T30sT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTSx7aXNUb3VjaExvY2tlZDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEF9fSxzb3VuZHM6e2dldDpmdW5jdGlvbigpe3JldHVybiBULnNvdW5kcy5zbGljZSgwKX19LHZvbHVtZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFQudm9sdW1lfSxzZXQ6ZnVuY3Rpb24oZSl7VC52b2x1bWU9ZX19fSksT2JqZWN0LmZyZWV6ZShNKX12YXIgSz17fTtLLmhhbmRsZVBhZ2VWaXNpYmlsaXR5PWZ1bmN0aW9uKGUsbil7ZnVuY3Rpb24gdCgpe2RvY3VtZW50W3JdP2UoKTpuKCl9dmFyIHI9dm9pZCAwLG89dm9pZCAwO1widW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudC5oaWRkZW4/KHI9XCJoaWRkZW5cIixvPVwidmlzaWJpbGl0eWNoYW5nZVwiKTpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQubW96SGlkZGVuPyhyPVwibW96SGlkZGVuXCIsbz1cIm1venZpc2liaWxpdHljaGFuZ2VcIik6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50Lm1zSGlkZGVuPyhyPVwibXNIaWRkZW5cIixvPVwibXN2aXNpYmlsaXR5Y2hhbmdlXCIpOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudC53ZWJraXRIaWRkZW4mJihyPVwid2Via2l0SGlkZGVuXCIsbz1cIndlYmtpdHZpc2liaWxpdHljaGFuZ2VcIiksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG8mJmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIobyx0LCExKX0sSy5oYW5kbGVUb3VjaExvY2s9ZnVuY3Rpb24oZSxuKXtmdW5jdGlvbiB0KCl7ZSYmXCJzdXNwZW5kZWRcIj09PWUuc3RhdGU/ZS5yZXN1bWUoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIHI9ZS5jcmVhdGVCdWZmZXIoMSwxLDIyMDUwKSxvPWUuY3JlYXRlQnVmZmVyU291cmNlKCk7by5idWZmZXI9cixvLmNvbm5lY3QoZS5kZXN0aW5hdGlvbiksby5zdGFydCgwKSxvLnN0b3AoMCksby5kaXNjb25uZWN0KCksZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix0KSxuKCl9KTooZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix0KSxuKCkpfXZhciByPW5hdmlnYXRvci51c2VyQWdlbnQsbz0hIXIubWF0Y2goL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbml8V2luZG93cyBQaG9uZXxTeW1iaWFuT1MvaSk7cmV0dXJuIG8mJmRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsdCwhMSksb307dmFyIEo9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbD9cInN5bWJvbFwiOnR5cGVvZiBlfSxZPWZ1bmN0aW9uKGUsbil7aWYoIShlIGluc3RhbmNlb2YgbikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0sJD1mdW5jdGlvbihlLG4pe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIG4mJm51bGwhPT1uKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBuKTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKG4mJm4ucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxuJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLG4pOmUuX19wcm90b19fPW4pfSxlZT1mdW5jdGlvbihlLG4pe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hbnx8XCJvYmplY3RcIiE9dHlwZW9mIG4mJlwiZnVuY3Rpb25cIiE9dHlwZW9mIG4/ZTpufSxuZT1bXSx0ZT17fSxyZT1be2V4dDpcIm9nZ1wiLHR5cGU6J2F1ZGlvL29nZzsgY29kZWNzPVwidm9yYmlzXCInfSx7ZXh0OlwibXAzXCIsdHlwZTpcImF1ZGlvL21wZWc7XCJ9LHtleHQ6XCJvcHVzXCIsdHlwZTonYXVkaW8vb2dnOyBjb2RlY3M9XCJvcHVzXCInfSx7ZXh0Olwid2F2XCIsdHlwZTonYXVkaW8vd2F2OyBjb2RlY3M9XCIxXCInfSx7ZXh0OlwibTRhXCIsdHlwZTpcImF1ZGlvL3gtbTRhO1wifSx7ZXh0OlwibTRhXCIsdHlwZTpcImF1ZGlvL2FhYztcIn1dLG9lPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhdWRpb1wiKTtvZSYmKHJlLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIG49ISFvZS5jYW5QbGF5VHlwZShlLnR5cGUpO24mJm5lLmluZGV4T2YoZS5leHQpPT09LTEmJm5lLnB1c2goZS5leHQpLHRlW2UuZXh0XT1ufSksb2U9bnVsbCk7dmFyIGllPXtjYW5QbGF5OnRlLGNvbnRhaW5zVVJMOnMsZXh0ZW5zaW9uczpuZSxnZXRGaWxlRXh0ZW5zaW9uOmUsZ2V0U3VwcG9ydGVkRmlsZTpuLGlzQXVkaW9CdWZmZXI6dCxpc01lZGlhRWxlbWVudDpvLGlzTWVkaWFTdHJlYW06aSxpc09zY2lsbGF0b3JUeXBlOnUsaXNTY3JpcHRDb25maWc6YSxpc1VSTDpjfSx1ZT0yMjA1MDtiLmRlZmF1bHRzPXtwYW5uaW5nTW9kZWw6XCJIUlRGXCIsZGlzdGFuY2VNb2RlbDpcImxpbmVhclwiLHJlZkRpc3RhbmNlOjEsbWF4RGlzdGFuY2U6MWUzLHJvbGxvZmZGYWN0b3I6MSxjb25lSW5uZXJBbmdsZTozNjAsY29uZU91dGVyQW5nbGU6MCxjb25lT3V0ZXJHYWluOjB9LE8uRWZmZWN0PUE7dmFyIGFlPUU7RS5FdmVudEVtaXR0ZXI9RSxFLnByb3RvdHlwZS5fZXZlbnRzPXZvaWQgMCxFLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzPXZvaWQgMCxFLmRlZmF1bHRNYXhMaXN0ZW5lcnM9MTAsRS5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzPWZ1bmN0aW9uKGUpe2lmKCF4KGUpfHxlPDB8fGlzTmFOKGUpKXRocm93IFR5cGVFcnJvcihcIm4gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtyZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzPWUsdGhpc30sRS5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbihlKXt2YXIgbix0LHIsbyxpLHU7aWYodGhpcy5fZXZlbnRzfHwodGhpcy5fZXZlbnRzPXt9KSxcImVycm9yXCI9PT1lJiYoIXRoaXMuX2V2ZW50cy5lcnJvcnx8TCh0aGlzLl9ldmVudHMuZXJyb3IpJiYhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpe2lmKG49YXJndW1lbnRzWzFdLG4gaW5zdGFuY2VvZiBFcnJvcil0aHJvdyBuO3ZhciBhPW5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcrbitcIilcIik7dGhyb3cgYS5jb250ZXh0PW4sYX1pZih0PXRoaXMuX2V2ZW50c1tlXSxfKHQpKXJldHVybiExO2lmKFModCkpc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe2Nhc2UgMTp0LmNhbGwodGhpcyk7YnJlYWs7Y2FzZSAyOnQuY2FsbCh0aGlzLGFyZ3VtZW50c1sxXSk7YnJlYWs7Y2FzZSAzOnQuY2FsbCh0aGlzLGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0pO2JyZWFrO2RlZmF1bHQ6bz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSksdC5hcHBseSh0aGlzLG8pfWVsc2UgaWYoTCh0KSlmb3Iobz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSksdT10LnNsaWNlKCkscj11Lmxlbmd0aCxpPTA7aTxyO2krKyl1W2ldLmFwcGx5KHRoaXMsbyk7cmV0dXJuITB9LEUucHJvdG90eXBlLmFkZExpc3RlbmVyPWZ1bmN0aW9uKGUsbil7dmFyIHQ7aWYoIVMobikpdGhyb3cgVHlwZUVycm9yKFwibGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO3JldHVybiB0aGlzLl9ldmVudHN8fCh0aGlzLl9ldmVudHM9e30pLHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lciYmdGhpcy5lbWl0KFwibmV3TGlzdGVuZXJcIixlLFMobi5saXN0ZW5lcik/bi5saXN0ZW5lcjpuKSx0aGlzLl9ldmVudHNbZV0/TCh0aGlzLl9ldmVudHNbZV0pP3RoaXMuX2V2ZW50c1tlXS5wdXNoKG4pOnRoaXMuX2V2ZW50c1tlXT1bdGhpcy5fZXZlbnRzW2VdLG5dOnRoaXMuX2V2ZW50c1tlXT1uLEwodGhpcy5fZXZlbnRzW2VdKSYmIXRoaXMuX2V2ZW50c1tlXS53YXJuZWQmJih0PV8odGhpcy5fbWF4TGlzdGVuZXJzKT9FLmRlZmF1bHRNYXhMaXN0ZW5lcnM6dGhpcy5fbWF4TGlzdGVuZXJzLHQmJnQ+MCYmdGhpcy5fZXZlbnRzW2VdLmxlbmd0aD50JiYodGhpcy5fZXZlbnRzW2VdLndhcm5lZD0hMCxcImZ1bmN0aW9uXCI9PXR5cGVvZiBjb25zb2xlLnRyYWNlKSksdGhpc30sRS5wcm90b3R5cGUub249RS5wcm90b3R5cGUuYWRkTGlzdGVuZXIsRS5wcm90b3R5cGUub25jZT1mdW5jdGlvbihlLG4pe2Z1bmN0aW9uIHQoKXt0aGlzLnJlbW92ZUxpc3RlbmVyKGUsdCkscnx8KHI9ITAsbi5hcHBseSh0aGlzLGFyZ3VtZW50cykpfWlmKCFTKG4pKXRocm93IFR5cGVFcnJvcihcImxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTt2YXIgcj0hMTtyZXR1cm4gdC5saXN0ZW5lcj1uLHRoaXMub24oZSx0KSx0aGlzfSxFLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcj1mdW5jdGlvbihlLG4pe3ZhciB0LHIsbyxpO2lmKCFTKG4pKXRocm93IFR5cGVFcnJvcihcImxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtpZighdGhpcy5fZXZlbnRzfHwhdGhpcy5fZXZlbnRzW2VdKXJldHVybiB0aGlzO2lmKHQ9dGhpcy5fZXZlbnRzW2VdLG89dC5sZW5ndGgscj0tMSx0PT09bnx8Uyh0Lmxpc3RlbmVyKSYmdC5saXN0ZW5lcj09PW4pZGVsZXRlIHRoaXMuX2V2ZW50c1tlXSx0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXImJnRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsZSxuKTtlbHNlIGlmKEwodCkpe2ZvcihpPW87aS0tID4wOylpZih0W2ldPT09bnx8dFtpXS5saXN0ZW5lciYmdFtpXS5saXN0ZW5lcj09PW4pe3I9aTticmVha31pZihyPDApcmV0dXJuIHRoaXM7MT09PXQubGVuZ3RoPyh0Lmxlbmd0aD0wLGRlbGV0ZSB0aGlzLl9ldmVudHNbZV0pOnQuc3BsaWNlKHIsMSksdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyJiZ0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lclwiLGUsbil9cmV0dXJuIHRoaXN9LEUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycz1mdW5jdGlvbihlKXt2YXIgbix0O2lmKCF0aGlzLl9ldmVudHMpcmV0dXJuIHRoaXM7aWYoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilyZXR1cm4gMD09PWFyZ3VtZW50cy5sZW5ndGg/dGhpcy5fZXZlbnRzPXt9OnRoaXMuX2V2ZW50c1tlXSYmZGVsZXRlIHRoaXMuX2V2ZW50c1tlXSx0aGlzO2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IobiBpbiB0aGlzLl9ldmVudHMpXCJyZW1vdmVMaXN0ZW5lclwiIT09biYmdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMobik7cmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwicmVtb3ZlTGlzdGVuZXJcIiksdGhpcy5fZXZlbnRzPXt9LHRoaXN9aWYodD10aGlzLl9ldmVudHNbZV0sUyh0KSl0aGlzLnJlbW92ZUxpc3RlbmVyKGUsdCk7ZWxzZSBpZih0KWZvcig7dC5sZW5ndGg7KXRoaXMucmVtb3ZlTGlzdGVuZXIoZSx0W3QubGVuZ3RoLTFdKTtyZXR1cm4gZGVsZXRlIHRoaXMuX2V2ZW50c1tlXSx0aGlzfSxFLnByb3RvdHlwZS5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7dmFyIG47cmV0dXJuIG49dGhpcy5fZXZlbnRzJiZ0aGlzLl9ldmVudHNbZV0/Uyh0aGlzLl9ldmVudHNbZV0pP1t0aGlzLl9ldmVudHNbZV1dOnRoaXMuX2V2ZW50c1tlXS5zbGljZSgpOltdfSxFLnByb3RvdHlwZS5saXN0ZW5lckNvdW50PWZ1bmN0aW9uKGUpe2lmKHRoaXMuX2V2ZW50cyl7dmFyIG49dGhpcy5fZXZlbnRzW2VdO2lmKFMobikpcmV0dXJuIDE7aWYobilyZXR1cm4gbi5sZW5ndGh9cmV0dXJuIDB9LEUubGlzdGVuZXJDb3VudD1mdW5jdGlvbihlLG4pe3JldHVybiBlLmxpc3RlbmVyQ291bnQobil9O3ZhciBjZT1hZS5FdmVudEVtaXR0ZXIsc2U9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbigpe3JldHVybiBZKHRoaXMsbiksZWUodGhpcyxlLmNhbGwodGhpcykpfXJldHVybiAkKG4sZSksbi5wcm90b3R5cGUub2ZmPWZ1bmN0aW9uKGUsbil7cmV0dXJuIG4/dGhpcy5yZW1vdmVMaXN0ZW5lcihlLG4pOmU/dGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZSk6dGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKX0sbn0oY2UpO0MuR3JvdXA9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3ZhciBuPXMrZTthLmVtaXQoXCJwcm9ncmVzc1wiLG4vZil9ZnVuY3Rpb24gbigpe3MrKyxvKCksYS5lbWl0KFwicHJvZ3Jlc3NcIixzL2YpLHIoKX1mdW5jdGlvbiB0KGUpe2NvbnNvbGUuZXJyb3IuY2FsbChjb25zb2xlLGUpLG8oKSxhLmVtaXQoXCJlcnJvclwiLGUpLHIoKX1mdW5jdGlvbiByKCl7cmV0dXJuIDA9PT1jLmxlbmd0aD8obD1udWxsLHZvaWQgYS5lbWl0KFwiY29tcGxldGVcIikpOihsPWMucG9wKCksbC5vbihcInByb2dyZXNzXCIsZSksbC5vbmNlKFwibG9hZGVkXCIsbiksbC5vbmNlKFwiZXJyb3JcIix0KSx2b2lkIGwuc3RhcnQoKSl9ZnVuY3Rpb24gbygpe2wub2ZmKFwicHJvZ3Jlc3NcIixlKSxsLm9mZihcImxvYWRlZFwiLG4pLGwub2ZmKFwiZXJyb3JcIix0KX1mdW5jdGlvbiBpKGUpe3JldHVybiBjLnB1c2goZSksZisrLGV9ZnVuY3Rpb24gdSgpe2Y9Yy5sZW5ndGgscigpfXZhciBhPW5ldyBzZSxjPVtdLHM9MCxmPTAsbD12b2lkIDA7cmV0dXJuIE9iamVjdC5mcmVlemUoe29uOmEub24uYmluZChhKSxvbmNlOmEub25jZS5iaW5kKGEpLG9mZjphLm9mZi5iaW5kKGEpLGFkZDppLHN0YXJ0OnV9KX0sei5fX3NvdXJjZT17QnVmZmVyU291cmNlOmssTWVkaWFTb3VyY2U6RCxNaWNyb3Bob25lU291cmNlOlAsT3NjaWxsYXRvclNvdXJjZTpSLFNjcmlwdFNvdXJjZTpxfTt2YXIgZmU9TWF0aC5QSS8yLGxlPTIqTWF0aC5QSSxkZT12b2lkIDAsdmU9dm9pZCAwLHBlPU9iamVjdC5mcmVlemUoe2dldENvbnRleHQ6VixnZXRPZmZsaW5lQ29udGV4dDpOLGNsb25lQnVmZmVyOkkscmV2ZXJzZUJ1ZmZlcjpVLHJhbXA6VyxnZXRGcmVxdWVuY3k6SCxtaWNyb3Bob25lOlgsdGltZUNvZGU6Wix3YXZlZm9ybWVyOkJ9KSxnZT1uZXcgUTtyZXR1cm4gZ2V9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWJzL3Nvbm8uanMiLCIvLyBhZGRDb250cm9scy5qc1xuXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vU2V0dGluZ3MnO1xuaW1wb3J0IENvbmZpZyBmcm9tICcuLi9Db25maWcnO1xuaW1wb3J0IHsgc2F2ZUpzb24gfSBmcm9tICcuLi91dGlscyc7XG5cblxuY29uc3Qgc2ltdWxhdGVLZXkgPSAoa2V5Q29kZSwgdHlwZSwgbW9kaWZpZXJzKSA9PiB7XG5cdHZhciBldnROYW1lID0gKHR5cGVvZih0eXBlKSA9PT0gXCJzdHJpbmdcIikgPyBcImtleVwiICsgdHlwZSA6IFwia2V5ZG93blwiO1x0XG5cdHZhciBtb2RpZmllciA9ICh0eXBlb2YobW9kaWZpZXJzKSA9PT0gXCJvYmplY3RcIikgPyBtb2RpZmllciA6IHt9O1xuXG5cdHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiSFRNTEV2ZW50c1wiKTtcblx0ZXZlbnQuaW5pdEV2ZW50KGV2dE5hbWUsIHRydWUsIGZhbHNlKTtcblx0ZXZlbnQua2V5Q29kZSA9IGtleUNvZGU7XG5cdFxuXHRmb3IgKHZhciBpIGluIG1vZGlmaWVycykge1xuXHRcdGV2ZW50W2ldID0gbW9kaWZpZXJzW2ldO1xuXHR9XG5cblx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IChzY2VuZSkgPT4ge1xuXHRzZXRUaW1lb3V0KCgpPT4ge1xuXHRcdGNvbnNvbGUubG9nKCdzZXR1cCBndWknKTtcblx0XHQvLyBndWkuYWRkKENvbmZpZywgJ251bVRyZWVzJywgMSwgMTAwKS5zdGVwKDEpLm9uRmluaXNoQ2hhbmdlKFNldHRpbmdzLnJlbG9hZCk7XG5cdFx0Ly8gZ3VpLmFkZChDb25maWcsICd0cmVlU2NhbGUnLCAwLCA1KS5vbkNoYW5nZShTZXR0aW5ncy5yZWZyZXNoKTtcblx0XHQvLyBndWkuYWRkKENvbmZpZywgJ2Zsb29yUmFkaXVzJywgMSwgNSkub25GaW5pc2hDaGFuZ2UoU2V0dGluZ3MucmVsb2FkKTtcblx0XHQvLyBndWkuYWRkKENvbmZpZywgJ21heEZsb29ySGVpZ2h0JywgMCwgMSkub25GaW5pc2hDaGFuZ2UoU2V0dGluZ3MucmVmcmVzaCk7XG5cdFx0Ly8gZ3VpLmFkZChDb25maWcsICd0cmVlQnVtcEhlaWdodCcsIDAsIDEpLm9uRmluaXNoQ2hhbmdlKFNldHRpbmdzLnJlbG9hZCk7XG5cdFx0Z3VpLmFkZChDb25maWcsICdudW1TbGlkZXMnLCAxLCAxMDAwKS5zdGVwKDEpLm9uRmluaXNoQ2hhbmdlKFNldHRpbmdzLnJlbG9hZCk7XG5cdFx0Ly8gZ3VpLmFkZChDb25maWcsICdub2lzZVNjYWxlJywgMSwgMTApLm9uRmluaXNoQ2hhbmdlKFNldHRpbmdzLnJlbG9hZCk7XG5cdFx0Ly8gZ3VpLmFkZChDb25maWcsICdvdmVybGF5T3BhY2l0eScsIDAsIDEpLm9uQ2hhbmdlKFNldHRpbmdzLnJlZnJlc2gpO1xuXHRcdC8vIGd1aS5hZGQoQ29uZmlnLCAnYmxvb21TdHJlbmd0aCcsIDAsIDEpLm9uQ2hhbmdlKFNldHRpbmdzLnJlZnJlc2gpO1xuXHRcdC8vIGd1aS5hZGQoQ29uZmlnLCAnZm9nTW92aW5nU3BlZWQnLCAwLCAxKS5vbkNoYW5nZShTZXR0aW5ncy5yZWZyZXNoKTtcblx0XHQvLyBndWkuYWRkKENvbmZpZywgJ3BpeGVsYXRlTWl4aW5nJywgMCwgMSkub25DaGFuZ2UoU2V0dGluZ3MucmVmcmVzaCk7XG5cdFx0Ly8gZ3VpLmFkZChDb25maWcsICdzbm93U3BlZWQnLCAwLCAxKS5vbkNoYW5nZShTZXR0aW5ncy5yZWZyZXNoKTtcblx0XHQvLyBndWkuYWRkKENvbmZpZywgJ3Nob3dTbm93JykubmFtZSgnU2hvdyBTbm93Jykub25DaGFuZ2UoU2V0dGluZ3MucmVmcmVzaCk7XG5cdFx0Ly8gZ3VpLmFkZChDb25maWcsICdncmFkaWVudE1hcCcsIDAsIDEpLm5hbWUoJ0dyYWRpZW50IE1hcCcpLm9uQ2hhbmdlKFNldHRpbmdzLnJlZnJlc2gpO1xuXHRcdC8vIGd1aS5hZGQoQ29uZmlnLCAnZnhhYScpLm5hbWUoJ1Bvc3QgRWZmZWN0Jykub25DaGFuZ2UoU2V0dGluZ3MucmVmcmVzaCk7XG5cdFx0Ly8gZ3VpLmFkZChzY2VuZSwgJ3Jlc2V0Q2FtZXJhJyk7XG5cblxuXHRcdGNvbnN0IG8gPSB7XG5cdFx0XHRzYXZlU2V0dGluZ3M6KCkgPT4ge1xuXHRcdFx0XHRzYXZlSnNvbihDb25maWcsICd4bWFzLXNldHRpbmdzJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gZ3VpLmFkZChvLCAnc2F2ZVNldHRpbmdzJykubmFtZSgnU2F2ZSBTZXR0aW5ncycpO1xuXHRcdHNldFRpbWVvdXQoKCk9PiB7XG5cdFx0XHQvLyBzaW11bGF0ZUtleSg3Mik7XG5cdFx0fSwgNTAwKTtcblx0XHRcblx0fSwgNTAwKTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvZGVidWcvYWRkQ29udHJvbHMuanMiLCIvKiFcbiAqIFZFUlNJT046IDIuMC4yXG4gKiBEQVRFOiAyMDE4LTA4LTI3XG4gKiBVUERBVEVTIEFORCBET0NTIEFUOiBodHRwOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwOC0yMDE4LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHdvcmsgaXMgc3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cDovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBzb2Z0d2FyZSBhZ3JlZW1lbnQgdGhhdCB3YXMgaXNzdWVkIHdpdGggeW91ciBtZW1iZXJzaGlwLlxuICogXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiAqKi9cblxuaW1wb3J0IFR3ZWVuTGl0ZSwgeyBUd2VlblBsdWdpbiwgRWFzZSwgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciB9IGZyb20gXCIuL1R3ZWVuTGl0ZS5qc1wiO1xuaW1wb3J0IFR3ZWVuTWF4QmFzZSBmcm9tIFwiLi9Ud2Vlbk1heEJhc2UuanNcIjtcbmltcG9ydCBDU1NQbHVnaW4gZnJvbSBcIi4vQ1NTUGx1Z2luLmpzXCI7XG5pbXBvcnQgQXR0clBsdWdpbiBmcm9tIFwiLi9BdHRyUGx1Z2luLmpzXCI7XG5pbXBvcnQgUm91bmRQcm9wc1BsdWdpbiBmcm9tIFwiLi9Sb3VuZFByb3BzUGx1Z2luLmpzXCI7XG5pbXBvcnQgRGlyZWN0aW9uYWxSb3RhdGlvblBsdWdpbiBmcm9tIFwiLi9EaXJlY3Rpb25hbFJvdGF0aW9uUGx1Z2luLmpzXCI7XG5pbXBvcnQgVGltZWxpbmVMaXRlIGZyb20gXCIuL1RpbWVsaW5lTGl0ZS5qc1wiO1xuaW1wb3J0IFRpbWVsaW5lTWF4IGZyb20gXCIuL1RpbWVsaW5lTWF4LmpzXCI7XG5pbXBvcnQgQmV6aWVyUGx1Z2luIGZyb20gXCIuL0JlemllclBsdWdpbi5qc1wiO1xuaW1wb3J0IHsgQmFjaywgRWxhc3RpYywgQm91bmNlLCBSb3VnaEVhc2UsIFNsb3dNbywgU3RlcHBlZEVhc2UsIENpcmMsIEV4cG8sIFNpbmUsIEV4cG9TY2FsZUVhc2UgfSBmcm9tIFwiLi9FYXNlUGFjay5qc1wiO1xuXG4vL3RoZSBmb2xsb3dpbmcgdHdvIGxpbmVzIGFyZSBkZXNpZ25lZCB0byBwcmV2ZW50IHRyZWUgc2hha2luZyBvZiB0aGUgY2xhc3NlcyB0aGF0IHdlcmUgaGlzdG9yaWNhbGx5IGluY2x1ZGVkIHdpdGggVHdlZW5NYXggKG90aGVyd2lzZSwgZm9sa3Mgd291bGQgaGF2ZSB0byByZWZlcmVuY2UgQ1NTUGx1Z2luLCBmb3IgZXhhbXBsZSwgdG8gZW5zdXJlIHRoZWlyIENTUy1yZWxhdGVkIGFuaW1hdGlvbnMgd29ya2VkKVxuZXhwb3J0IHZhciBUd2Vlbk1heCA9IFR3ZWVuTWF4QmFzZTtcblR3ZWVuTWF4Ll9hdXRvQWN0aXZhdGVkID0gW1RpbWVsaW5lTGl0ZSwgVGltZWxpbmVNYXgsIENTU1BsdWdpbiwgQXR0clBsdWdpbiwgQmV6aWVyUGx1Z2luLCBSb3VuZFByb3BzUGx1Z2luLCBEaXJlY3Rpb25hbFJvdGF0aW9uUGx1Z2luLCBCYWNrLCBFbGFzdGljLCBCb3VuY2UsIFJvdWdoRWFzZSwgU2xvd01vLCBTdGVwcGVkRWFzZSwgQ2lyYywgRXhwbywgU2luZSwgRXhwb1NjYWxlRWFzZV07XG5cbmV4cG9ydCB7IFR3ZWVuTWF4IGFzIGRlZmF1bHQgfTtcbmV4cG9ydCB7IFR3ZWVuTGl0ZSwgVGltZWxpbmVMaXRlLCBUaW1lbGluZU1heCwgQ1NTUGx1Z2luLCBBdHRyUGx1Z2luLCBCZXppZXJQbHVnaW4sIERpcmVjdGlvbmFsUm90YXRpb25QbHVnaW4sIFJvdW5kUHJvcHNQbHVnaW4sIFR3ZWVuUGx1Z2luLCBFYXNlLCBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIFBvd2VyNCwgTGluZWFyLCBCYWNrLCBFbGFzdGljLCBCb3VuY2UsIFJvdWdoRWFzZSwgU2xvd01vLCBTdGVwcGVkRWFzZSwgQ2lyYywgRXhwbywgU2luZSwgRXhwb1NjYWxlRWFzZSB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ3NhcC9Ud2Vlbk1heC5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbE1vZHVsZSkge1xyXG5cdGlmKCFvcmlnaW5hbE1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdHZhciBtb2R1bGUgPSBPYmplY3QuY3JlYXRlKG9yaWdpbmFsTW9kdWxlKTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImV4cG9ydHNcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vaGFybW9ueS1tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogVkVSU0lPTjogMi4wLjJcbiAqIERBVEU6IDIwMTgtMDgtMjdcbiAqIFVQREFURVMgQU5EIERPQ1MgQVQ6IGh0dHA6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDA4LTIwMTgsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgd29yayBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIHNvZnR3YXJlIGFncmVlbWVudCB0aGF0IHdhcyBpc3N1ZWQgd2l0aCB5b3VyIG1lbWJlcnNoaXAuXG4gKiBcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICoqL1xuXG5pbXBvcnQgVHdlZW5MaXRlLCB7IF9nc1Njb3BlLCBnbG9iYWxzLCBBbmltYXRpb24sIFNpbXBsZVRpbWVsaW5lLCBFYXNlLCBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIFBvd2VyNCwgTGluZWFyICB9IGZyb20gXCIuL1R3ZWVuTGl0ZS5qc1wiO1xuXG5cbl9nc1Njb3BlLl9nc0RlZmluZShcIlR3ZWVuTWF4XCIsIFtcImNvcmUuQW5pbWF0aW9uXCIsXCJjb3JlLlNpbXBsZVRpbWVsaW5lXCIsXCJUd2VlbkxpdGVcIl0sIGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9zbGljZSA9IGZ1bmN0aW9uKGEpIHsgLy9kb24ndCB1c2UgW10uc2xpY2UgYmVjYXVzZSB0aGF0IGRvZXNuJ3Qgd29yayBpbiBJRTggd2l0aCBhIE5vZGVMaXN0IHRoYXQncyByZXR1cm5lZCBieSBxdWVyeVNlbGVjdG9yQWxsKClcblx0XHRcdFx0dmFyIGIgPSBbXSxcblx0XHRcdFx0XHRsID0gYS5sZW5ndGgsXG5cdFx0XHRcdFx0aTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSAhPT0gbDsgYi5wdXNoKGFbaSsrXSkpO1xuXHRcdFx0XHRyZXR1cm4gYjtcblx0XHRcdH0sXG5cdFx0XHRfYXBwbHlDeWNsZSA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldHMsIGkpIHtcblx0XHRcdFx0dmFyIGFsdCA9IHZhcnMuY3ljbGUsXG5cdFx0XHRcdFx0cCwgdmFsO1xuXHRcdFx0XHRmb3IgKHAgaW4gYWx0KSB7XG5cdFx0XHRcdFx0dmFsID0gYWx0W3BdO1xuXHRcdFx0XHRcdHZhcnNbcF0gPSAodHlwZW9mKHZhbCkgPT09IFwiZnVuY3Rpb25cIikgPyB2YWwoaSwgdGFyZ2V0c1tpXSkgOiB2YWxbaSAlIHZhbC5sZW5ndGhdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSB2YXJzLmN5Y2xlO1xuXHRcdFx0fSxcblx0XHRcdFR3ZWVuTWF4ID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0XHRUd2VlbkxpdGUuY2FsbCh0aGlzLCB0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHRcdFx0dGhpcy5fY3ljbGUgPSAwO1xuXHRcdFx0XHR0aGlzLl95b3lvID0gKHRoaXMudmFycy55b3lvID09PSB0cnVlIHx8ICEhdGhpcy52YXJzLnlveW9FYXNlKTtcblx0XHRcdFx0dGhpcy5fcmVwZWF0ID0gdGhpcy52YXJzLnJlcGVhdCB8fCAwO1xuXHRcdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHRoaXMudmFycy5yZXBlYXREZWxheSB8fCAwO1xuXHRcdFx0XHRpZiAodGhpcy5fcmVwZWF0KSB7XG5cdFx0XHRcdFx0dGhpcy5fdW5jYWNoZSh0cnVlKTsgLy9lbnN1cmVzIHRoYXQgaWYgdGhlcmUgaXMgYW55IHJlcGVhdCwgdGhlIHRvdGFsRHVyYXRpb24gd2lsbCBnZXQgcmVjYWxjdWxhdGVkIHRvIGFjY3VyYXRlbHkgcmVwb3J0IGl0LlxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucmVuZGVyID0gVHdlZW5NYXgucHJvdG90eXBlLnJlbmRlcjsgLy9zcGVlZCBvcHRpbWl6YXRpb24gKGF2b2lkIHByb3RvdHlwZSBsb29rdXAgb24gdGhpcyBcImhvdFwiIG1ldGhvZClcblx0XHRcdH0sXG5cdFx0XHRfdGlueU51bSA9IDAuMDAwMDAwMDAwMSxcblx0XHRcdFR3ZWVuTGl0ZUludGVybmFscyA9IFR3ZWVuTGl0ZS5faW50ZXJuYWxzLFxuXHRcdFx0X2lzU2VsZWN0b3IgPSBUd2VlbkxpdGVJbnRlcm5hbHMuaXNTZWxlY3Rvcixcblx0XHRcdF9pc0FycmF5ID0gVHdlZW5MaXRlSW50ZXJuYWxzLmlzQXJyYXksXG5cdFx0XHRwID0gVHdlZW5NYXgucHJvdG90eXBlID0gVHdlZW5MaXRlLnRvKHt9LCAwLjEsIHt9KSxcblx0XHRcdF9ibGFua0FycmF5ID0gW107XG5cblx0XHRUd2Vlbk1heC52ZXJzaW9uID0gXCIyLjAuMlwiO1xuXHRcdHAuY29uc3RydWN0b3IgPSBUd2Vlbk1heDtcblx0XHRwLmtpbGwoKS5fZ2MgPSBmYWxzZTtcblx0XHRUd2Vlbk1heC5raWxsVHdlZW5zT2YgPSBUd2Vlbk1heC5raWxsRGVsYXllZENhbGxzVG8gPSBUd2VlbkxpdGUua2lsbFR3ZWVuc09mO1xuXHRcdFR3ZWVuTWF4LmdldFR3ZWVuc09mID0gVHdlZW5MaXRlLmdldFR3ZWVuc09mO1xuXHRcdFR3ZWVuTWF4LmxhZ1Ntb290aGluZyA9IFR3ZWVuTGl0ZS5sYWdTbW9vdGhpbmc7XG5cdFx0VHdlZW5NYXgudGlja2VyID0gVHdlZW5MaXRlLnRpY2tlcjtcblx0XHRUd2Vlbk1heC5yZW5kZXIgPSBUd2VlbkxpdGUucmVuZGVyO1xuXG5cdFx0cC5pbnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl95b3lvID0gKHRoaXMudmFycy55b3lvID09PSB0cnVlIHx8ICEhdGhpcy52YXJzLnlveW9FYXNlKTtcblx0XHRcdHRoaXMuX3JlcGVhdCA9IHRoaXMudmFycy5yZXBlYXQgfHwgMDtcblx0XHRcdHRoaXMuX3JlcGVhdERlbGF5ID0gdGhpcy52YXJzLnJlcGVhdERlbGF5IHx8IDA7XG5cdFx0XHR0aGlzLl95b3lvRWFzZSA9IG51bGw7XG5cdFx0XHR0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0cmV0dXJuIFR3ZWVuTGl0ZS5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdH07XG5cblx0XHRwLnVwZGF0ZVRvID0gZnVuY3Rpb24odmFycywgcmVzZXREdXJhdGlvbikge1xuXHRcdFx0dmFyIGN1clJhdGlvID0gdGhpcy5yYXRpbyxcblx0XHRcdFx0aW1tZWRpYXRlID0gdGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlciB8fCB2YXJzLmltbWVkaWF0ZVJlbmRlcixcblx0XHRcdFx0cDtcblx0XHRcdGlmIChyZXNldER1cmF0aW9uICYmIHRoaXMuX3N0YXJ0VGltZSA8IHRoaXMuX3RpbWVsaW5lLl90aW1lKSB7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IHRoaXMuX3RpbWVsaW5lLl90aW1lO1xuXHRcdFx0XHR0aGlzLl91bmNhY2hlKGZhbHNlKTtcblx0XHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZWxpbmUuaW5zZXJ0KHRoaXMsIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX2RlbGF5KTsgLy9lbnN1cmVzIHRoYXQgYW55IG5lY2Vzc2FyeSByZS1zZXF1ZW5jaW5nIG9mIEFuaW1hdGlvbnMgaW4gdGhlIHRpbWVsaW5lIG9jY3VycyB0byBtYWtlIHN1cmUgdGhlIHJlbmRlcmluZyBvcmRlciBpcyBjb3JyZWN0LlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHR0aGlzLnZhcnNbcF0gPSB2YXJzW3BdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2luaXR0ZWQgfHwgaW1tZWRpYXRlKSB7XG5cdFx0XHRcdGlmIChyZXNldER1cmF0aW9uKSB7XG5cdFx0XHRcdFx0dGhpcy5faW5pdHRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChpbW1lZGlhdGUpIHtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyKDAsIHRydWUsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fZ2MpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCAmJiB0aGlzLl9maXJzdFBUKSB7XG5cdFx0XHRcdFx0XHRUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQoXCJfb25EaXNhYmxlXCIsIHRoaXMpOyAvL2luIGNhc2UgYSBwbHVnaW4gbGlrZSBNb3Rpb25CbHVyIG11c3QgcGVyZm9ybSBzb21lIGNsZWFudXAgdGFza3Ncblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgLyB0aGlzLl9kdXJhdGlvbiA+IDAuOTk4KSB7IC8vaWYgdGhlIHR3ZWVuIGhhcyBmaW5pc2hlZCAob3IgY29tZSBleHRyZW1lbHkgY2xvc2UgdG8gZmluaXNoaW5nKSwgd2UganVzdCBuZWVkIHRvIHJld2luZCBpdCB0byAwIGFuZCB0aGVuIHJlbmRlciBpdCBhZ2FpbiBhdCB0aGUgZW5kIHdoaWNoIGZvcmNlcyBpdCB0byByZS1pbml0aWFsaXplIChwYXJzaW5nIHRoZSBuZXcgdmFycykuIFdlIGFsbG93IHR3ZWVucyB0aGF0IGFyZSBjbG9zZSB0byBmaW5pc2hpbmcgKGJ1dCBoYXZlbid0IHF1aXRlIGZpbmlzaGVkKSB0byB3b3JrIHRoaXMgd2F5IHRvbyBiZWNhdXNlIG90aGVyd2lzZSwgdGhlIHZhbHVlcyBhcmUgc28gc21hbGwgd2hlbiBkZXRlcm1pbmluZyB3aGVyZSB0byBwcm9qZWN0IHRoZSBzdGFydGluZyB2YWx1ZXMgdGhhdCBiaW5hcnkgbWF0aCBpc3N1ZXMgY3JlZXAgaW4gYW5kIGNhbiBtYWtlIHRoZSB0d2VlbiBhcHBlYXIgdG8gcmVuZGVyIGluY29ycmVjdGx5IHdoZW4gcnVuIGJhY2t3YXJkcy5cblx0XHRcdFx0XHRcdHZhciBwcmV2VGltZSA9IHRoaXMuX3RvdGFsVGltZTtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyKDAsIHRydWUsIGZhbHNlKTtcblx0XHRcdFx0XHRcdHRoaXMuX2luaXR0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyKHByZXZUaW1lLCB0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuX2luaXR0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHRoaXMuX2luaXQoKTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLl90aW1lID4gMCB8fCBpbW1lZGlhdGUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGludiA9IDEgLyAoMSAtIGN1clJhdGlvKSxcblx0XHRcdFx0XHRcdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQsIGVuZFZhbHVlO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IHB0LnMgKyBwdC5jO1xuXHRcdFx0XHRcdFx0XHRcdHB0LmMgKj0gaW52O1xuXHRcdFx0XHRcdFx0XHRcdHB0LnMgPSBlbmRWYWx1ZSAtIHB0LmM7XG5cdFx0XHRcdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIGlmICh0aGlzLl9kdXJhdGlvbiA9PT0gMCAmJiB0aGlzLnZhcnMucmVwZWF0KSB7IC8vemVybyBkdXJhdGlvbiB0d2VlbnMgdGhhdCByZW5kZXIgaW1tZWRpYXRlbHkgaGF2ZSByZW5kZXIoKSBjYWxsZWQgZnJvbSBUd2VlbkxpdGUncyBjb25zdHJ1Y3RvciwgYmVmb3JlIFR3ZWVuTWF4J3MgY29uc3RydWN0b3IgaGFzIGZpbmlzaGVkIHNldHRpbmcgX3JlcGVhdCwgX3JlcGVhdERlbGF5LCBhbmQgX3lveW8gd2hpY2ggYXJlIGNyaXRpY2FsIGluIGRldGVybWluaW5nIHRvdGFsRHVyYXRpb24oKSBzbyB3ZSBuZWVkIHRvIGNhbGwgaW52YWxpZGF0ZSgpIHdoaWNoIGlzIGEgbG93LWtiIHdheSB0byBnZXQgdGhvc2Ugc2V0IHByb3Blcmx5LlxuXHRcdFx0XHR0aGlzLmludmFsaWRhdGUoKTtcblx0XHRcdH1cblx0XHRcdHZhciB0b3RhbER1ciA9ICghdGhpcy5fZGlydHkpID8gdGhpcy5fdG90YWxEdXJhdGlvbiA6IHRoaXMudG90YWxEdXJhdGlvbigpLFxuXHRcdFx0XHRwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdHByZXZUb3RhbFRpbWUgPSB0aGlzLl90b3RhbFRpbWUsXG5cdFx0XHRcdHByZXZDeWNsZSA9IHRoaXMuX2N5Y2xlLFxuXHRcdFx0XHRkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uLFxuXHRcdFx0XHRwcmV2UmF3UHJldlRpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSxcblx0XHRcdFx0aXNDb21wbGV0ZSwgY2FsbGJhY2ssIHB0LCBjeWNsZUR1cmF0aW9uLCByLCB0eXBlLCBwb3csIHJhd1ByZXZUaW1lLCB5b3lvRWFzZTtcblx0XHRcdGlmICh0aW1lID49IHRvdGFsRHVyIC0gMC4wMDAwMDAxICYmIHRpbWUgPj0gMCkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRvdGFsRHVyO1xuXHRcdFx0XHR0aGlzLl9jeWNsZSA9IHRoaXMuX3JlcGVhdDtcblx0XHRcdFx0aWYgKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gMDtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMCkgOiAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXJhdGlvbjtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMSkgOiAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25Db21wbGV0ZVwiO1xuXHRcdFx0XHRcdGZvcmNlID0gKGZvcmNlIHx8IHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbik7IC8vb3RoZXJ3aXNlLCBpZiB0aGUgYW5pbWF0aW9uIGlzIHVucGF1c2VkL2FjdGl2YXRlZCBhZnRlciBpdCdzIGFscmVhZHkgZmluaXNoZWQsIGl0IGRvZXNuJ3QgZ2V0IHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IHRpbWVsaW5lLlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCkgaWYgKHRoaXMuX2luaXR0ZWQgfHwgIXRoaXMudmFycy5sYXp5IHx8IGZvcmNlKSB7IC8vemVyby1kdXJhdGlvbiB0d2VlbnMgYXJlIHRyaWNreSBiZWNhdXNlIHdlIG11c3QgZGlzY2VybiB0aGUgbW9tZW50dW0vZGlyZWN0aW9uIG9mIHRpbWUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN0YXJ0aW5nIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQgb3IgdGhlIGVuZGluZyB2YWx1ZXMuIElmIHRoZSBcInBsYXloZWFkXCIgb2YgaXRzIHRpbWVsaW5lIGdvZXMgcGFzdCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb24gb3IgbGFuZHMgZGlyZWN0bHkgb24gaXQsIHRoZSBlbmQgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCwgYnV0IGlmIHRoZSB0aW1lbGluZSdzIFwicGxheWhlYWRcIiBtb3ZlcyBwYXN0IGl0IGluIHRoZSBiYWNrd2FyZCBkaXJlY3Rpb24gKGZyb20gYSBwb3N0aXRpdmUgdGltZSB0byBhIG5lZ2F0aXZlIHRpbWUpLCB0aGUgc3RhcnRpbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQuXG5cdFx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0VGltZSA9PT0gdGhpcy5fdGltZWxpbmUuX2R1cmF0aW9uKSB7IC8vaWYgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGlzIGF0IHRoZSBWRVJZIGVuZCBvZiBhIHRpbWVsaW5lIGFuZCB0aGF0IHRpbWVsaW5lIHJlbmRlcnMgYXQgaXRzIGVuZCwgaXQgd2lsbCB0eXBpY2FsbHkgYWRkIGEgdGlueSBiaXQgb2YgY3VzaGlvbiB0byB0aGUgcmVuZGVyIHRpbWUgdG8gcHJldmVudCByb3VuZGluZyBlcnJvcnMgZnJvbSBnZXR0aW5nIGluIHRoZSB3YXkgb2YgdHdlZW5zIHJlbmRlcmluZyB0aGVpciBWRVJZIGVuZC4gSWYgd2UgdGhlbiByZXZlcnNlKCkgdGhhdCB0aW1lbGluZSwgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gd2lsbCB0cmlnZ2VyIGl0cyBvblJldmVyc2VDb21wbGV0ZSBldmVuIHRob3VnaCB0ZWNobmljYWxseSB0aGUgcGxheWhlYWQgZGlkbid0IHBhc3Mgb3ZlciBpdCBhZ2Fpbi4gSXQncyBhIHZlcnkgc3BlY2lmaWMgZWRnZSBjYXNlIHdlIG11c3QgYWNjb21tb2RhdGUuXG5cdFx0XHRcdFx0XHR0aW1lID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA8IDAgfHwgKHRpbWUgPD0gMCAmJiB0aW1lID49IC0wLjAwMDAwMDEpIHx8IChwcmV2UmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHRoaXMuZGF0YSAhPT0gXCJpc1BhdXNlXCIpKSBpZiAocHJldlJhd1ByZXZUaW1lICE9PSB0aW1lKSB7IC8vbm90ZTogd2hlbiB0aGlzLmRhdGEgaXMgXCJpc1BhdXNlXCIsIGl0J3MgYSBjYWxsYmFjayBhZGRlZCBieSBhZGRQYXVzZSgpIG9uIGEgdGltZWxpbmUgdGhhdCB3ZSBzaG91bGQgbm90IGJlIHRyaWdnZXJlZCB3aGVuIExFQVZJTkcgaXRzIGV4YWN0IHN0YXJ0IHRpbWUuIEluIG90aGVyIHdvcmRzLCB0bC5hZGRQYXVzZSgxKS5wbGF5KDEpIHNob3VsZG4ndCBwYXVzZS5cblx0XHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPiBfdGlueU51bSkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSByYXdQcmV2VGltZSA9ICghc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCBwcmV2UmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAodGltZSA8IDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMsIHJvdW5kIHN1cGVyIHNtYWxsIHZhbHVlcyB0byAwLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdGhpcy5fY3ljbGUgPSAwO1xuXHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMCkgOiAwO1xuXHRcdFx0XHRpZiAocHJldlRvdGFsVGltZSAhPT0gMCB8fCAoZHVyYXRpb24gPT09IDAgJiYgcHJldlJhd1ByZXZUaW1lID4gMCkpIHtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRpbWUgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwKSBpZiAodGhpcy5faW5pdHRlZCB8fCAhdGhpcy52YXJzLmxhenkgfHwgZm9yY2UpIHsgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyBhcmUgdHJpY2t5IGJlY2F1c2Ugd2UgbXVzdCBkaXNjZXJuIHRoZSBtb21lbnR1bS9kaXJlY3Rpb24gb2YgdGltZSBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc3RhcnRpbmcgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCBvciB0aGUgZW5kaW5nIHZhbHVlcy4gSWYgdGhlIFwicGxheWhlYWRcIiBvZiBpdHMgdGltZWxpbmUgZ29lcyBwYXN0IHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbiBvciBsYW5kcyBkaXJlY3RseSBvbiBpdCwgdGhlIGVuZCB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkLCBidXQgaWYgdGhlIHRpbWVsaW5lJ3MgXCJwbGF5aGVhZFwiIG1vdmVzIHBhc3QgaXQgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiAoZnJvbSBhIHBvc3RpdGl2ZSB0aW1lIHRvIGEgbmVnYXRpdmUgdGltZSksIHRoZSBzdGFydGluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZC5cblx0XHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPj0gMCkge1xuXHRcdFx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJhd1ByZXZUaW1lID0gKCFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCkgeyAvL2lmIHdlIHJlbmRlciB0aGUgdmVyeSBiZWdpbm5pbmcgKHRpbWUgPT0gMCkgb2YgYSBmcm9tVG8oKSwgd2UgbXVzdCBmb3JjZSB0aGUgcmVuZGVyIChub3JtYWwgdHdlZW5zIHdvdWxkbid0IG5lZWQgdG8gcmVuZGVyIGF0IGEgdGltZSBvZiAwIHdoZW4gdGhlIHByZXZUaW1lIHdhcyBhbHNvIDApLiBUaGlzIGlzIGFsc28gbWFuZGF0b3J5IHRvIG1ha2Ugc3VyZSBvdmVyd3JpdGluZyBraWNrcyBpbiBpbW1lZGlhdGVseS5cblx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aW1lO1xuXHRcdFx0XHRpZiAodGhpcy5fcmVwZWF0ICE9PSAwKSB7XG5cdFx0XHRcdFx0Y3ljbGVEdXJhdGlvbiA9IGR1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXk7XG5cdFx0XHRcdFx0dGhpcy5fY3ljbGUgPSAodGhpcy5fdG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbikgPj4gMDsgLy9vcmlnaW5hbGx5IF90b3RhbFRpbWUgJSBjeWNsZUR1cmF0aW9uIGJ1dCBmbG9hdGluZyBwb2ludCBlcnJvcnMgY2F1c2VkIHByb2JsZW1zLCBzbyBJIG5vcm1hbGl6ZWQgaXQuICg0ICUgMC44IHNob3VsZCBiZSAwIGJ1dCBzb21lIGJyb3dzZXJzIHJlcG9ydCBpdCBhcyAwLjc5OTk5OTk5ISlcblx0XHRcdFx0XHRpZiAodGhpcy5fY3ljbGUgIT09IDApIGlmICh0aGlzLl9jeWNsZSA9PT0gdGhpcy5fdG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbiAmJiBwcmV2VG90YWxUaW1lIDw9IHRpbWUpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2N5Y2xlLS07IC8vb3RoZXJ3aXNlIHdoZW4gcmVuZGVyZWQgZXhhY3RseSBhdCB0aGUgZW5kIHRpbWUsIGl0IHdpbGwgYWN0IGFzIHRob3VnaCBpdCBpcyByZXBlYXRpbmcgKGF0IHRoZSBiZWdpbm5pbmcpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgLSAodGhpcy5fY3ljbGUgKiBjeWNsZUR1cmF0aW9uKTtcblx0XHRcdFx0XHRpZiAodGhpcy5feW95bykgaWYgKCh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyYXRpb24gLSB0aGlzLl90aW1lO1xuXHRcdFx0XHRcdFx0eW95b0Vhc2UgPSB0aGlzLl95b3lvRWFzZSB8fCB0aGlzLnZhcnMueW95b0Vhc2U7IC8vbm90ZTogd2UgZG9uJ3Qgc2V0IHRoaXMuX3lveW9FYXNlIGluIF9pbml0KCkgbGlrZSB3ZSBkbyBvdGhlciBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQncyBUd2Vlbk1heC1zcGVjaWZpYyBhbmQgZG9pbmcgaXQgaGVyZSBhbGxvd3MgdXMgdG8gb3B0aW1pemUgcGVyZm9ybWFuY2UgKG1vc3QgdHdlZW5zIGRvbid0IGhhdmUgYSB5b3lvRWFzZSkuIE5vdGUgdGhhdCB3ZSBhbHNvIG11c3Qgc2tpcCB0aGUgdGhpcy5yYXRpbyBjYWxjdWxhdGlvbiBmdXJ0aGVyIGRvd24gcmlnaHQgYWZ0ZXIgd2UgX2luaXQoKSBpbiB0aGlzIGZ1bmN0aW9uLCBiZWNhdXNlIHdlJ3JlIGRvaW5nIGl0IGhlcmUuXG5cdFx0XHRcdFx0XHRpZiAoeW95b0Vhc2UpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0aGlzLl95b3lvRWFzZSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICh5b3lvRWFzZSA9PT0gdHJ1ZSAmJiAhdGhpcy5faW5pdHRlZCkgeyAvL2lmIGl0J3Mgbm90IGluaXR0ZWQgYW5kIHlveW9FYXNlIGlzIHRydWUsIHRoaXMuX2Vhc2Ugd29uJ3QgaGF2ZSBiZWVuIHBvcHVsYXRlZCB5ZXQgc28gd2UgbXVzdCBkaXNjZXJuIGl0IGhlcmUuXG5cdFx0XHRcdFx0XHRcdFx0XHR5b3lvRWFzZSA9IHRoaXMudmFycy5lYXNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5feW95b0Vhc2UgPSB5b3lvRWFzZSA9ICF5b3lvRWFzZSA/IFR3ZWVuTGl0ZS5kZWZhdWx0RWFzZSA6ICh5b3lvRWFzZSBpbnN0YW5jZW9mIEVhc2UpID8geW95b0Vhc2UgOiAodHlwZW9mKHlveW9FYXNlKSA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyBFYXNlKHlveW9FYXNlLCB0aGlzLnZhcnMuZWFzZVBhcmFtcykgOiBFYXNlLm1hcFt5b3lvRWFzZV0gfHwgVHdlZW5MaXRlLmRlZmF1bHRFYXNlO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl95b3lvRWFzZSA9IHlveW9FYXNlID0gKHlveW9FYXNlID09PSB0cnVlKSA/IHRoaXMuX2Vhc2UgOiAoeW95b0Vhc2UgaW5zdGFuY2VvZiBFYXNlKSA/IHlveW9FYXNlIDogRWFzZS5tYXBbeW95b0Vhc2VdO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0geW95b0Vhc2UgPyAxIC0geW95b0Vhc2UuZ2V0UmF0aW8oKGR1cmF0aW9uIC0gdGhpcy5fdGltZSkgLyBkdXJhdGlvbikgOiAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSA+IGR1cmF0aW9uKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyYXRpb247XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lIDwgMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl9lYXNlVHlwZSAmJiAheW95b0Vhc2UpIHtcblx0XHRcdFx0XHRyID0gdGhpcy5fdGltZSAvIGR1cmF0aW9uO1xuXHRcdFx0XHRcdHR5cGUgPSB0aGlzLl9lYXNlVHlwZTtcblx0XHRcdFx0XHRwb3cgPSB0aGlzLl9lYXNlUG93ZXI7XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDEgfHwgKHR5cGUgPT09IDMgJiYgciA+PSAwLjUpKSB7XG5cdFx0XHRcdFx0XHRyID0gMSAtIHI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0eXBlID09PSAzKSB7XG5cdFx0XHRcdFx0XHRyICo9IDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwb3cgPT09IDEpIHtcblx0XHRcdFx0XHRcdHIgKj0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gMikge1xuXHRcdFx0XHRcdFx0ciAqPSByICogcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gMykge1xuXHRcdFx0XHRcdFx0ciAqPSByICogciAqIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDQpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHIgKiByICogcjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IDEgLSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gMikge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lIC8gZHVyYXRpb24gPCAwLjUpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSByIC8gMjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IDEgLSAociAvIDIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCF5b3lvRWFzZSkge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKHRoaXMuX3RpbWUgLyBkdXJhdGlvbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocHJldlRpbWUgPT09IHRoaXMuX3RpbWUgJiYgIWZvcmNlICYmIHByZXZDeWNsZSA9PT0gdGhpcy5fY3ljbGUpIHtcblx0XHRcdFx0aWYgKHByZXZUb3RhbFRpbWUgIT09IHRoaXMuX3RvdGFsVGltZSkgaWYgKHRoaXMuX29uVXBkYXRlKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7IC8vc28gdGhhdCBvblVwZGF0ZSBmaXJlcyBldmVuIGR1cmluZyB0aGUgcmVwZWF0RGVsYXkgLSBhcyBsb25nIGFzIHRoZSB0b3RhbFRpbWUgY2hhbmdlZCwgd2Ugc2hvdWxkIHRyaWdnZXIgb25VcGRhdGUuXG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2UgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdHRoaXMuX2luaXQoKTtcblx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkIHx8IHRoaXMuX2djKSB7IC8vaW1tZWRpYXRlUmVuZGVyIHR3ZWVucyB0eXBpY2FsbHkgd29uJ3QgaW5pdGlhbGl6ZSB1bnRpbCB0aGUgcGxheWhlYWQgYWR2YW5jZXMgKF90aW1lIGlzIGdyZWF0ZXIgdGhhbiAwKSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBvdmVyd3JpdGluZyBvY2N1cnMgcHJvcGVybHkuIEFsc28sIGlmIGFsbCBvZiB0aGUgdHdlZW5pbmcgcHJvcGVydGllcyBoYXZlIGJlZW4gb3ZlcndyaXR0ZW4gKHdoaWNoIHdvdWxkIGNhdXNlIF9nYyB0byBiZSB0cnVlLCBhcyBzZXQgaW4gX2luaXQoKSksIHdlIHNob3VsZG4ndCBjb250aW51ZSBvdGhlcndpc2UgYW4gb25TdGFydCBjYWxsYmFjayBjb3VsZCBiZSBjYWxsZWQgZm9yIGV4YW1wbGUuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFmb3JjZSAmJiB0aGlzLl9maXJzdFBUICYmICgodGhpcy52YXJzLmxhenkgIT09IGZhbHNlICYmIHRoaXMuX2R1cmF0aW9uKSB8fCAodGhpcy52YXJzLmxhenkgJiYgIXRoaXMuX2R1cmF0aW9uKSkpIHsgLy93ZSBzdGljayBpdCBpbiB0aGUgcXVldWUgZm9yIHJlbmRlcmluZyBhdCB0aGUgdmVyeSBlbmQgb2YgdGhlIHRpY2sgLSB0aGlzIGlzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIGJlY2F1c2UgYnJvd3NlcnMgaW52YWxpZGF0ZSBzdHlsZXMgYW5kIGZvcmNlIGEgcmVjYWxjdWxhdGlvbiBpZiB5b3UgcmVhZCwgd3JpdGUsIGFuZCB0aGVuIHJlYWQgc3R5bGUgZGF0YSAoc28gaXQncyBiZXR0ZXIgdG8gcmVhZC9yZWFkL3JlYWQvd3JpdGUvd3JpdGUvd3JpdGUgdGhhbiByZWFkL3dyaXRlL3JlYWQvd3JpdGUvcmVhZC93cml0ZSkuIFRoZSBkb3duIHNpZGUsIG9mIGNvdXJzZSwgaXMgdGhhdCB1c3VhbGx5IHlvdSBXQU5UIHRoaW5ncyB0byByZW5kZXIgaW1tZWRpYXRlbHkgYmVjYXVzZSB5b3UgbWF5IGhhdmUgY29kZSBydW5uaW5nIHJpZ2h0IGFmdGVyIHRoYXQgd2hpY2ggZGVwZW5kcyBvbiB0aGUgY2hhbmdlLiBMaWtlIGltYWdpbmUgcnVubmluZyBUd2VlbkxpdGUuc2V0KC4uLikgYW5kIHRoZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhhdCwgY3JlYXRpbmcgYSBub3RoZXIgdHdlZW4gdGhhdCBhbmltYXRlcyB0aGUgc2FtZSBwcm9wZXJ0eSB0byBhbm90aGVyIHZhbHVlOyB0aGUgc3RhcnRpbmcgdmFsdWVzIG9mIHRoYXQgMm5kIHR3ZWVuIHdvdWxkbid0IGJlIGFjY3VyYXRlIGlmIGxhenkgaXMgdHJ1ZS5cblx0XHRcdFx0XHR0aGlzLl90aW1lID0gcHJldlRpbWU7XG5cdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gcHJldlRvdGFsVGltZTtcblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHByZXZSYXdQcmV2VGltZTtcblx0XHRcdFx0XHR0aGlzLl9jeWNsZSA9IHByZXZDeWNsZTtcblx0XHRcdFx0XHRUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVR3ZWVucy5wdXNoKHRoaXMpO1xuXHRcdFx0XHRcdHRoaXMuX2xhenkgPSBbdGltZSwgc3VwcHJlc3NFdmVudHNdO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL19lYXNlIGlzIGluaXRpYWxseSBzZXQgdG8gZGVmYXVsdEVhc2UsIHNvIG5vdyB0aGF0IGluaXQoKSBoYXMgcnVuLCBfZWFzZSBpcyBzZXQgcHJvcGVybHkgYW5kIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgdGhlIHJhdGlvLiBPdmVyYWxsIHRoaXMgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY29uZGl0aW9uYWwgbG9naWMgZWFybGllciBpbiB0aGUgbWV0aG9kIHRvIGF2b2lkIGhhdmluZyB0byBzZXQgcmF0aW8gdHdpY2UgYmVjYXVzZSB3ZSBvbmx5IGluaXQoKSBvbmNlIGJ1dCByZW5kZXJUaW1lKCkgZ2V0cyBjYWxsZWQgVkVSWSBmcmVxdWVudGx5LlxuXHRcdFx0XHRpZiAodGhpcy5fdGltZSAmJiAhaXNDb21wbGV0ZSAmJiAheW95b0Vhc2UpIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbyh0aGlzLl90aW1lIC8gZHVyYXRpb24pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGlzQ29tcGxldGUgJiYgdGhpcy5fZWFzZS5fY2FsY0VuZCAmJiAheW95b0Vhc2UpIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbygodGhpcy5fdGltZSA9PT0gMCkgPyAwIDogMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9sYXp5ICE9PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl9sYXp5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5fYWN0aXZlKSBpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl90aW1lICE9PSBwcmV2VGltZSAmJiB0aW1lID49IDApIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTsgLy9zbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgYSB0d2VlbiAoYXMgb3Bwb3NlZCB0byB0aGUgdGltZWxpbmUgcmVuZGVyaW5nIGl0KSwgdGhlIHRpbWVsaW5lIGlzIGZvcmNlZCB0byByZS1yZW5kZXIgYW5kIGFsaWduIGl0IHdpdGggdGhlIHByb3BlciB0aW1lL2ZyYW1lIG9uIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZS4gTWF5YmUgdGhlIHR3ZWVuIGFscmVhZHkgZmluaXNoZWQgYnV0IHRoZSB1c2VyIG1hbnVhbGx5IHJlLXJlbmRlcnMgaXQgYXMgaGFsZndheSBkb25lLlxuXHRcdFx0fVxuXHRcdFx0aWYgKHByZXZUb3RhbFRpbWUgPT09IDApIHtcblx0XHRcdFx0aWYgKHRoaXMuX2luaXR0ZWQgPT09IDIgJiYgdGltZSA+IDApIHtcblx0XHRcdFx0XHQvL3RoaXMuaW52YWxpZGF0ZSgpO1xuXHRcdFx0XHRcdHRoaXMuX2luaXQoKTsgLy93aWxsIGp1c3QgYXBwbHkgb3ZlcndyaXRpbmcgc2luY2UgX2luaXR0ZWQgb2YgKDIpIG1lYW5zIGl0IHdhcyBhIGZyb20oKSB0d2VlbiB0aGF0IGhhZCBpbW1lZGlhdGVSZW5kZXI6dHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl9zdGFydEF0KSB7XG5cdFx0XHRcdFx0aWYgKHRpbWUgPj0gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgdHJ1ZSwgZm9yY2UpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIWNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwiX2R1bW15R1NcIjsgLy9pZiBubyBjYWxsYmFjayBpcyBkZWZpbmVkLCB1c2UgYSBkdW1teSB2YWx1ZSBqdXN0IHNvIHRoYXQgdGhlIGNvbmRpdGlvbiBhdCB0aGUgZW5kIGV2YWx1YXRlcyBhcyB0cnVlIGJlY2F1c2UgX3N0YXJ0QXQgc2hvdWxkIHJlbmRlciBBRlRFUiB0aGUgbm9ybWFsIHJlbmRlciBsb29wIHdoZW4gdGhlIHRpbWUgaXMgbmVnYXRpdmUuIFdlIGNvdWxkIGhhbmRsZSB0aGlzIGluIGEgbW9yZSBpbnR1aXRpdmUgd2F5LCBvZiBjb3Vyc2UsIGJ1dCB0aGUgcmVuZGVyIGxvb3AgaXMgdGhlIE1PU1QgaW1wb3J0YW50IHRoaW5nIHRvIG9wdGltaXplLCBzbyB0aGlzIHRlY2huaXF1ZSBhbGxvd3MgdXMgdG8gYXZvaWQgYWRkaW5nIGV4dHJhIGNvbmRpdGlvbmFsIGxvZ2ljIGluIGEgaGlnaC1mcmVxdWVuY3kgYXJlYS5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMudmFycy5vblN0YXJ0KSBpZiAodGhpcy5fdG90YWxUaW1lICE9PSAwIHx8IGR1cmF0aW9uID09PSAwKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAocHQuZikge1xuXHRcdFx0XHRcdHB0LnRbcHQucF0ocHQuYyAqIHRoaXMucmF0aW8gKyBwdC5zKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQuYyAqIHRoaXMucmF0aW8gKyBwdC5zO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9vblVwZGF0ZSkge1xuXHRcdFx0XHRpZiAodGltZSA8IDApIGlmICh0aGlzLl9zdGFydEF0ICYmIHRoaXMuX3N0YXJ0VGltZSkgeyAvL2lmIHRoZSB0d2VlbiBpcyBwb3NpdGlvbmVkIGF0IHRoZSBWRVJZIGJlZ2lubmluZyAoX3N0YXJ0VGltZSAwKSBvZiBpdHMgcGFyZW50IHRpbWVsaW5lLCBpdCdzIGlsbGVnYWwgZm9yIHRoZSBwbGF5aGVhZCB0byBnbyBiYWNrIGZ1cnRoZXIsIHNvIHdlIHNob3VsZCBub3QgcmVuZGVyIHRoZSByZWNvcmRlZCBzdGFydEF0IHZhbHVlcy5cblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCB0cnVlLCBmb3JjZSk7IC8vbm90ZTogZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIHR1Y2sgdGhpcyBjb25kaXRpb25hbCBsb2dpYyBpbnNpZGUgbGVzcyB0cmF2ZWxlZCBhcmVhcyAobW9zdCB0d2VlbnMgZG9uJ3QgaGF2ZSBhbiBvblVwZGF0ZSkuIFdlJ2QganVzdCBoYXZlIGl0IGF0IHRoZSBlbmQgYmVmb3JlIHRoZSBvbkNvbXBsZXRlLCBidXQgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCBiZWZvcmUgYW55IG9uVXBkYXRlIGlzIGNhbGxlZCwgc28gd2UgQUxTTyBwdXQgaXQgaGVyZSBhbmQgdGhlbiBpZiBpdCdzIG5vdCBjYWxsZWQsIHdlIGRvIHNvIGxhdGVyIG5lYXIgdGhlIG9uQ29tcGxldGUuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cykgaWYgKHRoaXMuX3RvdGFsVGltZSAhPT0gcHJldlRvdGFsVGltZSB8fCBjYWxsYmFjaykge1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9jeWNsZSAhPT0gcHJldkN5Y2xlKSBpZiAoIXN1cHByZXNzRXZlbnRzKSBpZiAoIXRoaXMuX2djKSBpZiAodGhpcy52YXJzLm9uUmVwZWF0KSB7XG5cdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25SZXBlYXRcIik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2FsbGJhY2spIGlmICghdGhpcy5fZ2MgfHwgZm9yY2UpIHsgLy9jaGVjayBnYyBiZWNhdXNlIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBraWxsKCkgY291bGQgYmUgY2FsbGVkIGluIGFuIG9uVXBkYXRlXG5cdFx0XHRcdGlmICh0aW1lIDwgMCAmJiB0aGlzLl9zdGFydEF0ICYmICF0aGlzLl9vblVwZGF0ZSAmJiB0aGlzLl9zdGFydFRpbWUpIHsgLy9pZiB0aGUgdHdlZW4gaXMgcG9zaXRpb25lZCBhdCB0aGUgVkVSWSBiZWdpbm5pbmcgKF9zdGFydFRpbWUgMCkgb2YgaXRzIHBhcmVudCB0aW1lbGluZSwgaXQncyBpbGxlZ2FsIGZvciB0aGUgcGxheWhlYWQgdG8gZ28gYmFjayBmdXJ0aGVyLCBzbyB3ZSBzaG91bGQgbm90IHJlbmRlciB0aGUgcmVjb3JkZWQgc3RhcnRBdCB2YWx1ZXMuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgdHJ1ZSwgZm9yY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzICYmIHRoaXMudmFyc1tjYWxsYmFja10pIHtcblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhjYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwICYmIHRoaXMuX3Jhd1ByZXZUaW1lID09PSBfdGlueU51bSAmJiByYXdQcmV2VGltZSAhPT0gX3RpbnlOdW0pIHsgLy90aGUgb25Db21wbGV0ZSBvciBvblJldmVyc2VDb21wbGV0ZSBjb3VsZCB0cmlnZ2VyIG1vdmVtZW50IG9mIHRoZSBwbGF5aGVhZCBhbmQgZm9yIHplcm8tZHVyYXRpb24gdHdlZW5zICh3aGljaCBtdXN0IGRpc2Nlcm4gZGlyZWN0aW9uKSB0aGF0IGxhbmQgZGlyZWN0bHkgYmFjayBvbiB0aGVpciBzdGFydCB0aW1lLCB3ZSBkb24ndCB3YW50IHRvIGZpcmUgYWdhaW4gb24gdGhlIG5leHQgcmVuZGVyLiBUaGluayBvZiBzZXZlcmFsIGFkZFBhdXNlKCkncyBpbiBhIHRpbWVsaW5lIHRoYXQgZm9yY2VzIHRoZSBwbGF5aGVhZCB0byBhIGNlcnRhaW4gc3BvdCwgYnV0IHdoYXQgaWYgaXQncyBhbHJlYWR5IHBhdXNlZCBhbmQgYW5vdGhlciB0d2VlbiBpcyB0d2VlbmluZyB0aGUgXCJ0aW1lXCIgb2YgdGhlIHRpbWVsaW5lPyBFYWNoIHRpbWUgaXQgbW92ZXMgW2ZvcndhcmRdIHBhc3QgdGhhdCBzcG90LCBpdCB3b3VsZCBtb3ZlIGJhY2ssIGFuZCBzaW5jZSBzdXBwcmVzc0V2ZW50cyBpcyB0cnVlLCBpdCdkIHJlc2V0IF9yYXdQcmV2VGltZSB0byBfdGlueU51bSBzbyB0aGF0IHdoZW4gaXQgYmVnaW5zIGFnYWluLCB0aGUgY2FsbGJhY2sgd291bGQgZmlyZSAoc28gdWx0aW1hdGVseSBpdCBjb3VsZCBib3VuY2UgYmFjayBhbmQgZm9ydGggZHVyaW5nIHRoYXQgdHdlZW4pLiBBZ2FpbiwgdGhpcyBpcyBhIHZlcnkgdW5jb21tb24gc2NlbmFyaW8sIGJ1dCBwb3NzaWJsZSBub25ldGhlbGVzcy5cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG4vLy0tLS0gU1RBVElDIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0VHdlZW5NYXgudG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTWF4KHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdH07XG5cblx0XHRUd2Vlbk1heC5mcm9tID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0dmFycy5ydW5CYWNrd2FyZHMgPSB0cnVlO1xuXHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIG5ldyBUd2Vlbk1heCh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5NYXguZnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycykge1xuXHRcdFx0dG9WYXJzLnN0YXJ0QXQgPSBmcm9tVmFycztcblx0XHRcdHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodG9WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSAmJiBmcm9tVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIG5ldyBUd2Vlbk1heCh0YXJnZXQsIGR1cmF0aW9uLCB0b1ZhcnMpO1xuXHRcdH07XG5cblx0XHRUd2Vlbk1heC5zdGFnZ2VyVG8gPSBUd2Vlbk1heC5hbGxUbyA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHN0YWdnZXIgPSBzdGFnZ2VyIHx8IDA7XG5cdFx0XHR2YXIgZGVsYXkgPSAwLFxuXHRcdFx0XHRhID0gW10sXG5cdFx0XHRcdGZpbmFsQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAodmFycy5vbkNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0XHR2YXJzLm9uQ29tcGxldGUuYXBwbHkodmFycy5vbkNvbXBsZXRlU2NvcGUgfHwgdGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0b25Db21wbGV0ZUFsbC5hcHBseShvbkNvbXBsZXRlQWxsU2NvcGUgfHwgdmFycy5jYWxsYmFja1Njb3BlIHx8IHRoaXMsIG9uQ29tcGxldGVBbGxQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRjeWNsZSA9IHZhcnMuY3ljbGUsXG5cdFx0XHRcdGZyb21DeWNsZSA9ICh2YXJzLnN0YXJ0QXQgJiYgdmFycy5zdGFydEF0LmN5Y2xlKSxcblx0XHRcdFx0bCwgY29weSwgaSwgcDtcblx0XHRcdGlmICghX2lzQXJyYXkodGFyZ2V0cykpIHtcblx0XHRcdFx0aWYgKHR5cGVvZih0YXJnZXRzKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdHRhcmdldHMgPSBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0cykgfHwgdGFyZ2V0cztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX2lzU2VsZWN0b3IodGFyZ2V0cykpIHtcblx0XHRcdFx0XHR0YXJnZXRzID0gX3NsaWNlKHRhcmdldHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXRzID0gdGFyZ2V0cyB8fCBbXTtcblx0XHRcdGlmIChzdGFnZ2VyIDwgMCkge1xuXHRcdFx0XHR0YXJnZXRzID0gX3NsaWNlKHRhcmdldHMpO1xuXHRcdFx0XHR0YXJnZXRzLnJldmVyc2UoKTtcblx0XHRcdFx0c3RhZ2dlciAqPSAtMTtcblx0XHRcdH1cblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aCAtIDE7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDw9IGw7IGkrKykge1xuXHRcdFx0XHRjb3B5ID0ge307XG5cdFx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdFx0Y29weVtwXSA9IHZhcnNbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGN5Y2xlKSB7XG5cdFx0XHRcdFx0X2FwcGx5Q3ljbGUoY29weSwgdGFyZ2V0cywgaSk7XG5cdFx0XHRcdFx0aWYgKGNvcHkuZHVyYXRpb24gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb24gPSBjb3B5LmR1cmF0aW9uO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIGNvcHkuZHVyYXRpb247XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChmcm9tQ3ljbGUpIHtcblx0XHRcdFx0XHRmcm9tQ3ljbGUgPSBjb3B5LnN0YXJ0QXQgPSB7fTtcblx0XHRcdFx0XHRmb3IgKHAgaW4gdmFycy5zdGFydEF0KSB7XG5cdFx0XHRcdFx0XHRmcm9tQ3ljbGVbcF0gPSB2YXJzLnN0YXJ0QXRbcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF9hcHBseUN5Y2xlKGNvcHkuc3RhcnRBdCwgdGFyZ2V0cywgaSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29weS5kZWxheSA9IGRlbGF5ICsgKGNvcHkuZGVsYXkgfHwgMCk7XG5cdFx0XHRcdGlmIChpID09PSBsICYmIG9uQ29tcGxldGVBbGwpIHtcblx0XHRcdFx0XHRjb3B5Lm9uQ29tcGxldGUgPSBmaW5hbENvbXBsZXRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFbaV0gPSBuZXcgVHdlZW5NYXgodGFyZ2V0c1tpXSwgZHVyYXRpb24sIGNvcHkpO1xuXHRcdFx0XHRkZWxheSArPSBzdGFnZ2VyO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTWF4LnN0YWdnZXJGcm9tID0gVHdlZW5NYXguYWxsRnJvbSA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHZhcnMucnVuQmFja3dhcmRzID0gdHJ1ZTtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBUd2Vlbk1heC5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTWF4LnN0YWdnZXJGcm9tVG8gPSBUd2Vlbk1heC5hbGxGcm9tVG8gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgc3RhZ2dlciwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuXHRcdFx0dG9WYXJzLmltbWVkaWF0ZVJlbmRlciA9ICh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlICYmIGZyb21WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gVHdlZW5NYXguc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB0b1ZhcnMsIHN0YWdnZXIsIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTWF4LmRlbGF5ZWRDYWxsID0gZnVuY3Rpb24oZGVsYXksIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlLCB1c2VGcmFtZXMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5NYXgoY2FsbGJhY2ssIDAsIHtkZWxheTpkZWxheSwgb25Db21wbGV0ZTpjYWxsYmFjaywgb25Db21wbGV0ZVBhcmFtczpwYXJhbXMsIGNhbGxiYWNrU2NvcGU6c2NvcGUsIG9uUmV2ZXJzZUNvbXBsZXRlOmNhbGxiYWNrLCBvblJldmVyc2VDb21wbGV0ZVBhcmFtczpwYXJhbXMsIGltbWVkaWF0ZVJlbmRlcjpmYWxzZSwgdXNlRnJhbWVzOnVzZUZyYW1lcywgb3ZlcndyaXRlOjB9KTtcblx0XHR9O1xuXG5cdFx0VHdlZW5NYXguc2V0ID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTWF4KHRhcmdldCwgMCwgdmFycyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTWF4LmlzVHdlZW5pbmcgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRcdHJldHVybiAoVHdlZW5MaXRlLmdldFR3ZWVuc09mKHRhcmdldCwgdHJ1ZSkubGVuZ3RoID4gMCk7XG5cdFx0fTtcblxuXHRcdHZhciBfZ2V0Q2hpbGRyZW5PZiA9IGZ1bmN0aW9uKHRpbWVsaW5lLCBpbmNsdWRlVGltZWxpbmVzKSB7XG5cdFx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdFx0Y250ID0gMCxcblx0XHRcdFx0XHR0d2VlbiA9IHRpbWVsaW5lLl9maXJzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0aWYgKHR3ZWVuIGluc3RhbmNlb2YgVHdlZW5MaXRlKSB7XG5cdFx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoaW5jbHVkZVRpbWVsaW5lcykge1xuXHRcdFx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YSA9IGEuY29uY2F0KF9nZXRDaGlsZHJlbk9mKHR3ZWVuLCBpbmNsdWRlVGltZWxpbmVzKSk7XG5cdFx0XHRcdFx0XHRjbnQgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdH0sXG5cdFx0XHRnZXRBbGxUd2VlbnMgPSBUd2Vlbk1heC5nZXRBbGxUd2VlbnMgPSBmdW5jdGlvbihpbmNsdWRlVGltZWxpbmVzKSB7XG5cdFx0XHRcdHJldHVybiBfZ2V0Q2hpbGRyZW5PZihBbmltYXRpb24uX3Jvb3RUaW1lbGluZSwgaW5jbHVkZVRpbWVsaW5lcykuY29uY2F0KCBfZ2V0Q2hpbGRyZW5PZihBbmltYXRpb24uX3Jvb3RGcmFtZXNUaW1lbGluZSwgaW5jbHVkZVRpbWVsaW5lcykgKTtcblx0XHRcdH07XG5cblx0XHRUd2Vlbk1heC5raWxsQWxsID0gZnVuY3Rpb24oY29tcGxldGUsIHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpIHtcblx0XHRcdGlmICh0d2VlbnMgPT0gbnVsbCkge1xuXHRcdFx0XHR0d2VlbnMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRlbGF5ZWRDYWxscyA9PSBudWxsKSB7XG5cdFx0XHRcdGRlbGF5ZWRDYWxscyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYSA9IGdldEFsbFR3ZWVucygodGltZWxpbmVzICE9IGZhbHNlKSksXG5cdFx0XHRcdGwgPSBhLmxlbmd0aCxcblx0XHRcdFx0YWxsVHJ1ZSA9ICh0d2VlbnMgJiYgZGVsYXllZENhbGxzICYmIHRpbWVsaW5lcyksXG5cdFx0XHRcdGlzREMsIHR3ZWVuLCBpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR0d2VlbiA9IGFbaV07XG5cdFx0XHRcdGlmIChhbGxUcnVlIHx8ICh0d2VlbiBpbnN0YW5jZW9mIFNpbXBsZVRpbWVsaW5lKSB8fCAoKGlzREMgPSAodHdlZW4udGFyZ2V0ID09PSB0d2Vlbi52YXJzLm9uQ29tcGxldGUpKSAmJiBkZWxheWVkQ2FsbHMpIHx8ICh0d2VlbnMgJiYgIWlzREMpKSB7XG5cdFx0XHRcdFx0aWYgKGNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi50b3RhbFRpbWUodHdlZW4uX3JldmVyc2VkID8gMCA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHR3ZWVuLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdFR3ZWVuTWF4LmtpbGxDaGlsZFR3ZWVuc09mID0gZnVuY3Rpb24ocGFyZW50LCBjb21wbGV0ZSkge1xuXHRcdFx0aWYgKHBhcmVudCA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciB0bCA9IFR3ZWVuTGl0ZUludGVybmFscy50d2Vlbkxvb2t1cCxcblx0XHRcdFx0YSwgY3VyUGFyZW50LCBwLCBpLCBsO1xuXHRcdFx0aWYgKHR5cGVvZihwYXJlbnQpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHBhcmVudCA9IFR3ZWVuTGl0ZS5zZWxlY3RvcihwYXJlbnQpIHx8IHBhcmVudDtcblx0XHRcdH1cblx0XHRcdGlmIChfaXNTZWxlY3RvcihwYXJlbnQpKSB7XG5cdFx0XHRcdHBhcmVudCA9IF9zbGljZShwYXJlbnQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKF9pc0FycmF5KHBhcmVudCkpIHtcblx0XHRcdFx0aSA9IHBhcmVudC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFR3ZWVuTWF4LmtpbGxDaGlsZFR3ZWVuc09mKHBhcmVudFtpXSwgY29tcGxldGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGEgPSBbXTtcblx0XHRcdGZvciAocCBpbiB0bCkge1xuXHRcdFx0XHRjdXJQYXJlbnQgPSB0bFtwXS50YXJnZXQucGFyZW50Tm9kZTtcblx0XHRcdFx0d2hpbGUgKGN1clBhcmVudCkge1xuXHRcdFx0XHRcdGlmIChjdXJQYXJlbnQgPT09IHBhcmVudCkge1xuXHRcdFx0XHRcdFx0YSA9IGEuY29uY2F0KHRsW3BdLnR3ZWVucyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN1clBhcmVudCA9IGN1clBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsID0gYS5sZW5ndGg7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmIChjb21wbGV0ZSkge1xuXHRcdFx0XHRcdGFbaV0udG90YWxUaW1lKGFbaV0udG90YWxEdXJhdGlvbigpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhW2ldLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciBfY2hhbmdlUGF1c2UgPSBmdW5jdGlvbihwYXVzZSwgdHdlZW5zLCBkZWxheWVkQ2FsbHMsIHRpbWVsaW5lcykge1xuXHRcdFx0dHdlZW5zID0gKHR3ZWVucyAhPT0gZmFsc2UpO1xuXHRcdFx0ZGVsYXllZENhbGxzID0gKGRlbGF5ZWRDYWxscyAhPT0gZmFsc2UpO1xuXHRcdFx0dGltZWxpbmVzID0gKHRpbWVsaW5lcyAhPT0gZmFsc2UpO1xuXHRcdFx0dmFyIGEgPSBnZXRBbGxUd2VlbnModGltZWxpbmVzKSxcblx0XHRcdFx0YWxsVHJ1ZSA9ICh0d2VlbnMgJiYgZGVsYXllZENhbGxzICYmIHRpbWVsaW5lcyksXG5cdFx0XHRcdGkgPSBhLmxlbmd0aCxcblx0XHRcdFx0aXNEQywgdHdlZW47XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0dHdlZW4gPSBhW2ldO1xuXHRcdFx0XHRpZiAoYWxsVHJ1ZSB8fCAodHdlZW4gaW5zdGFuY2VvZiBTaW1wbGVUaW1lbGluZSkgfHwgKChpc0RDID0gKHR3ZWVuLnRhcmdldCA9PT0gdHdlZW4udmFycy5vbkNvbXBsZXRlKSkgJiYgZGVsYXllZENhbGxzKSB8fCAodHdlZW5zICYmICFpc0RDKSkge1xuXHRcdFx0XHRcdHR3ZWVuLnBhdXNlZChwYXVzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0VHdlZW5NYXgucGF1c2VBbGwgPSBmdW5jdGlvbih0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKSB7XG5cdFx0XHRfY2hhbmdlUGF1c2UodHJ1ZSwgdHdlZW5zLCBkZWxheWVkQ2FsbHMsIHRpbWVsaW5lcyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTWF4LnJlc3VtZUFsbCA9IGZ1bmN0aW9uKHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpIHtcblx0XHRcdF9jaGFuZ2VQYXVzZShmYWxzZSwgdHdlZW5zLCBkZWxheWVkQ2FsbHMsIHRpbWVsaW5lcyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTWF4Lmdsb2JhbFRpbWVTY2FsZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgdGwgPSBBbmltYXRpb24uX3Jvb3RUaW1lbGluZSxcblx0XHRcdFx0dCA9IFR3ZWVuTGl0ZS50aWNrZXIudGltZTtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGwuX3RpbWVTY2FsZTtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gdmFsdWUgfHwgX3RpbnlOdW07IC8vY2FuJ3QgYWxsb3cgemVybyBiZWNhdXNlIGl0J2xsIHRocm93IHRoZSBtYXRoIG9mZlxuXHRcdFx0dGwuX3N0YXJ0VGltZSA9IHQgLSAoKHQgLSB0bC5fc3RhcnRUaW1lKSAqIHRsLl90aW1lU2NhbGUgLyB2YWx1ZSk7XG5cdFx0XHR0bCA9IEFuaW1hdGlvbi5fcm9vdEZyYW1lc1RpbWVsaW5lO1xuXHRcdFx0dCA9IFR3ZWVuTGl0ZS50aWNrZXIuZnJhbWU7XG5cdFx0XHR0bC5fc3RhcnRUaW1lID0gdCAtICgodCAtIHRsLl9zdGFydFRpbWUpICogdGwuX3RpbWVTY2FsZSAvIHZhbHVlKTtcblx0XHRcdHRsLl90aW1lU2NhbGUgPSBBbmltYXRpb24uX3Jvb3RUaW1lbGluZS5fdGltZVNjYWxlID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblxuXG4vLy0tLS0gR0VUVEVSUyAvIFNFVFRFUlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0cC5wcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90aW1lIC8gdGhpcy5kdXJhdGlvbigpIDogdGhpcy50b3RhbFRpbWUoIHRoaXMuZHVyYXRpb24oKSAqICgodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkgPyAxIC0gdmFsdWUgOiB2YWx1ZSkgKyAodGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSkpLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90b3RhbFRpbWUgLyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMudG90YWxUaW1lKCB0aGlzLnRvdGFsRHVyYXRpb24oKSAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudGltZSA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90aW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdHRoaXMudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlID4gdGhpcy5fZHVyYXRpb24pIHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLl9kdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdHZhbHVlID0gKHRoaXMuX2R1cmF0aW9uIC0gdmFsdWUpICsgKHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fcmVwZWF0ICE9PSAwKSB7XG5cdFx0XHRcdHZhbHVlICs9IHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAuZHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9kdXJhdGlvbjsgLy9kb24ndCBzZXQgX2RpcnR5ID0gZmFsc2UgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSByZXBlYXRzIHRoYXQgaGF2ZW4ndCBiZWVuIGZhY3RvcmVkIGludG8gdGhlIF90b3RhbER1cmF0aW9uIHlldC4gT3RoZXJ3aXNlLCBpZiB5b3UgY3JlYXRlIGEgcmVwZWF0ZWQgVHdlZW5NYXggYW5kIHRoZW4gaW1tZWRpYXRlbHkgY2hlY2sgaXRzIGR1cmF0aW9uKCksIGl0IHdvdWxkIGNhY2hlIHRoZSB2YWx1ZSBhbmQgdGhlIHRvdGFsRHVyYXRpb24gd291bGQgbm90IGJlIGNvcnJlY3QsIHRodXMgcmVwZWF0cyB3b3VsZG4ndCB0YWtlIGVmZmVjdC5cblx0XHRcdH1cblx0XHRcdHJldHVybiBBbmltYXRpb24ucHJvdG90eXBlLmR1cmF0aW9uLmNhbGwodGhpcywgdmFsdWUpO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHRcdC8vaW5zdGVhZCBvZiBJbmZpbml0eSwgd2UgdXNlIDk5OTk5OTk5OTk5OSBzbyB0aGF0IHdlIGNhbiBhY2NvbW1vZGF0ZSByZXZlcnNlc1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsRHVyYXRpb24gPSAodGhpcy5fcmVwZWF0ID09PSAtMSkgPyA5OTk5OTk5OTk5OTkgOiB0aGlzLl9kdXJhdGlvbiAqICh0aGlzLl9yZXBlYXQgKyAxKSArICh0aGlzLl9yZXBlYXREZWxheSAqIHRoaXMuX3JlcGVhdCk7XG5cdFx0XHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdG90YWxEdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodGhpcy5fcmVwZWF0ID09PSAtMSkgPyB0aGlzIDogdGhpcy5kdXJhdGlvbiggKHZhbHVlIC0gKHRoaXMuX3JlcGVhdCAqIHRoaXMuX3JlcGVhdERlbGF5KSkgLyAodGhpcy5fcmVwZWF0ICsgMSkgKTtcblx0XHR9O1xuXG5cdFx0cC5yZXBlYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXBlYXQ7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXQgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLnJlcGVhdERlbGF5ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVwZWF0RGVsYXk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAueW95byA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3lveW87XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl95b3lvID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cblx0XHRyZXR1cm4gVHdlZW5NYXg7XG5cblx0fSwgdHJ1ZSk7XG5cbmV4cG9ydCB2YXIgVHdlZW5NYXggPSBnbG9iYWxzLlR3ZWVuTWF4O1xuZXhwb3J0IHZhciBUd2Vlbk1heEJhc2UgPSBUd2Vlbk1heDtcbmV4cG9ydCB7IFR3ZWVuTWF4IGFzIGRlZmF1bHQgfTtcbmV4cG9ydCB7IFR3ZWVuTGl0ZSwgRWFzZSwgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ3NhcC9Ud2Vlbk1heEJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogVkVSU0lPTjogMi4wLjJcbiAqIERBVEU6IDIwMTgtMDgtMjdcbiAqIFVQREFURVMgQU5EIERPQ1MgQVQ6IGh0dHA6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDA4LTIwMTgsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgd29yayBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIHNvZnR3YXJlIGFncmVlbWVudCB0aGF0IHdhcyBpc3N1ZWQgd2l0aCB5b3VyIG1lbWJlcnNoaXAuXG4gKiBcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICovXG5pbXBvcnQgVHdlZW5MaXRlLCB7IF9nc1Njb3BlLCBnbG9iYWxzLCBUd2VlblBsdWdpbiB9IGZyb20gXCIuL1R3ZWVuTGl0ZS5qc1wiO1xuXG5cdF9nc1Njb3BlLl9nc0RlZmluZShcInBsdWdpbnMuQ1NTUGx1Z2luXCIsIFtcInBsdWdpbnMuVHdlZW5QbHVnaW5cIixcIlR3ZWVuTGl0ZVwiXSwgZnVuY3Rpb24oKSB7XG5cblx0XHQvKiogQGNvbnN0cnVjdG9yICoqL1xuXHRcdHZhciBDU1NQbHVnaW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0VHdlZW5QbHVnaW4uY2FsbCh0aGlzLCBcImNzc1wiKTtcblx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMubGVuZ3RoID0gMDtcblx0XHRcdFx0dGhpcy5zZXRSYXRpbyA9IENTU1BsdWdpbi5wcm90b3R5cGUuc2V0UmF0aW87IC8vc3BlZWQgb3B0aW1pemF0aW9uIChhdm9pZCBwcm90b3R5cGUgbG9va3VwIG9uIHRoaXMgXCJob3RcIiBtZXRob2QpXG5cdFx0XHR9LFxuXHRcdFx0X2dsb2JhbHMgPSBfZ3NTY29wZS5fZ3NEZWZpbmUuZ2xvYmFscyxcblx0XHRcdF9oYXNQcmlvcml0eSwgLy90dXJucyB0cnVlIHdoZW5ldmVyIGEgQ1NTUHJvcFR3ZWVuIGluc3RhbmNlIGlzIGNyZWF0ZWQgdGhhdCBoYXMgYSBwcmlvcml0eSBvdGhlciB0aGFuIDAuIFRoaXMgaGVscHMgdXMgZGlzY2VybiB3aGV0aGVyIG9yIG5vdCB3ZSBzaG91bGQgc3BlbmQgdGhlIHRpbWUgb3JnYW5pemluZyB0aGUgbGlua2VkIGxpc3Qgb3Igbm90IGFmdGVyIGEgQ1NTUGx1Z2luJ3MgX29uSW5pdFR3ZWVuKCkgbWV0aG9kIGlzIGNhbGxlZC5cblx0XHRcdF9zdWZmaXhNYXAsIC8vd2Ugc2V0IHRoaXMgaW4gX29uSW5pdFR3ZWVuKCkgZWFjaCB0aW1lIGFzIGEgd2F5IHRvIGhhdmUgYSBwZXJzaXN0ZW50IHZhcmlhYmxlIHdlIGNhbiB1c2UgaW4gb3RoZXIgbWV0aG9kcyBsaWtlIF9wYXJzZSgpIHdpdGhvdXQgaGF2aW5nIHRvIHBhc3MgaXQgYXJvdW5kIGFzIGEgcGFyYW1ldGVyIGFuZCB3ZSBrZWVwIF9wYXJzZSgpIGRlY291cGxlZCBmcm9tIGEgcGFydGljdWxhciBDU1NQbHVnaW4gaW5zdGFuY2Vcblx0XHRcdF9jcywgLy9jb21wdXRlZCBzdHlsZSAod2Ugc3RvcmUgdGhpcyBpbiBhIHNoYXJlZCB2YXJpYWJsZSB0byBjb25zZXJ2ZSBtZW1vcnkgYW5kIG1ha2UgbWluaWZpY2F0aW9uIHRpZ2h0ZXJcblx0XHRcdF9vdmVyd3JpdGVQcm9wcywgLy9hbGlhcyB0byB0aGUgY3VycmVudGx5IGluc3RhbnRpYXRpbmcgQ1NTUGx1Z2luJ3MgX292ZXJ3cml0ZVByb3BzIGFycmF5LiBXZSB1c2UgdGhpcyBjbG9zdXJlIGluIG9yZGVyIHRvIGF2b2lkIGhhdmluZyB0byBwYXNzIGEgcmVmZXJlbmNlIGFyb3VuZCBmcm9tIG1ldGhvZCB0byBtZXRob2QgYW5kIGFpZCBpbiBtaW5pZmljYXRpb24uXG5cdFx0XHRfc3BlY2lhbFByb3BzID0ge30sXG5cdFx0XHRwID0gQ1NTUGx1Z2luLnByb3RvdHlwZSA9IG5ldyBUd2VlblBsdWdpbihcImNzc1wiKTtcblxuXHRcdHAuY29uc3RydWN0b3IgPSBDU1NQbHVnaW47XG5cdFx0Q1NTUGx1Z2luLnZlcnNpb24gPSBcIjIuMC4yXCI7XG5cdFx0Q1NTUGx1Z2luLkFQSSA9IDI7XG5cdFx0Q1NTUGx1Z2luLmRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IDA7XG5cdFx0Q1NTUGx1Z2luLmRlZmF1bHRTa2V3VHlwZSA9IFwiY29tcGVuc2F0ZWRcIjtcblx0XHRDU1NQbHVnaW4uZGVmYXVsdFNtb290aE9yaWdpbiA9IHRydWU7XG5cdFx0cCA9IFwicHhcIjsgLy93ZSdsbCByZXVzZSB0aGUgXCJwXCIgdmFyaWFibGUgdG8ga2VlcCBmaWxlIHNpemUgZG93blxuXHRcdENTU1BsdWdpbi5zdWZmaXhNYXAgPSB7dG9wOnAsIHJpZ2h0OnAsIGJvdHRvbTpwLCBsZWZ0OnAsIHdpZHRoOnAsIGhlaWdodDpwLCBmb250U2l6ZTpwLCBwYWRkaW5nOnAsIG1hcmdpbjpwLCBwZXJzcGVjdGl2ZTpwLCBsaW5lSGVpZ2h0OlwiXCJ9O1xuXG5cblx0XHR2YXIgX251bUV4cCA9IC8oPzpcXC18XFwufFxcYikoXFxkfFxcLnxlXFwtKSsvZyxcblx0XHRcdF9yZWxOdW1FeHAgPSAvKD86XFxkfFxcLVxcZHxcXC5cXGR8XFwtXFwuXFxkfFxcKz1cXGR8XFwtPVxcZHxcXCs9LlxcZHxcXC09XFwuXFxkKSsvZyxcblx0XHRcdF92YWx1ZXNFeHAgPSAvKD86XFwrPXxcXC09fFxcLXxcXGIpW1xcZFxcLVxcLl0rW2EtekEtWjAtOV0qKD86JXxcXGIpL2dpLCAvL2ZpbmRzIGFsbCB0aGUgdmFsdWVzIHRoYXQgYmVnaW4gd2l0aCBudW1iZXJzIG9yICs9IG9yIC09IGFuZCB0aGVuIGEgbnVtYmVyLiBJbmNsdWRlcyBzdWZmaXhlcy4gV2UgdXNlIHRoaXMgdG8gc3BsaXQgY29tcGxleCB2YWx1ZXMgYXBhcnQgbGlrZSBcIjFweCA1cHggMjBweCByZ2IoMjU1LDEwMiw1MSlcIlxuXHRcdFx0X05hTkV4cCA9IC8oPyFbKy1dP1xcZCpcXC4/XFxkK3xbKy1dfGVbKy1dXFxkKylbXjAtOV0vZywgLy9hbHNvIGFsbG93cyBzY2llbnRpZmljIG5vdGF0aW9uIGFuZCBkb2Vzbid0IGtpbGwgdGhlIGxlYWRpbmcgLS8rIGluIC09IGFuZCArPVxuXHRcdFx0X3N1ZmZpeEV4cCA9IC8oPzpcXGR8XFwtfFxcK3w9fCN8XFwuKSovZyxcblx0XHRcdF9vcGFjaXR5RXhwID0gL29wYWNpdHkgKj0gKihbXildKikvaSxcblx0XHRcdF9vcGFjaXR5VmFsRXhwID0gL29wYWNpdHk6KFteO10qKS9pLFxuXHRcdFx0X2FscGhhRmlsdGVyRXhwID0gL2FscGhhXFwob3BhY2l0eSAqPS4rP1xcKS9pLFxuXHRcdFx0X3JnYmhzbEV4cCA9IC9eKHJnYnxoc2wpLyxcblx0XHRcdF9jYXBzRXhwID0gLyhbQS1aXSkvZyxcblx0XHRcdF9jYW1lbEV4cCA9IC8tKFthLXpdKS9naSxcblx0XHRcdF91cmxFeHAgPSAvKF4oPzp1cmxcXChcXFwifHVybFxcKCkpfCg/OihcXFwiXFwpKSR8XFwpJCkvZ2ksIC8vZm9yIHB1bGxpbmcgb3V0IHVybHMgZnJvbSB1cmwoLi4uKSBvciB1cmwoXCIuLi5cIikgc3RyaW5ncyAoc29tZSBicm93c2VycyB3cmFwIHVybHMgaW4gcXVvdGVzLCBzb21lIGRvbid0IHdoZW4gcmVwb3J0aW5nIHRoaW5ncyBsaWtlIGJhY2tncm91bmRJbWFnZSlcblx0XHRcdF9jYW1lbEZ1bmMgPSBmdW5jdGlvbihzLCBnKSB7IHJldHVybiBnLnRvVXBwZXJDYXNlKCk7IH0sXG5cdFx0XHRfaG9yaXpFeHAgPSAvKD86TGVmdHxSaWdodHxXaWR0aCkvaSxcblx0XHRcdF9pZUdldE1hdHJpeEV4cCA9IC8oTTExfE0xMnxNMjF8TTIyKT1bXFxkXFwtXFwuZV0rL2dpLFxuXHRcdFx0X2llU2V0TWF0cml4RXhwID0gL3Byb2dpZFxcOkRYSW1hZ2VUcmFuc2Zvcm1cXC5NaWNyb3NvZnRcXC5NYXRyaXhcXCguKz9cXCkvaSxcblx0XHRcdF9jb21tYXNPdXRzaWRlUGFyZW5FeHAgPSAvLCg/PVteXFwpXSooPzpcXCh8JCkpL2dpLCAvL2ZpbmRzIGFueSBjb21tYXMgdGhhdCBhcmUgbm90IHdpdGhpbiBwYXJlbnRoZXNpc1xuXHRcdFx0X2NvbXBsZXhFeHAgPSAvW1xccyxcXChdL2ksIC8vZm9yIHRlc3RpbmcgYSBzdHJpbmcgdG8gZmluZCBpZiBpdCBoYXMgYSBzcGFjZSwgY29tbWEsIG9yIG9wZW4gcGFyZW50aGVzaXMgKGNsdWVzIHRoYXQgaXQncyBhIGNvbXBsZXggdmFsdWUpXG5cdFx0XHRfREVHMlJBRCA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHRfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG5cdFx0XHRfZm9yY2VQVCA9IHt9LFxuXHRcdFx0X2R1bW15RWxlbWVudCA9IHtzdHlsZTp7fX0sXG5cdFx0XHRfZG9jID0gX2dzU2NvcGUuZG9jdW1lbnQgfHwge2NyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge3JldHVybiBfZHVtbXlFbGVtZW50O319LFxuXHRcdFx0X2NyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbih0eXBlLCBucykge1xuXHRcdFx0XHRyZXR1cm4gX2RvYy5jcmVhdGVFbGVtZW50TlMgPyBfZG9jLmNyZWF0ZUVsZW1lbnROUyhucyB8fCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgdHlwZSkgOiBfZG9jLmNyZWF0ZUVsZW1lbnQodHlwZSk7XG5cdFx0XHR9LFxuXHRcdFx0X3RlbXBEaXYgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKSxcblx0XHRcdF90ZW1wSW1nID0gX2NyZWF0ZUVsZW1lbnQoXCJpbWdcIiksXG5cdFx0XHRfaW50ZXJuYWxzID0gQ1NTUGx1Z2luLl9pbnRlcm5hbHMgPSB7X3NwZWNpYWxQcm9wczpfc3BlY2lhbFByb3BzfSwgLy9wcm92aWRlcyBhIGhvb2sgdG8gYSBmZXcgaW50ZXJuYWwgbWV0aG9kcyB0aGF0IHdlIG5lZWQgdG8gYWNjZXNzIGZyb20gaW5zaWRlIG90aGVyIHBsdWdpbnNcblx0XHRcdF9hZ2VudCA9IChfZ3NTY29wZS5uYXZpZ2F0b3IgfHwge30pLnVzZXJBZ2VudCB8fCBcIlwiLFxuXHRcdFx0X2F1dG9Sb3VuZCxcblx0XHRcdF9yZXFTYWZhcmlGaXgsIC8vd2Ugd29uJ3QgYXBwbHkgdGhlIFNhZmFyaSB0cmFuc2Zvcm0gZml4IHVudGlsIHdlIGFjdHVhbGx5IGNvbWUgYWNyb3NzIGEgdHdlZW4gdGhhdCBhZmZlY3RzIGEgdHJhbnNmb3JtIHByb3BlcnR5ICh0byBtYWludGFpbiBiZXN0IHBlcmZvcm1hbmNlKS5cblxuXHRcdFx0X2lzU2FmYXJpLFxuXHRcdFx0X2lzRmlyZWZveCwgLy9GaXJlZm94IGhhcyBhIGJ1ZyB0aGF0IGNhdXNlcyAzRCB0cmFuc2Zvcm1lZCBlbGVtZW50cyB0byByYW5kb21seSBkaXNhcHBlYXIgdW5sZXNzIGEgcmVwYWludCBpcyBmb3JjZWQgYWZ0ZXIgZWFjaCB1cGRhdGUgb24gZWFjaCBlbGVtZW50LlxuXHRcdFx0X2lzU2FmYXJpTFQ2LCAvL1NhZmFyaSAoYW5kIEFuZHJvaWQgNCB3aGljaCB1c2VzIGEgZmxhdm9yIG9mIFNhZmFyaSkgaGFzIGEgYnVnIHRoYXQgcHJldmVudHMgY2hhbmdlcyB0byBcInRvcFwiIGFuZCBcImxlZnRcIiBwcm9wZXJ0aWVzIGZyb20gcmVuZGVyaW5nIHByb3Blcmx5IGlmIGNoYW5nZWQgb24gdGhlIHNhbWUgZnJhbWUgYXMgYSB0cmFuc2Zvcm0gVU5MRVNTIHdlIHNldCB0aGUgZWxlbWVudCdzIFdlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSB0byBoaWRkZW4gKHdlaXJkLCBJIGtub3cpLiBEb2luZyB0aGlzIGZvciBBbmRyb2lkIDMgYW5kIGVhcmxpZXIgc2VlbXMgdG8gYWN0dWFsbHkgY2F1c2Ugb3RoZXIgcHJvYmxlbXMsIHRob3VnaCAoZnVuISlcblx0XHRcdF9pZVZlcnMsXG5cdFx0XHRfc3VwcG9ydHNPcGFjaXR5ID0gKGZ1bmN0aW9uKCkgeyAvL3dlIHNldCBfaXNTYWZhcmksIF9pZVZlcnMsIF9pc0ZpcmVmb3gsIGFuZCBfc3VwcG9ydHNPcGFjaXR5IGFsbCBpbiBvbmUgZnVuY3Rpb24gaGVyZSB0byByZWR1Y2UgZmlsZSBzaXplIHNsaWdodGx5LCBlc3BlY2lhbGx5IGluIHRoZSBtaW5pZmllZCB2ZXJzaW9uLlxuXHRcdFx0XHR2YXIgaSA9IF9hZ2VudC5pbmRleE9mKFwiQW5kcm9pZFwiKSxcblx0XHRcdFx0XHRhID0gX2NyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXHRcdFx0XHRfaXNTYWZhcmkgPSAoX2FnZW50LmluZGV4T2YoXCJTYWZhcmlcIikgIT09IC0xICYmIF9hZ2VudC5pbmRleE9mKFwiQ2hyb21lXCIpID09PSAtMSAmJiAoaSA9PT0gLTEgfHwgcGFyc2VGbG9hdChfYWdlbnQuc3Vic3RyKGkrOCwgMikpID4gMykpO1xuXHRcdFx0XHRfaXNTYWZhcmlMVDYgPSAoX2lzU2FmYXJpICYmIChwYXJzZUZsb2F0KF9hZ2VudC5zdWJzdHIoX2FnZW50LmluZGV4T2YoXCJWZXJzaW9uL1wiKSs4LCAyKSkgPCA2KSk7XG5cdFx0XHRcdF9pc0ZpcmVmb3ggPSAoX2FnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpICE9PSAtMSk7XG5cdFx0XHRcdGlmICgoL01TSUUgKFswLTldezEsfVtcXC4wLTldezAsfSkvKS5leGVjKF9hZ2VudCkgfHwgKC9UcmlkZW50XFwvLipydjooWzAtOV17MSx9W1xcLjAtOV17MCx9KS8pLmV4ZWMoX2FnZW50KSkge1xuXHRcdFx0XHRcdF9pZVZlcnMgPSBwYXJzZUZsb2F0KCBSZWdFeHAuJDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWEpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0YS5zdHlsZS5jc3NUZXh0ID0gXCJ0b3A6MXB4O29wYWNpdHk6LjU1O1wiO1xuXHRcdFx0XHRyZXR1cm4gL14wLjU1Ly50ZXN0KGEuc3R5bGUub3BhY2l0eSk7XG5cdFx0XHR9KCkpLFxuXHRcdFx0X2dldElFT3BhY2l0eSA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0cmV0dXJuIChfb3BhY2l0eUV4cC50ZXN0KCAoKHR5cGVvZih2KSA9PT0gXCJzdHJpbmdcIikgPyB2IDogKHYuY3VycmVudFN0eWxlID8gdi5jdXJyZW50U3R5bGUuZmlsdGVyIDogdi5zdHlsZS5maWx0ZXIpIHx8IFwiXCIpICkgPyAoIHBhcnNlRmxvYXQoIFJlZ0V4cC4kMSApIC8gMTAwICkgOiAxKTtcblx0XHRcdH0sXG5cdFx0XHRfbG9nID0gZnVuY3Rpb24ocykgey8vZm9yIGxvZ2dpbmcgbWVzc2FnZXMsIGJ1dCBpbiBhIHdheSB0aGF0IHdvbid0IHRocm93IGVycm9ycyBpbiBvbGQgdmVyc2lvbnMgb2YgSUUuXG5cdFx0XHRcdGlmIChfZ3NTY29wZS5jb25zb2xlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2cocyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfdGFyZ2V0LCAvL3doZW4gaW5pdHRpbmcgYSBDU1NQbHVnaW4sIHdlIHNldCB0aGlzIHZhcmlhYmxlIHNvIHRoYXQgd2UgY2FuIGFjY2VzcyBpdCBmcm9tIHdpdGhpbiBtYW55IG90aGVyIGZ1bmN0aW9ucyB3aXRob3V0IGhhdmluZyB0byBwYXNzIGl0IGFyb3VuZCBhcyBwYXJhbXNcblx0XHRcdF9pbmRleCwgLy93aGVuIGluaXR0aW5nIGEgQ1NTUGx1Z2luLCB3ZSBzZXQgdGhpcyB2YXJpYWJsZSBzbyB0aGF0IHdlIGNhbiBhY2Nlc3MgaXQgZnJvbSB3aXRoaW4gbWFueSBvdGhlciBmdW5jdGlvbnMgd2l0aG91dCBoYXZpbmcgdG8gcGFzcyBpdCBhcm91bmQgYXMgcGFyYW1zXG5cblx0XHRcdF9wcmVmaXhDU1MgPSBcIlwiLCAvL3RoZSBub24tY2FtZWxDYXNlIHZlbmRvciBwcmVmaXggbGlrZSBcIi1vLVwiLCBcIi1tb3otXCIsIFwiLW1zLVwiLCBvciBcIi13ZWJraXQtXCJcblx0XHRcdF9wcmVmaXggPSBcIlwiLCAvL2NhbWVsQ2FzZSB2ZW5kb3IgcHJlZml4IGxpa2UgXCJPXCIsIFwibXNcIiwgXCJXZWJraXRcIiwgb3IgXCJNb3pcIi5cblxuXHRcdFx0Ly8gQHByaXZhdGUgZmVlZCBpbiBhIGNhbWVsQ2FzZSBwcm9wZXJ0eSBuYW1lIGxpa2UgXCJ0cmFuc2Zvcm1cIiBhbmQgaXQgd2lsbCBjaGVjayB0byBzZWUgaWYgaXQgaXMgdmFsaWQgYXMtaXMgb3IgaWYgaXQgbmVlZHMgYSB2ZW5kb3IgcHJlZml4LiBJdCByZXR1cm5zIHRoZSBjb3JyZWN0ZWQgY2FtZWxDYXNlIHByb3BlcnR5IG5hbWUgKGkuZS4gXCJXZWJraXRUcmFuc2Zvcm1cIiBvciBcIk1velRyYW5zZm9ybVwiIG9yIFwidHJhbnNmb3JtXCIgb3IgbnVsbCBpZiBubyBzdWNoIHByb3BlcnR5IGlzIGZvdW5kLCBsaWtlIGlmIHRoZSBicm93c2VyIGlzIElFOCBvciBiZWZvcmUsIFwidHJhbnNmb3JtXCIgd29uJ3QgYmUgZm91bmQgYXQgYWxsKVxuXHRcdFx0X2NoZWNrUHJvcFByZWZpeCA9IGZ1bmN0aW9uKHAsIGUpIHtcblx0XHRcdFx0ZSA9IGUgfHwgX3RlbXBEaXY7XG5cdFx0XHRcdHZhciBzID0gZS5zdHlsZSxcblx0XHRcdFx0XHRhLCBpO1xuXHRcdFx0XHRpZiAoc1twXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cCA9IHAuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwLnN1YnN0cigxKTtcblx0XHRcdFx0YSA9IFtcIk9cIixcIk1velwiLFwibXNcIixcIk1zXCIsXCJXZWJraXRcIl07XG5cdFx0XHRcdGkgPSA1O1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEgJiYgc1thW2ldK3BdID09PSB1bmRlZmluZWQpIHsgfVxuXHRcdFx0XHRpZiAoaSA+PSAwKSB7XG5cdFx0XHRcdFx0X3ByZWZpeCA9IChpID09PSAzKSA/IFwibXNcIiA6IGFbaV07XG5cdFx0XHRcdFx0X3ByZWZpeENTUyA9IFwiLVwiICsgX3ByZWZpeC50b0xvd2VyQ2FzZSgpICsgXCItXCI7XG5cdFx0XHRcdFx0cmV0dXJuIF9wcmVmaXggKyBwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSxcblxuXHRcdFx0X2dldENvbXB1dGVkU3R5bGUgPSAodHlwZW9mKHdpbmRvdykgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBfZG9jLmRlZmF1bHRWaWV3IHx8IHtnZXRDb21wdXRlZFN0eWxlOmZ1bmN0aW9uKCkge319KS5nZXRDb21wdXRlZFN0eWxlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFJldHVybnMgdGhlIGNzcyBzdHlsZSBmb3IgYSBwYXJ0aWN1bGFyIHByb3BlcnR5IG9mIGFuIGVsZW1lbnQuIEZvciBleGFtcGxlLCB0byBnZXQgd2hhdGV2ZXIgdGhlIGN1cnJlbnQgXCJsZWZ0XCIgY3NzIHZhbHVlIGZvciBhbiBlbGVtZW50IHdpdGggYW4gSUQgb2YgXCJteUVsZW1lbnRcIiwgeW91IGNvdWxkIGRvOlxuXHRcdFx0ICogdmFyIGN1cnJlbnRMZWZ0ID0gQ1NTUGx1Z2luLmdldFN0eWxlKCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15RWxlbWVudFwiKSwgXCJsZWZ0XCIpO1xuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgZWxlbWVudCB3aG9zZSBzdHlsZSBwcm9wZXJ0eSB5b3Ugd2FudCB0byBxdWVyeVxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWUgKGxpa2UgXCJsZWZ0XCIgb3IgXCJ0b3BcIiBvciBcIm1hcmdpblRvcFwiLCBldGMuKVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBjcyBDb21wdXRlZCBzdHlsZSBvYmplY3QuIFRoaXMganVzdCBwcm92aWRlcyBhIHdheSB0byBzcGVlZCBwcm9jZXNzaW5nIGlmIHlvdSdyZSBnb2luZyB0byBnZXQgc2V2ZXJhbCBwcm9wZXJ0aWVzIG9uIHRoZSBzYW1lIGVsZW1lbnQgaW4gcXVpY2sgc3VjY2Vzc2lvbiAtIHlvdSBjYW4gcmV1c2UgdGhlIHJlc3VsdCBvZiB0aGUgZ2V0Q29tcHV0ZWRTdHlsZSgpIGNhbGwuXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBjYWxjIElmIHRydWUsIHRoZSB2YWx1ZSB3aWxsIG5vdCBiZSByZWFkIGRpcmVjdGx5IGZyb20gdGhlIGVsZW1lbnQncyBcInN0eWxlXCIgcHJvcGVydHkgKGlmIGl0IGV4aXN0cyB0aGVyZSksIGJ1dCBpbnN0ZWFkIHRoZSBnZXRDb21wdXRlZFN0eWxlKCkgcmVzdWx0IHdpbGwgYmUgdXNlZC4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gZW5zdXJlIHRoYXQgdGhlIGJyb3dzZXIgaXRzZWxmIGlzIGludGVycHJldGluZyB0aGUgdmFsdWUuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IGRmbHQgRGVmYXVsdCB2YWx1ZSB0aGF0IHNob3VsZCBiZSByZXR1cm5lZCBpbiB0aGUgcGxhY2Ugb2YgbnVsbCwgXCJub25lXCIsIFwiYXV0b1wiIG9yIFwiYXV0byBhdXRvXCIuXG5cdFx0XHQgKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgY3VycmVudCBwcm9wZXJ0eSB2YWx1ZVxuXHRcdFx0ICovXG5cdFx0XHRfZ2V0U3R5bGUgPSBDU1NQbHVnaW4uZ2V0U3R5bGUgPSBmdW5jdGlvbih0LCBwLCBjcywgY2FsYywgZGZsdCkge1xuXHRcdFx0XHR2YXIgcnY7XG5cdFx0XHRcdGlmICghX3N1cHBvcnRzT3BhY2l0eSkgaWYgKHAgPT09IFwib3BhY2l0eVwiKSB7IC8vc2V2ZXJhbCB2ZXJzaW9ucyBvZiBJRSBkb24ndCB1c2UgdGhlIHN0YW5kYXJkIFwib3BhY2l0eVwiIHByb3BlcnR5IC0gdGhleSB1c2UgdGhpbmdzIGxpa2UgZmlsdGVyOmFscGhhKG9wYWNpdHk9NTApLCBzbyB3ZSBwYXJzZSB0aGF0IGhlcmUuXG5cdFx0XHRcdFx0cmV0dXJuIF9nZXRJRU9wYWNpdHkodCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFjYWxjICYmIHQuc3R5bGVbcF0pIHtcblx0XHRcdFx0XHRydiA9IHQuc3R5bGVbcF07XG5cdFx0XHRcdH0gZWxzZSBpZiAoKGNzID0gY3MgfHwgX2dldENvbXB1dGVkU3R5bGUodCkpKSB7XG5cdFx0XHRcdFx0cnYgPSBjc1twXSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHApIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocC5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0LmN1cnJlbnRTdHlsZSkge1xuXHRcdFx0XHRcdHJ2ID0gdC5jdXJyZW50U3R5bGVbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIChkZmx0ICE9IG51bGwgJiYgKCFydiB8fCBydiA9PT0gXCJub25lXCIgfHwgcnYgPT09IFwiYXV0b1wiIHx8IHJ2ID09PSBcImF1dG8gYXV0b1wiKSkgPyBkZmx0IDogcnY7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFBhc3MgdGhlIHRhcmdldCBlbGVtZW50LCB0aGUgcHJvcGVydHkgbmFtZSwgdGhlIG51bWVyaWMgdmFsdWUsIGFuZCB0aGUgc3VmZml4IChsaWtlIFwiJVwiLCBcImVtXCIsIFwicHhcIiwgZXRjLikgYW5kIGl0IHdpbGwgc3BpdCBiYWNrIHRoZSBlcXVpdmFsZW50IHBpeGVsIG51bWJlci5cblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWUgKGxpa2UgXCJsZWZ0XCIsIFwidG9wXCIsIFwibWFyZ2luTGVmdFwiLCBldGMuKVxuXHRcdFx0ICogQHBhcmFtIHshbnVtYmVyfSB2IFZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IHNmeCBTdWZmaXggKGxpa2UgXCJweFwiIG9yIFwiJVwiIG9yIFwiZW1cIilcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHJlY3Vyc2UgSWYgdHJ1ZSwgdGhlIGNhbGwgaXMgYSByZWN1cnNpdmUgb25lLiBJbiBzb21lIGJyb3dzZXJzIChsaWtlIElFNy84KSwgb2NjYXNpb25hbGx5IHRoZSB2YWx1ZSBpc24ndCBhY2N1cmF0ZWx5IHJlcG9ydGVkIGluaXRpYWxseSwgYnV0IGlmIHdlIHJ1biB0aGUgZnVuY3Rpb24gYWdhaW4gaXQgd2lsbCB0YWtlIGVmZmVjdC5cblx0XHRcdCAqIEByZXR1cm4ge251bWJlcn0gdmFsdWUgaW4gcGl4ZWxzXG5cdFx0XHQgKi9cblx0XHRcdF9jb252ZXJ0VG9QaXhlbHMgPSBfaW50ZXJuYWxzLmNvbnZlcnRUb1BpeGVscyA9IGZ1bmN0aW9uKHQsIHAsIHYsIHNmeCwgcmVjdXJzZSkge1xuXHRcdFx0XHRpZiAoc2Z4ID09PSBcInB4XCIgfHwgKCFzZnggJiYgcCAhPT0gXCJsaW5lSGVpZ2h0XCIpKSB7IHJldHVybiB2OyB9XG5cdFx0XHRcdGlmIChzZnggPT09IFwiYXV0b1wiIHx8ICF2KSB7IHJldHVybiAwOyB9XG5cdFx0XHRcdHZhciBob3JpeiA9IF9ob3JpekV4cC50ZXN0KHApLFxuXHRcdFx0XHRcdG5vZGUgPSB0LFxuXHRcdFx0XHRcdHN0eWxlID0gX3RlbXBEaXYuc3R5bGUsXG5cdFx0XHRcdFx0bmVnID0gKHYgPCAwKSxcblx0XHRcdFx0XHRwcmVjaXNlID0gKHYgPT09IDEpLFxuXHRcdFx0XHRcdHBpeCwgY2FjaGUsIHRpbWU7XG5cdFx0XHRcdGlmIChuZWcpIHtcblx0XHRcdFx0XHR2ID0gLXY7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByZWNpc2UpIHtcblx0XHRcdFx0XHR2ICo9IDEwMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocCA9PT0gXCJsaW5lSGVpZ2h0XCIgJiYgIXNmeCkgeyAvL3NwZWNpYWwgY2FzZSBvZiB3aGVuIGEgc2ltcGxlIGxpbmVIZWlnaHQgKHdpdGhvdXQgYSB1bml0KSBpcyB1c2VkLiBTZXQgaXQgdG8gdGhlIHZhbHVlLCByZWFkIGJhY2sgdGhlIGNvbXB1dGVkIHZhbHVlLCBhbmQgdGhlbiByZXZlcnQuXG5cdFx0XHRcdFx0Y2FjaGUgPSBfZ2V0Q29tcHV0ZWRTdHlsZSh0KS5saW5lSGVpZ2h0O1xuXHRcdFx0XHRcdHQuc3R5bGUubGluZUhlaWdodCA9IHY7XG5cdFx0XHRcdFx0cGl4ID0gcGFyc2VGbG9hdChfZ2V0Q29tcHV0ZWRTdHlsZSh0KS5saW5lSGVpZ2h0KTtcblx0XHRcdFx0XHR0LnN0eWxlLmxpbmVIZWlnaHQgPSBjYWNoZTtcblx0XHRcdFx0fSBlbHNlIGlmIChzZnggPT09IFwiJVwiICYmIHAuaW5kZXhPZihcImJvcmRlclwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRwaXggPSAodiAvIDEwMCkgKiAoaG9yaXogPyB0LmNsaWVudFdpZHRoIDogdC5jbGllbnRIZWlnaHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowIHNvbGlkIHJlZDtwb3NpdGlvbjpcIiArIF9nZXRTdHlsZSh0LCBcInBvc2l0aW9uXCIpICsgXCI7bGluZS1oZWlnaHQ6MDtcIjtcblx0XHRcdFx0XHRpZiAoc2Z4ID09PSBcIiVcIiB8fCAhbm9kZS5hcHBlbmRDaGlsZCB8fCBzZnguY2hhckF0KDApID09PSBcInZcIiB8fCBzZnggPT09IFwicmVtXCIpIHtcblx0XHRcdFx0XHRcdG5vZGUgPSB0LnBhcmVudE5vZGUgfHwgX2RvYy5ib2R5O1xuXHRcdFx0XHRcdFx0aWYgKF9nZXRTdHlsZShub2RlLCBcImRpc3BsYXlcIikuaW5kZXhPZihcImZsZXhcIikgIT09IC0xKSB7IC8vRWRnZSBhbmQgSUUxMSBoYXZlIGEgYnVnIHRoYXQgY2F1c2VzIG9mZnNldFdpZHRoIHRvIHJlcG9ydCBhcyAwIGlmIHRoZSBjb250YWluZXIgaGFzIGRpc3BsYXk6ZmxleCBhbmQgdGhlIGNoaWxkIGlzIHBvc2l0aW9uOnJlbGF0aXZlLiBTd2l0Y2hpbmcgdG8gcG9zaXRpb246IGFic29sdXRlIHNvbHZlcyBpdC5cblx0XHRcdFx0XHRcdFx0c3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjYWNoZSA9IG5vZGUuX2dzQ2FjaGU7XG5cdFx0XHRcdFx0XHR0aW1lID0gVHdlZW5MaXRlLnRpY2tlci5mcmFtZTtcblx0XHRcdFx0XHRcdGlmIChjYWNoZSAmJiBob3JpeiAmJiBjYWNoZS50aW1lID09PSB0aW1lKSB7IC8vcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiB3ZSByZWNvcmQgdGhlIHdpZHRoIG9mIGVsZW1lbnRzIGFsb25nIHdpdGggdGhlIHRpY2tlciBmcmFtZSBzbyB0aGF0IHdlIGNhbiBxdWlja2x5IGdldCBpdCBhZ2FpbiBvbiB0aGUgc2FtZSB0aWNrIChzZWVtcyByZWxhdGl2ZWx5IHNhZmUgdG8gYXNzdW1lIGl0IHdvdWxkbid0IGNoYW5nZSBvbiB0aGUgc2FtZSB0aWNrKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY2FjaGUud2lkdGggKiB2IC8gMTAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c3R5bGVbKGhvcml6ID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIildID0gdiArIHNmeDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3R5bGVbKGhvcml6ID8gXCJib3JkZXJMZWZ0V2lkdGhcIiA6IFwiYm9yZGVyVG9wV2lkdGhcIildID0gdiArIHNmeDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChfdGVtcERpdik7XG5cdFx0XHRcdFx0cGl4ID0gcGFyc2VGbG9hdChfdGVtcERpdlsoaG9yaXogPyBcIm9mZnNldFdpZHRoXCIgOiBcIm9mZnNldEhlaWdodFwiKV0pO1xuXHRcdFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQoX3RlbXBEaXYpO1xuXHRcdFx0XHRcdGlmIChob3JpeiAmJiBzZnggPT09IFwiJVwiICYmIENTU1BsdWdpbi5jYWNoZVdpZHRocyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGNhY2hlID0gbm9kZS5fZ3NDYWNoZSA9IG5vZGUuX2dzQ2FjaGUgfHwge307XG5cdFx0XHRcdFx0XHRjYWNoZS50aW1lID0gdGltZTtcblx0XHRcdFx0XHRcdGNhY2hlLndpZHRoID0gcGl4IC8gdiAqIDEwMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBpeCA9PT0gMCAmJiAhcmVjdXJzZSkge1xuXHRcdFx0XHRcdFx0cGl4ID0gX2NvbnZlcnRUb1BpeGVscyh0LCBwLCB2LCBzZngsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJlY2lzZSkge1xuXHRcdFx0XHRcdHBpeCAvPSAxMDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG5lZyA/IC1waXggOiBwaXg7XG5cdFx0XHR9LFxuXHRcdFx0X2NhbGN1bGF0ZU9mZnNldCA9IF9pbnRlcm5hbHMuY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24odCwgcCwgY3MpIHsgLy9mb3IgZmlndXJpbmcgb3V0IFwidG9wXCIgb3IgXCJsZWZ0XCIgaW4gcHggd2hlbiBpdCdzIFwiYXV0b1wiLiBXZSBuZWVkIHRvIGZhY3RvciBpbiBtYXJnaW4gd2l0aCB0aGUgb2Zmc2V0TGVmdC9vZmZzZXRUb3Bcblx0XHRcdFx0aWYgKF9nZXRTdHlsZSh0LCBcInBvc2l0aW9uXCIsIGNzKSAhPT0gXCJhYnNvbHV0ZVwiKSB7IHJldHVybiAwOyB9XG5cdFx0XHRcdHZhciBkaW0gPSAoKHAgPT09IFwibGVmdFwiKSA/IFwiTGVmdFwiIDogXCJUb3BcIiksXG5cdFx0XHRcdFx0diA9IF9nZXRTdHlsZSh0LCBcIm1hcmdpblwiICsgZGltLCBjcyk7XG5cdFx0XHRcdHJldHVybiB0W1wib2Zmc2V0XCIgKyBkaW1dIC0gKF9jb252ZXJ0VG9QaXhlbHModCwgcCwgcGFyc2VGbG9hdCh2KSwgdi5yZXBsYWNlKF9zdWZmaXhFeHAsIFwiXCIpKSB8fCAwKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBwcml2YXRlIHJldHVybnMgYXQgb2JqZWN0IGNvbnRhaW5pbmcgQUxMIG9mIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIGluIGNhbWVsQ2FzZSBhbmQgdGhlaXIgYXNzb2NpYXRlZCB2YWx1ZXMuXG5cdFx0XHRfZ2V0QWxsU3R5bGVzID0gZnVuY3Rpb24odCwgY3MpIHtcblx0XHRcdFx0dmFyIHMgPSB7fSxcblx0XHRcdFx0XHRpLCB0ciwgcDtcblx0XHRcdFx0aWYgKChjcyA9IGNzIHx8IF9nZXRDb21wdXRlZFN0eWxlKHQsIG51bGwpKSkge1xuXHRcdFx0XHRcdGlmICgoaSA9IGNzLmxlbmd0aCkpIHtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRwID0gY3NbaV07XG5cdFx0XHRcdFx0XHRcdGlmIChwLmluZGV4T2YoXCItdHJhbnNmb3JtXCIpID09PSAtMSB8fCBfdHJhbnNmb3JtUHJvcENTUyA9PT0gcCkgeyAvL1NvbWUgd2Via2l0IGJyb3dzZXJzIGR1cGxpY2F0ZSB0cmFuc2Zvcm0gdmFsdWVzLCBvbmUgbm9uLXByZWZpeGVkIGFuZCBvbmUgcHJlZml4ZWQgKFwidHJhbnNmb3JtXCIgYW5kIFwiV2Via2l0VHJhbnNmb3JtXCIpLCBzbyB3ZSBtdXN0IHdlZWQgb3V0IHRoZSBleHRyYSBvbmUgaGVyZS5cblx0XHRcdFx0XHRcdFx0XHRzW3AucmVwbGFjZShfY2FtZWxFeHAsIF9jYW1lbEZ1bmMpXSA9IGNzLmdldFByb3BlcnR5VmFsdWUocCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgeyAvL3NvbWUgYnJvd3NlcnMgYmVoYXZlIGRpZmZlcmVudGx5IC0gY3MubGVuZ3RoIGlzIGFsd2F5cyAwLCBzbyB3ZSBtdXN0IGRvIGEgZm9yLi4uaW4gbG9vcC5cblx0XHRcdFx0XHRcdGZvciAoaSBpbiBjcykge1xuXHRcdFx0XHRcdFx0XHRpZiAoaS5pbmRleE9mKFwiVHJhbnNmb3JtXCIpID09PSAtMSB8fCBfdHJhbnNmb3JtUHJvcCA9PT0gaSkgeyAvL1NvbWUgd2Via2l0IGJyb3dzZXJzIGR1cGxpY2F0ZSB0cmFuc2Zvcm0gdmFsdWVzLCBvbmUgbm9uLXByZWZpeGVkIGFuZCBvbmUgcHJlZml4ZWQgKFwidHJhbnNmb3JtXCIgYW5kIFwiV2Via2l0VHJhbnNmb3JtXCIpLCBzbyB3ZSBtdXN0IHdlZWQgb3V0IHRoZSBleHRyYSBvbmUgaGVyZS5cblx0XHRcdFx0XHRcdFx0XHRzW2ldID0gY3NbaV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoKGNzID0gdC5jdXJyZW50U3R5bGUgfHwgdC5zdHlsZSkpIHtcblx0XHRcdFx0XHRmb3IgKGkgaW4gY3MpIHtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YoaSkgPT09IFwic3RyaW5nXCIgJiYgc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdHNbaS5yZXBsYWNlKF9jYW1lbEV4cCwgX2NhbWVsRnVuYyldID0gY3NbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghX3N1cHBvcnRzT3BhY2l0eSkge1xuXHRcdFx0XHRcdHMub3BhY2l0eSA9IF9nZXRJRU9wYWNpdHkodCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHIgPSBfZ2V0VHJhbnNmb3JtKHQsIGNzLCBmYWxzZSk7XG5cdFx0XHRcdHMucm90YXRpb24gPSB0ci5yb3RhdGlvbjtcblx0XHRcdFx0cy5za2V3WCA9IHRyLnNrZXdYO1xuXHRcdFx0XHRzLnNjYWxlWCA9IHRyLnNjYWxlWDtcblx0XHRcdFx0cy5zY2FsZVkgPSB0ci5zY2FsZVk7XG5cdFx0XHRcdHMueCA9IHRyLng7XG5cdFx0XHRcdHMueSA9IHRyLnk7XG5cdFx0XHRcdGlmIChfc3VwcG9ydHMzRCkge1xuXHRcdFx0XHRcdHMueiA9IHRyLno7XG5cdFx0XHRcdFx0cy5yb3RhdGlvblggPSB0ci5yb3RhdGlvblg7XG5cdFx0XHRcdFx0cy5yb3RhdGlvblkgPSB0ci5yb3RhdGlvblk7XG5cdFx0XHRcdFx0cy5zY2FsZVogPSB0ci5zY2FsZVo7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHMuZmlsdGVycykge1xuXHRcdFx0XHRcdGRlbGV0ZSBzLmZpbHRlcnM7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAcHJpdmF0ZSBhbmFseXplcyB0d28gc3R5bGUgb2JqZWN0cyAoYXMgcmV0dXJuZWQgYnkgX2dldEFsbFN0eWxlcygpKSBhbmQgb25seSBsb29rcyBmb3IgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGVtIHRoYXQgY29udGFpbiB0d2VlbmFibGUgdmFsdWVzIChsaWtlIGEgbnVtYmVyIG9yIGNvbG9yKS4gSXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIFwiZGlmc1wiIHByb3BlcnR5IHdoaWNoIHJlZmVycyB0byBhbiBvYmplY3QgY29udGFpbmluZyBvbmx5IHRob3NlIGlzb2xhdGVkIHByb3BlcnRpZXMgYW5kIHZhbHVlcyBmb3IgdHdlZW5pbmcsIGFuZCBhIFwiZmlyc3RNUFRcIiBwcm9wZXJ0eSB3aGljaCByZWZlcnMgdG8gdGhlIGZpcnN0IE1pbmlQcm9wVHdlZW4gaW5zdGFuY2UgaW4gYSBsaW5rZWQgbGlzdCB0aGF0IHJlY29yZGVkIGFsbCB0aGUgc3RhcnRpbmcgdmFsdWVzIG9mIHRoZSBkaWZmZXJlbnQgcHJvcGVydGllcyBzbyB0aGF0IHdlIGNhbiByZXZlcnQgdG8gdGhlbSBhdCB0aGUgZW5kIG9yIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4gLSB3ZSBkb24ndCB3YW50IHRoZSBjYXNjYWRpbmcgdG8gZ2V0IG1lc3NlZCB1cC4gVGhlIGZvcmNlTG9va3VwIHBhcmFtZXRlciBpcyBhbiBvcHRpb25hbCBnZW5lcmljIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgZm9yY2VkIGludG8gdGhlIHJlc3VsdHMgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY2xhc3NOYW1lIHR3ZWVucyB0aGF0IGFyZSBvdmVyd3JpdGluZyBvdGhlcnMgYmVjYXVzZSBpbWFnaW5lIGEgc2NlbmFyaW8gd2hlcmUgYSByb2xsb3Zlci9yb2xsb3V0IGFkZHMvcmVtb3ZlcyBhIGNsYXNzIGFuZCB0aGUgdXNlciBzd2lwZXMgdGhlIG1vdXNlIG92ZXIgdGhlIHRhcmdldCBTVVBFUiBmYXN0LCB0aHVzIG5vdGhpbmcgYWN0dWFsbHkgY2hhbmdlZCB5ZXQgYW5kIHRoZSBzdWJzZXF1ZW50IGNvbXBhcmlzb24gb2YgdGhlIHByb3BlcnRpZXMgd291bGQgaW5kaWNhdGUgdGhleSBtYXRjaCAoZXNwZWNpYWxseSB3aGVuIHB4IHJvdW5kaW5nIGlzIHRha2VuIGludG8gY29uc2lkZXJhdGlvbiksIHRodXMgbm8gdHdlZW5pbmcgaXMgbmVjZXNzYXJ5IGV2ZW4gdGhvdWdoIGl0IFNIT1VMRCB0d2VlbiBhbmQgcmVtb3ZlIHRob3NlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIHR3ZWVuIChvdGhlcndpc2UgdGhlIGlubGluZSBzdHlsZXMgd2lsbCBjb250YW1pbmF0ZSB0aGluZ3MpLiBTZWUgdGhlIGNsYXNzTmFtZSBTcGVjaWFsUHJvcCBjb2RlIGZvciBkZXRhaWxzLlxuXHRcdFx0X2Nzc0RpZiA9IGZ1bmN0aW9uKHQsIHMxLCBzMiwgdmFycywgZm9yY2VMb29rdXApIHtcblx0XHRcdFx0dmFyIGRpZnMgPSB7fSxcblx0XHRcdFx0XHRzdHlsZSA9IHQuc3R5bGUsXG5cdFx0XHRcdFx0dmFsLCBwLCBtcHQ7XG5cdFx0XHRcdGZvciAocCBpbiBzMikge1xuXHRcdFx0XHRcdGlmIChwICE9PSBcImNzc1RleHRcIikgaWYgKHAgIT09IFwibGVuZ3RoXCIpIGlmIChpc05hTihwKSkgaWYgKHMxW3BdICE9PSAodmFsID0gczJbcF0pIHx8IChmb3JjZUxvb2t1cCAmJiBmb3JjZUxvb2t1cFtwXSkpIGlmIChwLmluZGV4T2YoXCJPcmlnaW5cIikgPT09IC0xKSBpZiAodHlwZW9mKHZhbCkgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mKHZhbCkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRcdGRpZnNbcF0gPSAodmFsID09PSBcImF1dG9cIiAmJiAocCA9PT0gXCJsZWZ0XCIgfHwgcCA9PT0gXCJ0b3BcIikpID8gX2NhbGN1bGF0ZU9mZnNldCh0LCBwKSA6ICgodmFsID09PSBcIlwiIHx8IHZhbCA9PT0gXCJhdXRvXCIgfHwgdmFsID09PSBcIm5vbmVcIikgJiYgdHlwZW9mKHMxW3BdKSA9PT0gXCJzdHJpbmdcIiAmJiBzMVtwXS5yZXBsYWNlKF9OYU5FeHAsIFwiXCIpICE9PSBcIlwiKSA/IDAgOiB2YWw7IC8vaWYgdGhlIGVuZGluZyB2YWx1ZSBpcyBkZWZhdWx0aW5nIChcIlwiIG9yIFwiYXV0b1wiKSwgd2UgY2hlY2sgdGhlIHN0YXJ0aW5nIHZhbHVlIGFuZCBpZiBpdCBjYW4gYmUgcGFyc2VkIGludG8gYSBudW1iZXIgKGEgc3RyaW5nIHdoaWNoIGNvdWxkIGhhdmUgYSBzdWZmaXggdG9vLCBsaWtlIDcwMHB4KSwgdGhlbiB3ZSBzd2FwIGluIDAgZm9yIFwiXCIgb3IgXCJhdXRvXCIgc28gdGhhdCB0aGluZ3MgYWN0dWFsbHkgdHdlZW4uXG5cdFx0XHRcdFx0XHRpZiAoc3R5bGVbcF0gIT09IHVuZGVmaW5lZCkgeyAvL2ZvciBjbGFzc05hbWUgdHdlZW5zLCB3ZSBtdXN0IHJlbWVtYmVyIHdoaWNoIHByb3BlcnRpZXMgYWxyZWFkeSBleGlzdGVkIGlubGluZSAtIHRoZSBvbmVzIHRoYXQgZGlkbid0IHNob3VsZCBiZSByZW1vdmVkIHdoZW4gdGhlIHR3ZWVuIGlzbid0IGluIHByb2dyZXNzIGJlY2F1c2UgdGhleSB3ZXJlIG9ubHkgaW50cm9kdWNlZCB0byBmYWNpbGl0YXRlIHRoZSB0cmFuc2l0aW9uIGJldHdlZW4gY2xhc3Nlcy5cblx0XHRcdFx0XHRcdFx0bXB0ID0gbmV3IE1pbmlQcm9wVHdlZW4oc3R5bGUsIHAsIHN0eWxlW3BdLCBtcHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodmFycykge1xuXHRcdFx0XHRcdGZvciAocCBpbiB2YXJzKSB7IC8vY29weSBwcm9wZXJ0aWVzIChleGNlcHQgY2xhc3NOYW1lKVxuXHRcdFx0XHRcdFx0aWYgKHAgIT09IFwiY2xhc3NOYW1lXCIpIHtcblx0XHRcdFx0XHRcdFx0ZGlmc1twXSA9IHZhcnNbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7ZGlmczpkaWZzLCBmaXJzdE1QVDptcHR9O1xuXHRcdFx0fSxcblx0XHRcdF9kaW1lbnNpb25zID0ge3dpZHRoOltcIkxlZnRcIixcIlJpZ2h0XCJdLCBoZWlnaHQ6W1wiVG9wXCIsXCJCb3R0b21cIl19LFxuXHRcdFx0X21hcmdpbnMgPSBbXCJtYXJnaW5MZWZ0XCIsXCJtYXJnaW5SaWdodFwiLFwibWFyZ2luVG9wXCIsXCJtYXJnaW5Cb3R0b21cIl0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgR2V0cyB0aGUgd2lkdGggb3IgaGVpZ2h0IG9mIGFuIGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWUgKFwid2lkdGhcIiBvciBcImhlaWdodFwiKVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBjcyBDb21wdXRlZCBzdHlsZSBvYmplY3QgKGlmIG9uZSBleGlzdHMpLiBKdXN0IGEgc3BlZWQgb3B0aW1pemF0aW9uLlxuXHRcdFx0ICogQHJldHVybiB7bnVtYmVyfSBEaW1lbnNpb24gKGluIHBpeGVscylcblx0XHRcdCAqL1xuXHRcdFx0X2dldERpbWVuc2lvbiA9IGZ1bmN0aW9uKHQsIHAsIGNzKSB7XG5cdFx0XHRcdGlmICgodC5ub2RlTmFtZSArIFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCIpIHsgLy9DaHJvbWUgbm8gbG9uZ2VyIHN1cHBvcnRzIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBvbiBTVkcgZWxlbWVudHMuXG5cdFx0XHRcdFx0cmV0dXJuIChjcyB8fCBfZ2V0Q29tcHV0ZWRTdHlsZSh0KSlbcF0gfHwgMDtcblx0XHRcdFx0fSBlbHNlIGlmICh0LmdldENUTSAmJiBfaXNTVkcodCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gdC5nZXRCQm94KClbcF0gfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgdiA9IHBhcnNlRmxvYXQoKHAgPT09IFwid2lkdGhcIikgPyB0Lm9mZnNldFdpZHRoIDogdC5vZmZzZXRIZWlnaHQpLFxuXHRcdFx0XHRcdGEgPSBfZGltZW5zaW9uc1twXSxcblx0XHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdGNzID0gY3MgfHwgX2dldENvbXB1dGVkU3R5bGUodCwgbnVsbCk7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHYgLT0gcGFyc2VGbG9hdCggX2dldFN0eWxlKHQsIFwicGFkZGluZ1wiICsgYVtpXSwgY3MsIHRydWUpICkgfHwgMDtcblx0XHRcdFx0XHR2IC09IHBhcnNlRmxvYXQoIF9nZXRTdHlsZSh0LCBcImJvcmRlclwiICsgYVtpXSArIFwiV2lkdGhcIiwgY3MsIHRydWUpICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdjtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBwcml2YXRlIFBhcnNlcyBwb3NpdGlvbi1yZWxhdGVkIGNvbXBsZXggc3RyaW5ncyBsaWtlIFwidG9wIGxlZnRcIiBvciBcIjUwcHggMTBweFwiIG9yIFwiNzAlIDIwJVwiLCBldGMuIHdoaWNoIGFyZSB1c2VkIGZvciB0aGluZ3MgbGlrZSB0cmFuc2Zvcm1PcmlnaW4gb3IgYmFja2dyb3VuZFBvc2l0aW9uLiBPcHRpb25hbGx5IGRlY29yYXRlcyBhIHN1cHBsaWVkIG9iamVjdCAocmVjT2JqKSB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczogXCJveFwiIChvZmZzZXRYKSwgXCJveVwiIChvZmZzZXRZKSwgXCJveHBcIiAoaWYgdHJ1ZSwgXCJveFwiIGlzIGEgcGVyY2VudGFnZSBub3QgYSBwaXhlbCB2YWx1ZSksIGFuZCBcIm94eVwiIChpZiB0cnVlLCBcIm95XCIgaXMgYSBwZXJjZW50YWdlIG5vdCBhIHBpeGVsIHZhbHVlKVxuXHRcdFx0X3BhcnNlUG9zaXRpb24gPSBmdW5jdGlvbih2LCByZWNPYmopIHtcblx0XHRcdFx0aWYgKHYgPT09IFwiY29udGFpblwiIHx8IHYgPT09IFwiYXV0b1wiIHx8IHYgPT09IFwiYXV0byBhdXRvXCIpIHsgLy9ub3RlOiBGaXJlZm94IHVzZXMgXCJhdXRvIGF1dG9cIiBhcyBkZWZhdWx0IHdoZXJlYXMgQ2hyb21lIHVzZXMgXCJhdXRvXCIuXG5cdFx0XHRcdFx0cmV0dXJuIHYgKyBcIiBcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodiA9PSBudWxsIHx8IHYgPT09IFwiXCIpIHtcblx0XHRcdFx0XHR2ID0gXCIwIDBcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgYSA9IHYuc3BsaXQoXCIgXCIpLFxuXHRcdFx0XHRcdHggPSAodi5pbmRleE9mKFwibGVmdFwiKSAhPT0gLTEpID8gXCIwJVwiIDogKHYuaW5kZXhPZihcInJpZ2h0XCIpICE9PSAtMSkgPyBcIjEwMCVcIiA6IGFbMF0sXG5cdFx0XHRcdFx0eSA9ICh2LmluZGV4T2YoXCJ0b3BcIikgIT09IC0xKSA/IFwiMCVcIiA6ICh2LmluZGV4T2YoXCJib3R0b21cIikgIT09IC0xKSA/IFwiMTAwJVwiIDogYVsxXSxcblx0XHRcdFx0XHRpO1xuXHRcdFx0XHRpZiAoYS5sZW5ndGggPiAzICYmICFyZWNPYmopIHsgLy9tdWx0aXBsZSBwb3NpdGlvbnNcblx0XHRcdFx0XHRhID0gdi5zcGxpdChcIiwgXCIpLmpvaW4oXCIsXCIpLnNwbGl0KFwiLFwiKTtcblx0XHRcdFx0XHR2ID0gW107XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHYucHVzaChfcGFyc2VQb3NpdGlvbihhW2ldKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2LmpvaW4oXCIsXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh5ID09IG51bGwpIHtcblx0XHRcdFx0XHR5ID0gKHggPT09IFwiY2VudGVyXCIpID8gXCI1MCVcIiA6IFwiMFwiO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHkgPT09IFwiY2VudGVyXCIpIHtcblx0XHRcdFx0XHR5ID0gXCI1MCVcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoeCA9PT0gXCJjZW50ZXJcIiB8fCAoaXNOYU4ocGFyc2VGbG9hdCh4KSkgJiYgKHggKyBcIlwiKS5pbmRleE9mKFwiPVwiKSA9PT0gLTEpKSB7IC8vcmVtZW1iZXIsIHRoZSB1c2VyIGNvdWxkIGZsaXAtZmxvcCB0aGUgdmFsdWVzIGFuZCBzYXkgXCJib3R0b20gY2VudGVyXCIgb3IgXCJjZW50ZXIgYm90dG9tXCIsIGV0Yy4gXCJjZW50ZXJcIiBpcyBhbWJpZ3VvdXMgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkIHRvIGRlc2NyaWJlIGhvcml6b250YWwgb3IgdmVydGljYWwsIGhlbmNlIHRoZSBpc05hTigpLiBJZiB0aGVyZSdzIGFuIFwiPVwiIHNpZ24gaW4gdGhlIHZhbHVlLCBpdCdzIHJlbGF0aXZlLlxuXHRcdFx0XHRcdHggPSBcIjUwJVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHYgPSB4ICsgXCIgXCIgKyB5ICsgKChhLmxlbmd0aCA+IDIpID8gXCIgXCIgKyBhWzJdIDogXCJcIik7XG5cdFx0XHRcdGlmIChyZWNPYmopIHtcblx0XHRcdFx0XHRyZWNPYmoub3hwID0gKHguaW5kZXhPZihcIiVcIikgIT09IC0xKTtcblx0XHRcdFx0XHRyZWNPYmoub3lwID0gKHkuaW5kZXhPZihcIiVcIikgIT09IC0xKTtcblx0XHRcdFx0XHRyZWNPYmoub3hyID0gKHguY2hhckF0KDEpID09PSBcIj1cIik7XG5cdFx0XHRcdFx0cmVjT2JqLm95ciA9ICh5LmNoYXJBdCgxKSA9PT0gXCI9XCIpO1xuXHRcdFx0XHRcdHJlY09iai5veCA9IHBhcnNlRmxvYXQoeC5yZXBsYWNlKF9OYU5FeHAsIFwiXCIpKTtcblx0XHRcdFx0XHRyZWNPYmoub3kgPSBwYXJzZUZsb2F0KHkucmVwbGFjZShfTmFORXhwLCBcIlwiKSk7XG5cdFx0XHRcdFx0cmVjT2JqLnYgPSB2O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZWNPYmogfHwgdjtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgVGFrZXMgYW4gZW5kaW5nIHZhbHVlICh0eXBpY2FsbHkgYSBzdHJpbmcsIGJ1dCBjYW4gYmUgYSBudW1iZXIpIGFuZCBhIHN0YXJ0aW5nIHZhbHVlIGFuZCByZXR1cm5zIHRoZSBjaGFuZ2UgYmV0d2VlbiB0aGUgdHdvLCBsb29raW5nIGZvciByZWxhdGl2ZSB2YWx1ZSBpbmRpY2F0b3JzIGxpa2UgKz0gYW5kIC09IGFuZCBpdCBhbHNvIGlnbm9yZXMgc3VmZml4ZXMgKGJ1dCBtYWtlIHN1cmUgdGhlIGVuZGluZyB2YWx1ZSBzdGFydHMgd2l0aCBhIG51bWJlciBvciArPS8tPSBhbmQgdGhhdCB0aGUgc3RhcnRpbmcgdmFsdWUgaXMgYSBOVU1CRVIhKVxuXHRcdFx0ICogQHBhcmFtIHsobnVtYmVyfHN0cmluZyl9IGUgRW5kIHZhbHVlIHdoaWNoIGlzIHR5cGljYWxseSBhIHN0cmluZywgYnV0IGNvdWxkIGJlIGEgbnVtYmVyXG5cdFx0XHQgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gYiBCZWdpbm5pbmcgdmFsdWUgd2hpY2ggaXMgdHlwaWNhbGx5IGEgc3RyaW5nIGJ1dCBjb3VsZCBiZSBhIG51bWJlclxuXHRcdFx0ICogQHJldHVybiB7bnVtYmVyfSBBbW91bnQgb2YgY2hhbmdlIGJldHdlZW4gdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyAocmVsYXRpdmUgdmFsdWVzIHRoYXQgaGF2ZSBhIFwiKz1cIiBvciBcIi09XCIgYXJlIHJlY29nbml6ZWQpXG5cdFx0XHQgKi9cblx0XHRcdF9wYXJzZUNoYW5nZSA9IGZ1bmN0aW9uKGUsIGIpIHtcblx0XHRcdFx0aWYgKHR5cGVvZihlKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0ZSA9IGUoX2luZGV4LCBfdGFyZ2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gKHR5cGVvZihlKSA9PT0gXCJzdHJpbmdcIiAmJiBlLmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gcGFyc2VJbnQoZS5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogcGFyc2VGbG9hdChlLnN1YnN0cigyKSkgOiAocGFyc2VGbG9hdChlKSAtIHBhcnNlRmxvYXQoYikpIHx8IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFRha2VzIGEgdmFsdWUgYW5kIGEgZGVmYXVsdCBudW1iZXIsIGNoZWNrcyBpZiB0aGUgdmFsdWUgaXMgcmVsYXRpdmUsIG51bGwsIG9yIG51bWVyaWMgYW5kIHNwaXRzIGJhY2sgYSBub3JtYWxpemVkIG51bWJlciBhY2NvcmRpbmdseS4gUHJpbWFyaWx5IHVzZWQgaW4gdGhlIF9wYXJzZVRyYW5zZm9ybSgpIGZ1bmN0aW9uLlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IHYgVmFsdWUgdG8gYmUgcGFyc2VkXG5cdFx0XHQgKiBAcGFyYW0geyFudW1iZXJ9IGQgRGVmYXVsdCB2YWx1ZSAod2hpY2ggaXMgYWxzbyB1c2VkIGZvciByZWxhdGl2ZSBjYWxjdWxhdGlvbnMgaWYgXCIrPVwiIG9yIFwiLT1cIiBpcyBmb3VuZCBpbiB0aGUgZmlyc3QgcGFyYW1ldGVyKVxuXHRcdFx0ICogQHJldHVybiB7bnVtYmVyfSBQYXJzZWQgdmFsdWVcblx0XHRcdCAqL1xuXHRcdFx0X3BhcnNlVmFsID0gZnVuY3Rpb24odiwgZCkge1xuXHRcdFx0XHRpZiAodHlwZW9mKHYpID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHR2ID0gdihfaW5kZXgsIF90YXJnZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBpc1JlbGF0aXZlID0gKHR5cGVvZih2KSA9PT0gXCJzdHJpbmdcIiAmJiB2LmNoYXJBdCgxKSA9PT0gXCI9XCIpO1xuXHRcdFx0XHRpZiAodHlwZW9mKHYpID09PSBcInN0cmluZ1wiICYmIHYuY2hhckF0KHYubGVuZ3RoIC0gMikgPT09IFwidlwiKSB7IC8vY29udmVydCB2dyBhbmQgdmggaW50byBweC1lcXVpdmFsZW50cy5cblx0XHRcdFx0XHR2ID0gKGlzUmVsYXRpdmUgPyB2LnN1YnN0cigwLCAyKSA6IDApICsgKHdpbmRvd1tcImlubmVyXCIgKyAoKHYuc3Vic3RyKC0yKSA9PT0gXCJ2aFwiKSA/IFwiSGVpZ2h0XCIgOiBcIldpZHRoXCIpXSAqIChwYXJzZUZsb2F0KGlzUmVsYXRpdmUgPyB2LnN1YnN0cigyKSA6IHYpIC8gMTAwKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICh2ID09IG51bGwpID8gZCA6IGlzUmVsYXRpdmUgPyBwYXJzZUludCh2LmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBwYXJzZUZsb2F0KHYuc3Vic3RyKDIpKSArIGQgOiBwYXJzZUZsb2F0KHYpIHx8IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFRyYW5zbGF0ZXMgc3RyaW5ncyBsaWtlIFwiNDBkZWdcIiBvciBcIjQwXCIgb3IgNDByYWRcIiBvciBcIis9NDBkZWdcIiBvciBcIjI3MF9zaG9ydFwiIG9yIFwiLTkwX2N3XCIgb3IgXCIrPTQ1X2Njd1wiIHRvIGEgbnVtZXJpYyByYWRpYW4gYW5nbGUuIE9mIGNvdXJzZSBhIHN0YXJ0aW5nL2RlZmF1bHQgdmFsdWUgbXVzdCBiZSBmZWQgaW4gdG9vIHNvIHRoYXQgcmVsYXRpdmUgdmFsdWVzIGNhbiBiZSBjYWxjdWxhdGVkIHByb3Blcmx5LlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IHYgVmFsdWUgdG8gYmUgcGFyc2VkXG5cdFx0XHQgKiBAcGFyYW0geyFudW1iZXJ9IGQgRGVmYXVsdCB2YWx1ZSAod2hpY2ggaXMgYWxzbyB1c2VkIGZvciByZWxhdGl2ZSBjYWxjdWxhdGlvbnMgaWYgXCIrPVwiIG9yIFwiLT1cIiBpcyBmb3VuZCBpbiB0aGUgZmlyc3QgcGFyYW1ldGVyKVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBwIHByb3BlcnR5IG5hbWUgZm9yIGRpcmVjdGlvbmFsRW5kIChvcHRpb25hbCAtIG9ubHkgdXNlZCB3aGVuIHRoZSBwYXJzZWQgdmFsdWUgaXMgZGlyZWN0aW9uYWwgKFwiX3Nob3J0XCIsIFwiX2N3XCIsIG9yIFwiX2Njd1wiIHN1ZmZpeCkuIFdlIG5lZWQgYSB3YXkgdG8gc3RvcmUgdGhlIHVuY29tcGVuc2F0ZWQgdmFsdWUgc28gdGhhdCBhdCB0aGUgZW5kIG9mIHRoZSB0d2Vlbiwgd2Ugc2V0IGl0IHRvIGV4YWN0bHkgd2hhdCB3YXMgcmVxdWVzdGVkIHdpdGggbm8gZGlyZWN0aW9uYWwgY29tcGVuc2F0aW9uKS4gUHJvcGVydHkgbmFtZSB3b3VsZCBiZSBcInJvdGF0aW9uXCIsIFwicm90YXRpb25YXCIsIG9yIFwicm90YXRpb25ZXCJcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gZGlyZWN0aW9uYWxFbmQgQW4gb2JqZWN0IHRoYXQgd2lsbCBzdG9yZSB0aGUgcmF3IGVuZCB2YWx1ZXMgZm9yIGRpcmVjdGlvbmFsIGFuZ2xlcyAoXCJfc2hvcnRcIiwgXCJfY3dcIiwgb3IgXCJfY2N3XCIgc3VmZml4KS4gV2UgbmVlZCBhIHdheSB0byBzdG9yZSB0aGUgdW5jb21wZW5zYXRlZCB2YWx1ZSBzbyB0aGF0IGF0IHRoZSBlbmQgb2YgdGhlIHR3ZWVuLCB3ZSBzZXQgaXQgdG8gZXhhY3RseSB3aGF0IHdhcyByZXF1ZXN0ZWQgd2l0aCBubyBkaXJlY3Rpb25hbCBjb21wZW5zYXRpb24uXG5cdFx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9IHBhcnNlZCBhbmdsZSBpbiByYWRpYW5zXG5cdFx0XHQgKi9cblx0XHRcdF9wYXJzZUFuZ2xlID0gZnVuY3Rpb24odiwgZCwgcCwgZGlyZWN0aW9uYWxFbmQpIHtcblx0XHRcdFx0dmFyIG1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0XHRcdGNhcCwgc3BsaXQsIGRpZiwgcmVzdWx0LCBpc1JlbGF0aXZlO1xuXHRcdFx0XHRpZiAodHlwZW9mKHYpID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHR2ID0gdihfaW5kZXgsIF90YXJnZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2ID09IG51bGwpIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBkO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2KSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdHJlc3VsdCA9IHY7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2FwID0gMzYwO1xuXHRcdFx0XHRcdHNwbGl0ID0gdi5zcGxpdChcIl9cIik7XG5cdFx0XHRcdFx0aXNSZWxhdGl2ZSA9ICh2LmNoYXJBdCgxKSA9PT0gXCI9XCIpO1xuXHRcdFx0XHRcdGRpZiA9IChpc1JlbGF0aXZlID8gcGFyc2VJbnQodi5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogcGFyc2VGbG9hdChzcGxpdFswXS5zdWJzdHIoMikpIDogcGFyc2VGbG9hdChzcGxpdFswXSkpICogKCh2LmluZGV4T2YoXCJyYWRcIikgPT09IC0xKSA/IDEgOiBfUkFEMkRFRykgLSAoaXNSZWxhdGl2ZSA/IDAgOiBkKTtcblx0XHRcdFx0XHRpZiAoc3BsaXQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoZGlyZWN0aW9uYWxFbmQpIHtcblx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uYWxFbmRbcF0gPSBkICsgZGlmO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHYuaW5kZXhPZihcInNob3J0XCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSBkaWYgJSBjYXA7XG5cdFx0XHRcdFx0XHRcdGlmIChkaWYgIT09IGRpZiAlIChjYXAgLyAyKSkge1xuXHRcdFx0XHRcdFx0XHRcdGRpZiA9IChkaWYgPCAwKSA/IGRpZiArIGNhcCA6IGRpZiAtIGNhcDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHYuaW5kZXhPZihcIl9jd1wiKSAhPT0gLTEgJiYgZGlmIDwgMCkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoKGRpZiArIGNhcCAqIDk5OTk5OTk5OTkpICUgY2FwKSAtICgoZGlmIC8gY2FwKSB8IDApICogY2FwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2LmluZGV4T2YoXCJjY3dcIikgIT09IC0xICYmIGRpZiA+IDApIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gKChkaWYgLSBjYXAgKiA5OTk5OTk5OTk5KSAlIGNhcCkgLSAoKGRpZiAvIGNhcCkgfCAwKSAqIGNhcDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0ID0gZCArIGRpZjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzdWx0IDwgbWluICYmIHJlc3VsdCA+IC1taW4pIHtcblx0XHRcdFx0XHRyZXN1bHQgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRfY29sb3JMb29rdXAgPSB7YXF1YTpbMCwyNTUsMjU1XSxcblx0XHRcdFx0bGltZTpbMCwyNTUsMF0sXG5cdFx0XHRcdHNpbHZlcjpbMTkyLDE5MiwxOTJdLFxuXHRcdFx0XHRibGFjazpbMCwwLDBdLFxuXHRcdFx0XHRtYXJvb246WzEyOCwwLDBdLFxuXHRcdFx0XHR0ZWFsOlswLDEyOCwxMjhdLFxuXHRcdFx0XHRibHVlOlswLDAsMjU1XSxcblx0XHRcdFx0bmF2eTpbMCwwLDEyOF0sXG5cdFx0XHRcdHdoaXRlOlsyNTUsMjU1LDI1NV0sXG5cdFx0XHRcdGZ1Y2hzaWE6WzI1NSwwLDI1NV0sXG5cdFx0XHRcdG9saXZlOlsxMjgsMTI4LDBdLFxuXHRcdFx0XHR5ZWxsb3c6WzI1NSwyNTUsMF0sXG5cdFx0XHRcdG9yYW5nZTpbMjU1LDE2NSwwXSxcblx0XHRcdFx0Z3JheTpbMTI4LDEyOCwxMjhdLFxuXHRcdFx0XHRwdXJwbGU6WzEyOCwwLDEyOF0sXG5cdFx0XHRcdGdyZWVuOlswLDEyOCwwXSxcblx0XHRcdFx0cmVkOlsyNTUsMCwwXSxcblx0XHRcdFx0cGluazpbMjU1LDE5MiwyMDNdLFxuXHRcdFx0XHRjeWFuOlswLDI1NSwyNTVdLFxuXHRcdFx0XHR0cmFuc3BhcmVudDpbMjU1LDI1NSwyNTUsMF19LFxuXG5cdFx0XHRfaHVlID0gZnVuY3Rpb24oaCwgbTEsIG0yKSB7XG5cdFx0XHRcdGggPSAoaCA8IDApID8gaCArIDEgOiAoaCA+IDEpID8gaCAtIDEgOiBoO1xuXHRcdFx0XHRyZXR1cm4gKCgoKGggKiA2IDwgMSkgPyBtMSArIChtMiAtIG0xKSAqIGggKiA2IDogKGggPCAwLjUpID8gbTIgOiAoaCAqIDMgPCAyKSA/IG0xICsgKG0yIC0gbTEpICogKDIgLyAzIC0gaCkgKiA2IDogbTEpICogMjU1KSArIDAuNSkgfCAwO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBQYXJzZXMgYSBjb2xvciAobGlrZSAjOUYwLCAjRkY5OTAwLCByZ2IoMjU1LDUxLDE1Mykgb3IgaHNsKDEwOCwgNTAlLCAxMCUpKSBpbnRvIGFuIGFycmF5IHdpdGggMyBlbGVtZW50cyBmb3IgcmVkLCBncmVlbiwgYW5kIGJsdWUgb3IgaWYgdG9IU0wgcGFyYW1ldGVyIGlzIHRydWUsIGl0IHdpbGwgcG9wdWxhdGUgdGhlIGFycmF5IHdpdGggaHVlLCBzYXR1cmF0aW9uLCBhbmQgbGlnaHRuZXNzIHZhbHVlcy4gSWYgYSByZWxhdGl2ZSB2YWx1ZSBpcyBmb3VuZCBpbiBhbiBoc2woKSBvciBoc2xhKCkgc3RyaW5nLCBpdCB3aWxsIHByZXNlcnZlIHRob3NlIHJlbGF0aXZlIHByZWZpeGVzIGFuZCBhbGwgdGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkgd2lsbCBiZSBzdHJpbmdzIGluc3RlYWQgb2YgbnVtYmVycyAoaW4gYWxsIG90aGVyIGNhc2VzIGl0IHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggbnVtYmVycykuXG5cdFx0XHQgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKX0gdiBUaGUgdmFsdWUgdGhlIHNob3VsZCBiZSBwYXJzZWQgd2hpY2ggY291bGQgYmUgYSBzdHJpbmcgbGlrZSAjOUYwIG9yIHJnYigyNTUsMTAyLDUxKSBvciByZ2JhKDI1NSwwLDAsMC41KSBvciBpdCBjb3VsZCBiZSBhIG51bWJlciBsaWtlIDB4RkYwMENDIG9yIGV2ZW4gYSBuYW1lZCBjb2xvciBsaWtlIHJlZCwgYmx1ZSwgcHVycGxlLCBldGMuXG5cdFx0XHQgKiBAcGFyYW0geyhib29sZWFuKX0gdG9IU0wgSWYgdHJ1ZSwgYW4gaHNsKCkgb3IgaHNsYSgpIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiByZ2IoKSBvciByZ2JhKClcblx0XHRcdCAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBBbiBhcnJheSBjb250YWluaW5nIHJlZCwgZ3JlZW4sIGFuZCBibHVlIChhbmQgb3B0aW9uYWxseSBhbHBoYSkgaW4gdGhhdCBvcmRlciwgb3IgaWYgdGhlIHRvSFNMIHBhcmFtZXRlciB3YXMgdHJ1ZSwgdGhlIGFycmF5IHdpbGwgY29udGFpbiBodWUsIHNhdHVyYXRpb24gYW5kIGxpZ2h0bmVzcyAoYW5kIG9wdGlvbmFsbHkgYWxwaGEpIGluIHRoYXQgb3JkZXIuIEFsd2F5cyBudW1iZXJzIHVubGVzcyB0aGVyZSdzIGEgcmVsYXRpdmUgcHJlZml4IGZvdW5kIGluIGFuIGhzbCgpIG9yIGhzbGEoKSBzdHJpbmcgYW5kIHRvSFNMIGlzIHRydWUuXG5cdFx0XHQgKi9cblx0XHRcdF9wYXJzZUNvbG9yID0gQ1NTUGx1Z2luLnBhcnNlQ29sb3IgPSBmdW5jdGlvbih2LCB0b0hTTCkge1xuXHRcdFx0XHR2YXIgYSwgciwgZywgYiwgaCwgcywgbCwgbWF4LCBtaW4sIGQsIHdhc0hTTDtcblx0XHRcdFx0aWYgKCF2KSB7XG5cdFx0XHRcdFx0YSA9IF9jb2xvckxvb2t1cC5ibGFjaztcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodikgPT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRhID0gW3YgPj4gMTYsICh2ID4+IDgpICYgMjU1LCB2ICYgMjU1XTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodi5jaGFyQXQodi5sZW5ndGggLSAxKSA9PT0gXCIsXCIpIHsgLy9zb21ldGltZXMgYSB0cmFpbGluZyBjb21tYSBpcyBpbmNsdWRlZCBhbmQgd2Ugc2hvdWxkIGNob3AgaXQgb2ZmICh0eXBpY2FsbHkgZnJvbSBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHZhbHVlcyBsaWtlIGEgdGV4dFNoYWRvdzpcIjJweCAycHggMnB4IGJsdWUsIDVweCA1cHggNXB4IHJnYigyNTUsMCwwKVwiIC0gaW4gdGhpcyBleGFtcGxlIFwiYmx1ZSxcIiBoYXMgYSB0cmFpbGluZyBjb21tYS4gV2UgY291bGQgc3RyaXAgaXQgb3V0IGluc2lkZSBwYXJzZUNvbXBsZXgoKSBidXQgd2UnZCBuZWVkIHRvIGRvIGl0IHRvIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgcGx1cyBpdCB3b3VsZG4ndCBwcm92aWRlIHByb3RlY3Rpb24gZnJvbSBvdGhlciBwb3RlbnRpYWwgc2NlbmFyaW9zIGxpa2UgaWYgdGhlIHVzZXIgcGFzc2VzIGluIGEgc2ltaWxhciB2YWx1ZS5cblx0XHRcdFx0XHRcdHYgPSB2LnN1YnN0cigwLCB2Lmxlbmd0aCAtIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoX2NvbG9yTG9va3VwW3ZdKSB7XG5cdFx0XHRcdFx0XHRhID0gX2NvbG9yTG9va3VwW3ZdO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodi5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG5cdFx0XHRcdFx0XHRpZiAodi5sZW5ndGggPT09IDQpIHsgLy9mb3Igc2hvcnRoYW5kIGxpa2UgIzlGMFxuXHRcdFx0XHRcdFx0XHRyID0gdi5jaGFyQXQoMSk7XG5cdFx0XHRcdFx0XHRcdGcgPSB2LmNoYXJBdCgyKTtcblx0XHRcdFx0XHRcdFx0YiA9IHYuY2hhckF0KDMpO1xuXHRcdFx0XHRcdFx0XHR2ID0gXCIjXCIgKyByICsgciArIGcgKyBnICsgYiArIGI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2ID0gcGFyc2VJbnQodi5zdWJzdHIoMSksIDE2KTtcblx0XHRcdFx0XHRcdGEgPSBbdiA+PiAxNiwgKHYgPj4gOCkgJiAyNTUsIHYgJiAyNTVdO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodi5zdWJzdHIoMCwgMykgPT09IFwiaHNsXCIpIHtcblx0XHRcdFx0XHRcdGEgPSB3YXNIU0wgPSB2Lm1hdGNoKF9udW1FeHApO1xuXHRcdFx0XHRcdFx0aWYgKCF0b0hTTCkge1xuXHRcdFx0XHRcdFx0XHRoID0gKE51bWJlcihhWzBdKSAlIDM2MCkgLyAzNjA7XG5cdFx0XHRcdFx0XHRcdHMgPSBOdW1iZXIoYVsxXSkgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdGwgPSBOdW1iZXIoYVsyXSkgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdGcgPSAobCA8PSAwLjUpID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuXHRcdFx0XHRcdFx0XHRyID0gbCAqIDIgLSBnO1xuXHRcdFx0XHRcdFx0XHRpZiAoYS5sZW5ndGggPiAzKSB7XG5cdFx0XHRcdFx0XHRcdFx0YVszXSA9IE51bWJlcihhWzNdKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRhWzBdID0gX2h1ZShoICsgMSAvIDMsIHIsIGcpO1xuXHRcdFx0XHRcdFx0XHRhWzFdID0gX2h1ZShoLCByLCBnKTtcblx0XHRcdFx0XHRcdFx0YVsyXSA9IF9odWUoaCAtIDEgLyAzLCByLCBnKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodi5pbmRleE9mKFwiPVwiKSAhPT0gLTEpIHsgLy9pZiByZWxhdGl2ZSB2YWx1ZXMgYXJlIGZvdW5kLCBqdXN0IHJldHVybiB0aGUgcmF3IHN0cmluZ3Mgd2l0aCB0aGUgcmVsYXRpdmUgcHJlZml4ZXMgaW4gcGxhY2UuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB2Lm1hdGNoKF9yZWxOdW1FeHApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRhID0gdi5tYXRjaChfbnVtRXhwKSB8fCBfY29sb3JMb29rdXAudHJhbnNwYXJlbnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGFbMF0gPSBOdW1iZXIoYVswXSk7XG5cdFx0XHRcdFx0YVsxXSA9IE51bWJlcihhWzFdKTtcblx0XHRcdFx0XHRhWzJdID0gTnVtYmVyKGFbMl0pO1xuXHRcdFx0XHRcdGlmIChhLmxlbmd0aCA+IDMpIHtcblx0XHRcdFx0XHRcdGFbM10gPSBOdW1iZXIoYVszXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0b0hTTCAmJiAhd2FzSFNMKSB7XG5cdFx0XHRcdFx0ciA9IGFbMF0gLyAyNTU7XG5cdFx0XHRcdFx0ZyA9IGFbMV0gLyAyNTU7XG5cdFx0XHRcdFx0YiA9IGFbMl0gLyAyNTU7XG5cdFx0XHRcdFx0bWF4ID0gTWF0aC5tYXgociwgZywgYik7XG5cdFx0XHRcdFx0bWluID0gTWF0aC5taW4ociwgZywgYik7XG5cdFx0XHRcdFx0bCA9IChtYXggKyBtaW4pIC8gMjtcblx0XHRcdFx0XHRpZiAobWF4ID09PSBtaW4pIHtcblx0XHRcdFx0XHRcdGggPSBzID0gMDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZCA9IG1heCAtIG1pbjtcblx0XHRcdFx0XHRcdHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcblx0XHRcdFx0XHRcdGggPSAobWF4ID09PSByKSA/IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApIDogKG1heCA9PT0gZykgPyAoYiAtIHIpIC8gZCArIDIgOiAociAtIGcpIC8gZCArIDQ7XG5cdFx0XHRcdFx0XHRoICo9IDYwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhWzBdID0gKGggKyAwLjUpIHwgMDtcblx0XHRcdFx0XHRhWzFdID0gKHMgKiAxMDAgKyAwLjUpIHwgMDtcblx0XHRcdFx0XHRhWzJdID0gKGwgKiAxMDAgKyAwLjUpIHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdH0sXG5cdFx0XHRfZm9ybWF0Q29sb3JzID0gZnVuY3Rpb24ocywgdG9IU0wpIHtcblx0XHRcdFx0dmFyIGNvbG9ycyA9IHMubWF0Y2goX2NvbG9yRXhwKSB8fCBbXSxcblx0XHRcdFx0XHRjaGFySW5kZXggPSAwLFxuXHRcdFx0XHRcdHBhcnNlZCA9IFwiXCIsXG5cdFx0XHRcdFx0aSwgY29sb3IsIHRlbXA7XG5cdFx0XHRcdGlmICghY29sb3JzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjb2xvciA9IGNvbG9yc1tpXTtcblx0XHRcdFx0XHR0ZW1wID0gcy5zdWJzdHIoY2hhckluZGV4LCBzLmluZGV4T2YoY29sb3IsIGNoYXJJbmRleCktY2hhckluZGV4KTtcblx0XHRcdFx0XHRjaGFySW5kZXggKz0gdGVtcC5sZW5ndGggKyBjb2xvci5sZW5ndGg7XG5cdFx0XHRcdFx0Y29sb3IgPSBfcGFyc2VDb2xvcihjb2xvciwgdG9IU0wpO1xuXHRcdFx0XHRcdGlmIChjb2xvci5sZW5ndGggPT09IDMpIHtcblx0XHRcdFx0XHRcdGNvbG9yLnB1c2goMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcnNlZCArPSB0ZW1wICsgKHRvSFNMID8gXCJoc2xhKFwiICsgY29sb3JbMF0gKyBcIixcIiArIGNvbG9yWzFdICsgXCIlLFwiICsgY29sb3JbMl0gKyBcIiUsXCIgKyBjb2xvclszXSA6IFwicmdiYShcIiArIGNvbG9yLmpvaW4oXCIsXCIpKSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwYXJzZWQgKyBzLnN1YnN0cihjaGFySW5kZXgpO1xuXHRcdFx0fSxcblx0XHRcdF9jb2xvckV4cCA9IFwiKD86XFxcXGIoPzooPzpyZ2J8cmdiYXxoc2x8aHNsYSlcXFxcKC4rP1xcXFwpKXxcXFxcQiMoPzpbMC05YS1mXXszfSl7MSwyfVxcXFxiXCI7IC8vd2UnbGwgZHluYW1pY2FsbHkgYnVpbGQgdGhpcyBSZWd1bGFyIEV4cHJlc3Npb24gdG8gY29uc2VydmUgZmlsZSBzaXplLiBBZnRlciBidWlsZGluZyBpdCwgaXQgd2lsbCBiZSBhYmxlIHRvIGZpbmQgcmdiKCksIHJnYmEoKSwgIyAoaGV4YWRlY2ltYWwpLCBhbmQgbmFtZWQgY29sb3IgdmFsdWVzIGxpa2UgcmVkLCBibHVlLCBwdXJwbGUsIGV0Yy5cblxuXHRcdGZvciAocCBpbiBfY29sb3JMb29rdXApIHtcblx0XHRcdF9jb2xvckV4cCArPSBcInxcIiArIHAgKyBcIlxcXFxiXCI7XG5cdFx0fVxuXHRcdF9jb2xvckV4cCA9IG5ldyBSZWdFeHAoX2NvbG9yRXhwK1wiKVwiLCBcImdpXCIpO1xuXG5cdFx0Q1NTUGx1Z2luLmNvbG9yU3RyaW5nRmlsdGVyID0gZnVuY3Rpb24oYSkge1xuXHRcdFx0dmFyIGNvbWJpbmVkID0gYVswXSArIFwiIFwiICsgYVsxXSxcblx0XHRcdFx0dG9IU0w7XG5cdFx0XHRpZiAoX2NvbG9yRXhwLnRlc3QoY29tYmluZWQpKSB7XG5cdFx0XHRcdHRvSFNMID0gKGNvbWJpbmVkLmluZGV4T2YoXCJoc2woXCIpICE9PSAtMSB8fCBjb21iaW5lZC5pbmRleE9mKFwiaHNsYShcIikgIT09IC0xKTtcblx0XHRcdFx0YVswXSA9IF9mb3JtYXRDb2xvcnMoYVswXSwgdG9IU0wpO1xuXHRcdFx0XHRhWzFdID0gX2Zvcm1hdENvbG9ycyhhWzFdLCB0b0hTTCk7XG5cdFx0XHR9XG5cdFx0XHRfY29sb3JFeHAubGFzdEluZGV4ID0gMDtcblx0XHR9O1xuXG5cdFx0aWYgKCFUd2VlbkxpdGUuZGVmYXVsdFN0cmluZ0ZpbHRlcikge1xuXHRcdFx0VHdlZW5MaXRlLmRlZmF1bHRTdHJpbmdGaWx0ZXIgPSBDU1NQbHVnaW4uY29sb3JTdHJpbmdGaWx0ZXI7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGUgUmV0dXJucyBhIGZvcm1hdHRlciBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgdGFraW5nIGEgc3RyaW5nIChvciBudW1iZXIgaW4gc29tZSBjYXNlcykgYW5kIHJldHVybmluZyBhIGNvbnNpc3RlbnRseSBmb3JtYXR0ZWQgb25lIGluIHRlcm1zIG9mIGRlbGltaXRlcnMsIHF1YW50aXR5IG9mIHZhbHVlcywgZXRjLiBGb3IgZXhhbXBsZSwgd2UgbWF5IGdldCBib3hTaGFkb3cgdmFsdWVzIGRlZmluZWQgYXMgXCIwcHggcmVkXCIgb3IgXCIwcHggMHB4IDEwcHggcmdiKDI1NSwwLDApXCIgb3IgXCIwcHggMHB4IDIwcHggMjBweCAjRjAwXCIgYW5kIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgd2hhdCB3ZSBnZXQgYmFjayBpcyBkZXNjcmliZWQgd2l0aCA0IG51bWJlcnMgYW5kIGEgY29sb3IuIFRoaXMgYWxsb3dzIHVzIHRvIGZlZWQgaXQgaW50byB0aGUgX3BhcnNlQ29tcGxleCgpIG1ldGhvZCBhbmQgc3BsaXQgdGhlIHZhbHVlcyB1cCBhcHByb3ByaWF0ZWx5LiBUaGUgbmVhdCB0aGluZyBhYm91dCB0aGlzIF9nZXRGb3JtYXR0ZXIoKSBmdW5jdGlvbiBpcyB0aGF0IHRoZSBkZmx0IGRlZmluZXMgYSBwYXR0ZXJuIGFzIHdlbGwgYXMgYSBkZWZhdWx0LCBzbyBmb3IgZXhhbXBsZSwgX2dldEZvcm1hdHRlcihcIjBweCAwcHggMHB4IDBweCAjNzc3XCIsIHRydWUpIG5vdCBvbmx5IHNldHMgdGhlIGRlZmF1bHQgYXMgMHB4IGZvciBhbGwgZGlzdGFuY2VzIGFuZCAjNzc3IGZvciB0aGUgY29sb3IsIGJ1dCBhbHNvIHNldHMgdGhlIHBhdHRlcm4gc3VjaCB0aGF0IDQgbnVtYmVycyBhbmQgYSBjb2xvciB3aWxsIGFsd2F5cyBnZXQgcmV0dXJuZWQuXG5cdFx0ICogQHBhcmFtIHshc3RyaW5nfSBkZmx0IFRoZSBkZWZhdWx0IHZhbHVlIGFuZCBwYXR0ZXJuIHRvIGZvbGxvdy4gU28gXCIwcHggMHB4IDBweCAwcHggIzc3N1wiIHdpbGwgZW5zdXJlIHRoYXQgNCBudW1iZXJzIGFuZCBhIGNvbG9yIHdpbGwgYWx3YXlzIGdldCByZXR1cm5lZC5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBjbHIgSWYgdHJ1ZSwgdGhlIHZhbHVlcyBzaG91bGQgYmUgc2VhcmNoZWQgZm9yIGNvbG9yLXJlbGF0ZWQgZGF0YS4gRm9yIGV4YW1wbGUsIGJveFNoYWRvdyB2YWx1ZXMgdHlwaWNhbGx5IGNvbnRhaW4gYSBjb2xvciB3aGVyZWFzIGJvcmRlclJhZGl1cyBkb24ndC5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBjb2xsYXBzaWJsZSBJZiB0cnVlLCB0aGUgdmFsdWUgaXMgYSB0b3AvbGVmdC9yaWdodC9ib3R0b20gc3R5bGUgb25lIHRoYXQgYWN0cyBsaWtlIG1hcmdpbiBvciBwYWRkaW5nLCB3aGVyZSBpZiBvbmx5IG9uZSB2YWx1ZSBpcyByZWNlaXZlZCwgaXQncyB1c2VkIGZvciBhbGwgNDsgaWYgMiBhcmUgcmVjZWl2ZWQsIHRoZSBmaXJzdCBpcyBkdXBsaWNhdGVkIGZvciAzcmQgKGJvdHRvbSkgYW5kIHRoZSAybmQgaXMgZHVwbGljYXRlZCBmb3IgdGhlIDR0aCBzcG90IChsZWZ0KSwgZXRjLlxuXHRcdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBmb3JtYXR0ZXIgZnVuY3Rpb25cblx0XHQgKi9cblx0XHR2YXIgX2dldEZvcm1hdHRlciA9IGZ1bmN0aW9uKGRmbHQsIGNsciwgY29sbGFwc2libGUsIG11bHRpKSB7XG5cdFx0XHRcdGlmIChkZmx0ID09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24odikge3JldHVybiB2O307XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGRDb2xvciA9IGNsciA/IChkZmx0Lm1hdGNoKF9jb2xvckV4cCkgfHwgW1wiXCJdKVswXSA6IFwiXCIsXG5cdFx0XHRcdFx0ZFZhbHMgPSBkZmx0LnNwbGl0KGRDb2xvcikuam9pbihcIlwiKS5tYXRjaChfdmFsdWVzRXhwKSB8fCBbXSxcblx0XHRcdFx0XHRwZnggPSBkZmx0LnN1YnN0cigwLCBkZmx0LmluZGV4T2YoZFZhbHNbMF0pKSxcblx0XHRcdFx0XHRzZnggPSAoZGZsdC5jaGFyQXQoZGZsdC5sZW5ndGggLSAxKSA9PT0gXCIpXCIpID8gXCIpXCIgOiBcIlwiLFxuXHRcdFx0XHRcdGRlbGltID0gKGRmbHQuaW5kZXhPZihcIiBcIikgIT09IC0xKSA/IFwiIFwiIDogXCIsXCIsXG5cdFx0XHRcdFx0bnVtVmFscyA9IGRWYWxzLmxlbmd0aCxcblx0XHRcdFx0XHRkU2Z4ID0gKG51bVZhbHMgPiAwKSA/IGRWYWxzWzBdLnJlcGxhY2UoX251bUV4cCwgXCJcIikgOiBcIlwiLFxuXHRcdFx0XHRcdGZvcm1hdHRlcjtcblx0XHRcdFx0aWYgKCFudW1WYWxzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHYpIHtyZXR1cm4gdjt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjbHIpIHtcblx0XHRcdFx0XHRmb3JtYXR0ZXIgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdFx0XHR2YXIgY29sb3IsIHZhbHMsIGksIGE7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKHYpID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0XHRcdHYgKz0gZFNmeDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobXVsdGkgJiYgX2NvbW1hc091dHNpZGVQYXJlbkV4cC50ZXN0KHYpKSB7XG5cdFx0XHRcdFx0XHRcdGEgPSB2LnJlcGxhY2UoX2NvbW1hc091dHNpZGVQYXJlbkV4cCwgXCJ8XCIpLnNwbGl0KFwifFwiKTtcblx0XHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRhW2ldID0gZm9ybWF0dGVyKGFbaV0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiBhLmpvaW4oXCIsXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29sb3IgPSAodi5tYXRjaChfY29sb3JFeHApIHx8IFtkQ29sb3JdKVswXTtcblx0XHRcdFx0XHRcdHZhbHMgPSB2LnNwbGl0KGNvbG9yKS5qb2luKFwiXCIpLm1hdGNoKF92YWx1ZXNFeHApIHx8IFtdO1xuXHRcdFx0XHRcdFx0aSA9IHZhbHMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0aWYgKG51bVZhbHMgPiBpLS0pIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCsraSA8IG51bVZhbHMpIHtcblx0XHRcdFx0XHRcdFx0XHR2YWxzW2ldID0gY29sbGFwc2libGUgPyB2YWxzWygoKGkgLSAxKSAvIDIpIHwgMCldIDogZFZhbHNbaV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBwZnggKyB2YWxzLmpvaW4oZGVsaW0pICsgZGVsaW0gKyBjb2xvciArIHNmeCArICh2LmluZGV4T2YoXCJpbnNldFwiKSAhPT0gLTEgPyBcIiBpbnNldFwiIDogXCJcIik7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRyZXR1cm4gZm9ybWF0dGVyO1xuXG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9ybWF0dGVyID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHRcdHZhciB2YWxzLCBhLCBpO1xuXHRcdFx0XHRcdGlmICh0eXBlb2YodikgPT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRcdHYgKz0gZFNmeDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG11bHRpICYmIF9jb21tYXNPdXRzaWRlUGFyZW5FeHAudGVzdCh2KSkge1xuXHRcdFx0XHRcdFx0YSA9IHYucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcInxcIikuc3BsaXQoXCJ8XCIpO1xuXHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0YVtpXSA9IGZvcm1hdHRlcihhW2ldKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBhLmpvaW4oXCIsXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YWxzID0gdi5tYXRjaChfdmFsdWVzRXhwKSB8fCBbXTtcblx0XHRcdFx0XHRpID0gdmFscy5sZW5ndGg7XG5cdFx0XHRcdFx0aWYgKG51bVZhbHMgPiBpLS0pIHtcblx0XHRcdFx0XHRcdHdoaWxlICgrK2kgPCBudW1WYWxzKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHNbaV0gPSBjb2xsYXBzaWJsZSA/IHZhbHNbKCgoaSAtIDEpIC8gMikgfCAwKV0gOiBkVmFsc1tpXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHBmeCArIHZhbHMuam9pbihkZWxpbSkgKyBzZng7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiBmb3JtYXR0ZXI7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIHJldHVybnMgYSBmb3JtYXR0ZXIgZnVuY3Rpb24gdGhhdCdzIHVzZWQgZm9yIGVkZ2UtcmVsYXRlZCB2YWx1ZXMgbGlrZSBtYXJnaW5Ub3AsIG1hcmdpbkxlZnQsIHBhZGRpbmdCb3R0b20sIHBhZGRpbmdSaWdodCwgZXRjLiBKdXN0IHBhc3MgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcyByZWxhdGVkIHRvIHRoZSBlZGdlcy5cblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcHJvcHMgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcyBpbiBvcmRlciBmcm9tIHRvcCB0byBsZWZ0LCBsaWtlIFwibWFyZ2luVG9wLG1hcmdpblJpZ2h0LG1hcmdpbkJvdHRvbSxtYXJnaW5MZWZ0XCJcblx0XHRcdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBhIGZvcm1hdHRlciBmdW5jdGlvblxuXHRcdFx0ICovXG5cdFx0XHRfZ2V0RWRnZVBhcnNlciA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0XHRcdHByb3BzID0gcHJvcHMuc3BsaXQoXCIsXCIpO1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0XHRcdHZhciBhID0gKGUgKyBcIlwiKS5zcGxpdChcIiBcIiksXG5cdFx0XHRcdFx0XHRpO1xuXHRcdFx0XHRcdHZhcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXJzW3Byb3BzW2ldXSA9IGFbaV0gPSBhW2ldIHx8IGFbKCgoaSAtIDEpIC8gMikgPj4gMCldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gY3NzcC5wYXJzZSh0LCB2YXJzLCBwdCwgcGx1Z2luKTtcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBwcml2YXRlIHVzZWQgd2hlbiBvdGhlciBwbHVnaW5zIG11c3QgdHdlZW4gdmFsdWVzIGZpcnN0LCBsaWtlIEJlemllclBsdWdpbiBvciBUaHJvd1Byb3BzUGx1Z2luLCBldGMuIFRoYXQgcGx1Z2luJ3Mgc2V0UmF0aW8oKSBnZXRzIGNhbGxlZCBmaXJzdCBzbyB0aGF0IHRoZSB2YWx1ZXMgYXJlIHVwZGF0ZWQsIGFuZCB0aGVuIHdlIGxvb3AgdGhyb3VnaCB0aGUgTWluaVByb3BUd2VlbnMgd2hpY2ggaGFuZGxlIGNvcHlpbmcgdGhlIHZhbHVlcyBpbnRvIHRoZWlyIGFwcHJvcHJpYXRlIHNsb3RzIHNvIHRoYXQgdGhleSBjYW4gdGhlbiBiZSBhcHBsaWVkIGNvcnJlY3RseSBpbiB0aGUgbWFpbiBDU1NQbHVnaW4gc2V0UmF0aW8oKSBtZXRob2QuIFJlbWVtYmVyLCB3ZSB0eXBpY2FsbHkgY3JlYXRlIGEgcHJveHkgb2JqZWN0IHRoYXQgaGFzIGEgYnVuY2ggb2YgdW5pcXVlbHktbmFtZWQgcHJvcGVydGllcyB0aGF0IHdlIGZlZWQgdG8gdGhlIHN1Yi1wbHVnaW4gYW5kIGl0IGRvZXMgaXRzIG1hZ2ljIG5vcm1hbGx5LCBhbmQgdGhlbiB3ZSBtdXN0IGludGVycHJldCB0aG9zZSB2YWx1ZXMgYW5kIGFwcGx5IHRoZW0gdG8gdGhlIGNzcyBiZWNhdXNlIG9mdGVuIG51bWJlcnMgbXVzdCBnZXQgY29tYmluZWQvY29uY2F0ZW5hdGVkLCBzdWZmaXhlcyBhZGRlZCwgZXRjLiB0byB3b3JrIHdpdGggY3NzLCBsaWtlIGJveFNoYWRvdyBjb3VsZCBoYXZlIDQgdmFsdWVzIHBsdXMgYSBjb2xvci5cblx0XHRcdF9zZXRQbHVnaW5SYXRpbyA9IF9pbnRlcm5hbHMuX3NldFBsdWdpblJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR0aGlzLnBsdWdpbi5zZXRSYXRpbyh2KTtcblx0XHRcdFx0dmFyIGQgPSB0aGlzLmRhdGEsXG5cdFx0XHRcdFx0cHJveHkgPSBkLnByb3h5LFxuXHRcdFx0XHRcdG1wdCA9IGQuZmlyc3RNUFQsXG5cdFx0XHRcdFx0bWluID0gMC4wMDAwMDEsXG5cdFx0XHRcdFx0dmFsLCBwdCwgaSwgc3RyLCBwO1xuXHRcdFx0XHR3aGlsZSAobXB0KSB7XG5cdFx0XHRcdFx0dmFsID0gcHJveHlbbXB0LnZdO1xuXHRcdFx0XHRcdGlmIChtcHQucikge1xuXHRcdFx0XHRcdFx0dmFsID0gbXB0LnIodmFsKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbCA8IG1pbiAmJiB2YWwgPiAtbWluKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtcHQudFttcHQucF0gPSB2YWw7XG5cdFx0XHRcdFx0bXB0ID0gbXB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkLmF1dG9Sb3RhdGUpIHtcblx0XHRcdFx0XHRkLmF1dG9Sb3RhdGUucm90YXRpb24gPSBkLm1vZCA/IGQubW9kLmNhbGwodGhpcy5fdHdlZW4sIHByb3h5LnJvdGF0aW9uLCB0aGlzLnQsIHRoaXMuX3R3ZWVuKSA6IHByb3h5LnJvdGF0aW9uOyAvL3NwZWNpYWwgY2FzZSBmb3IgTW9kaWZ5UGx1Z2luIHRvIGhvb2sgaW50byBhbiBhdXRvLXJvdGF0aW5nIGJlemllclxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vYXQgdGhlIGVuZCwgd2UgbXVzdCBzZXQgdGhlIENTU1Byb3BUd2VlbidzIFwiZVwiIChlbmQpIHZhbHVlIGR5bmFtaWNhbGx5IGhlcmUgYmVjYXVzZSB0aGF0J3Mgd2hhdCBpcyB1c2VkIGluIHRoZSBmaW5hbCBzZXRSYXRpbygpIG1ldGhvZC4gU2FtZSBmb3IgXCJiXCIgYXQgdGhlIGJlZ2lubmluZy5cblx0XHRcdFx0aWYgKHYgPT09IDEgfHwgdiA9PT0gMCkge1xuXHRcdFx0XHRcdG1wdCA9IGQuZmlyc3RNUFQ7XG5cdFx0XHRcdFx0cCA9ICh2ID09PSAxKSA/IFwiZVwiIDogXCJiXCI7XG5cdFx0XHRcdFx0d2hpbGUgKG1wdCkge1xuXHRcdFx0XHRcdFx0cHQgPSBtcHQudDtcblx0XHRcdFx0XHRcdGlmICghcHQudHlwZSkge1xuXHRcdFx0XHRcdFx0XHRwdFtwXSA9IHB0LnMgKyBwdC54czA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0LnR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0c3RyID0gcHQueHMwICsgcHQucyArIHB0LnhzMTtcblx0XHRcdFx0XHRcdFx0Zm9yIChpID0gMTsgaSA8IHB0Lmw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHN0ciArPSBwdFtcInhuXCIraV0gKyBwdFtcInhzXCIrKGkrMSldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHB0W3BdID0gc3RyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bXB0ID0gbXB0Ll9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBAY29uc3RydWN0b3IgVXNlZCBieSBhIGZldyBTcGVjaWFsUHJvcHMgdG8gaG9sZCBpbXBvcnRhbnQgdmFsdWVzIGZvciBwcm94aWVzLiBGb3IgZXhhbXBsZSwgX3BhcnNlVG9Qcm94eSgpIGNyZWF0ZXMgYSBNaW5pUHJvcFR3ZWVuIGluc3RhbmNlIGZvciBlYWNoIHByb3BlcnR5IHRoYXQgbXVzdCBnZXQgdHdlZW5lZCBvbiB0aGUgcHJveHksIGFuZCB3ZSByZWNvcmQgdGhlIG9yaWdpbmFsIHByb3BlcnR5IG5hbWUgYXMgd2VsbCBhcyB0aGUgdW5pcXVlIG9uZSB3ZSBjcmVhdGUgZm9yIHRoZSBwcm94eSwgcGx1cyB3aGV0aGVyIG9yIG5vdCB0aGUgdmFsdWUgbmVlZHMgdG8gYmUgcm91bmRlZCBwbHVzIHRoZSBvcmlnaW5hbCB2YWx1ZS5cblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCB0YXJnZXQgb2JqZWN0IHdob3NlIHByb3BlcnR5IHdlJ3JlIHR3ZWVuaW5nIChvZnRlbiBhIENTU1Byb3BUd2Vlbilcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBwcm9wZXJ0eSBuYW1lXG5cdFx0XHQgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nfG9iamVjdCl9IHYgdmFsdWVcblx0XHRcdCAqIEBwYXJhbSB7TWluaVByb3BUd2Vlbj19IG5leHQgbmV4dCBNaW5pUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdFxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gciBpZiB0cnVlLCB0aGUgdHdlZW5lZCB2YWx1ZSBzaG91bGQgYmUgcm91bmRlZCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyXG5cdFx0XHQgKi9cblx0XHRcdE1pbmlQcm9wVHdlZW4gPSBmdW5jdGlvbih0LCBwLCB2LCBuZXh0LCByKSB7XG5cdFx0XHRcdHRoaXMudCA9IHQ7XG5cdFx0XHRcdHRoaXMucCA9IHA7XG5cdFx0XHRcdHRoaXMudiA9IHY7XG5cdFx0XHRcdHRoaXMuciA9IHI7XG5cdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0bmV4dC5fcHJldiA9IHRoaXM7XG5cdFx0XHRcdFx0dGhpcy5fbmV4dCA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgTW9zdCBvdGhlciBwbHVnaW5zIChsaWtlIEJlemllclBsdWdpbiBhbmQgVGhyb3dQcm9wc1BsdWdpbiBhbmQgb3RoZXJzKSBjYW4gb25seSB0d2VlbiBudW1lcmljIHZhbHVlcywgYnV0IENTU1BsdWdpbiBtdXN0IGFjY29tbW9kYXRlIHNwZWNpYWwgdmFsdWVzIHRoYXQgaGF2ZSBhIGJ1bmNoIG9mIGV4dHJhIGRhdGEgKGxpa2UgYSBzdWZmaXggb3Igc3RyaW5ncyBiZXR3ZWVuIG51bWVyaWMgdmFsdWVzLCBldGMuKS4gRm9yIGV4YW1wbGUsIGJveFNoYWRvdyBoYXMgdmFsdWVzIGxpa2UgXCIxMHB4IDEwcHggMjBweCAzMHB4IHJnYigyNTUsMCwwKVwiIHdoaWNoIHdvdWxkIHV0dGVybHkgY29uZnVzZSBvdGhlciBwbHVnaW5zLiBUaGlzIG1ldGhvZCBhbGxvd3MgdXMgdG8gc3BsaXQgdGhhdCBkYXRhIGFwYXJ0IGFuZCBncmFiIG9ubHkgdGhlIG51bWVyaWMgZGF0YSBhbmQgYXR0YWNoIGl0IHRvIHVuaXF1ZWx5LW5hbWVkIHByb3BlcnRpZXMgb2YgYSBnZW5lcmljIHByb3h5IG9iamVjdCAoe30pIHNvIHRoYXQgd2UgY2FuIGZlZWQgdGhhdCB0byB2aXJ0dWFsbHkgYW55IHBsdWdpbiB0byBoYXZlIHRoZSBudW1iZXJzIHR3ZWVuZWQuIEhvd2V2ZXIsIHdlIG11c3QgYWxzbyBrZWVwIHRyYWNrIG9mIHdoaWNoIHByb3BlcnRpZXMgZnJvbSB0aGUgcHJveHkgZ28gd2l0aCB3aGljaCBDU1NQcm9wVHdlZW4gdmFsdWVzIGFuZCBpbnN0YW5jZXMuIFNvIHdlIGNyZWF0ZSBhIGxpbmtlZCBsaXN0IG9mIE1pbmlQcm9wVHdlZW5zLiBFYWNoIG9uZSByZWNvcmRzIGEgdGFyZ2V0ICh0aGUgb3JpZ2luYWwgQ1NTUHJvcFR3ZWVuKSwgcHJvcGVydHkgKGxpa2UgXCJzXCIgb3IgXCJ4bjFcIiBvciBcInhuMlwiKSB0aGF0IHdlJ3JlIHR3ZWVuaW5nIGFuZCB0aGUgdW5pcXVlIHByb3BlcnR5IG5hbWUgdGhhdCB3YXMgdXNlZCBmb3IgdGhlIHByb3h5IChsaWtlIFwiYm94U2hhZG93X3huMVwiIGFuZCBcImJveFNoYWRvd194bjJcIikgYW5kIHdoZXRoZXIgb3Igbm90IHRoZXkgbmVlZCB0byBiZSByb3VuZGVkLiBUaGF0IHdheSwgaW4gdGhlIF9zZXRQbHVnaW5SYXRpbygpIG1ldGhvZCB3ZSBjYW4gc2ltcGx5IGNvcHkgdGhlIHZhbHVlcyBvdmVyIGZyb20gdGhlIHByb3h5IHRvIHRoZSBDU1NQcm9wVHdlZW4gaW5zdGFuY2UocykuIFRoZW4sIHdoZW4gdGhlIG1haW4gQ1NTUGx1Z2luIHNldFJhdGlvKCkgbWV0aG9kIHJ1bnMgYW5kIGFwcGxpZXMgdGhlIENTU1Byb3BUd2VlbiB2YWx1ZXMgYWNjb3JkaW5nbHksIHRoZXkncmUgdXBkYXRlZCBuaWNlbHkuIFNvIHRoZSBleHRlcm5hbCBwbHVnaW4gdHdlZW5zIHRoZSBudW1iZXJzLCBfc2V0UGx1Z2luUmF0aW8oKSBjb3BpZXMgdGhlbSBvdmVyLCBhbmQgc2V0UmF0aW8oKSBhY3RzIG5vcm1hbGx5LCBhcHBseWluZyBjc3Mtc3BlY2lmaWMgdmFsdWVzIHRvIHRoZSBlbGVtZW50LlxuXHRcdFx0ICogVGhpcyBtZXRob2QgcmV0dXJucyBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXHRcdFx0ICogIC0gcHJveHk6IGEgZ2VuZXJpYyBvYmplY3QgY29udGFpbmluZyB0aGUgc3RhcnRpbmcgdmFsdWVzIGZvciBhbGwgdGhlIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIHR3ZWVuZWQgYnkgdGhlIGV4dGVybmFsIHBsdWdpbi4gIFRoaXMgaXMgd2hhdCB3ZSBmZWVkIHRvIHRoZSBleHRlcm5hbCBfb25Jbml0VHdlZW4oKSBhcyB0aGUgdGFyZ2V0XG5cdFx0XHQgKiAgLSBlbmQ6IGEgZ2VuZXJpYyBvYmplY3QgY29udGFpbmluZyB0aGUgZW5kaW5nIHZhbHVlcyBmb3IgYWxsIHRoZSBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSB0d2VlbmVkIGJ5IHRoZSBleHRlcm5hbCBwbHVnaW4uIFRoaXMgaXMgd2hhdCB3ZSBmZWVkIHRvIHRoZSBleHRlcm5hbCBwbHVnaW4ncyBfb25Jbml0VHdlZW4oKSBhcyB0aGUgZGVzdGluYXRpb24gdmFsdWVzXG5cdFx0XHQgKiAgLSBmaXJzdE1QVDogdGhlIGZpcnN0IE1pbmlQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0XG5cdFx0XHQgKiAgLSBwdDogdGhlIGZpcnN0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3QgdGhhdCB3YXMgY3JlYXRlZCB3aGVuIHBhcnNpbmcuIElmIHNoYWxsb3cgaXMgdHJ1ZSwgdGhpcyBsaW5rZWQgbGlzdCB3aWxsIE5PVCBhdHRhY2ggdG8gdGhlIG9uZSBwYXNzZWQgaW50byB0aGUgX3BhcnNlVG9Qcm94eSgpIGFzIHRoZSBcInB0XCIgKDR0aCkgcGFyYW1ldGVyLlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IHRhcmdldCBvYmplY3QgdG8gYmUgdHdlZW5lZFxuXHRcdFx0ICogQHBhcmFtIHshKE9iamVjdHxzdHJpbmcpfSB2YXJzIHRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHR3ZWVuaW5nIHZhbHVlcyAodHlwaWNhbGx5IHRoZSBlbmQvZGVzdGluYXRpb24gdmFsdWVzKSB0aGF0IHNob3VsZCBiZSBwYXJzZWRcblx0XHRcdCAqIEBwYXJhbSB7IUNTU1BsdWdpbn0gY3NzcCBUaGUgQ1NTUGx1Z2luIGluc3RhbmNlXG5cdFx0XHQgKiBAcGFyYW0ge0NTU1Byb3BUd2Vlbj19IHB0IHRoZSBuZXh0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Rcblx0XHRcdCAqIEBwYXJhbSB7VHdlZW5QbHVnaW49fSBwbHVnaW4gdGhlIGV4dGVybmFsIFR3ZWVuUGx1Z2luIGluc3RhbmNlIHRoYXQgd2lsbCBiZSBoYW5kbGluZyB0d2VlbmluZyB0aGUgbnVtZXJpYyB2YWx1ZXNcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHNoYWxsb3cgaWYgdHJ1ZSwgdGhlIHJlc3VsdGluZyBsaW5rZWQgbGlzdCBmcm9tIHRoZSBwYXJzZSB3aWxsIE5PVCBiZSBhdHRhY2hlZCB0byB0aGUgQ1NTUHJvcFR3ZWVuIHRoYXQgd2FzIHBhc3NlZCBpbiBhcyB0aGUgXCJwdFwiICg0dGgpIHBhcmFtZXRlci5cblx0XHRcdCAqIEByZXR1cm4gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOiBwcm94eSwgZW5kLCBmaXJzdE1QVCwgYW5kIHB0IChzZWUgYWJvdmUgZm9yIGRlc2NyaXB0aW9ucylcblx0XHRcdCAqL1xuXHRcdFx0X3BhcnNlVG9Qcm94eSA9IF9pbnRlcm5hbHMuX3BhcnNlVG9Qcm94eSA9IGZ1bmN0aW9uKHQsIHZhcnMsIGNzc3AsIHB0LCBwbHVnaW4sIHNoYWxsb3cpIHtcblx0XHRcdFx0dmFyIGJwdCA9IHB0LFxuXHRcdFx0XHRcdHN0YXJ0ID0ge30sXG5cdFx0XHRcdFx0ZW5kID0ge30sXG5cdFx0XHRcdFx0dHJhbnNmb3JtID0gY3NzcC5fdHJhbnNmb3JtLFxuXHRcdFx0XHRcdG9sZEZvcmNlID0gX2ZvcmNlUFQsXG5cdFx0XHRcdFx0aSwgcCwgeHAsIG1wdCwgZmlyc3RQVDtcblx0XHRcdFx0Y3NzcC5fdHJhbnNmb3JtID0gbnVsbDtcblx0XHRcdFx0X2ZvcmNlUFQgPSB2YXJzO1xuXHRcdFx0XHRwdCA9IGZpcnN0UFQgPSBjc3NwLnBhcnNlKHQsIHZhcnMsIHB0LCBwbHVnaW4pO1xuXHRcdFx0XHRfZm9yY2VQVCA9IG9sZEZvcmNlO1xuXHRcdFx0XHQvL2JyZWFrIG9mZiBmcm9tIHRoZSBsaW5rZWQgbGlzdCBzbyB0aGUgbmV3IG9uZXMgYXJlIGlzb2xhdGVkLlxuXHRcdFx0XHRpZiAoc2hhbGxvdykge1xuXHRcdFx0XHRcdGNzc3AuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblx0XHRcdFx0XHRpZiAoYnB0KSB7XG5cdFx0XHRcdFx0XHRicHQuX3ByZXYgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKGJwdC5fcHJldikge1xuXHRcdFx0XHRcdFx0XHRicHQuX3ByZXYuX25leHQgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR3aGlsZSAocHQgJiYgcHQgIT09IGJwdCkge1xuXHRcdFx0XHRcdGlmIChwdC50eXBlIDw9IDEpIHtcblx0XHRcdFx0XHRcdHAgPSBwdC5wO1xuXHRcdFx0XHRcdFx0ZW5kW3BdID0gcHQucyArIHB0LmM7XG5cdFx0XHRcdFx0XHRzdGFydFtwXSA9IHB0LnM7XG5cdFx0XHRcdFx0XHRpZiAoIXNoYWxsb3cpIHtcblx0XHRcdFx0XHRcdFx0bXB0ID0gbmV3IE1pbmlQcm9wVHdlZW4ocHQsIFwic1wiLCBwLCBtcHQsIHB0LnIpO1xuXHRcdFx0XHRcdFx0XHRwdC5jID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChwdC50eXBlID09PSAxKSB7XG5cdFx0XHRcdFx0XHRcdGkgPSBwdC5sO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHhwID0gXCJ4blwiICsgaTtcblx0XHRcdFx0XHRcdFx0XHRwID0gcHQucCArIFwiX1wiICsgeHA7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kW3BdID0gcHQuZGF0YVt4cF07XG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRbcF0gPSBwdFt4cF07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFzaGFsbG93KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtcHQgPSBuZXcgTWluaVByb3BUd2VlbihwdCwgeHAsIHAsIG1wdCwgcHQucnhwW3hwXSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtwcm94eTpzdGFydCwgZW5kOmVuZCwgZmlyc3RNUFQ6bXB0LCBwdDpmaXJzdFBUfTtcblx0XHRcdH0sXG5cblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBjb25zdHJ1Y3RvciBFYWNoIHByb3BlcnR5IHRoYXQgaXMgdHdlZW5lZCBoYXMgYXQgbGVhc3Qgb25lIENTU1Byb3BUd2VlbiBhc3NvY2lhdGVkIHdpdGggaXQuIFRoZXNlIGluc3RhbmNlcyBzdG9yZSBpbXBvcnRhbnQgaW5mb3JtYXRpb24gbGlrZSB0aGUgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnRpbmcgdmFsdWUsIGFtb3VudCBvZiBjaGFuZ2UsIGV0Yy4gVGhleSBjYW4gYWxzbyBvcHRpb25hbGx5IGhhdmUgYSBudW1iZXIgb2YgXCJleHRyYVwiIHN0cmluZ3MgYW5kIG51bWVyaWMgdmFsdWVzIG5hbWVkIHhzMSwgeG4xLCB4czIsIHhuMiwgeHMzLCB4bjMsIGV0Yy4gd2hlcmUgXCJzXCIgaW5kaWNhdGVzIHN0cmluZyBhbmQgXCJuXCIgaW5kaWNhdGVzIG51bWJlci4gVGhlc2UgY2FuIGJlIHBpZWNlZCB0b2dldGhlciBpbiBhIGNvbXBsZXgtdmFsdWUgdHdlZW4gKHR5cGU6MSkgdGhhdCBoYXMgYWx0ZXJuYXRpbmcgdHlwZXMgb2YgZGF0YSBsaWtlIGEgc3RyaW5nLCBudW1iZXIsIHN0cmluZywgbnVtYmVyLCBldGMuIEZvciBleGFtcGxlLCBib3hTaGFkb3cgY291bGQgYmUgXCI1cHggNXB4IDhweCByZ2IoMTAyLCAxMDIsIDUxKVwiLiBJbiB0aGF0IHZhbHVlLCB0aGVyZSBhcmUgNiBudW1iZXJzIHRoYXQgbWF5IG5lZWQgdG8gdHdlZW4gYW5kIHRoZW4gcGllY2VkIGJhY2sgdG9nZXRoZXIgaW50byBhIHN0cmluZyBhZ2FpbiB3aXRoIHNwYWNlcywgc3VmZml4ZXMsIGV0Yy4geHMwIGlzIHNwZWNpYWwgaW4gdGhhdCBpdCBzdG9yZXMgdGhlIHN1ZmZpeCBmb3Igc3RhbmRhcmQgKHR5cGU6MCkgdHdlZW5zLCAtT1ItIHRoZSBmaXJzdCBzdHJpbmcgKHByZWZpeCkgaW4gYSBjb21wbGV4LXZhbHVlICh0eXBlOjEpIENTU1Byb3BUd2VlbiAtT1ItIGl0IGNhbiBiZSB0aGUgbm9uLXR3ZWVuaW5nIHZhbHVlIGluIGEgdHlwZTotMSBDU1NQcm9wVHdlZW4uIFdlIGRvIHRoaXMgdG8gY29uc2VydmUgbWVtb3J5LlxuXHRcdFx0ICogQ1NTUHJvcFR3ZWVucyBoYXZlIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgcHJvcGVydGllcyBhcyB3ZWxsIChub3QgZGVmaW5lZCB0aHJvdWdoIHRoZSBjb25zdHJ1Y3Rvcik6XG5cdFx0XHQgKiAgLSBsOiBMZW5ndGggaW4gdGVybXMgb2YgdGhlIG51bWJlciBvZiBleHRyYSBwcm9wZXJ0aWVzIHRoYXQgdGhlIENTU1Byb3BUd2VlbiBoYXMgKGRlZmF1bHQ6IDApLiBGb3IgZXhhbXBsZSwgZm9yIGEgYm94U2hhZG93IHdlIG1heSBuZWVkIHRvIHR3ZWVuIDUgbnVtYmVycyBpbiB3aGljaCBjYXNlIGwgd291bGQgYmUgNTsgS2VlcCBpbiBtaW5kIHRoYXQgdGhlIHN0YXJ0L2VuZCB2YWx1ZXMgZm9yIHRoZSBmaXJzdCBudW1iZXIgdGhhdCdzIHR3ZWVuZWQgYXJlIGFsd2F5cyBzdG9yZWQgaW4gdGhlIHMgYW5kIGMgcHJvcGVydGllcyB0byBjb25zZXJ2ZSBtZW1vcnkuIEFsbCBhZGRpdGlvbmFsIHZhbHVlcyB0aGVyZWFmdGVyIGFyZSBzdG9yZWQgaW4geG4xLCB4bjIsIGV0Yy5cblx0XHRcdCAqICAtIHhmaXJzdDogVGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBzdWItQ1NTUHJvcFR3ZWVucyB0aGF0IGFyZSB0d2VlbmluZyBwcm9wZXJ0aWVzIG9mIHRoaXMgaW5zdGFuY2UuIEZvciBleGFtcGxlLCB3ZSBtYXkgc3BsaXQgdXAgYSBib3hTaGFkb3cgdHdlZW4gc28gdGhhdCB0aGVyZSdzIGEgbWFpbiBDU1NQcm9wVHdlZW4gb2YgdHlwZToxIHRoYXQgaGFzIHZhcmlvdXMgeHMqIGFuZCB4biogdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgaC1zaGFkb3csIHYtc2hhZG93LCBibHVyLCBjb2xvciwgZXRjLiBUaGVuIHdlIHNwYXduIGEgQ1NTUHJvcFR3ZWVuIGZvciBlYWNoIG9mIHRob3NlIHRoYXQgaGFzIGEgaGlnaGVyIHByaW9yaXR5IGFuZCBydW5zIEJFRk9SRSB0aGUgbWFpbiBDU1NQcm9wVHdlZW4gc28gdGhhdCB0aGUgdmFsdWVzIGFyZSBhbGwgc2V0IGJ5IHRoZSB0aW1lIGl0IG5lZWRzIHRvIHJlLWFzc2VtYmxlIHRoZW0uIFRoZSB4Zmlyc3QgZ2l2ZXMgdXMgYW4gZWFzeSB3YXkgdG8gaWRlbnRpZnkgdGhlIGZpcnN0IG9uZSBpbiB0aGF0IGNoYWluIHdoaWNoIHR5cGljYWxseSBlbmRzIGF0IHRoZSBtYWluIG9uZSAoYmVjYXVzZSB0aGV5J3JlIGFsbCBwcmVwZW5kZSB0byB0aGUgbGlua2VkIGxpc3QpXG5cdFx0XHQgKiAgLSBwbHVnaW46IFRoZSBUd2VlblBsdWdpbiBpbnN0YW5jZSB0aGF0IHdpbGwgaGFuZGxlIHRoZSB0d2VlbmluZyBvZiBhbnkgY29tcGxleCB2YWx1ZXMuIEZvciBleGFtcGxlLCBzb21ldGltZXMgd2UgZG9uJ3Qgd2FudCB0byB1c2Ugbm9ybWFsIHN1YnR3ZWVucyAobGlrZSB4Zmlyc3QgcmVmZXJzIHRvKSB0byB0d2VlbiB0aGUgdmFsdWVzIC0gd2UgbWlnaHQgd2FudCBUaHJvd1Byb3BzUGx1Z2luIG9yIEJlemllclBsdWdpbiBzb21lIG90aGVyIHBsdWdpbiB0byBkbyB0aGUgYWN0dWFsIHR3ZWVuaW5nLCBzbyB3ZSBjcmVhdGUgYSBwbHVnaW4gaW5zdGFuY2UgYW5kIHN0b3JlIGEgcmVmZXJlbmNlIGhlcmUuIFdlIG5lZWQgdGhpcyByZWZlcmVuY2Ugc28gdGhhdCBpZiB3ZSBnZXQgYSByZXF1ZXN0IHRvIHJvdW5kIHZhbHVlcyBvciBkaXNhYmxlIGEgdHdlZW4sIHdlIGNhbiBwYXNzIGFsb25nIHRoYXQgcmVxdWVzdC5cblx0XHRcdCAqICAtIGRhdGE6IEFyYml0cmFyeSBkYXRhIHRoYXQgbmVlZHMgdG8gYmUgc3RvcmVkIHdpdGggdGhlIENTU1Byb3BUd2Vlbi4gVHlwaWNhbGx5IGlmIHdlJ3JlIGdvaW5nIHRvIGhhdmUgYSBwbHVnaW4gaGFuZGxlIHRoZSB0d2VlbmluZyBvZiBhIGNvbXBsZXgtdmFsdWUgdHdlZW4sIHdlIGNyZWF0ZSBhIGdlbmVyaWMgb2JqZWN0IHRoYXQgc3RvcmVzIHRoZSBFTkQgdmFsdWVzIHRoYXQgd2UncmUgdHdlZW5pbmcgdG8gYW5kIHRoZSBDU1NQcm9wVHdlZW4ncyB4czEsIHhzMiwgZXRjLiBoYXZlIHRoZSBzdGFydGluZyB2YWx1ZXMuIFdlIHN0b3JlIHRoYXQgb2JqZWN0IGFzIGRhdGEuIFRoYXQgd2F5LCB3ZSBjYW4gc2ltcGx5IHBhc3MgdGhhdCBvYmplY3QgdG8gdGhlIHBsdWdpbiBhbmQgdXNlIHRoZSBDU1NQcm9wVHdlZW4gYXMgdGhlIHRhcmdldC5cblx0XHRcdCAqICAtIHNldFJhdGlvOiBPbmx5IHVzZWQgZm9yIHR5cGU6MiB0d2VlbnMgdGhhdCByZXF1aXJlIGN1c3RvbSBmdW5jdGlvbmFsaXR5LiBJbiB0aGlzIGNhc2UsIHdlIGNhbGwgdGhlIENTU1Byb3BUd2VlbidzIHNldFJhdGlvKCkgbWV0aG9kIGFuZCBwYXNzIHRoZSByYXRpbyBlYWNoIHRpbWUgdGhlIHR3ZWVuIHVwZGF0ZXMuIFRoaXMgaXNuJ3QgcXVpdGUgYXMgZWZmaWNpZW50IGFzIGRvaW5nIHRoaW5ncyBkaXJlY3RseSBpbiB0aGUgQ1NTUGx1Z2luJ3Mgc2V0UmF0aW8oKSBtZXRob2QsIGJ1dCBpdCdzIHZlcnkgY29udmVuaWVudCBhbmQgZmxleGlibGUuXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IG9iamVjdCB3aG9zZSBwcm9wZXJ0eSB3aWxsIGJlIHR3ZWVuZWQuIE9mdGVuIGEgRE9NIGVsZW1lbnQsIGJ1dCBub3QgYWx3YXlzLiBJdCBjb3VsZCBiZSBhbnl0aGluZy5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBwIFByb3BlcnR5IHRvIHR3ZWVuIChuYW1lKS4gRm9yIGV4YW1wbGUsIHRvIHR3ZWVuIGVsZW1lbnQud2lkdGgsIHAgd291bGQgYmUgXCJ3aWR0aFwiLlxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXJ9IHMgU3RhcnRpbmcgbnVtZXJpYyB2YWx1ZVxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXJ9IGMgQ2hhbmdlIGluIG51bWVyaWMgdmFsdWUgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBlbnRpcmUgdHdlZW4uIEZvciBleGFtcGxlLCBpZiBlbGVtZW50LndpZHRoIHN0YXJ0cyBhdCA1IGFuZCBzaG91bGQgZW5kIGF0IDEwMCwgYyB3b3VsZCBiZSA5NS5cblx0XHRcdCAqIEBwYXJhbSB7Q1NTUHJvcFR3ZWVuPX0gbmV4dCBUaGUgbmV4dCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0LiBJZiBvbmUgaXMgZGVmaW5lZCwgd2Ugd2lsbCBkZWZpbmUgaXRzIF9wcmV2IGFzIHRoZSBuZXcgaW5zdGFuY2UsIGFuZCB0aGUgbmV3IGluc3RhbmNlJ3MgX25leHQgd2lsbCBiZSBwb2ludGVkIGF0IGl0LlxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXI9fSB0eXBlIFRoZSB0eXBlIG9mIENTU1Byb3BUd2VlbiB3aGVyZSAtMSA9IGEgbm9uLXR3ZWVuaW5nIHZhbHVlLCAwID0gYSBzdGFuZGFyZCBzaW1wbGUgdHdlZW4sIDEgPSBhIGNvbXBsZXggdmFsdWUgKGxpa2Ugb25lIHRoYXQgaGFzIG11bHRpcGxlIG51bWJlcnMgaW4gYSBjb21tYS0gb3Igc3BhY2UtZGVsaW1pdGVkIHN0cmluZyBsaWtlIGJvcmRlcjpcIjFweCBzb2xpZCByZWRcIiksIGFuZCAyID0gb25lIHRoYXQgdXNlcyBhIGN1c3RvbSBzZXRSYXRpbyBmdW5jdGlvbiB0aGF0IGRvZXMgYWxsIG9mIHRoZSB3b3JrIG9mIGFwcGx5aW5nIHRoZSB2YWx1ZXMgb24gZWFjaCB1cGRhdGUuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IG4gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3Igb3ZlcndyaXRpbmcgcHVycG9zZXMgd2hpY2ggaXMgdHlwaWNhbGx5IHRoZSBzYW1lIGFzIHAgYnV0IG5vdCBhbHdheXMuIEZvciBleGFtcGxlLCB3ZSBtYXkgbmVlZCB0byBjcmVhdGUgYSBzdWJ0d2VlbiBmb3IgdGhlIDJuZCBwYXJ0IG9mIGEgXCJjbGlwOnJlY3QoLi4uKVwiIHR3ZWVuIGluIHdoaWNoIGNhc2UgXCJwXCIgbWlnaHQgYmUgeHMxIGJ1dCBcIm5cIiBpcyBzdGlsbCBcImNsaXBcIlxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gciBJZiB0cnVlLCB0aGUgdmFsdWUocykgc2hvdWxkIGJlIHJvdW5kZWRcblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyPX0gcHIgUHJpb3JpdHkgaW4gdGhlIGxpbmtlZCBsaXN0IG9yZGVyLiBIaWdoZXIgcHJpb3JpdHkgQ1NTUHJvcFR3ZWVucyB3aWxsIGJlIHVwZGF0ZWQgYmVmb3JlIGxvd2VyIHByaW9yaXR5IG9uZXMuIFRoZSBkZWZhdWx0IHByaW9yaXR5IGlzIDAuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IGIgQmVnaW5uaW5nIHZhbHVlLiBXZSBzdG9yZSB0aGlzIHRvIGVuc3VyZSB0aGF0IGl0IGlzIEVYQUNUTFkgd2hhdCBpdCB3YXMgd2hlbiB0aGUgdHdlZW4gYmVnYW4gd2l0aG91dCBhbnkgcmlzayBvZiBpbnRlcnByZXRhdGlvbiBpc3N1ZXMuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IGUgRW5kaW5nIHZhbHVlLiBXZSBzdG9yZSB0aGlzIHRvIGVuc3VyZSB0aGF0IGl0IGlzIEVYQUNUTFkgd2hhdCB0aGUgdXNlciBkZWZpbmVkIGF0IHRoZSBlbmQgb2YgdGhlIHR3ZWVuIHdpdGhvdXQgYW55IHJpc2sgb2YgaW50ZXJwcmV0YXRpb24gaXNzdWVzLlxuXHRcdFx0ICovXG5cdFx0XHRDU1NQcm9wVHdlZW4gPSBfaW50ZXJuYWxzLkNTU1Byb3BUd2VlbiA9IGZ1bmN0aW9uKHQsIHAsIHMsIGMsIG5leHQsIHR5cGUsIG4sIHIsIHByLCBiLCBlKSB7XG5cdFx0XHRcdHRoaXMudCA9IHQ7IC8vdGFyZ2V0XG5cdFx0XHRcdHRoaXMucCA9IHA7IC8vcHJvcGVydHlcblx0XHRcdFx0dGhpcy5zID0gczsgLy9zdGFydGluZyB2YWx1ZVxuXHRcdFx0XHR0aGlzLmMgPSBjOyAvL2NoYW5nZSB2YWx1ZVxuXHRcdFx0XHR0aGlzLm4gPSBuIHx8IHA7IC8vbmFtZSB0aGF0IHRoaXMgQ1NTUHJvcFR3ZWVuIHNob3VsZCBiZSBhc3NvY2lhdGVkIHRvICh1c3VhbGx5IHRoZSBzYW1lIGFzIHAsIGJ1dCBub3QgYWx3YXlzIC0gbiBpcyB3aGF0IG92ZXJ3cml0aW5nIGxvb2tzIGF0KVxuXHRcdFx0XHRpZiAoISh0IGluc3RhbmNlb2YgQ1NTUHJvcFR3ZWVuKSkge1xuXHRcdFx0XHRcdF9vdmVyd3JpdGVQcm9wcy5wdXNoKHRoaXMubik7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5yID0gIXIgPyByIDogKHR5cGVvZihyKSA9PT0gXCJmdW5jdGlvblwiKSA/IHIgOiBNYXRoLnJvdW5kOyAvL3JvdW5kIChib29sZWFuKVxuXHRcdFx0XHR0aGlzLnR5cGUgPSB0eXBlIHx8IDA7IC8vMCA9IG5vcm1hbCB0d2VlbiwgLTEgPSBub24tdHdlZW5pbmcgKGluIHdoaWNoIGNhc2UgeHMwIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgdGFyZ2V0J3MgcHJvcGVydHksIGxpa2UgdHAudFt0cC5wXSA9IHRwLnhzMCksIDEgPSBjb21wbGV4LXZhbHVlIFNwZWNpYWxQcm9wLCAyID0gY3VzdG9tIHNldFJhdGlvKCkgdGhhdCBkb2VzIGFsbCB0aGUgd29ya1xuXHRcdFx0XHRpZiAocHIpIHtcblx0XHRcdFx0XHR0aGlzLnByID0gcHI7XG5cdFx0XHRcdFx0X2hhc1ByaW9yaXR5ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmIgPSAoYiA9PT0gdW5kZWZpbmVkKSA/IHMgOiBiO1xuXHRcdFx0XHR0aGlzLmUgPSAoZSA9PT0gdW5kZWZpbmVkKSA/IHMgKyBjIDogZTtcblx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHR0aGlzLl9uZXh0ID0gbmV4dDtcblx0XHRcdFx0XHRuZXh0Ll9wcmV2ID0gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X2FkZE5vblR3ZWVuaW5nTnVtZXJpY1BUID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBuZXh0LCBvdmVyd3JpdGVQcm9wKSB7IC8vY2xlYW5zIHVwIHNvbWUgY29kZSByZWR1bmRhbmNpZXMgYW5kIGhlbHBzIG1pbmlmaWNhdGlvbi4gSnVzdCBhIGZhc3Qgd2F5IHRvIGFkZCBhIE5VTUVSSUMgbm9uLXR3ZWVuaW5nIENTU1Byb3BUd2VlblxuXHRcdFx0XHR2YXIgcHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCAtIHN0YXJ0LCBuZXh0LCAtMSwgb3ZlcndyaXRlUHJvcCk7XG5cdFx0XHRcdHB0LmIgPSBzdGFydDtcblx0XHRcdFx0cHQuZSA9IHB0LnhzMCA9IGVuZDtcblx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUYWtlcyBhIHRhcmdldCwgdGhlIGJlZ2lubmluZyB2YWx1ZSBhbmQgZW5kaW5nIHZhbHVlIChhcyBzdHJpbmdzKSBhbmQgcGFyc2VzIHRoZW0gaW50byBhIENTU1Byb3BUd2VlbiAocG9zc2libHkgd2l0aCBjaGlsZCBDU1NQcm9wVHdlZW5zKSB0aGF0IGFjY29tbW9kYXRlcyBtdWx0aXBsZSBudW1iZXJzLCBjb2xvcnMsIGNvbW1hLWRlbGltaXRlZCB2YWx1ZXMsIGV0Yy4gRm9yIGV4YW1wbGU6XG5cdFx0XHQgKiBzcC5wYXJzZUNvbXBsZXgoZWxlbWVudCwgXCJib3hTaGFkb3dcIiwgXCI1cHggMTBweCAyMHB4IHJnYigyNTUsMTAyLDUxKVwiLCBcIjBweCAwcHggMHB4IHJlZFwiLCB0cnVlLCBcIjBweCAwcHggMHB4IHJnYigwLDAsMCwwKVwiLCBwdCk7XG5cdFx0XHQgKiBJdCB3aWxsIHdhbGsgdGhyb3VnaCB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzICh3aGljaCBzaG91bGQgYmUgaW4gdGhlIHNhbWUgZm9ybWF0IHdpdGggdGhlIHNhbWUgbnVtYmVyIGFuZCB0eXBlIG9mIHZhbHVlcykgYW5kIGZpZ3VyZSBvdXQgd2hpY2ggcGFydHMgYXJlIG51bWJlcnMsIHdoYXQgc3RyaW5ncyBzZXBhcmF0ZSB0aGUgbnVtZXJpYy90d2VlbmFibGUgdmFsdWVzLCBhbmQgdGhlbiBjcmVhdGUgdGhlIENTU1Byb3BUd2VlbnMgYWNjb3JkaW5nbHkuIElmIGEgcGx1Z2luIGlzIGRlZmluZWQsIG5vIGNoaWxkIENTU1Byb3BUd2VlbnMgd2lsbCBiZSBjcmVhdGVkLiBJbnN0ZWFkLCB0aGUgZW5kaW5nIHZhbHVlcyB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgXCJkYXRhXCIgcHJvcGVydHkgb2YgdGhlIHJldHVybmVkIENTU1Byb3BUd2VlbiBsaWtlOiB7czotNSwgeG4xOi0xMCwgeG4yOi0yMCwgeG4zOjI1NSwgeG40OjAsIHhuNTowfSBzbyB0aGF0IGl0IGNhbiBiZSBmZWQgdG8gYW55IG90aGVyIHBsdWdpbiBhbmQgaXQnbGwgYmUgcGxhaW4gbnVtZXJpYyB0d2VlbnMgYnV0IHRoZSByZWNvbXBvc2l0aW9uIG9mIHRoZSBjb21wbGV4IHZhbHVlIHdpbGwgYmUgaGFuZGxlZCBpbnNpZGUgQ1NTUGx1Z2luJ3Mgc2V0UmF0aW8oKS5cblx0XHRcdCAqIElmIGEgc2V0UmF0aW8gaXMgZGVmaW5lZCwgdGhlIHR5cGUgb2YgdGhlIENTU1Byb3BUd2VlbiB3aWxsIGJlIHNldCB0byAyIGFuZCByZWNvbXBvc2l0aW9uIG9mIHRoZSB2YWx1ZXMgd2lsbCBiZSB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhhdCBtZXRob2QuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IFRhcmdldCB3aG9zZSBwcm9wZXJ0eSB3aWxsIGJlIHR3ZWVuZWRcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSB0aGF0IHdpbGwgYmUgdHdlZW5lZCAoaXRzIG5hbWUsIGxpa2UgXCJsZWZ0XCIgb3IgXCJiYWNrZ3JvdW5kQ29sb3JcIiBvciBcImJveFNoYWRvd1wiKVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGIgQmVnaW5uaW5nIHZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gZSBFbmRpbmcgdmFsdWVcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xycyBJZiB0cnVlLCB0aGUgdmFsdWUgY291bGQgY29udGFpbiBhIGNvbG9yIHZhbHVlIGxpa2UgXCJyZ2IoMjU1LDAsMClcIiBvciBcIiNGMDBcIiBvciBcInJlZFwiLiBUaGUgZGVmYXVsdCBpcyBmYWxzZSwgc28gbm8gY29sb3JzIHdpbGwgYmUgcmVjb2duaXplZCAoYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pXG5cdFx0XHQgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyfE9iamVjdCl9IGRmbHQgVGhlIGRlZmF1bHQgYmVnaW5uaW5nIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgaWYgbm8gdmFsaWQgYmVnaW5uaW5nIHZhbHVlIGlzIGRlZmluZWQgb3IgaWYgdGhlIG51bWJlciBvZiB2YWx1ZXMgaW5zaWRlIHRoZSBjb21wbGV4IGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBkb24ndCBtYXRjaFxuXHRcdFx0ICogQHBhcmFtIHs/Q1NTUHJvcFR3ZWVufSBwdCBDU1NQcm9wVHdlZW4gaW5zdGFuY2UgdGhhdCBpcyB0aGUgY3VycmVudCBoZWFkIG9mIHRoZSBsaW5rZWQgbGlzdCAod2UnbGwgcHJlcGVuZCB0byB0aGlzKS5cblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyPX0gcHIgUHJpb3JpdHkgaW4gdGhlIGxpbmtlZCBsaXN0IG9yZGVyLiBIaWdoZXIgcHJpb3JpdHkgcHJvcGVydGllcyB3aWxsIGJlIHVwZGF0ZWQgYmVmb3JlIGxvd2VyIHByaW9yaXR5IG9uZXMuIFRoZSBkZWZhdWx0IHByaW9yaXR5IGlzIDAuXG5cdFx0XHQgKiBAcGFyYW0ge1R3ZWVuUGx1Z2luPX0gcGx1Z2luIElmIGEgcGx1Z2luIHNob3VsZCBoYW5kbGUgdGhlIHR3ZWVuaW5nIG9mIGV4dHJhIHByb3BlcnRpZXMsIHBhc3MgdGhlIHBsdWdpbiBpbnN0YW5jZSBoZXJlLiBJZiBvbmUgaXMgZGVmaW5lZCwgdGhlbiBOTyBzdWJ0d2VlbnMgd2lsbCBiZSBjcmVhdGVkIGZvciBhbnkgZXh0cmEgcHJvcGVydGllcyAodGhlIHByb3BlcnRpZXMgd2lsbCBiZSBjcmVhdGVkIC0ganVzdCBub3QgYWRkaXRpb25hbCBDU1NQcm9wVHdlZW4gaW5zdGFuY2VzIHRvIHR3ZWVuIHRoZW0pIGJlY2F1c2UgdGhlIHBsdWdpbiBpcyBleHBlY3RlZCB0byBkbyBzby4gSG93ZXZlciwgdGhlIGVuZCB2YWx1ZXMgV0lMTCBiZSBwb3B1bGF0ZWQgaW4gdGhlIFwiZGF0YVwiIHByb3BlcnR5LCBsaWtlIHtzOjEwMCwgeG4xOjUwLCB4bjI6MzAwfVxuXHRcdFx0ICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpPX0gc2V0UmF0aW8gSWYgdmFsdWVzIHNob3VsZCBiZSBzZXQgaW4gYSBjdXN0b20gZnVuY3Rpb24gaW5zdGVhZCBvZiBiZWluZyBwaWVjZWQgdG9nZXRoZXIgaW4gYSB0eXBlOjEgKGNvbXBsZXgtdmFsdWUpIENTU1Byb3BUd2VlbiwgZGVmaW5lIHRoYXQgY3VzdG9tIGZ1bmN0aW9uIGhlcmUuXG5cdFx0XHQgKiBAcmV0dXJuIHtDU1NQcm9wVHdlZW59IFRoZSBmaXJzdCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0IHdoaWNoIGluY2x1ZGVzIHRoZSBuZXcgb25lKHMpIGFkZGVkIGJ5IHRoZSBwYXJzZUNvbXBsZXgoKSBjYWxsLlxuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VDb21wbGV4ID0gQ1NTUGx1Z2luLnBhcnNlQ29tcGxleCA9IGZ1bmN0aW9uKHQsIHAsIGIsIGUsIGNscnMsIGRmbHQsIHB0LCBwciwgcGx1Z2luLCBzZXRSYXRpbykge1xuXHRcdFx0XHQvL0RFQlVHOiBfbG9nKFwicGFyc2VDb21wbGV4OiBcIitwK1wiLCBiOiBcIitiK1wiLCBlOiBcIitlKTtcblx0XHRcdFx0YiA9IGIgfHwgZGZsdCB8fCBcIlwiO1xuXHRcdFx0XHRpZiAodHlwZW9mKGUpID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRlID0gZShfaW5kZXgsIF90YXJnZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2Vlbih0LCBwLCAwLCAwLCBwdCwgKHNldFJhdGlvID8gMiA6IDEpLCBudWxsLCBmYWxzZSwgcHIsIGIsIGUpO1xuXHRcdFx0XHRlICs9IFwiXCI7IC8vZW5zdXJlcyBpdCdzIGEgc3RyaW5nXG5cdFx0XHRcdGlmIChjbHJzICYmIF9jb2xvckV4cC50ZXN0KGUgKyBiKSkgeyAvL2lmIGNvbG9ycyBhcmUgZm91bmQsIG5vcm1hbGl6ZSB0aGUgZm9ybWF0dGluZyB0byByZ2JhKCkgb3IgaHNsYSgpLlxuXHRcdFx0XHRcdGUgPSBbYiwgZV07XG5cdFx0XHRcdFx0Q1NTUGx1Z2luLmNvbG9yU3RyaW5nRmlsdGVyKGUpO1xuXHRcdFx0XHRcdGIgPSBlWzBdO1xuXHRcdFx0XHRcdGUgPSBlWzFdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBiYSA9IGIuc3BsaXQoXCIsIFwiKS5qb2luKFwiLFwiKS5zcGxpdChcIiBcIiksIC8vYmVnaW5uaW5nIGFycmF5XG5cdFx0XHRcdFx0ZWEgPSBlLnNwbGl0KFwiLCBcIikuam9pbihcIixcIikuc3BsaXQoXCIgXCIpLCAvL2VuZGluZyBhcnJheVxuXHRcdFx0XHRcdGwgPSBiYS5sZW5ndGgsXG5cdFx0XHRcdFx0YXV0b1JvdW5kID0gKF9hdXRvUm91bmQgIT09IGZhbHNlKSxcblx0XHRcdFx0XHRpLCB4aSwgbmksIGJ2LCBldiwgYm51bXMsIGVudW1zLCBibiwgaGFzQWxwaGEsIHRlbXAsIGN2LCBzdHIsIHVzZUhTTDtcblx0XHRcdFx0aWYgKGUuaW5kZXhPZihcIixcIikgIT09IC0xIHx8IGIuaW5kZXhPZihcIixcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0aWYgKChlICsgYikuaW5kZXhPZihcInJnYlwiKSAhPT0gLTEgfHwgKGUgKyBiKS5pbmRleE9mKFwiaHNsXCIpICE9PSAtMSkgeyAvL2tlZXAgcmdiKCksIHJnYmEoKSwgaHNsKCksIGFuZCBoc2xhKCkgdmFsdWVzIHRvZ2V0aGVyISAocmVtZW1iZXIsIHdlJ3JlIHNwbGl0dGluZyBvbiBzcGFjZXMpXG5cdFx0XHRcdFx0XHRiYSA9IGJhLmpvaW4oXCIgXCIpLnJlcGxhY2UoX2NvbW1hc091dHNpZGVQYXJlbkV4cCwgXCIsIFwiKS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0XHRlYSA9IGVhLmpvaW4oXCIgXCIpLnJlcGxhY2UoX2NvbW1hc091dHNpZGVQYXJlbkV4cCwgXCIsIFwiKS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJhID0gYmEuam9pbihcIiBcIikuc3BsaXQoXCIsXCIpLmpvaW4oXCIsIFwiKS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0XHRlYSA9IGVhLmpvaW4oXCIgXCIpLnNwbGl0KFwiLFwiKS5qb2luKFwiLCBcIikuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsID0gYmEubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsICE9PSBlYS5sZW5ndGgpIHtcblx0XHRcdFx0XHQvL0RFQlVHOiBfbG9nKFwibWlzbWF0Y2hlZCBmb3JtYXR0aW5nIGRldGVjdGVkIG9uIFwiICsgcCArIFwiIChcIiArIGIgKyBcIiB2cyBcIiArIGUgKyBcIilcIik7XG5cdFx0XHRcdFx0YmEgPSAoZGZsdCB8fCBcIlwiKS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0bCA9IGJhLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdHB0LnNldFJhdGlvID0gc2V0UmF0aW87XG5cdFx0XHRcdF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0YnYgPSBiYVtpXTtcblx0XHRcdFx0XHRldiA9IGVhW2ldICsgXCJcIjtcblx0XHRcdFx0XHRibiA9IHBhcnNlRmxvYXQoYnYpO1xuXHRcdFx0XHRcdC8vaWYgdGhlIHZhbHVlIGJlZ2lucyB3aXRoIGEgbnVtYmVyIChtb3N0IGNvbW1vbikuIEl0J3MgZmluZSBpZiBpdCBoYXMgYSBzdWZmaXggbGlrZSBweFxuXHRcdFx0XHRcdGlmIChibiB8fCBibiA9PT0gMCkge1xuXHRcdFx0XHRcdFx0cHQuYXBwZW5kWHRyYShcIlwiLCBibiwgX3BhcnNlQ2hhbmdlKGV2LCBibiksIGV2LnJlcGxhY2UoX3JlbE51bUV4cCwgXCJcIiksIChhdXRvUm91bmQgJiYgZXYuaW5kZXhPZihcInB4XCIpICE9PSAtMSkgPyBNYXRoLnJvdW5kIDogZmFsc2UsIHRydWUpO1xuXG5cdFx0XHRcdFx0Ly9pZiB0aGUgdmFsdWUgaXMgYSBjb2xvclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY2xycyAmJiBfY29sb3JFeHAudGVzdChidikpIHtcblx0XHRcdFx0XHRcdHN0ciA9IGV2LmluZGV4T2YoXCIpXCIpICsgMTtcblx0XHRcdFx0XHRcdHN0ciA9IFwiKVwiICsgKHN0ciA/IGV2LnN1YnN0cihzdHIpIDogXCJcIik7IC8vaWYgdGhlcmUncyBhIGNvbW1hIG9yICkgYXQgdGhlIGVuZCwgcmV0YWluIGl0LlxuXHRcdFx0XHRcdFx0dXNlSFNMID0gKGV2LmluZGV4T2YoXCJoc2xcIikgIT09IC0xICYmIF9zdXBwb3J0c09wYWNpdHkpO1xuXHRcdFx0XHRcdFx0dGVtcCA9IGV2OyAvL29yaWdpbmFsIHN0cmluZyB2YWx1ZSBzbyB3ZSBjYW4gbG9vayBmb3IgYW55IHByZWZpeCBsYXRlci5cblx0XHRcdFx0XHRcdGJ2ID0gX3BhcnNlQ29sb3IoYnYsIHVzZUhTTCk7XG5cdFx0XHRcdFx0XHRldiA9IF9wYXJzZUNvbG9yKGV2LCB1c2VIU0wpO1xuXHRcdFx0XHRcdFx0aGFzQWxwaGEgPSAoYnYubGVuZ3RoICsgZXYubGVuZ3RoID4gNik7XG5cdFx0XHRcdFx0XHRpZiAoaGFzQWxwaGEgJiYgIV9zdXBwb3J0c09wYWNpdHkgJiYgZXZbM10gPT09IDApIHsgLy9vbGRlciB2ZXJzaW9ucyBvZiBJRSBkb24ndCBzdXBwb3J0IHJnYmEoKSwgc28gaWYgdGhlIGRlc3RpbmF0aW9uIGFscGhhIGlzIDAsIGp1c3QgdXNlIFwidHJhbnNwYXJlbnRcIiBmb3IgdGhlIGVuZCBjb2xvclxuXHRcdFx0XHRcdFx0XHRwdFtcInhzXCIgKyBwdC5sXSArPSBwdC5sID8gXCIgdHJhbnNwYXJlbnRcIiA6IFwidHJhbnNwYXJlbnRcIjtcblx0XHRcdFx0XHRcdFx0cHQuZSA9IHB0LmUuc3BsaXQoZWFbaV0pLmpvaW4oXCJ0cmFuc3BhcmVudFwiKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmICghX3N1cHBvcnRzT3BhY2l0eSkgeyAvL29sZCB2ZXJzaW9ucyBvZiBJRSBkb24ndCBzdXBwb3J0IHJnYmEoKS5cblx0XHRcdFx0XHRcdFx0XHRoYXNBbHBoYSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICh1c2VIU0wpIHtcblx0XHRcdFx0XHRcdFx0XHRwdC5hcHBlbmRYdHJhKHRlbXAuc3Vic3RyKDAsIHRlbXAuaW5kZXhPZihcImhzbFwiKSkgKyAoaGFzQWxwaGEgPyBcImhzbGEoXCIgOiBcImhzbChcIiksIGJ2WzBdLCBfcGFyc2VDaGFuZ2UoZXZbMF0sIGJ2WzBdKSwgXCIsXCIsIGZhbHNlLCB0cnVlKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFh0cmEoXCJcIiwgYnZbMV0sIF9wYXJzZUNoYW5nZShldlsxXSwgYnZbMV0pLCBcIiUsXCIsIGZhbHNlKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFh0cmEoXCJcIiwgYnZbMl0sIF9wYXJzZUNoYW5nZShldlsyXSwgYnZbMl0pLCAoaGFzQWxwaGEgPyBcIiUsXCIgOiBcIiVcIiArIHN0ciksIGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRwdC5hcHBlbmRYdHJhKHRlbXAuc3Vic3RyKDAsIHRlbXAuaW5kZXhPZihcInJnYlwiKSkgKyAoaGFzQWxwaGEgPyBcInJnYmEoXCIgOiBcInJnYihcIiksIGJ2WzBdLCBldlswXSAtIGJ2WzBdLCBcIixcIiwgTWF0aC5yb3VuZCwgdHJ1ZSlcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmRYdHJhKFwiXCIsIGJ2WzFdLCBldlsxXSAtIGJ2WzFdLCBcIixcIiwgTWF0aC5yb3VuZClcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmRYdHJhKFwiXCIsIGJ2WzJdLCBldlsyXSAtIGJ2WzJdLCAoaGFzQWxwaGEgPyBcIixcIiA6IHN0ciksIE1hdGgucm91bmQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKGhhc0FscGhhKSB7XG5cdFx0XHRcdFx0XHRcdFx0YnYgPSAoYnYubGVuZ3RoIDwgNCkgPyAxIDogYnZbM107XG5cdFx0XHRcdFx0XHRcdFx0cHQuYXBwZW5kWHRyYShcIlwiLCBidiwgKChldi5sZW5ndGggPCA0KSA/IDEgOiBldlszXSkgLSBidiwgc3RyLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdF9jb2xvckV4cC5sYXN0SW5kZXggPSAwOyAvL290aGVyd2lzZSB0aGUgdGVzdCgpIG9uIHRoZSBSZWdFeHAgY291bGQgbW92ZSB0aGUgbGFzdEluZGV4IGFuZCB0YWludCBmdXR1cmUgcmVzdWx0cy5cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRibnVtcyA9IGJ2Lm1hdGNoKF9udW1FeHApOyAvL2dldHMgZWFjaCBncm91cCBvZiBudW1iZXJzIGluIHRoZSBiZWdpbm5pbmcgdmFsdWUgc3RyaW5nIGFuZCBkcm9wcyB0aGVtIGludG8gYW4gYXJyYXlcblxuXHRcdFx0XHRcdFx0Ly9pZiBubyBudW1iZXIgaXMgZm91bmQsIHRyZWF0IGl0IGFzIGEgbm9uLXR3ZWVuaW5nIHZhbHVlIGFuZCBqdXN0IGFwcGVuZCB0aGUgc3RyaW5nIHRvIHRoZSBjdXJyZW50IHhzLlxuXHRcdFx0XHRcdFx0aWYgKCFibnVtcykge1xuXHRcdFx0XHRcdFx0XHRwdFtcInhzXCIgKyBwdC5sXSArPSAocHQubCB8fCBwdFtcInhzXCIgKyBwdC5sXSkgPyBcIiBcIiArIGV2IDogZXY7XG5cblx0XHRcdFx0XHRcdC8vbG9vcCB0aHJvdWdoIGFsbCB0aGUgbnVtYmVycyB0aGF0IGFyZSBmb3VuZCBhbmQgY29uc3RydWN0IHRoZSBleHRyYSB2YWx1ZXMgb24gdGhlIHB0LlxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZW51bXMgPSBldi5tYXRjaChfcmVsTnVtRXhwKTsgLy9nZXQgZWFjaCBncm91cCBvZiBudW1iZXJzIGluIHRoZSBlbmQgdmFsdWUgc3RyaW5nIGFuZCBkcm9wIHRoZW0gaW50byBhbiBhcnJheS4gV2UgYWxsb3cgcmVsYXRpdmUgdmFsdWVzIHRvbywgbGlrZSArPTUwIG9yIC09LjVcblx0XHRcdFx0XHRcdFx0aWYgKCFlbnVtcyB8fCBlbnVtcy5sZW5ndGggIT09IGJudW1zLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vREVCVUc6IF9sb2coXCJtaXNtYXRjaGVkIGZvcm1hdHRpbmcgZGV0ZWN0ZWQgb24gXCIgKyBwICsgXCIgKFwiICsgYiArIFwiIHZzIFwiICsgZSArIFwiKVwiKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bmkgPSAwO1xuXHRcdFx0XHRcdFx0XHRmb3IgKHhpID0gMDsgeGkgPCBibnVtcy5sZW5ndGg7IHhpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRjdiA9IGJudW1zW3hpXTtcblx0XHRcdFx0XHRcdFx0XHR0ZW1wID0gYnYuaW5kZXhPZihjdiwgbmkpO1xuXHRcdFx0XHRcdFx0XHRcdHB0LmFwcGVuZFh0cmEoYnYuc3Vic3RyKG5pLCB0ZW1wIC0gbmkpLCBOdW1iZXIoY3YpLCBfcGFyc2VDaGFuZ2UoZW51bXNbeGldLCBjdiksIFwiXCIsIChhdXRvUm91bmQgJiYgYnYuc3Vic3RyKHRlbXAgKyBjdi5sZW5ndGgsIDIpID09PSBcInB4XCIpID8gTWF0aC5yb3VuZCA6IGZhbHNlLCAoeGkgPT09IDApKTtcblx0XHRcdFx0XHRcdFx0XHRuaSA9IHRlbXAgKyBjdi5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cHRbXCJ4c1wiICsgcHQubF0gKz0gYnYuc3Vic3RyKG5pKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9pZiB0aGVyZSBhcmUgcmVsYXRpdmUgdmFsdWVzIChcIis9XCIgb3IgXCItPVwiIHByZWZpeCksIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSBlbmRpbmcgdmFsdWUgdG8gZWxpbWluYXRlIHRoZSBwcmVmaXhlcyBhbmQgY29tYmluZSB0aGUgdmFsdWVzIHByb3Blcmx5LlxuXHRcdFx0XHRpZiAoZS5pbmRleE9mKFwiPVwiKSAhPT0gLTEpIGlmIChwdC5kYXRhKSB7XG5cdFx0XHRcdFx0c3RyID0gcHQueHMwICsgcHQuZGF0YS5zO1xuXHRcdFx0XHRcdGZvciAoaSA9IDE7IGkgPCBwdC5sOyBpKyspIHtcblx0XHRcdFx0XHRcdHN0ciArPSBwdFtcInhzXCIgKyBpXSArIHB0LmRhdGFbXCJ4blwiICsgaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0LmUgPSBzdHIgKyBwdFtcInhzXCIgKyBpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXB0LmwpIHtcblx0XHRcdFx0XHRwdC50eXBlID0gLTE7XG5cdFx0XHRcdFx0cHQueHMwID0gcHQuZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHQueGZpcnN0IHx8IHB0O1xuXHRcdFx0fSxcblx0XHRcdGkgPSA5O1xuXG5cblx0XHRwID0gQ1NTUHJvcFR3ZWVuLnByb3RvdHlwZTtcblx0XHRwLmwgPSBwLnByID0gMDsgLy9sZW5ndGggKG51bWJlciBvZiBleHRyYSBwcm9wZXJ0aWVzIGxpa2UgeG4xLCB4bjIsIHhuMywgZXRjLlxuXHRcdHdoaWxlICgtLWkgPiAwKSB7XG5cdFx0XHRwW1wieG5cIiArIGldID0gMDtcblx0XHRcdHBbXCJ4c1wiICsgaV0gPSBcIlwiO1xuXHRcdH1cblx0XHRwLnhzMCA9IFwiXCI7XG5cdFx0cC5fbmV4dCA9IHAuX3ByZXYgPSBwLnhmaXJzdCA9IHAuZGF0YSA9IHAucGx1Z2luID0gcC5zZXRSYXRpbyA9IHAucnhwID0gbnVsbDtcblxuXG5cdFx0LyoqXG5cdFx0ICogQXBwZW5kcyBhbmQgZXh0cmEgdHdlZW5pbmcgdmFsdWUgdG8gYSBDU1NQcm9wVHdlZW4gYW5kIGF1dG9tYXRpY2FsbHkgbWFuYWdlcyBhbnkgcHJlZml4IGFuZCBzdWZmaXggc3RyaW5ncy4gVGhlIGZpcnN0IGV4dHJhIHZhbHVlIGlzIHN0b3JlZCBpbiB0aGUgcyBhbmQgYyBvZiB0aGUgbWFpbiBDU1NQcm9wVHdlZW4gaW5zdGFuY2UsIGJ1dCB0aGVyZWFmdGVyIGFueSBleHRyYXMgYXJlIHN0b3JlZCBpbiB0aGUgeG4xLCB4bjIsIHhuMywgZXRjLiBUaGUgcHJlZml4ZXMgYW5kIHN1ZmZpeGVzIGFyZSBzdG9yZWQgaW4gdGhlIHhzMCwgeHMxLCB4czIsIGV0Yy4gcHJvcGVydGllcy4gRm9yIGV4YW1wbGUsIGlmIEkgd2FsayB0aHJvdWdoIGEgY2xpcCB2YWx1ZSBsaWtlIFwicmVjdCgxMHB4LCA1cHgsIDBweCwgMjBweClcIiwgdGhlIHZhbHVlcyB3b3VsZCBiZSBzdG9yZWQgbGlrZSB0aGlzOlxuXHRcdCAqIHhzMDpcInJlY3QoXCIsIHM6MTAsIHhzMTpcInB4LCBcIiwgeG4xOjUsIHhzMjpcInB4LCBcIiwgeG4yOjAsIHhzMzpcInB4LCBcIiwgeG4zOjIwLCB4bjQ6XCJweClcIlxuXHRcdCAqIEFuZCB0aGV5J2QgYWxsIGdldCBqb2luZWQgdG9nZXRoZXIgd2hlbiB0aGUgQ1NTUGx1Z2luIHJlbmRlcnMgKGluIHRoZSBzZXRSYXRpbygpIG1ldGhvZCkuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBwZnggUHJlZml4IChpZiBhbnkpXG5cdFx0ICogQHBhcmFtIHshbnVtYmVyfSBzIFN0YXJ0aW5nIHZhbHVlXG5cdFx0ICogQHBhcmFtIHshbnVtYmVyfSBjIENoYW5nZSBpbiBudW1lcmljIHZhbHVlIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgZW50aXJlIHR3ZWVuLiBGb3IgZXhhbXBsZSwgaWYgdGhlIHN0YXJ0IGlzIDUgYW5kIHRoZSBlbmQgaXMgMTAwLCB0aGUgY2hhbmdlIHdvdWxkIGJlIDk1LlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gc2Z4IFN1ZmZpeCAoaWYgYW55KVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHIgUm91bmQgKGlmIHRydWUpLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHBhZCBJZiB0cnVlLCB0aGlzIGV4dHJhIHZhbHVlIHNob3VsZCBiZSBzZXBhcmF0ZWQgYnkgdGhlIHByZXZpb3VzIG9uZSBieSBhIHNwYWNlLiBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBleHRyYSBhbmQgcGFkIGlzIHRydWUsIGl0IHdpbGwgYXV0b21hdGljYWxseSBkcm9wIHRoZSBzcGFjZS5cblx0XHQgKiBAcmV0dXJuIHtDU1NQcm9wVHdlZW59IHJldHVybnMgaXRzZWxmIHNvIHRoYXQgbXVsdGlwbGUgbWV0aG9kcyBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci5cblx0XHQgKi9cblx0XHRwLmFwcGVuZFh0cmEgPSBmdW5jdGlvbihwZngsIHMsIGMsIHNmeCwgciwgcGFkKSB7XG5cdFx0XHR2YXIgcHQgPSB0aGlzLFxuXHRcdFx0XHRsID0gcHQubDtcblx0XHRcdHB0W1wieHNcIiArIGxdICs9IChwYWQgJiYgKGwgfHwgcHRbXCJ4c1wiICsgbF0pKSA/IFwiIFwiICsgcGZ4IDogcGZ4IHx8IFwiXCI7XG5cdFx0XHRpZiAoIWMpIGlmIChsICE9PSAwICYmICFwdC5wbHVnaW4pIHsgLy90eXBpY2FsbHkgd2UnbGwgY29tYmluZSBub24tY2hhbmdpbmcgdmFsdWVzIHJpZ2h0IGludG8gdGhlIHhzIHRvIG9wdGltaXplIHBlcmZvcm1hbmNlLCBidXQgd2UgZG9uJ3QgY29tYmluZSB0aGVtIHdoZW4gdGhlcmUncyBhIHBsdWdpbiB0aGF0IHdpbGwgYmUgdHdlZW5pbmcgdGhlIHZhbHVlcyBiZWNhdXNlIGl0IG1heSBkZXBlbmQgb24gdGhlIHZhbHVlcyBiZWluZyBzcGxpdCBhcGFydCwgbGlrZSBmb3IgYSBiZXppZXIsIGlmIGEgdmFsdWUgZG9lc24ndCBjaGFuZ2UgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIHNlY29uZCBpdGVyYXRpb24gYnV0IHRoZW4gaXQgZG9lcyBvbiB0aGUgM3JkLCB3ZSdsbCBydW4gaW50byB0cm91YmxlIGJlY2F1c2UgdGhlcmUncyBubyB4biBzbG90IGZvciB0aGF0IHZhbHVlIVxuXHRcdFx0XHRwdFtcInhzXCIgKyBsXSArPSBzICsgKHNmeCB8fCBcIlwiKTtcblx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0fVxuXHRcdFx0cHQubCsrO1xuXHRcdFx0cHQudHlwZSA9IHB0LnNldFJhdGlvID8gMiA6IDE7XG5cdFx0XHRwdFtcInhzXCIgKyBwdC5sXSA9IHNmeCB8fCBcIlwiO1xuXHRcdFx0aWYgKGwgPiAwKSB7XG5cdFx0XHRcdHB0LmRhdGFbXCJ4blwiICsgbF0gPSBzICsgYztcblx0XHRcdFx0cHQucnhwW1wieG5cIiArIGxdID0gcjsgLy9yb3VuZCBleHRyYSBwcm9wZXJ0eSAod2UgbmVlZCB0byB0YXAgaW50byB0aGlzIGluIHRoZSBfcGFyc2VUb1Byb3h5KCkgbWV0aG9kKVxuXHRcdFx0XHRwdFtcInhuXCIgKyBsXSA9IHM7XG5cdFx0XHRcdGlmICghcHQucGx1Z2luKSB7XG5cdFx0XHRcdFx0cHQueGZpcnN0ID0gbmV3IENTU1Byb3BUd2VlbihwdCwgXCJ4blwiICsgbCwgcywgYywgcHQueGZpcnN0IHx8IHB0LCAwLCBwdC5uLCByLCBwdC5wcik7XG5cdFx0XHRcdFx0cHQueGZpcnN0LnhzMCA9IDA7IC8vanVzdCB0byBlbnN1cmUgdGhhdCB0aGUgcHJvcGVydHkgc3RheXMgbnVtZXJpYyB3aGljaCBoZWxwcyBtb2Rlcm4gYnJvd3NlcnMgc3BlZWQgdXAgcHJvY2Vzc2luZy4gUmVtZW1iZXIsIGluIHRoZSBzZXRSYXRpbygpIG1ldGhvZCwgd2UgZG8gcHQudFtwdC5wXSA9IHZhbCArIHB0LnhzMCBzbyBpZiBwdC54czAgaXMgXCJcIiAodGhlIGRlZmF1bHQpLCBpdCdsbCBjYXN0IHRoZSBlbmQgdmFsdWUgYXMgYSBzdHJpbmcuIFdoZW4gYSBwcm9wZXJ0eSBpcyBhIG51bWJlciBzb21ldGltZXMgYW5kIGEgc3RyaW5nIHNvbWV0aW1lcywgaXQgcHJldmVudHMgdGhlIGNvbXBpbGVyIGZyb20gbG9ja2luZyBpbiB0aGUgZGF0YSB0eXBlLCBzbG93aW5nIHRoaW5ncyBkb3duIHNsaWdodGx5LlxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdH1cblx0XHRcdHB0LmRhdGEgPSB7czpzICsgY307XG5cdFx0XHRwdC5yeHAgPSB7fTtcblx0XHRcdHB0LnMgPSBzO1xuXHRcdFx0cHQuYyA9IGM7XG5cdFx0XHRwdC5yID0gcjtcblx0XHRcdHJldHVybiBwdDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQGNvbnN0cnVjdG9yIEEgU3BlY2lhbFByb3AgaXMgYmFzaWNhbGx5IGEgY3NzIHByb3BlcnR5IHRoYXQgbmVlZHMgdG8gYmUgdHJlYXRlZCBpbiBhIG5vbi1zdGFuZGFyZCB3YXksIGxpa2UgaWYgaXQgbWF5IGNvbnRhaW4gYSBjb21wbGV4IHZhbHVlIGxpa2UgYm94U2hhZG93OlwiNXB4IDEwcHggMTVweCByZ2IoMjU1LCAxMDIsIDUxKVwiIG9yIGlmIGl0IGlzIGFzc29jaWF0ZWQgd2l0aCBhbm90aGVyIHBsdWdpbiBsaWtlIFRocm93UHJvcHNQbHVnaW4gb3IgQmV6aWVyUGx1Z2luLiBFdmVyeSBTcGVjaWFsUHJvcCBpcyBhc3NvY2lhdGVkIHdpdGggYSBwYXJ0aWN1bGFyIHByb3BlcnR5IG5hbWUgbGlrZSBcImJveFNoYWRvd1wiIG9yIFwidGhyb3dQcm9wc1wiIG9yIFwiYmV6aWVyXCIgYW5kIGl0IHdpbGwgaW50ZXJjZXB0IHRob3NlIHZhbHVlcyBpbiB0aGUgdmFycyBvYmplY3QgdGhhdCdzIHBhc3NlZCB0byB0aGUgQ1NTUGx1Z2luIGFuZCBoYW5kbGUgdGhlbSBhY2NvcmRpbmdseS5cblx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHAgUHJvcGVydHkgbmFtZSAobGlrZSBcImJveFNoYWRvd1wiIG9yIFwidGhyb3dQcm9wc1wiKVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBhbnkgb2YgdGhlIGZvbGxvd2luZyBjb25maWd1cmF0aW9uIG9wdGlvbnM6XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBkZWZhdWx0VmFsdWU6IHRoZSBkZWZhdWx0IHZhbHVlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBwYXJzZXI6IEEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgbmFtZSBpcyBmb3VuZCBpbiB0aGUgdmFycy4gVGhpcyBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgQ1NTUHJvcFR3ZWVuIGluc3RhbmNlIGFuZCBpdCBzaG91bGQgZW5zdXJlIHRoYXQgaXQgaXMgcHJvcGVybHkgaW5zZXJ0ZWQgaW50byB0aGUgbGlua2VkIGxpc3QuIEl0IHdpbGwgcmVjZWl2ZSA0IHBhcmFtdGVyczogMSkgVGhlIHRhcmdldCwgMikgVGhlIHZhbHVlIGRlZmluZWQgaW4gdGhlIHZhcnMsIDMpIFRoZSBDU1NQbHVnaW4gaW5zdGFuY2UgKHdob3NlIF9maXJzdFBUIHNob3VsZCBiZSB1c2VkIGZvciB0aGUgbGlua2VkIGxpc3QpLCBhbmQgNCkgQSBjb21wdXRlZCBzdHlsZSBvYmplY3QgaWYgb25lIHdhcyBjYWxjdWxhdGVkICh0aGlzIGlzIGEgc3BlZWQgb3B0aW1pemF0aW9uIHRoYXQgYWxsb3dzIHJldHJpZXZhbCBvZiBzdGFydGluZyB2YWx1ZXMgcXVpY2tlcilcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIGZvcm1hdHRlcjogYSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgYW55IHZhbHVlIHJlY2VpdmVkIGZvciB0aGlzIHNwZWNpYWwgcHJvcGVydHkgKGZvciBleGFtcGxlLCBib3hTaGFkb3cgY291bGQgdGFrZSBcIjVweCA1cHggcmVkXCIgYW5kIGZvcm1hdCBpdCB0byBcIjVweCA1cHggMHB4IDBweCByZWRcIiBzbyB0aGF0IGJvdGggdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBoYXZlIGEgY29tbW9uIG9yZGVyIGFuZCBxdWFudGl0eSBvZiB2YWx1ZXMuKVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gcHJlZml4OiBpZiB0cnVlLCB3ZSdsbCBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdGhpcyBwcm9wZXJ0eSByZXF1aXJlcyBhIHZlbmRvciBwcmVmaXggKGxpa2UgV2Via2l0IG9yIE1veiBvciBtcyBvciBPKVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gY29sb3I6IHNldCB0aGlzIHRvIHRydWUgaWYgdGhlIHZhbHVlIGZvciB0aGlzIFNwZWNpYWxQcm9wIG1heSBjb250YWluIGNvbG9yLXJlbGF0ZWQgdmFsdWVzIGxpa2UgcmdiKCksIHJnYmEoKSwgZXRjLlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gcHJpb3JpdHk6IHByaW9yaXR5IGluIHRoZSBsaW5rZWQgbGlzdCBvcmRlci4gSGlnaGVyIHByaW9yaXR5IFNwZWNpYWxQcm9wcyB3aWxsIGJlIHVwZGF0ZWQgYmVmb3JlIGxvd2VyIHByaW9yaXR5IG9uZXMuIFRoZSBkZWZhdWx0IHByaW9yaXR5IGlzIDAuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBtdWx0aTogaWYgdHJ1ZSwgdGhlIGZvcm1hdHRlciBzaG91bGQgYWNjb21tb2RhdGUgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiB2YWx1ZXMsIGxpa2UgYm94U2hhZG93IGNvdWxkIGhhdmUgbXVsdGlwbGUgYm94U2hhZG93cyBsaXN0ZWQgb3V0LlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gY29sbGFwc2libGU6IGlmIHRydWUsIHRoZSBmb3JtYXR0ZXIgc2hvdWxkIHRyZWF0IHRoZSB2YWx1ZSBsaWtlIGl0J3MgYSB0b3AvcmlnaHQvYm90dG9tL2xlZnQgdmFsdWUgdGhhdCBjb3VsZCBiZSBjb2xsYXBzZWQsIGxpa2UgXCI1cHhcIiB3b3VsZCBhcHBseSB0byBhbGwsIFwiNXB4LCAxMHB4XCIgd291bGQgdXNlIDVweCBmb3IgdG9wL2JvdHRvbSBhbmQgMTBweCBmb3IgcmlnaHQvbGVmdCwgZXRjLlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0ga2V5d29yZDogYSBzcGVjaWFsIGtleXdvcmQgdGhhdCBjYW4gW29wdGlvbmFsbHldIGJlIGZvdW5kIGluc2lkZSB0aGUgdmFsdWUgKGxpa2UgXCJpbnNldFwiIGZvciBib3hTaGFkb3cpLiBUaGlzIGFsbG93cyB1cyB0byB2YWxpZGF0ZSBiZWdpbm5pbmcvZW5kaW5nIHZhbHVlcyB0byBtYWtlIHN1cmUgdGhleSBtYXRjaCAoaWYgdGhlIGtleXdvcmQgaXMgZm91bmQgaW4gb25lLCBpdCdsbCBiZSBhZGRlZCB0byB0aGUgb3RoZXIgZm9yIGNvbnNpc3RlbmN5IGJ5IGRlZmF1bHQpLlxuXHRcdCAqL1xuXHRcdHZhciBTcGVjaWFsUHJvcCA9IGZ1bmN0aW9uKHAsIG9wdGlvbnMpIHtcblx0XHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHRcdHRoaXMucCA9IG9wdGlvbnMucHJlZml4ID8gX2NoZWNrUHJvcFByZWZpeChwKSB8fCBwIDogcDtcblx0XHRcdFx0X3NwZWNpYWxQcm9wc1twXSA9IF9zcGVjaWFsUHJvcHNbdGhpcy5wXSA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXR0ZXIgfHwgX2dldEZvcm1hdHRlcihvcHRpb25zLmRlZmF1bHRWYWx1ZSwgb3B0aW9ucy5jb2xvciwgb3B0aW9ucy5jb2xsYXBzaWJsZSwgb3B0aW9ucy5tdWx0aSk7XG5cdFx0XHRcdGlmIChvcHRpb25zLnBhcnNlcikge1xuXHRcdFx0XHRcdHRoaXMucGFyc2UgPSBvcHRpb25zLnBhcnNlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmNscnMgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0XHR0aGlzLm11bHRpID0gb3B0aW9ucy5tdWx0aTtcblx0XHRcdFx0dGhpcy5rZXl3b3JkID0gb3B0aW9ucy5rZXl3b3JkO1xuXHRcdFx0XHR0aGlzLmRmbHQgPSBvcHRpb25zLmRlZmF1bHRWYWx1ZTtcblx0XHRcdFx0dGhpcy5wciA9IG9wdGlvbnMucHJpb3JpdHkgfHwgMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vc2hvcnRjdXQgZm9yIGNyZWF0aW5nIGEgbmV3IFNwZWNpYWxQcm9wIHRoYXQgY2FuIGFjY2VwdCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGFzIGEgY29tbWEtZGVsaW1pdGVkIGxpc3QgKGhlbHBzIG1pbmlmaWNhdGlvbikuIGRmbHQgY2FuIGJlIGFuIGFycmF5IGZvciBtdWx0aXBsZSB2YWx1ZXMgKHdlIGRvbid0IGRvIGEgY29tbWEtZGVsaW1pdGVkIGxpc3QgYmVjYXVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBtYXkgY29udGFpbiBjb21tYXMsIGxpa2UgcmVjdCgwcHgsMHB4LDBweCwwcHgpKS4gV2UgYXR0YWNoIHRoaXMgbWV0aG9kIHRvIHRoZSBTcGVjaWFsUHJvcCBjbGFzcy9vYmplY3QgaW5zdGVhZCBvZiB1c2luZyBhIHByaXZhdGUgX2NyZWF0ZVNwZWNpYWxQcm9wKCkgbWV0aG9kIHNvIHRoYXQgd2UgY2FuIHRhcCBpbnRvIGl0IGV4dGVybmFsbHkgaWYgbmVjZXNzYXJ5LCBsaWtlIGZyb20gYW5vdGhlciBwbHVnaW4uXG5cdFx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AgPSBfaW50ZXJuYWxzLl9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcCA9IGZ1bmN0aW9uKHAsIG9wdGlvbnMsIGRlZmF1bHRzKSB7XG5cdFx0XHRcdGlmICh0eXBlb2Yob3B0aW9ucykgIT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0XHRvcHRpb25zID0ge3BhcnNlcjpkZWZhdWx0c307IC8vdG8gbWFrZSBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIEJlemllclBsdWdpbiBhbmQgVGhyb3dQcm9wc1BsdWdpblxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBhID0gcC5zcGxpdChcIixcIiksXG5cdFx0XHRcdFx0ZCA9IG9wdGlvbnMuZGVmYXVsdFZhbHVlLFxuXHRcdFx0XHRcdGksIHRlbXA7XG5cdFx0XHRcdGRlZmF1bHRzID0gZGVmYXVsdHMgfHwgW2RdO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG9wdGlvbnMucHJlZml4ID0gKGkgPT09IDAgJiYgb3B0aW9ucy5wcmVmaXgpO1xuXHRcdFx0XHRcdG9wdGlvbnMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdHNbaV0gfHwgZDtcblx0XHRcdFx0XHR0ZW1wID0gbmV3IFNwZWNpYWxQcm9wKGFbaV0sIG9wdGlvbnMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvL2NyZWF0ZXMgYSBwbGFjZWhvbGRlciBzcGVjaWFsIHByb3AgZm9yIGEgcGx1Z2luIHNvIHRoYXQgdGhlIHByb3BlcnR5IGdldHMgY2F1Z2h0IHRoZSBmaXJzdCB0aW1lIGEgdHdlZW4gb2YgaXQgaXMgYXR0ZW1wdGVkLCBhbmQgYXQgdGhhdCB0aW1lIGl0IG1ha2VzIHRoZSBwbHVnaW4gcmVnaXN0ZXIgaXRzZWxmLCB0aHVzIHRha2luZyBvdmVyIGZvciBhbGwgZnV0dXJlIHR3ZWVucyBvZiB0aGF0IHByb3BlcnR5LiBUaGlzIGFsbG93cyB1cyB0byBub3QgbWFuZGF0ZSB0aGF0IHRoaW5ncyBsb2FkIGluIGEgcGFydGljdWxhciBvcmRlciBhbmQgaXQgYWxzbyBhbGxvd3MgdXMgdG8gbG9nKCkgYW4gZXJyb3IgdGhhdCBpbmZvcm1zIHRoZSB1c2VyIHdoZW4gdGhleSBhdHRlbXB0IHRvIHR3ZWVuIGFuIGV4dGVybmFsIHBsdWdpbi1yZWxhdGVkIHByb3BlcnR5IHdpdGhvdXQgbG9hZGluZyBpdHMgLmpzIGZpbGUuXG5cdFx0XHRfcmVnaXN0ZXJQbHVnaW5Qcm9wID0gX2ludGVybmFscy5fcmVnaXN0ZXJQbHVnaW5Qcm9wID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRpZiAoIV9zcGVjaWFsUHJvcHNbcF0pIHtcblx0XHRcdFx0XHR2YXIgcGx1Z2luTmFtZSA9IHAuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwLnN1YnN0cigxKSArIFwiUGx1Z2luXCI7XG5cdFx0XHRcdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKHAsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0XHRcdFx0dmFyIHBsdWdpbkNsYXNzID0gX2dsb2JhbHMuY29tLmdyZWVuc29jay5wbHVnaW5zW3BsdWdpbk5hbWVdO1xuXHRcdFx0XHRcdFx0aWYgKCFwbHVnaW5DbGFzcykge1xuXHRcdFx0XHRcdFx0XHRfbG9nKFwiRXJyb3I6IFwiICsgcGx1Z2luTmFtZSArIFwiIGpzIGZpbGUgbm90IGxvYWRlZC5cIik7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBsdWdpbkNsYXNzLl9jc3NSZWdpc3RlcigpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIF9zcGVjaWFsUHJvcHNbcF0ucGFyc2UodCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycyk7XG5cdFx0XHRcdFx0fX0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cblx0XHRwID0gU3BlY2lhbFByb3AucHJvdG90eXBlO1xuXG5cdFx0LyoqXG5cdFx0ICogQWxpYXMgZm9yIF9wYXJzZUNvbXBsZXgoKSB0aGF0IGF1dG9tYXRpY2FsbHkgcGx1Z3MgaW4gY2VydGFpbiB2YWx1ZXMgZm9yIHRoaXMgU3BlY2lhbFByb3AsIGxpa2UgaXRzIHByb3BlcnR5IG5hbWUsIHdoZXRoZXIgb3Igbm90IGNvbG9ycyBzaG91bGQgYmUgc2Vuc2VkLCB0aGUgZGVmYXVsdCB2YWx1ZSwgYW5kIHByaW9yaXR5LiBJdCBhbHNvIGxvb2tzIGZvciBhbnkga2V5d29yZCB0aGF0IHRoZSBTcGVjaWFsUHJvcCBkZWZpbmVzIChsaWtlIFwiaW5zZXRcIiBmb3IgYm94U2hhZG93KSBhbmQgZW5zdXJlcyB0aGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgdmFsdWVzIGZvciBTcGVjaWFsUHJvcHMgd2hlcmUgbXVsdGkgaXMgdHJ1ZSAobGlrZSBib3hTaGFkb3cgYW5kIHRleHRTaGFkb3cgY2FuIGhhdmUgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdClcblx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgdGFyZ2V0IGVsZW1lbnRcblx0XHQgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyfG9iamVjdCl9IGIgYmVnaW5uaW5nIHZhbHVlXG5cdFx0ICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcnxvYmplY3QpfSBlIGVuZGluZyAoZGVzdGluYXRpb24pIHZhbHVlXG5cdFx0ICogQHBhcmFtIHtDU1NQcm9wVHdlZW49fSBwdCBuZXh0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Rcblx0XHQgKiBAcGFyYW0ge1R3ZWVuUGx1Z2luPX0gcGx1Z2luIElmIGFub3RoZXIgcGx1Z2luIHdpbGwgYmUgdHdlZW5pbmcgdGhlIGNvbXBsZXggdmFsdWUsIHRoYXQgVHdlZW5QbHVnaW4gaW5zdGFuY2UgZ29lcyBoZXJlLlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb249fSBzZXRSYXRpbyBJZiBhIGN1c3RvbSBzZXRSYXRpbygpIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byBoYW5kbGUgdGhpcyBjb21wbGV4IHZhbHVlLCB0aGF0IGdvZXMgaGVyZS5cblx0XHQgKiBAcmV0dXJuIHtDU1NQcm9wVHdlZW49fSBGaXJzdCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0XG5cdFx0ICovXG5cdFx0cC5wYXJzZUNvbXBsZXggPSBmdW5jdGlvbih0LCBiLCBlLCBwdCwgcGx1Z2luLCBzZXRSYXRpbykge1xuXHRcdFx0dmFyIGt3ZCA9IHRoaXMua2V5d29yZCxcblx0XHRcdFx0aSwgYmEsIGVhLCBsLCBiaSwgZWk7XG5cdFx0XHQvL2lmIHRoaXMgU3BlY2lhbFByb3AncyB2YWx1ZSBjYW4gY29udGFpbiBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHZhbHVlcyAobGlrZSBib3hTaGFkb3cgb3IgdGV4dFNoYWRvdyksIHdlIG11c3QgcGFyc2UgdGhlbSBpbiBhIHNwZWNpYWwgd2F5LCBhbmQgbG9vayBmb3IgYSBrZXl3b3JkIChsaWtlIFwiaW5zZXRcIiBmb3IgYm94U2hhZG93KSBhbmQgZW5zdXJlIHRoYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIEJPVEggaGF2ZSBpdCBpZiB0aGUgZW5kIGRlZmluZXMgaXQgYXMgc3VjaC4gV2UgYWxzbyBtdXN0IGVuc3VyZSB0aGF0IHRoZXJlIGFyZSBhbiBlcXVhbCBudW1iZXIgb2YgdmFsdWVzIHNwZWNpZmllZCAod2UgY2FuJ3QgdHdlZW4gMSBib3hTaGFkb3cgdG8gMyBmb3IgZXhhbXBsZSlcblx0XHRcdGlmICh0aGlzLm11bHRpKSBpZiAoX2NvbW1hc091dHNpZGVQYXJlbkV4cC50ZXN0KGUpIHx8IF9jb21tYXNPdXRzaWRlUGFyZW5FeHAudGVzdChiKSkge1xuXHRcdFx0XHRiYSA9IGIucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcInxcIikuc3BsaXQoXCJ8XCIpO1xuXHRcdFx0XHRlYSA9IGUucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcInxcIikuc3BsaXQoXCJ8XCIpO1xuXHRcdFx0fSBlbHNlIGlmIChrd2QpIHtcblx0XHRcdFx0YmEgPSBbYl07XG5cdFx0XHRcdGVhID0gW2VdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVhKSB7XG5cdFx0XHRcdGwgPSAoZWEubGVuZ3RoID4gYmEubGVuZ3RoKSA/IGVhLmxlbmd0aCA6IGJhLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGIgPSBiYVtpXSA9IGJhW2ldIHx8IHRoaXMuZGZsdDtcblx0XHRcdFx0XHRlID0gZWFbaV0gPSBlYVtpXSB8fCB0aGlzLmRmbHQ7XG5cdFx0XHRcdFx0aWYgKGt3ZCkge1xuXHRcdFx0XHRcdFx0YmkgPSBiLmluZGV4T2Yoa3dkKTtcblx0XHRcdFx0XHRcdGVpID0gZS5pbmRleE9mKGt3ZCk7XG5cdFx0XHRcdFx0XHRpZiAoYmkgIT09IGVpKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChlaSA9PT0gLTEpIHsgLy9pZiB0aGUga2V5d29yZCBpc24ndCBpbiB0aGUgZW5kIHZhbHVlLCByZW1vdmUgaXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9uZS5cblx0XHRcdFx0XHRcdFx0XHRiYVtpXSA9IGJhW2ldLnNwbGl0KGt3ZCkuam9pbihcIlwiKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChiaSA9PT0gLTEpIHsgLy9pZiB0aGUga2V5d29yZCBpc24ndCBpbiB0aGUgYmVnaW5uaW5nLCBhZGQgaXQuXG5cdFx0XHRcdFx0XHRcdFx0YmFbaV0gKz0gXCIgXCIgKyBrd2Q7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YiA9IGJhLmpvaW4oXCIsIFwiKTtcblx0XHRcdFx0ZSA9IGVhLmpvaW4oXCIsIFwiKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBfcGFyc2VDb21wbGV4KHQsIHRoaXMucCwgYiwgZSwgdGhpcy5jbHJzLCB0aGlzLmRmbHQsIHB0LCB0aGlzLnByLCBwbHVnaW4sIHNldFJhdGlvKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQWNjZXB0cyBhIHRhcmdldCBhbmQgZW5kIHZhbHVlIGFuZCBzcGl0cyBiYWNrIGEgQ1NTUHJvcFR3ZWVuIHRoYXQgaGFzIGJlZW4gaW5zZXJ0ZWQgaW50byB0aGUgQ1NTUGx1Z2luJ3MgbGlua2VkIGxpc3QgYW5kIGNvbmZvcm1zIHdpdGggYWxsIHRoZSBjb252ZW50aW9ucyB3ZSB1c2UgaW50ZXJuYWxseSwgbGlrZSB0eXBlOi0xLCAwLCAxLCBvciAyLCBzZXR0aW5nIHVwIGFueSBleHRyYSBwcm9wZXJ0eSB0d2VlbnMsIHByaW9yaXR5LCBldGMuIEZvciBleGFtcGxlLCBpZiB3ZSBoYXZlIGEgYm94U2hhZG93IFNwZWNpYWxQcm9wIGFuZCBjYWxsOlxuXHRcdCAqIHRoaXMuX2ZpcnN0UFQgPSBzcC5wYXJzZShlbGVtZW50LCBcIjVweCAxMHB4IDIwcHggcmdiKDI1NTAsMTAyLDUxKVwiLCBcImJveFNoYWRvd1wiLCB0aGlzKTtcblx0XHQgKiBJdCBzaG91bGQgZmlndXJlIG91dCB0aGUgc3RhcnRpbmcgdmFsdWUgb2YgdGhlIGVsZW1lbnQncyBib3hTaGFkb3csIGNvbXBhcmUgaXQgdG8gdGhlIHByb3ZpZGVkIGVuZCB2YWx1ZSBhbmQgY3JlYXRlIGFsbCB0aGUgbmVjZXNzYXJ5IENTU1Byb3BUd2VlbnMgb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGVzIHRvIHR3ZWVuIHRoZSBib3hTaGFkb3cuIFRoZSBDU1NQcm9wVHdlZW4gdGhhdCBnZXRzIHNwaXQgYmFjayBzaG91bGQgYWxyZWFkeSBiZSBpbnNlcnRlZCBpbnRvIHRoZSBsaW5rZWQgbGlzdCAodGhlIDR0aCBwYXJhbWV0ZXIgaXMgdGhlIGN1cnJlbnQgaGVhZCwgc28gcHJlcGVuZCB0byB0aGF0KS5cblx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IG9iamVjdCB3aG9zZSBwcm9wZXJ0eSBpcyBiZWluZyB0d2VlbmVkXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGUgRW5kIHZhbHVlIGFzIHByb3ZpZGVkIGluIHRoZSB2YXJzIG9iamVjdCAodHlwaWNhbGx5IGEgc3RyaW5nLCBidXQgbm90IGFsd2F5cyAtIGxpa2UgYSB0aHJvd1Byb3BzIHdvdWxkIGJlIGFuIG9iamVjdCkuXG5cdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWVcblx0XHQgKiBAcGFyYW0geyFDU1NQbHVnaW59IGNzc3AgVGhlIENTU1BsdWdpbiBpbnN0YW5jZSB0aGF0IHNob3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0d2Vlbi5cblx0XHQgKiBAcGFyYW0gez9DU1NQcm9wVHdlZW59IHB0IFRoZSBDU1NQcm9wVHdlZW4gdGhhdCBpcyB0aGUgY3VycmVudCBoZWFkIG9mIHRoZSBsaW5rZWQgbGlzdCAod2UnbGwgcHJlcGVuZCB0byBpdClcblx0XHQgKiBAcGFyYW0ge1R3ZWVuUGx1Z2luPX0gcGx1Z2luIElmIGEgcGx1Z2luIHdpbGwgYmUgdXNlZCB0byB0d2VlbiB0aGUgcGFyc2VkIHZhbHVlLCB0aGlzIGlzIHRoZSBwbHVnaW4gaW5zdGFuY2UuXG5cdFx0ICogQHBhcmFtIHtPYmplY3Q9fSB2YXJzIE9yaWdpbmFsIHZhcnMgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGRhdGEgZm9yIHBhcnNpbmcuXG5cdFx0ICogQHJldHVybiB7Q1NTUHJvcFR3ZWVufSBUaGUgZmlyc3QgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdCB3aGljaCBpbmNsdWRlcyB0aGUgbmV3IG9uZShzKSBhZGRlZCBieSB0aGUgcGFyc2UoKSBjYWxsLlxuXHRcdCAqL1xuXHRcdHAucGFyc2UgPSBmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luLCB2YXJzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZUNvbXBsZXgodC5zdHlsZSwgdGhpcy5mb3JtYXQoX2dldFN0eWxlKHQsIHRoaXMucCwgX2NzLCBmYWxzZSwgdGhpcy5kZmx0KSksIHRoaXMuZm9ybWF0KGUpLCBwdCwgcGx1Z2luKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXJzIGEgc3BlY2lhbCBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSBpbnRlcmNlcHRlZCBmcm9tIGFueSBcImNzc1wiIG9iamVjdHMgZGVmaW5lZCBpbiB0d2VlbnMuIFRoaXMgYWxsb3dzIHlvdSB0byBoYW5kbGUgdGhlbSBob3dldmVyIHlvdSB3YW50IHdpdGhvdXQgQ1NTUGx1Z2luIGRvaW5nIGl0IGZvciB5b3UuIFRoZSAybmQgcGFyYW1ldGVyIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyAzIHBhcmFtZXRlcnM6XG5cdFx0ICogIDEpIFRhcmdldCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgc2hvdWxkIGJlIHR3ZWVuZWQgKHR5cGljYWxseSBhIERPTSBlbGVtZW50KVxuXHRcdCAqICAyKSBUaGUgZW5kL2Rlc3RpbmF0aW9uIHZhbHVlIChjb3VsZCBiZSBhIHN0cmluZywgbnVtYmVyLCBvYmplY3QsIG9yIHdoYXRldmVyIHlvdSB3YW50KVxuXHRcdCAqICAzKSBUaGUgdHdlZW4gaW5zdGFuY2UgKHlvdSBwcm9iYWJseSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoaXMsIGJ1dCBpdCBjYW4gYmUgdXNlZnVsIGZvciBsb29raW5nIHVwIGluZm9ybWF0aW9uIGxpa2UgdGhlIGR1cmF0aW9uKVxuXHRcdCAqXG5cdFx0ICogVGhlbiwgeW91ciBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgZWFjaCB0aW1lIHRoZSB0d2VlbiBnZXRzIHJlbmRlcmVkLCBwYXNzaW5nIGEgbnVtZXJpYyBcInJhdGlvXCIgcGFyYW1ldGVyIHRvIHlvdXIgZnVuY3Rpb24gdGhhdCBpbmRpY2F0ZXMgdGhlIGNoYW5nZSBmYWN0b3IgKHVzdWFsbHkgYmV0d2VlbiAwIGFuZCAxKS4gRm9yIGV4YW1wbGU6XG5cdFx0ICpcblx0XHQgKiBDU1NQbHVnaW4ucmVnaXN0ZXJTcGVjaWFsUHJvcChcIm15Q3VzdG9tUHJvcFwiLCBmdW5jdGlvbih0YXJnZXQsIHZhbHVlLCB0d2Vlbikge1xuXHRcdCAqICAgICAgdmFyIHN0YXJ0ID0gdGFyZ2V0LnN0eWxlLndpZHRoO1xuXHRcdCAqICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJhdGlvKSB7XG5cdFx0ICogICAgICAgICAgICAgIHRhcmdldC5zdHlsZS53aWR0aCA9IChzdGFydCArIHZhbHVlICogcmF0aW8pICsgXCJweFwiO1xuXHRcdCAqICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInNldCB3aWR0aCB0byBcIiArIHRhcmdldC5zdHlsZS53aWR0aCk7XG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqIH0sIDApO1xuXHRcdCAqXG5cdFx0ICogVGhlbiwgd2hlbiBJIGRvIHRoaXMgdHdlZW4sIGl0IHdpbGwgdHJpZ2dlciBteSBzcGVjaWFsIHByb3BlcnR5OlxuXHRcdCAqXG5cdFx0ICogVHdlZW5MaXRlLnRvKGVsZW1lbnQsIDEsIHtjc3M6e215Q3VzdG9tUHJvcDoxMDB9fSk7XG5cdFx0ICpcblx0XHQgKiBJbiB0aGUgZXhhbXBsZSwgb2YgY291cnNlLCB3ZSdyZSBqdXN0IGNoYW5naW5nIHRoZSB3aWR0aCwgYnV0IHlvdSBjYW4gZG8gYW55dGhpbmcgeW91IHdhbnQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IG5hbWUgUHJvcGVydHkgbmFtZSAob3IgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMpIHRoYXQgc2hvdWxkIGJlIGludGVyY2VwdGVkIGFuZCBoYW5kbGVkIGJ5IHlvdXIgZnVuY3Rpb24uIEZvciBleGFtcGxlLCBpZiBJIGRlZmluZSBcIm15Q3VzdG9tUHJvcFwiLCB0aGVuIGl0IHdvdWxkIGhhbmRsZSB0aGF0IHBvcnRpb24gb2YgdGhlIGZvbGxvd2luZyB0d2VlbjogVHdlZW5MaXRlLnRvKGVsZW1lbnQsIDEsIHtjc3M6e215Q3VzdG9tUHJvcDoxMDB9fSlcblx0XHQgKiBAcGFyYW0geyFmdW5jdGlvbihPYmplY3QsIE9iamVjdCwgT2JqZWN0LCBzdHJpbmcpOmZ1bmN0aW9uKG51bWJlcil9IG9uSW5pdFR3ZWVuIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYSB0d2VlbiBvZiB0aGlzIHNwZWNpYWwgcHJvcGVydHkgaXMgcGVyZm9ybWVkLiBUaGUgZnVuY3Rpb24gd2lsbCByZWNlaXZlIDQgcGFyYW1ldGVyczogMSkgVGFyZ2V0IG9iamVjdCB0aGF0IHNob3VsZCBiZSB0d2VlbmVkLCAyKSBWYWx1ZSB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIHR3ZWVuLCAzKSBUaGUgdHdlZW4gaW5zdGFuY2UgaXRzZWxmIChyYXJlbHkgdXNlZCksIGFuZCA0KSBUaGUgcHJvcGVydHkgbmFtZSB0aGF0J3MgYmVpbmcgdHdlZW5lZC4gWW91ciBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIG9uIGV2ZXJ5IHVwZGF0ZSBvZiB0aGUgdHdlZW4uIFRoYXQgZnVuY3Rpb24gd2lsbCByZWNlaXZlIGEgc2luZ2xlIHBhcmFtZXRlciB0aGF0IGlzIGEgXCJjaGFuZ2UgZmFjdG9yXCIgdmFsdWUgKHR5cGljYWxseSBiZXR3ZWVuIDAgYW5kIDEpIGluZGljYXRpbmcgdGhlIGFtb3VudCBvZiBjaGFuZ2UgYXMgYSByYXRpby4gWW91IGNhbiB1c2UgdGhpcyB0byBkZXRlcm1pbmUgaG93IHRvIHNldCB0aGUgdmFsdWVzIGFwcHJvcHJpYXRlbHkgaW4geW91ciBmdW5jdGlvbi5cblx0XHQgKiBAcGFyYW0ge251bWJlcj19IHByaW9yaXR5IFByaW9yaXR5IHRoYXQgaGVscHMgdGhlIGVuZ2luZSBkZXRlcm1pbmUgdGhlIG9yZGVyIGluIHdoaWNoIHRvIHNldCB0aGUgcHJvcGVydGllcyAoZGVmYXVsdDogMCkuIEhpZ2hlciBwcmlvcml0eSBwcm9wZXJ0aWVzIHdpbGwgYmUgdXBkYXRlZCBiZWZvcmUgbG93ZXIgcHJpb3JpdHkgb25lcy5cblx0XHQgKi9cblx0XHRDU1NQbHVnaW4ucmVnaXN0ZXJTcGVjaWFsUHJvcCA9IGZ1bmN0aW9uKG5hbWUsIG9uSW5pdFR3ZWVuLCBwcmlvcml0eSkge1xuXHRcdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKG5hbWUsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0XHR2YXIgcnYgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIHAsIDAsIDAsIHB0LCAyLCBwLCBmYWxzZSwgcHJpb3JpdHkpO1xuXHRcdFx0XHRydi5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdHJ2LnNldFJhdGlvID0gb25Jbml0VHdlZW4odCwgZSwgY3NzcC5fdHdlZW4sIHApO1xuXHRcdFx0XHRyZXR1cm4gcnY7XG5cdFx0XHR9LCBwcmlvcml0eTpwcmlvcml0eX0pO1xuXHRcdH07XG5cblxuXG5cblxuXG5cdFx0Ly90cmFuc2Zvcm0tcmVsYXRlZCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzXG5cdFx0Q1NTUGx1Z2luLnVzZVNWR1RyYW5zZm9ybUF0dHIgPSB0cnVlOyAvL1NhZmFyaSBhbmQgRmlyZWZveCBib3RoIGhhdmUgc29tZSByZW5kZXJpbmcgYnVncyB3aGVuIGFwcGx5aW5nIENTUyB0cmFuc2Zvcm1zIHRvIFNWRyBlbGVtZW50cywgc28gZGVmYXVsdCB0byB1c2luZyB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUgaW5zdGVhZCAodXNlcnMgY2FuIG92ZXJyaWRlIHRoaXMpLlxuXHRcdHZhciBfdHJhbnNmb3JtUHJvcHMgPSAoXCJzY2FsZVgsc2NhbGVZLHNjYWxlWix4LHkseixza2V3WCxza2V3WSxyb3RhdGlvbixyb3RhdGlvblgscm90YXRpb25ZLHBlcnNwZWN0aXZlLHhQZXJjZW50LHlQZXJjZW50XCIpLnNwbGl0KFwiLFwiKSxcblx0XHRcdF90cmFuc2Zvcm1Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChcInRyYW5zZm9ybVwiKSwgLy90aGUgSmF2YXNjcmlwdCAoY2FtZWxDYXNlKSB0cmFuc2Zvcm0gcHJvcGVydHksIGxpa2UgbXNUcmFuc2Zvcm0sIFdlYmtpdFRyYW5zZm9ybSwgTW96VHJhbnNmb3JtLCBvciBPVHJhbnNmb3JtLlxuXHRcdFx0X3RyYW5zZm9ybVByb3BDU1MgPSBfcHJlZml4Q1NTICsgXCJ0cmFuc2Zvcm1cIixcblx0XHRcdF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChcInRyYW5zZm9ybU9yaWdpblwiKSxcblx0XHRcdF9zdXBwb3J0czNEID0gKF9jaGVja1Byb3BQcmVmaXgoXCJwZXJzcGVjdGl2ZVwiKSAhPT0gbnVsbCksXG5cdFx0XHRUcmFuc2Zvcm0gPSBfaW50ZXJuYWxzLlRyYW5zZm9ybSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnBlcnNwZWN0aXZlID0gcGFyc2VGbG9hdChDU1NQbHVnaW4uZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlKSB8fCAwO1xuXHRcdFx0XHR0aGlzLmZvcmNlM0QgPSAoQ1NTUGx1Z2luLmRlZmF1bHRGb3JjZTNEID09PSBmYWxzZSB8fCAhX3N1cHBvcnRzM0QpID8gZmFsc2UgOiBDU1NQbHVnaW4uZGVmYXVsdEZvcmNlM0QgfHwgXCJhdXRvXCI7XG5cdFx0XHR9LFxuXHRcdFx0X1NWR0VsZW1lbnQgPSBfZ3NTY29wZS5TVkdFbGVtZW50LFxuXHRcdFx0X3VzZVNWR1RyYW5zZm9ybUF0dHIsXG5cdFx0XHQvL1NvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCBhbmQgSUUpIGRvbid0IGhvbm9yIHRyYW5zZm9ybS1vcmlnaW4gcHJvcGVybHkgaW4gU1ZHIGVsZW1lbnRzLCBzbyB3ZSBuZWVkIHRvIG1hbnVhbGx5IGFkanVzdCB0aGUgbWF0cml4IGFjY29yZGluZ2x5LiBXZSBmZWF0dXJlIGRldGVjdCBoZXJlIHJhdGhlciB0aGFuIGFsd2F5cyBkb2luZyB0aGUgY29udmVyc2lvbiBmb3IgY2VydGFpbiBicm93c2VycyBiZWNhdXNlIHRoZXkgbWF5IGZpeCB0aGUgcHJvYmxlbSBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUuXG5cblx0XHRcdF9jcmVhdGVTVkcgPSBmdW5jdGlvbih0eXBlLCBjb250YWluZXIsIGF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0dmFyIGVsZW1lbnQgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHR5cGUpLFxuXHRcdFx0XHRcdHJlZyA9IC8oW2Etel0pKFtBLVpdKS9nLFxuXHRcdFx0XHRcdHA7XG5cdFx0XHRcdGZvciAocCBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBwLnJlcGxhY2UocmVnLCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCksIGF0dHJpYnV0ZXNbcF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcblx0XHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0XHR9LFxuXHRcdFx0X2RvY0VsZW1lbnQgPSBfZG9jLmRvY3VtZW50RWxlbWVudCB8fCB7fSxcblx0XHRcdF9mb3JjZVNWR1RyYW5zZm9ybUF0dHIgPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vSUUgYW5kIEFuZHJvaWQgc3RvY2sgZG9uJ3Qgc3VwcG9ydCBDU1MgdHJhbnNmb3JtcyBvbiBTVkcgZWxlbWVudHMsIHNvIHdlIG11c3Qgd3JpdGUgdGhlbSB0byB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUuIFdlIHBvcHVsYXRlIHRoaXMgdmFyaWFibGUgaW4gdGhlIF9wYXJzZVRyYW5zZm9ybSgpIG1ldGhvZCwgYW5kIG9ubHkgaWYvd2hlbiB3ZSBjb21lIGFjcm9zcyBhbiBTVkcgZWxlbWVudFxuXHRcdFx0XHR2YXIgZm9yY2UgPSBfaWVWZXJzIHx8ICgvQW5kcm9pZC9pLnRlc3QoX2FnZW50KSAmJiAhX2dzU2NvcGUuY2hyb21lKSxcblx0XHRcdFx0XHRzdmcsIHJlY3QsIHdpZHRoO1xuXHRcdFx0XHRpZiAoX2RvYy5jcmVhdGVFbGVtZW50TlMgJiYgIWZvcmNlKSB7IC8vSUU4IGFuZCBlYXJsaWVyIGRvZXNuJ3Qgc3VwcG9ydCBTVkcgYW55d2F5XG5cdFx0XHRcdFx0c3ZnID0gX2NyZWF0ZVNWRyhcInN2Z1wiLCBfZG9jRWxlbWVudCk7XG5cdFx0XHRcdFx0cmVjdCA9IF9jcmVhdGVTVkcoXCJyZWN0XCIsIHN2Zywge3dpZHRoOjEwMCwgaGVpZ2h0OjUwLCB4OjEwMH0pO1xuXHRcdFx0XHRcdHdpZHRoID0gcmVjdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblx0XHRcdFx0XHRyZWN0LnN0eWxlW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSA9IFwiNTAlIDUwJVwiO1xuXHRcdFx0XHRcdHJlY3Quc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gXCJzY2FsZVgoMC41KVwiO1xuXHRcdFx0XHRcdGZvcmNlID0gKHdpZHRoID09PSByZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICYmICEoX2lzRmlyZWZveCAmJiBfc3VwcG9ydHMzRCkpOyAvL25vdGU6IEZpcmVmb3ggZmFpbHMgdGhlIHRlc3QgZXZlbiB0aG91Z2ggaXQgZG9lcyBzdXBwb3J0IENTUyB0cmFuc2Zvcm1zIGluIDNELiBTaW5jZSB3ZSBjYW4ndCBwdXNoIDNEIHN0dWZmIGludG8gdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUsIHdlIGZvcmNlIEZpcmVmb3ggdG8gcGFzcyB0aGUgdGVzdCBoZXJlIChhcyBsb25nIGFzIGl0IGRvZXMgdHJ1bHkgc3VwcG9ydCAzRCkuXG5cdFx0XHRcdFx0X2RvY0VsZW1lbnQucmVtb3ZlQ2hpbGQoc3ZnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZm9yY2U7XG5cdFx0XHR9KSgpLFxuXHRcdFx0X3BhcnNlU1ZHT3JpZ2luID0gZnVuY3Rpb24oZSwgbG9jYWwsIGRlY29yYXRlZSwgYWJzb2x1dGUsIHNtb290aE9yaWdpbiwgc2tpcFJlY29yZCkge1xuXHRcdFx0XHR2YXIgdG0gPSBlLl9nc1RyYW5zZm9ybSxcblx0XHRcdFx0XHRtID0gX2dldE1hdHJpeChlLCB0cnVlKSxcblx0XHRcdFx0XHR2LCB4LCB5LCB4T3JpZ2luLCB5T3JpZ2luLCBhLCBiLCBjLCBkLCB0eCwgdHksIGRldGVybWluYW50LCB4T3JpZ2luT2xkLCB5T3JpZ2luT2xkO1xuXHRcdFx0XHRpZiAodG0pIHtcblx0XHRcdFx0XHR4T3JpZ2luT2xkID0gdG0ueE9yaWdpbjsgLy9yZWNvcmQgdGhlIG9yaWdpbmFsIHZhbHVlcyBiZWZvcmUgd2UgYWx0ZXIgdGhlbS5cblx0XHRcdFx0XHR5T3JpZ2luT2xkID0gdG0ueU9yaWdpbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWFic29sdXRlIHx8ICh2ID0gYWJzb2x1dGUuc3BsaXQoXCIgXCIpKS5sZW5ndGggPCAyKSB7XG5cdFx0XHRcdFx0YiA9IGUuZ2V0QkJveCgpO1xuXHRcdFx0XHRcdGlmIChiLnggPT09IDAgJiYgYi55ID09PSAwICYmIGIud2lkdGggKyBiLmhlaWdodCA9PT0gMCkgeyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgbWlzcmVwb3J0IHRoZSBib3VuZHMgaWYgdGhlIGVsZW1lbnQgaGFzIHplcm8gd2lkdGggYW5kIGhlaWdodCAoaXQganVzdCBhc3N1bWVzIGl0J3MgYXQgeDowLCB5OjApLCB0aHVzIHdlIG5lZWQgdG8gbWFudWFsbHkgZ3JhYiB0aGUgcG9zaXRpb24gaW4gdGhhdCBjYXNlLlxuXHRcdFx0XHRcdFx0YiA9IHt4OiBwYXJzZUZsb2F0KGUuaGFzQXR0cmlidXRlKFwieFwiKSA/IGUuZ2V0QXR0cmlidXRlKFwieFwiKSA6IGUuaGFzQXR0cmlidXRlKFwiY3hcIikgPyBlLmdldEF0dHJpYnV0ZShcImN4XCIpIDogMCkgfHwgMCwgeTogcGFyc2VGbG9hdChlLmhhc0F0dHJpYnV0ZShcInlcIikgPyBlLmdldEF0dHJpYnV0ZShcInlcIikgOiBlLmhhc0F0dHJpYnV0ZShcImN5XCIpID8gZS5nZXRBdHRyaWJ1dGUoXCJjeVwiKSA6IDApIHx8IDAsIHdpZHRoOjAsIGhlaWdodDowfTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bG9jYWwgPSBfcGFyc2VQb3NpdGlvbihsb2NhbCkuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdHYgPSBbKGxvY2FsWzBdLmluZGV4T2YoXCIlXCIpICE9PSAtMSA/IHBhcnNlRmxvYXQobG9jYWxbMF0pIC8gMTAwICogYi53aWR0aCA6IHBhcnNlRmxvYXQobG9jYWxbMF0pKSArIGIueCxcblx0XHRcdFx0XHRcdCAobG9jYWxbMV0uaW5kZXhPZihcIiVcIikgIT09IC0xID8gcGFyc2VGbG9hdChsb2NhbFsxXSkgLyAxMDAgKiBiLmhlaWdodCA6IHBhcnNlRmxvYXQobG9jYWxbMV0pKSArIGIueV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVjb3JhdGVlLnhPcmlnaW4gPSB4T3JpZ2luID0gcGFyc2VGbG9hdCh2WzBdKTtcblx0XHRcdFx0ZGVjb3JhdGVlLnlPcmlnaW4gPSB5T3JpZ2luID0gcGFyc2VGbG9hdCh2WzFdKTtcblx0XHRcdFx0aWYgKGFic29sdXRlICYmIG0gIT09IF9pZGVudGl0eTJETWF0cml4KSB7IC8vaWYgc3ZnT3JpZ2luIGlzIGJlaW5nIHNldCwgd2UgbXVzdCBpbnZlcnQgdGhlIG1hdHJpeCBhbmQgZGV0ZXJtaW5lIHdoZXJlIHRoZSBhYnNvbHV0ZSBwb2ludCBpcywgZmFjdG9yaW5nIGluIHRoZSBjdXJyZW50IHRyYW5zZm9ybXMuIE90aGVyd2lzZSwgdGhlIHN2Z09yaWdpbiB3b3VsZCBiZSBiYXNlZCBvbiB0aGUgZWxlbWVudCdzIG5vbi10cmFuc2Zvcm1lZCBwb3NpdGlvbiBvbiB0aGUgY2FudmFzLlxuXHRcdFx0XHRcdGEgPSBtWzBdO1xuXHRcdFx0XHRcdGIgPSBtWzFdO1xuXHRcdFx0XHRcdGMgPSBtWzJdO1xuXHRcdFx0XHRcdGQgPSBtWzNdO1xuXHRcdFx0XHRcdHR4ID0gbVs0XTtcblx0XHRcdFx0XHR0eSA9IG1bNV07XG5cdFx0XHRcdFx0ZGV0ZXJtaW5hbnQgPSAoYSAqIGQgLSBiICogYyk7XG5cdFx0XHRcdFx0aWYgKGRldGVybWluYW50KSB7IC8vaWYgaXQncyB6ZXJvIChsaWtlIGlmIHNjYWxlWCBhbmQgc2NhbGVZIGFyZSB6ZXJvKSwgc2tpcCBpdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBkaXZpZGluZyBieSB6ZXJvLlxuXHRcdFx0XHRcdFx0eCA9IHhPcmlnaW4gKiAoZCAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoLWMgLyBkZXRlcm1pbmFudCkgKyAoKGMgKiB0eSAtIGQgKiB0eCkgLyBkZXRlcm1pbmFudCk7XG5cdFx0XHRcdFx0XHR5ID0geE9yaWdpbiAqICgtYiAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoYSAvIGRldGVybWluYW50KSAtICgoYSAqIHR5IC0gYiAqIHR4KSAvIGRldGVybWluYW50KTtcblx0XHRcdFx0XHRcdHhPcmlnaW4gPSBkZWNvcmF0ZWUueE9yaWdpbiA9IHZbMF0gPSB4O1xuXHRcdFx0XHRcdFx0eU9yaWdpbiA9IGRlY29yYXRlZS55T3JpZ2luID0gdlsxXSA9IHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0bSkgeyAvL2F2b2lkIGp1bXAgd2hlbiB0cmFuc2Zvcm1PcmlnaW4gaXMgY2hhbmdlZCAtIGFkanVzdCB0aGUgeC95IHZhbHVlcyBhY2NvcmRpbmdseVxuXHRcdFx0XHRcdGlmIChza2lwUmVjb3JkKSB7XG5cdFx0XHRcdFx0XHRkZWNvcmF0ZWUueE9mZnNldCA9IHRtLnhPZmZzZXQ7XG5cdFx0XHRcdFx0XHRkZWNvcmF0ZWUueU9mZnNldCA9IHRtLnlPZmZzZXQ7XG5cdFx0XHRcdFx0XHR0bSA9IGRlY29yYXRlZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHNtb290aE9yaWdpbiB8fCAoc21vb3RoT3JpZ2luICE9PSBmYWxzZSAmJiBDU1NQbHVnaW4uZGVmYXVsdFNtb290aE9yaWdpbiAhPT0gZmFsc2UpKSB7XG5cdFx0XHRcdFx0XHR4ID0geE9yaWdpbiAtIHhPcmlnaW5PbGQ7XG5cdFx0XHRcdFx0XHR5ID0geU9yaWdpbiAtIHlPcmlnaW5PbGQ7XG5cdFx0XHRcdFx0XHQvL29yaWdpbmFsbHksIHdlIHNpbXBseSBhZGp1c3RlZCB0aGUgeCBhbmQgeSB2YWx1ZXMsIGJ1dCB0aGF0IHdvdWxkIGNhdXNlIHByb2JsZW1zIGlmLCBmb3IgZXhhbXBsZSwgeW91IGNyZWF0ZWQgYSByb3RhdGlvbmFsIHR3ZWVuIHBhcnQtd2F5IHRocm91Z2ggYW4geC95IHR3ZWVuLiBNYW5hZ2luZyB0aGUgb2Zmc2V0IGluIGEgc2VwYXJhdGUgdmFyaWFibGUgZ2l2ZXMgdXMgdWx0aW1hdGUgZmxleGliaWxpdHkuXG5cdFx0XHRcdFx0XHQvL3RtLnggLT0geCAtICh4ICogbVswXSArIHkgKiBtWzJdKTtcblx0XHRcdFx0XHRcdC8vdG0ueSAtPSB5IC0gKHggKiBtWzFdICsgeSAqIG1bM10pO1xuXHRcdFx0XHRcdFx0dG0ueE9mZnNldCArPSAoeCAqIG1bMF0gKyB5ICogbVsyXSkgLSB4O1xuXHRcdFx0XHRcdFx0dG0ueU9mZnNldCArPSAoeCAqIG1bMV0gKyB5ICogbVszXSkgLSB5O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0bS54T2Zmc2V0ID0gdG0ueU9mZnNldCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc2tpcFJlY29yZCkge1xuXHRcdFx0XHRcdGUuc2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIsIHYuam9pbihcIiBcIikpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X2dldEJCb3hIYWNrID0gZnVuY3Rpb24oc3dhcElmUG9zc2libGUpIHsgLy93b3JrcyBhcm91bmQgaXNzdWVzIGluIHNvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgdGhhdCBkb24ndCBjb3JyZWN0bHkgcmVwb3J0IGdldEJCb3goKSBvbiBTVkcgZWxlbWVudHMgaW5zaWRlIGEgPGRlZnM+IGVsZW1lbnQgYW5kL29yIDxtYXNrPi4gV2UgdHJ5IGNyZWF0aW5nIGFuIFNWRywgYWRkaW5nIGl0IHRvIHRoZSBkb2N1bWVudEVsZW1lbnQgYW5kIHRvc3MgdGhlIGVsZW1lbnQgaW4gdGhlcmUgc28gdGhhdCBpdCdzIGRlZmluaXRlbHkgcGFydCBvZiB0aGUgcmVuZGVyaW5nIHRyZWUsIHRoZW4gZ3JhYiB0aGUgYmJveCBhbmQgaWYgaXQgd29ya3MsIHdlIGFjdHVhbGx5IHN3YXAgb3V0IHRoZSBvcmlnaW5hbCBnZXRCQm94KCkgbWV0aG9kIGZvciBvdXIgb3duIHRoYXQgZG9lcyB0aGVzZSBleHRyYSBzdGVwcyB3aGVuZXZlciBnZXRCQm94IGlzIG5lZWRlZC4gVGhpcyBoZWxwcyBlbnN1cmUgdGhhdCBwZXJmb3JtYW5jZSBpcyBvcHRpbWFsIChvbmx5IGRvIGFsbCB0aGVzZSBleHRyYSBzdGVwcyB3aGVuIGFic29sdXRlbHkgbmVjZXNzYXJ5Li4ubW9zdCBlbGVtZW50cyBkb24ndCBuZWVkIGl0KS5cblx0XHRcdFx0dmFyIHN2ZyA9IF9jcmVhdGVFbGVtZW50KFwic3ZnXCIsICh0aGlzLm93bmVyU1ZHRWxlbWVudCAmJiB0aGlzLm93bmVyU1ZHRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiKSkgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKSxcblx0XHRcdFx0XHRvbGRQYXJlbnQgPSB0aGlzLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0b2xkU2libGluZyA9IHRoaXMubmV4dFNpYmxpbmcsXG5cdFx0XHRcdFx0b2xkQ1NTID0gdGhpcy5zdHlsZS5jc3NUZXh0LFxuXHRcdFx0XHRcdGJib3g7XG5cdFx0XHRcdF9kb2NFbGVtZW50LmFwcGVuZENoaWxkKHN2Zyk7XG5cdFx0XHRcdHN2Zy5hcHBlbmRDaGlsZCh0aGlzKTtcblx0XHRcdFx0dGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXHRcdFx0XHRpZiAoc3dhcElmUG9zc2libGUpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0YmJveCA9IHRoaXMuZ2V0QkJveCgpO1xuXHRcdFx0XHRcdFx0dGhpcy5fb3JpZ2luYWxHZXRCQm94ID0gdGhpcy5nZXRCQm94O1xuXHRcdFx0XHRcdFx0dGhpcy5nZXRCQm94ID0gX2dldEJCb3hIYWNrO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHsgfVxuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX29yaWdpbmFsR2V0QkJveCkge1xuXHRcdFx0XHRcdGJib3ggPSB0aGlzLl9vcmlnaW5hbEdldEJCb3goKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob2xkU2libGluZykge1xuXHRcdFx0XHRcdG9sZFBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgb2xkU2libGluZyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b2xkUGFyZW50LmFwcGVuZENoaWxkKHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHN2Zyk7XG5cdFx0XHRcdHRoaXMuc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcblx0XHRcdFx0cmV0dXJuIGJib3g7XG5cdFx0XHR9LFxuXHRcdFx0X2dldEJCb3ggPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmV0dXJuIGUuZ2V0QkJveCgpOyAvL0ZpcmVmb3ggdGhyb3dzIGVycm9ycyBpZiB5b3UgdHJ5IGNhbGxpbmcgZ2V0QkJveCgpIG9uIGFuIFNWRyBlbGVtZW50IHRoYXQncyBub3QgcmVuZGVyZWQgKGxpa2UgaW4gYSA8c3ltYm9sPiBvciA8ZGVmcz4pLiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02MTIxMThcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRyZXR1cm4gX2dldEJCb3hIYWNrLmNhbGwoZSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfaXNTVkcgPSBmdW5jdGlvbihlKSB7IC8vcmVwb3J0cyBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkcgb24gd2hpY2ggZ2V0QkJveCgpIGFjdHVhbGx5IHdvcmtzXG5cdFx0XHRcdHJldHVybiAhIShfU1ZHRWxlbWVudCAmJiBlLmdldENUTSAmJiAoIWUucGFyZW50Tm9kZSB8fCBlLm93bmVyU1ZHRWxlbWVudCkgJiYgX2dldEJCb3goZSkpO1xuXHRcdFx0fSxcblx0XHRcdF9pZGVudGl0eTJETWF0cml4ID0gWzEsMCwwLDEsMCwwXSxcblx0XHRcdF9nZXRNYXRyaXggPSBmdW5jdGlvbihlLCBmb3JjZTJEKSB7XG5cdFx0XHRcdHZhciB0bSA9IGUuX2dzVHJhbnNmb3JtIHx8IG5ldyBUcmFuc2Zvcm0oKSxcblx0XHRcdFx0XHRybmQgPSAxMDAwMDAsXG5cdFx0XHRcdFx0c3R5bGUgPSBlLnN0eWxlLFxuXHRcdFx0XHRcdGlzRGVmYXVsdCwgcywgbSwgbiwgZGVjLCBub25lO1xuXHRcdFx0XHRpZiAoX3RyYW5zZm9ybVByb3ApIHtcblx0XHRcdFx0XHRzID0gX2dldFN0eWxlKGUsIF90cmFuc2Zvcm1Qcm9wQ1NTLCBudWxsLCB0cnVlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChlLmN1cnJlbnRTdHlsZSkge1xuXHRcdFx0XHRcdC8vZm9yIG9sZGVyIHZlcnNpb25zIG9mIElFLCB3ZSBuZWVkIHRvIGludGVycHJldCB0aGUgZmlsdGVyIHBvcnRpb24gdGhhdCBpcyBpbiB0aGUgZm9ybWF0OiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT02LjEyMzIzMzk5NTczNjc2NmUtMTcsIE0xMj0tMSwgTTIxPTEsIE0yMj02LjEyMzIzMzk5NTczNjc2NmUtMTcsIHNpemluZ01ldGhvZD0nYXV0byBleHBhbmQnKSBOb3RpY2UgdGhhdCB3ZSBuZWVkIHRvIHN3YXAgYiBhbmQgYyBjb21wYXJlZCB0byBhIG5vcm1hbCBtYXRyaXguXG5cdFx0XHRcdFx0cyA9IGUuY3VycmVudFN0eWxlLmZpbHRlci5tYXRjaChfaWVHZXRNYXRyaXhFeHApO1xuXHRcdFx0XHRcdHMgPSAocyAmJiBzLmxlbmd0aCA9PT0gNCkgPyBbc1swXS5zdWJzdHIoNCksIE51bWJlcihzWzJdLnN1YnN0cig0KSksIE51bWJlcihzWzFdLnN1YnN0cig0KSksIHNbM10uc3Vic3RyKDQpLCAodG0ueCB8fCAwKSwgKHRtLnkgfHwgMCldLmpvaW4oXCIsXCIpIDogXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpc0RlZmF1bHQgPSAoIXMgfHwgcyA9PT0gXCJub25lXCIgfHwgcyA9PT0gXCJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgMClcIik7XG5cdFx0XHRcdGlmIChfdHJhbnNmb3JtUHJvcCAmJiAoKG5vbmUgPSAoIV9nZXRDb21wdXRlZFN0eWxlKGUpIHx8IF9nZXRDb21wdXRlZFN0eWxlKGUpLmRpc3BsYXkgPT09IFwibm9uZVwiKSkgfHwgIWUucGFyZW50Tm9kZSkpIHsgLy9ub3RlOiBGaXJlZm94IHJldHVybnMgbnVsbCBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSgpIGlmIHRoZSBlbGVtZW50IGlzIGluIGFuIGlmcmFtZSB0aGF0IGhhcyBkaXNwbGF5Om5vbmUuIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuXHRcdFx0XHRcdGlmIChub25lKSB7IC8vYnJvd3NlcnMgZG9uJ3QgcmVwb3J0IHRyYW5zZm9ybXMgYWNjdXJhdGVseSB1bmxlc3MgdGhlIGVsZW1lbnQgaXMgaW4gdGhlIERPTSBhbmQgaGFzIGEgZGlzcGxheSB2YWx1ZSB0aGF0J3Mgbm90IFwibm9uZVwiLiBGaXJlZm94IGFuZCBNaWNyb3NvZnQgYnJvd3NlcnMgaGF2ZSBhIHBhcnRpYWwgYnVnIHdoZXJlIHRoZXknbGwgcmVwb3J0IHRyYW5zZm9ybXMgZXZlbiBpZiBkaXNwbGF5Om5vbmUgQlVUIG5vdCBhbnkgcGVyY2VudGFnZS1iYXNlZCB2YWx1ZXMgbGlrZSB0cmFuc2xhdGUoLTUwJSwgOHB4KSB3aWxsIGJlIHJlcG9ydGVkIGFzIGlmIGl0J3MgdHJhbnNsYXRlKDAsIDhweCkuXG5cdFx0XHRcdFx0XHRuID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghZS5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdFx0XHRkZWMgPSAxOyAvL2ZsYWdcblx0XHRcdFx0XHRcdF9kb2NFbGVtZW50LmFwcGVuZENoaWxkKGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzID0gX2dldFN0eWxlKGUsIF90cmFuc2Zvcm1Qcm9wQ1NTLCBudWxsLCB0cnVlKTtcblx0XHRcdFx0XHRpc0RlZmF1bHQgPSAoIXMgfHwgcyA9PT0gXCJub25lXCIgfHwgcyA9PT0gXCJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgMClcIik7XG5cdFx0XHRcdFx0aWYgKG4pIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBuO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobm9uZSkge1xuXHRcdFx0XHRcdFx0X3JlbW92ZVByb3Aoc3R5bGUsIFwiZGlzcGxheVwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGRlYykge1xuXHRcdFx0XHRcdFx0X2RvY0VsZW1lbnQucmVtb3ZlQ2hpbGQoZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0bS5zdmcgfHwgKGUuZ2V0Q1RNICYmIF9pc1NWRyhlKSkpIHtcblx0XHRcdFx0XHRpZiAoaXNEZWZhdWx0ICYmIChzdHlsZVtfdHJhbnNmb3JtUHJvcF0gKyBcIlwiKS5pbmRleE9mKFwibWF0cml4XCIpICE9PSAtMSkgeyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgQ2hyb21lIDQwKSBkb24ndCBjb3JyZWN0bHkgcmVwb3J0IHRyYW5zZm9ybXMgdGhhdCBhcmUgYXBwbGllZCBpbmxpbmUgb24gYW4gU1ZHIGVsZW1lbnQgKHRoZXkgZG9uJ3QgZ2V0IGluY2x1ZGVkIGluIHRoZSBjb21wdXRlZCBzdHlsZSksIHNvIHdlIGRvdWJsZS1jaGVjayBoZXJlIGFuZCBhY2NlcHQgbWF0cml4IHZhbHVlc1xuXHRcdFx0XHRcdFx0cyA9IHN0eWxlW190cmFuc2Zvcm1Qcm9wXTtcblx0XHRcdFx0XHRcdGlzRGVmYXVsdCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG0gPSBlLmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblx0XHRcdFx0XHRpZiAoaXNEZWZhdWx0ICYmIG0pIHtcblx0XHRcdFx0XHRcdG0gPSBlLnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkubWF0cml4OyAvL2Vuc3VyZXMgdGhhdCBldmVuIGNvbXBsZXggdmFsdWVzIGxpa2UgXCJ0cmFuc2xhdGUoNTAsNjApIHJvdGF0ZSgxMzUsMCwwKVwiIGFyZSBwYXJzZWQgYmVjYXVzZSBpdCBtYXNoZXMgaXQgaW50byBhIG1hdHJpeC5cblx0XHRcdFx0XHRcdHMgPSBcIm1hdHJpeChcIiArIG0uYSArIFwiLFwiICsgbS5iICsgXCIsXCIgKyBtLmMgKyBcIixcIiArIG0uZCArIFwiLFwiICsgbS5lICsgXCIsXCIgKyBtLmYgKyBcIilcIjtcblx0XHRcdFx0XHRcdGlzRGVmYXVsdCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc0RlZmF1bHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gX2lkZW50aXR5MkRNYXRyaXg7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9zcGxpdCB0aGUgbWF0cml4IHZhbHVlcyBvdXQgaW50byBhbiBhcnJheSAobSBmb3IgbWF0cml4KVxuXHRcdFx0XHRtID0gKHMgfHwgXCJcIikubWF0Y2goX251bUV4cCkgfHwgW107XG5cdFx0XHRcdGkgPSBtLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0biA9IE51bWJlcihtW2ldKTtcblx0XHRcdFx0XHRtW2ldID0gKGRlYyA9IG4gLSAobiB8PSAwKSkgPyAoKGRlYyAqIHJuZCArIChkZWMgPCAwID8gLTAuNSA6IDAuNSkpIHwgMCkgLyBybmQgKyBuIDogbjsgLy9jb252ZXJ0IHN0cmluZ3MgdG8gTnVtYmVycyBhbmQgcm91bmQgdG8gNSBkZWNpbWFsIHBsYWNlcyB0byBhdm9pZCBpc3N1ZXMgd2l0aCB0aW55IG51bWJlcnMuIFJvdWdobHkgMjB4IGZhc3RlciB0aGFuIE51bWJlci50b0ZpeGVkKCkuIFdlIGFsc28gbXVzdCBtYWtlIHN1cmUgdG8gcm91bmQgYmVmb3JlIGRpdmlkaW5nIHNvIHRoYXQgdmFsdWVzIGxpa2UgMC45OTk5OTk5OTk5IGJlY29tZSAxIHRvIGF2b2lkIGdsaXRjaGVzIGluIGJyb3dzZXIgcmVuZGVyaW5nIGFuZCBpbnRlcnByZXRhdGlvbiBvZiBmbGlwcGVkL3JvdGF0ZWQgM0QgbWF0cmljZXMuIEFuZCBkb24ndCBqdXN0IG11bHRpcGx5IHRoZSBudW1iZXIgYnkgcm5kLCBmbG9vciBpdCwgYW5kIHRoZW4gZGl2aWRlIGJ5IHJuZCBiZWNhdXNlIHRoZSBiaXR3aXNlIG9wZXJhdGlvbnMgbWF4IG91dCBhdCBhIDMyLWJpdCBzaWduZWQgaW50ZWdlciwgdGh1cyBpdCBjb3VsZCBnZXQgY2xpcHBlZCBhdCBhIHJlbGF0aXZlbHkgbG93IHZhbHVlIChsaWtlIDIyLDAwMC4wMDAwMCBmb3IgZXhhbXBsZSkuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIChmb3JjZTJEICYmIG0ubGVuZ3RoID4gNikgPyBbbVswXSwgbVsxXSwgbVs0XSwgbVs1XSwgbVsxMl0sIG1bMTNdXSA6IG07XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFBhcnNlcyB0aGUgdHJhbnNmb3JtIHZhbHVlcyBmb3IgYW4gZWxlbWVudCwgcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIHgsIHksIHosIHNjYWxlWCwgc2NhbGVZLCBzY2FsZVosIHJvdGF0aW9uLCByb3RhdGlvblgsIHJvdGF0aW9uWSwgc2tld1gsIGFuZCBza2V3WSBwcm9wZXJ0aWVzLiBOb3RlOiBieSBkZWZhdWx0IChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyksIGFsbCBza2V3aW5nIGlzIGNvbWJpbmVkIGludG8gc2tld1ggYW5kIHJvdGF0aW9uIGJ1dCBza2V3WSBzdGlsbCBoYXMgYSBwbGFjZSBpbiB0aGUgdHJhbnNmb3JtIG9iamVjdCBzbyB0aGF0IHdlIGNhbiByZWNvcmQgaG93IG11Y2ggb2YgdGhlIHNrZXcgaXMgYXR0cmlidXRlZCB0byBza2V3WCB2cyBza2V3WS4gUmVtZW1iZXIsIGEgc2tld1kgb2YgMTAgbG9va3MgdGhlIHNhbWUgYXMgYSByb3RhdGlvbiBvZiAxMCBhbmQgc2tld1ggb2YgLTEwLlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IHRhcmdldCBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdD19IGNzIGNvbXB1dGVkIHN0eWxlIG9iamVjdCAob3B0aW9uYWwpXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWMgaWYgdHJ1ZSwgdGhlIHRyYW5zZm9ybSB2YWx1ZXMgd2lsbCBiZSByZWNvcmRlZCB0byB0aGUgdGFyZ2V0IGVsZW1lbnQncyBfZ3NUcmFuc2Zvcm0gb2JqZWN0LCBsaWtlIHRhcmdldC5fZ3NUcmFuc2Zvcm0gPSB7eDowLCB5OjAsIHo6MCwgc2NhbGVYOjEuLi59XG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBwYXJzZSBpZiB0cnVlLCB3ZSdsbCBpZ25vcmUgYW55IF9nc1RyYW5zZm9ybSB2YWx1ZXMgdGhhdCBhbHJlYWR5IGV4aXN0IG9uIHRoZSBlbGVtZW50LCBhbmQgZm9yY2UgYSByZXBhcnNpbmcgb2YgdGhlIGNzcyAoY2FsY3VsYXRlZCBzdHlsZSlcblx0XHRcdCAqIEByZXR1cm4ge29iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcy92YWx1ZXMgbGlrZSB7eDowLCB5OjAsIHo6MCwgc2NhbGVYOjEuLi59XG5cdFx0XHQgKi9cblx0XHRcdF9nZXRUcmFuc2Zvcm0gPSBfaW50ZXJuYWxzLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHQsIGNzLCByZWMsIHBhcnNlKSB7XG5cdFx0XHRcdGlmICh0Ll9nc1RyYW5zZm9ybSAmJiByZWMgJiYgIXBhcnNlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHQuX2dzVHJhbnNmb3JtOyAvL2lmIHRoZSBlbGVtZW50IGFscmVhZHkgaGFzIGEgX2dzVHJhbnNmb3JtLCB1c2UgdGhhdC4gTm90ZTogc29tZSBicm93c2VycyBkb24ndCBhY2N1cmF0ZWx5IHJldHVybiB0aGUgY2FsY3VsYXRlZCBzdHlsZSBmb3IgdGhlIHRyYW5zZm9ybSAocGFydGljdWxhcmx5IGZvciBTVkcpLCBzbyBpdCdzIGFsbW9zdCBhbHdheXMgc2FmZXN0IHRvIGp1c3QgdXNlIHRoZSB2YWx1ZXMgd2UndmUgYWxyZWFkeSBhcHBsaWVkIHJhdGhlciB0aGFuIHJlLXBhcnNpbmcgdGhpbmdzLlxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciB0bSA9IHJlYyA/IHQuX2dzVHJhbnNmb3JtIHx8IG5ldyBUcmFuc2Zvcm0oKSA6IG5ldyBUcmFuc2Zvcm0oKSxcblx0XHRcdFx0XHRpbnZYID0gKHRtLnNjYWxlWCA8IDApLCAvL2luIG9yZGVyIHRvIGludGVycHJldCB0aGluZ3MgcHJvcGVybHksIHdlIG5lZWQgdG8ga25vdyBpZiB0aGUgdXNlciBhcHBsaWVkIGEgbmVnYXRpdmUgc2NhbGVYIHByZXZpb3VzbHkgc28gdGhhdCB3ZSBjYW4gYWRqdXN0IHRoZSByb3RhdGlvbiBhbmQgc2tld1ggYWNjb3JkaW5nbHkuIE90aGVyd2lzZSwgaWYgd2UgYWx3YXlzIGludGVycHJldCBhIGZsaXBwZWQgbWF0cml4IGFzIGFmZmVjdGluZyBzY2FsZVkgYW5kIHRoZSB1c2VyIG9ubHkgd2FudHMgdG8gdHdlZW4gdGhlIHNjYWxlWCBvbiBtdWx0aXBsZSBzZXF1ZW50aWFsIHR3ZWVucywgaXQgd291bGQga2VlcCB0aGUgbmVnYXRpdmUgc2NhbGVZIHdpdGhvdXQgdGhhdCBiZWluZyB0aGUgdXNlcidzIGludGVudC5cblx0XHRcdFx0XHRtaW4gPSAwLjAwMDAyLFxuXHRcdFx0XHRcdHJuZCA9IDEwMDAwMCxcblx0XHRcdFx0XHR6T3JpZ2luID0gX3N1cHBvcnRzM0QgPyBwYXJzZUZsb2F0KF9nZXRTdHlsZSh0LCBfdHJhbnNmb3JtT3JpZ2luUHJvcCwgY3MsIGZhbHNlLCBcIjAgMCAwXCIpLnNwbGl0KFwiIFwiKVsyXSkgfHwgdG0uek9yaWdpbiAgfHwgMCA6IDAsXG5cdFx0XHRcdFx0ZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlID0gcGFyc2VGbG9hdChDU1NQbHVnaW4uZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlKSB8fCAwLFxuXHRcdFx0XHRcdG0sIGksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1g7XG5cblx0XHRcdFx0dG0uc3ZnID0gISEodC5nZXRDVE0gJiYgX2lzU1ZHKHQpKTtcblx0XHRcdFx0aWYgKHRtLnN2Zykge1xuXHRcdFx0XHRcdF9wYXJzZVNWR09yaWdpbih0LCBfZ2V0U3R5bGUodCwgX3RyYW5zZm9ybU9yaWdpblByb3AsIGNzLCBmYWxzZSwgXCI1MCUgNTAlXCIpICsgXCJcIiwgdG0sIHQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIpKTtcblx0XHRcdFx0XHRfdXNlU1ZHVHJhbnNmb3JtQXR0ciA9IENTU1BsdWdpbi51c2VTVkdUcmFuc2Zvcm1BdHRyIHx8IF9mb3JjZVNWR1RyYW5zZm9ybUF0dHI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bSA9IF9nZXRNYXRyaXgodCk7XG5cdFx0XHRcdGlmIChtICE9PSBfaWRlbnRpdHkyRE1hdHJpeCkge1xuXG5cdFx0XHRcdFx0aWYgKG0ubGVuZ3RoID09PSAxNikge1xuXHRcdFx0XHRcdFx0Ly93ZSdsbCBvbmx5IGxvb2sgYXQgdGhlc2UgcG9zaXRpb24tcmVsYXRlZCA2IHZhcmlhYmxlcyBmaXJzdCBiZWNhdXNlIGlmIHgveS96IGFsbCBtYXRjaCwgaXQncyByZWxhdGl2ZWx5IHNhZmUgdG8gYXNzdW1lIHdlIGRvbid0IG5lZWQgdG8gcmUtcGFyc2UgZXZlcnl0aGluZyB3aGljaCByaXNrcyBsb3NpbmcgaW1wb3J0YW50IHJvdGF0aW9uYWwgaW5mb3JtYXRpb24gKGxpa2Ugcm90YXRpb25YOjE4MCBwbHVzIHJvdGF0aW9uWToxODAgd291bGQgbG9vayB0aGUgc2FtZSBhcyByb3RhdGlvbjoxODAgLSB0aGVyZSdzIG5vIHdheSB0byBrbm93IGZvciBzdXJlIHdoaWNoIGRpcmVjdGlvbiB3YXMgdGFrZW4gYmFzZWQgc29sZWx5IG9uIHRoZSBtYXRyaXgzZCgpIHZhbHVlcylcblx0XHRcdFx0XHRcdHZhciBhMTEgPSBtWzBdLCBhMjEgPSBtWzFdLCBhMzEgPSBtWzJdLCBhNDEgPSBtWzNdLFxuXHRcdFx0XHRcdFx0XHRhMTIgPSBtWzRdLCBhMjIgPSBtWzVdLCBhMzIgPSBtWzZdLCBhNDIgPSBtWzddLFxuXHRcdFx0XHRcdFx0XHRhMTMgPSBtWzhdLCBhMjMgPSBtWzldLCBhMzMgPSBtWzEwXSxcblx0XHRcdFx0XHRcdFx0YTE0ID0gbVsxMl0sIGEyNCA9IG1bMTNdLCBhMzQgPSBtWzE0XSxcblx0XHRcdFx0XHRcdFx0YTQzID0gbVsxMV0sXG5cdFx0XHRcdFx0XHRcdGFuZ2xlID0gTWF0aC5hdGFuMihhMzIsIGEzMyksXG5cdFx0XHRcdFx0XHRcdHQxLCB0MiwgdDMsIHQ0LCBjb3MsIHNpbjtcblx0XHRcdFx0XHRcdC8vd2UgbWFudWFsbHkgY29tcGVuc2F0ZSBmb3Igbm9uLXplcm8geiBjb21wb25lbnQgb2YgdHJhbnNmb3JtT3JpZ2luIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gU2FmYXJpXG5cdFx0XHRcdFx0XHRpZiAodG0uek9yaWdpbikge1xuXHRcdFx0XHRcdFx0XHRhMzQgPSAtdG0uek9yaWdpbjtcblx0XHRcdFx0XHRcdFx0YTE0ID0gYTEzKmEzNC1tWzEyXTtcblx0XHRcdFx0XHRcdFx0YTI0ID0gYTIzKmEzNC1tWzEzXTtcblx0XHRcdFx0XHRcdFx0YTM0ID0gYTMzKmEzNCt0bS56T3JpZ2luLW1bMTRdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly9ub3RlIGZvciBwb3NzaWJsZSBmdXR1cmUgY29uc29saWRhdGlvbjogcm90YXRpb25YOiBNYXRoLmF0YW4yKGEzMiwgYTMzKSwgcm90YXRpb25ZOiBNYXRoLmF0YW4yKC1hMzEsIE1hdGguc3FydChhMzMgKiBhMzMgKyBhMzIgKiBhMzIpKSwgcm90YXRpb246IE1hdGguYXRhbjIoYTIxLCBhMTEpLCBza2V3OiBNYXRoLmF0YW4yKGExMiwgYTIyKS4gSG93ZXZlciwgaXQgZG9lc24ndCBzZWVtIHRvIGJlIHF1aXRlIGFzIHJlbGlhYmxlIGFzIHRoZSBmdWxsLW9uIGJhY2t3YXJkcyByb3RhdGlvbiBwcm9jZWR1cmUuXG5cdFx0XHRcdFx0XHR0bS5yb3RhdGlvblggPSBhbmdsZSAqIF9SQUQyREVHO1xuXHRcdFx0XHRcdFx0Ly9yb3RhdGlvblhcblx0XHRcdFx0XHRcdGlmIChhbmdsZSkge1xuXHRcdFx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHR0MSA9IGExMipjb3MrYTEzKnNpbjtcblx0XHRcdFx0XHRcdFx0dDIgPSBhMjIqY29zK2EyMypzaW47XG5cdFx0XHRcdFx0XHRcdHQzID0gYTMyKmNvcythMzMqc2luO1xuXHRcdFx0XHRcdFx0XHRhMTMgPSBhMTIqLXNpbithMTMqY29zO1xuXHRcdFx0XHRcdFx0XHRhMjMgPSBhMjIqLXNpbithMjMqY29zO1xuXHRcdFx0XHRcdFx0XHRhMzMgPSBhMzIqLXNpbithMzMqY29zO1xuXHRcdFx0XHRcdFx0XHRhNDMgPSBhNDIqLXNpbithNDMqY29zO1xuXHRcdFx0XHRcdFx0XHRhMTIgPSB0MTtcblx0XHRcdFx0XHRcdFx0YTIyID0gdDI7XG5cdFx0XHRcdFx0XHRcdGEzMiA9IHQzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly9yb3RhdGlvbllcblx0XHRcdFx0XHRcdGFuZ2xlID0gTWF0aC5hdGFuMigtYTMxLCBhMzMpO1xuXHRcdFx0XHRcdFx0dG0ucm90YXRpb25ZID0gYW5nbGUgKiBfUkFEMkRFRztcblx0XHRcdFx0XHRcdGlmIChhbmdsZSkge1xuXHRcdFx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHR0MSA9IGExMSpjb3MtYTEzKnNpbjtcblx0XHRcdFx0XHRcdFx0dDIgPSBhMjEqY29zLWEyMypzaW47XG5cdFx0XHRcdFx0XHRcdHQzID0gYTMxKmNvcy1hMzMqc2luO1xuXHRcdFx0XHRcdFx0XHRhMjMgPSBhMjEqc2luK2EyMypjb3M7XG5cdFx0XHRcdFx0XHRcdGEzMyA9IGEzMSpzaW4rYTMzKmNvcztcblx0XHRcdFx0XHRcdFx0YTQzID0gYTQxKnNpbithNDMqY29zO1xuXHRcdFx0XHRcdFx0XHRhMTEgPSB0MTtcblx0XHRcdFx0XHRcdFx0YTIxID0gdDI7XG5cdFx0XHRcdFx0XHRcdGEzMSA9IHQzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly9yb3RhdGlvblpcblx0XHRcdFx0XHRcdGFuZ2xlID0gTWF0aC5hdGFuMihhMjEsIGExMSk7XG5cdFx0XHRcdFx0XHR0bS5yb3RhdGlvbiA9IGFuZ2xlICogX1JBRDJERUc7XG5cdFx0XHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0XHRcdFx0XHRcdHQxID0gYTExKmNvcythMjEqc2luO1xuXHRcdFx0XHRcdFx0XHR0MiA9IGExMipjb3MrYTIyKnNpbjtcblx0XHRcdFx0XHRcdFx0dDMgPSBhMTMqY29zK2EyMypzaW47XG5cdFx0XHRcdFx0XHRcdGEyMSA9IGEyMSpjb3MtYTExKnNpbjtcblx0XHRcdFx0XHRcdFx0YTIyID0gYTIyKmNvcy1hMTIqc2luO1xuXHRcdFx0XHRcdFx0XHRhMjMgPSBhMjMqY29zLWExMypzaW47XG5cdFx0XHRcdFx0XHRcdGExMSA9IHQxO1xuXHRcdFx0XHRcdFx0XHRhMTIgPSB0Mjtcblx0XHRcdFx0XHRcdFx0YTEzID0gdDM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh0bS5yb3RhdGlvblggJiYgTWF0aC5hYnModG0ucm90YXRpb25YKSArIE1hdGguYWJzKHRtLnJvdGF0aW9uKSA+IDM1OS45KSB7IC8vd2hlbiByb3RhdGlvblkgaXMgc2V0LCBpdCB3aWxsIG9mdGVuIGJlIHBhcnNlZCBhcyAxODAgZGVncmVlcyBkaWZmZXJlbnQgdGhhbiBpdCBzaG91bGQgYmUsIGFuZCByb3RhdGlvblggYW5kIHJvdGF0aW9uIGJvdGggYmVpbmcgMTgwIChpdCBsb29rcyB0aGUgc2FtZSksIHNvIHdlIGFkanVzdCBmb3IgdGhhdCBoZXJlLlxuXHRcdFx0XHRcdFx0XHR0bS5yb3RhdGlvblggPSB0bS5yb3RhdGlvbiA9IDA7XG5cdFx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uWSA9IDE4MCAtIHRtLnJvdGF0aW9uWTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly9za2V3WFxuXHRcdFx0XHRcdFx0YW5nbGUgPSBNYXRoLmF0YW4yKGExMiwgYTIyKTtcblxuXHRcdFx0XHRcdFx0Ly9zY2FsZXNcblx0XHRcdFx0XHRcdHRtLnNjYWxlWCA9ICgoTWF0aC5zcXJ0KGExMSAqIGExMSArIGEyMSAqIGEyMSArIGEzMSAqIGEzMSkgKiBybmQgKyAwLjUpIHwgMCkgLyBybmQ7XG5cdFx0XHRcdFx0XHR0bS5zY2FsZVkgPSAoKE1hdGguc3FydChhMjIgKiBhMjIgKyBhMzIgKiBhMzIpICogcm5kICsgMC41KSB8IDApIC8gcm5kO1xuXHRcdFx0XHRcdFx0dG0uc2NhbGVaID0gKChNYXRoLnNxcnQoYTEzICogYTEzICsgYTIzICogYTIzICsgYTMzICogYTMzKSAqIHJuZCArIDAuNSkgfCAwKSAvIHJuZDtcblx0XHRcdFx0XHRcdGExMSAvPSB0bS5zY2FsZVg7XG5cdFx0XHRcdFx0XHRhMTIgLz0gdG0uc2NhbGVZO1xuXHRcdFx0XHRcdFx0YTIxIC89IHRtLnNjYWxlWDtcblx0XHRcdFx0XHRcdGEyMiAvPSB0bS5zY2FsZVk7XG5cdFx0XHRcdFx0XHRpZiAoTWF0aC5hYnMoYW5nbGUpID4gbWluKSB7XG5cdFx0XHRcdFx0XHRcdHRtLnNrZXdYID0gYW5nbGUgKiBfUkFEMkRFRztcblx0XHRcdFx0XHRcdFx0YTEyID0gMDsgLy91bnNrZXdzXG5cdFx0XHRcdFx0XHRcdGlmICh0bS5za2V3VHlwZSAhPT0gXCJzaW1wbGVcIikge1xuXHRcdFx0XHRcdFx0XHRcdHRtLnNjYWxlWSAqPSAxIC8gTWF0aC5jb3MoYW5nbGUpOyAvL2J5IGRlZmF1bHQsIHdlIGNvbXBlbnNhdGUgdGhlIHNjYWxlIGJhc2VkIG9uIHRoZSBza2V3IHNvIHRoYXQgdGhlIGVsZW1lbnQgbWFpbnRhaW5zIGEgc2ltaWxhciBwcm9wb3J0aW9uIHdoZW4gc2tld2VkLCBzbyB3ZSBoYXZlIHRvIGFsdGVyIHRoZSBzY2FsZVkgaGVyZSBhY2NvcmRpbmdseSB0byBtYXRjaCB0aGUgZGVmYXVsdCAobm9uLWFkanVzdGVkKSBza2V3aW5nIHRoYXQgQ1NTIGRvZXMgKHN0cmV0Y2hpbmcgbW9yZSBhbmQgbW9yZSBhcyBpdCBza2V3cykuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dG0uc2tld1ggPSAwO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiAvL2ZvciB0ZXN0aW5nIHB1cnBvc2VzXG5cdFx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtID0gXCJtYXRyaXgzZChcIixcblx0XHRcdFx0XHRcdFx0Y29tbWEgPSBcIixcIixcblx0XHRcdFx0XHRcdFx0emVybyA9IFwiMFwiO1xuXHRcdFx0XHRcdFx0YTEzIC89IHRtLnNjYWxlWjtcblx0XHRcdFx0XHRcdGEyMyAvPSB0bS5zY2FsZVo7XG5cdFx0XHRcdFx0XHRhMzEgLz0gdG0uc2NhbGVYO1xuXHRcdFx0XHRcdFx0YTMyIC89IHRtLnNjYWxlWTtcblx0XHRcdFx0XHRcdGEzMyAvPSB0bS5zY2FsZVo7XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm0gKz0gKChhMTEgPCBtaW4gJiYgYTExID4gLW1pbikgPyB6ZXJvIDogYTExKSArIGNvbW1hICsgKChhMjEgPCBtaW4gJiYgYTIxID4gLW1pbikgPyB6ZXJvIDogYTIxKSArIGNvbW1hICsgKChhMzEgPCBtaW4gJiYgYTMxID4gLW1pbikgPyB6ZXJvIDogYTMxKTtcblx0XHRcdFx0XHRcdHRyYW5zZm9ybSArPSBjb21tYSArICgoYTQxIDwgbWluICYmIGE0MSA+IC1taW4pID8gemVybyA6IGE0MSkgKyBjb21tYSArICgoYTEyIDwgbWluICYmIGExMiA+IC1taW4pID8gemVybyA6IGExMikgKyBjb21tYSArICgoYTIyIDwgbWluICYmIGEyMiA+IC1taW4pID8gemVybyA6IGEyMik7XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm0gKz0gY29tbWEgKyAoKGEzMiA8IG1pbiAmJiBhMzIgPiAtbWluKSA/IHplcm8gOiBhMzIpICsgY29tbWEgKyAoKGE0MiA8IG1pbiAmJiBhNDIgPiAtbWluKSA/IHplcm8gOiBhNDIpICsgY29tbWEgKyAoKGExMyA8IG1pbiAmJiBhMTMgPiAtbWluKSA/IHplcm8gOiBhMTMpO1xuXHRcdFx0XHRcdFx0dHJhbnNmb3JtICs9IGNvbW1hICsgKChhMjMgPCBtaW4gJiYgYTIzID4gLW1pbikgPyB6ZXJvIDogYTIzKSArIGNvbW1hICsgKChhMzMgPCBtaW4gJiYgYTMzID4gLW1pbikgPyB6ZXJvIDogYTMzKSArIGNvbW1hICsgKChhNDMgPCBtaW4gJiYgYTQzID4gLW1pbikgPyB6ZXJvIDogYTQzKSArIGNvbW1hO1xuXHRcdFx0XHRcdFx0dHJhbnNmb3JtICs9IGExNCArIGNvbW1hICsgYTI0ICsgY29tbWEgKyBhMzQgKyBjb21tYSArICh0bS5wZXJzcGVjdGl2ZSA/ICgxICsgKC1hMzQgLyB0bS5wZXJzcGVjdGl2ZSkpIDogMSkgKyBcIilcIjtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKHRyYW5zZm9ybSk7XG5cdFx0XHRcdFx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRlc3RcIikuc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuXHRcdFx0XHRcdFx0Ki9cblxuXHRcdFx0XHRcdFx0dG0ucGVyc3BlY3RpdmUgPSBhNDMgPyAxIC8gKChhNDMgPCAwKSA/IC1hNDMgOiBhNDMpIDogMDtcblx0XHRcdFx0XHRcdHRtLnggPSBhMTQ7XG5cdFx0XHRcdFx0XHR0bS55ID0gYTI0O1xuXHRcdFx0XHRcdFx0dG0ueiA9IGEzNDtcblx0XHRcdFx0XHRcdGlmICh0bS5zdmcpIHtcblx0XHRcdFx0XHRcdFx0dG0ueCAtPSB0bS54T3JpZ2luIC0gKHRtLnhPcmlnaW4gKiBhMTEgLSB0bS55T3JpZ2luICogYTEyKTtcblx0XHRcdFx0XHRcdFx0dG0ueSAtPSB0bS55T3JpZ2luIC0gKHRtLnlPcmlnaW4gKiBhMjEgLSB0bS54T3JpZ2luICogYTIyKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoKCFfc3VwcG9ydHMzRCB8fCBwYXJzZSB8fCAhbS5sZW5ndGggfHwgdG0ueCAhPT0gbVs0XSB8fCB0bS55ICE9PSBtWzVdIHx8ICghdG0ucm90YXRpb25YICYmICF0bS5yb3RhdGlvblkpKSkgeyAvL3NvbWV0aW1lcyBhIDYtZWxlbWVudCBtYXRyaXggaXMgcmV0dXJuZWQgZXZlbiB3aGVuIHdlIHBlcmZvcm1lZCAzRCB0cmFuc2Zvcm1zLCBsaWtlIGlmIHJvdGF0aW9uWCBhbmQgcm90YXRpb25ZIGFyZSAxODAuIEluIGNhc2VzIGxpa2UgdGhpcywgd2Ugc3RpbGwgbmVlZCB0byBob25vciB0aGUgM0QgdHJhbnNmb3Jtcy4gSWYgd2UganVzdCByZWx5IG9uIHRoZSAyRCBpbmZvLCBpdCBjb3VsZCBhZmZlY3QgaG93IHRoZSBkYXRhIGlzIGludGVycHJldGVkLCBsaWtlIHNjYWxlWSBtaWdodCBnZXQgc2V0IHRvIC0xIG9yIHJvdGF0aW9uIGNvdWxkIGdldCBvZmZzZXQgYnkgMTgwIGRlZ3JlZXMuIEZvciBleGFtcGxlLCBkbyBhIFR3ZWVuTGl0ZS50byhlbGVtZW50LCAxLCB7Y3NzOntyb3RhdGlvblg6MTgwLCByb3RhdGlvblk6MTgwfX0pIGFuZCB0aGVuIGxhdGVyLCBUd2VlbkxpdGUudG8oZWxlbWVudCwgMSwge2Nzczp7cm90YXRpb25YOjB9fSkgYW5kIHdpdGhvdXQgdGhpcyBjb25kaXRpb25hbCBsb2dpYyBpbiBwbGFjZSwgaXQnZCBqdW1wIHRvIGEgc3RhdGUgb2YgYmVpbmcgdW5yb3RhdGVkIHdoZW4gdGhlIDJuZCB0d2VlbiBzdGFydHMuIFRoZW4gYWdhaW4sIHdlIG5lZWQgdG8gaG9ub3IgdGhlIGZhY3QgdGhhdCB0aGUgdXNlciBDT1VMRCBhbHRlciB0aGUgdHJhbnNmb3JtcyBvdXRzaWRlIG9mIENTU1BsdWdpbiwgbGlrZSBieSBtYW51YWxseSBhcHBseWluZyBuZXcgY3NzLCBzbyB3ZSB0cnkgdG8gc2Vuc2UgdGhhdCBieSBsb29raW5nIGF0IHggYW5kIHkgYmVjYXVzZSBpZiB0aG9zZSBjaGFuZ2VkLCB3ZSBrbm93IHRoZSBjaGFuZ2VzIHdlcmUgbWFkZSBvdXRzaWRlIENTU1BsdWdpbiBhbmQgd2UgZm9yY2UgYSByZWludGVycHJldGF0aW9uIG9mIHRoZSBtYXRyaXggdmFsdWVzLiBBbHNvLCBpbiBXZWJraXQgYnJvd3NlcnMsIGlmIHRoZSBlbGVtZW50J3MgXCJkaXNwbGF5XCIgaXMgXCJub25lXCIsIGl0cyBjYWxjdWxhdGVkIHN0eWxlIHZhbHVlIHdpbGwgYWx3YXlzIHJldHVybiBlbXB0eSwgc28gaWYgd2UndmUgYWxyZWFkeSByZWNvcmRlZCB0aGUgdmFsdWVzIGluIHRoZSBfZ3NUcmFuc2Zvcm0gb2JqZWN0LCB3ZSdsbCBqdXN0IHJlbHkgb24gdGhvc2UuXG5cdFx0XHRcdFx0XHR2YXIgayA9IChtLmxlbmd0aCA+PSA2KSxcblx0XHRcdFx0XHRcdFx0YSA9IGsgPyBtWzBdIDogMSxcblx0XHRcdFx0XHRcdFx0YiA9IG1bMV0gfHwgMCxcblx0XHRcdFx0XHRcdFx0YyA9IG1bMl0gfHwgMCxcblx0XHRcdFx0XHRcdFx0ZCA9IGsgPyBtWzNdIDogMTtcblx0XHRcdFx0XHRcdHRtLnggPSBtWzRdIHx8IDA7XG5cdFx0XHRcdFx0XHR0bS55ID0gbVs1XSB8fCAwO1xuXHRcdFx0XHRcdFx0c2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuXHRcdFx0XHRcdFx0c2NhbGVZID0gTWF0aC5zcXJ0KGQgKiBkICsgYyAqIGMpO1xuXHRcdFx0XHRcdFx0cm90YXRpb24gPSAoYSB8fCBiKSA/IE1hdGguYXRhbjIoYiwgYSkgKiBfUkFEMkRFRyA6IHRtLnJvdGF0aW9uIHx8IDA7IC8vbm90ZTogaWYgc2NhbGVYIGlzIDAsIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IG1lYXN1cmUgcm90YXRpb24uIFNhbWUgZm9yIHNrZXdYIHdpdGggYSBzY2FsZVkgb2YgMC4gVGhlcmVmb3JlLCB3ZSBkZWZhdWx0IHRvIHRoZSBwcmV2aW91c2x5IHJlY29yZGVkIHZhbHVlIChvciB6ZXJvIGlmIHRoYXQgZG9lc24ndCBleGlzdCkuXG5cdFx0XHRcdFx0XHRza2V3WCA9IChjIHx8IGQpID8gTWF0aC5hdGFuMihjLCBkKSAqIF9SQUQyREVHICsgcm90YXRpb24gOiB0bS5za2V3WCB8fCAwO1xuXHRcdFx0XHRcdFx0dG0uc2NhbGVYID0gc2NhbGVYO1xuXHRcdFx0XHRcdFx0dG0uc2NhbGVZID0gc2NhbGVZO1xuXHRcdFx0XHRcdFx0dG0ucm90YXRpb24gPSByb3RhdGlvbjtcblx0XHRcdFx0XHRcdHRtLnNrZXdYID0gc2tld1g7XG5cdFx0XHRcdFx0XHRpZiAoX3N1cHBvcnRzM0QpIHtcblx0XHRcdFx0XHRcdFx0dG0ucm90YXRpb25YID0gdG0ucm90YXRpb25ZID0gdG0ueiA9IDA7XG5cdFx0XHRcdFx0XHRcdHRtLnBlcnNwZWN0aXZlID0gZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlO1xuXHRcdFx0XHRcdFx0XHR0bS5zY2FsZVogPSAxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHRtLnN2Zykge1xuXHRcdFx0XHRcdFx0XHR0bS54IC09IHRtLnhPcmlnaW4gLSAodG0ueE9yaWdpbiAqIGEgKyB0bS55T3JpZ2luICogYyk7XG5cdFx0XHRcdFx0XHRcdHRtLnkgLT0gdG0ueU9yaWdpbiAtICh0bS54T3JpZ2luICogYiArIHRtLnlPcmlnaW4gKiBkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKE1hdGguYWJzKHRtLnNrZXdYKSA+IDkwICYmIE1hdGguYWJzKHRtLnNrZXdYKSA8IDI3MCkge1xuXHRcdFx0XHRcdFx0aWYgKGludlgpIHtcblx0XHRcdFx0XHRcdFx0dG0uc2NhbGVYICo9IC0xO1xuXHRcdFx0XHRcdFx0XHR0bS5za2V3WCArPSAodG0ucm90YXRpb24gPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0XHR0bS5yb3RhdGlvbiArPSAodG0ucm90YXRpb24gPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dG0uc2NhbGVZICo9IC0xO1xuXHRcdFx0XHRcdFx0XHR0bS5za2V3WCArPSAodG0uc2tld1ggPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bS56T3JpZ2luID0gek9yaWdpbjtcblx0XHRcdFx0XHQvL3NvbWUgYnJvd3NlcnMgaGF2ZSBhIGhhcmQgdGltZSB3aXRoIHZlcnkgc21hbGwgdmFsdWVzIGxpa2UgMi40NDkyOTM1OTgyOTQ3MDY0ZS0xNiAobm90aWNlIHRoZSBcImUtXCIgdG93YXJkcyB0aGUgZW5kKSBhbmQgd291bGQgcmVuZGVyIHRoZSBvYmplY3Qgc2xpZ2h0bHkgb2ZmLiBTbyB3ZSByb3VuZCB0byAwIGluIHRoZXNlIGNhc2VzLiBUaGUgY29uZGl0aW9uYWwgbG9naWMgaGVyZSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIE1hdGguYWJzKCkuIEFsc28sIGJyb3dzZXJzIHRlbmQgdG8gcmVuZGVyIGEgU0xJR0hUTFkgcm90YXRlZCBvYmplY3QgaW4gYSBmdXp6eSB3YXksIHNvIHdlIG5lZWQgdG8gc25hcCB0byBleGFjdGx5IDAgd2hlbiBhcHByb3ByaWF0ZS5cblx0XHRcdFx0XHRmb3IgKGkgaW4gdG0pIHtcblx0XHRcdFx0XHRcdGlmICh0bVtpXSA8IG1pbikgaWYgKHRtW2ldID4gLW1pbikge1xuXHRcdFx0XHRcdFx0XHR0bVtpXSA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vREVCVUc6IF9sb2coXCJwYXJzZWQgcm90YXRpb24gb2YgXCIgKyB0LmdldEF0dHJpYnV0ZShcImlkXCIpK1wiOiBcIisodG0ucm90YXRpb25YKStcIiwgXCIrKHRtLnJvdGF0aW9uWSkrXCIsIFwiKyh0bS5yb3RhdGlvbikrXCIsIHNjYWxlOiBcIit0bS5zY2FsZVgrXCIsIFwiK3RtLnNjYWxlWStcIiwgXCIrdG0uc2NhbGVaK1wiLCBwb3NpdGlvbjogXCIrdG0ueCtcIiwgXCIrdG0ueStcIiwgXCIrdG0ueitcIiwgcGVyc3BlY3RpdmU6IFwiK3RtLnBlcnNwZWN0aXZlKyBcIiwgb3JpZ2luOiBcIisgdG0ueE9yaWdpbisgXCIsXCIrIHRtLnlPcmlnaW4pO1xuXHRcdFx0XHRpZiAocmVjKSB7XG5cdFx0XHRcdFx0dC5fZ3NUcmFuc2Zvcm0gPSB0bTsgLy9yZWNvcmQgdG8gdGhlIG9iamVjdCdzIF9nc1RyYW5zZm9ybSB3aGljaCB3ZSB1c2Ugc28gdGhhdCB0d2VlbnMgY2FuIGNvbnRyb2wgaW5kaXZpZHVhbCBwcm9wZXJ0aWVzIGluZGVwZW5kZW50bHkgKHdlIG5lZWQgYWxsIHRoZSBwcm9wZXJ0aWVzIHRvIGFjY3VyYXRlbHkgcmVjb21wb3NlIHRoZSBtYXRyaXggaW4gdGhlIHNldFJhdGlvKCkgbWV0aG9kKVxuXHRcdFx0XHRcdGlmICh0bS5zdmcpIHsgLy9pZiB3ZSdyZSBzdXBwb3NlZCB0byBhcHBseSB0cmFuc2Zvcm1zIHRvIHRoZSBTVkcgZWxlbWVudCdzIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlLCBtYWtlIHN1cmUgdGhlcmUgYXJlbid0IGFueSBDU1MgdHJhbnNmb3JtcyBhcHBsaWVkIG9yIHRoZXknbGwgb3ZlcnJpZGUgdGhlIGF0dHJpYnV0ZSBvbmVzLiBBbHNvIGNsZWFyIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIGlmIHdlJ3JlIHVzaW5nIENTUywganVzdCB0byBiZSBjbGVhbi5cblx0XHRcdFx0XHRcdGlmIChfdXNlU1ZHVHJhbnNmb3JtQXR0ciAmJiB0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSkge1xuXHRcdFx0XHRcdFx0XHRUd2VlbkxpdGUuZGVsYXllZENhbGwoMC4wMDEsIGZ1bmN0aW9uKCl7IC8vaWYgd2UgYXBwbHkgdGhpcyByaWdodCBhd2F5IChiZWZvcmUgYW55dGhpbmcgaGFzIHJlbmRlcmVkKSwgd2UgcmlzayB0aGVyZSBiZWluZyBubyB0cmFuc2Zvcm1zIGZvciBhIGJyaWVmIG1vbWVudCBhbmQgaXQgYWxzbyBpbnRlcmZlcmVzIHdpdGggYWRqdXN0aW5nIHRoZSB0cmFuc2Zvcm1PcmlnaW4gaW4gYSB0d2VlbiB3aXRoIGltbWVkaWF0ZVJlbmRlcjp0cnVlIChpdCdkIHRyeSByZWFkaW5nIHRoZSBtYXRyaXggYW5kIGl0IHdvdWxkbid0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGRhdGEgaW4gcGxhY2UgYmVjYXVzZSB3ZSBqdXN0IHJlbW92ZWQgaXQpLlxuXHRcdFx0XHRcdFx0XHRcdF9yZW1vdmVQcm9wKHQuc3R5bGUsIF90cmFuc2Zvcm1Qcm9wKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCFfdXNlU1ZHVHJhbnNmb3JtQXR0ciAmJiB0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSkge1xuXHRcdFx0XHRcdFx0XHRUd2VlbkxpdGUuZGVsYXllZENhbGwoMC4wMDEsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0dC5yZW1vdmVBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdG07XG5cdFx0XHR9LFxuXG5cdFx0XHQvL2ZvciBzZXR0aW5nIDJEIHRyYW5zZm9ybXMgaW4gSUU2LCBJRTcsIGFuZCBJRTggKG11c3QgdXNlIGEgXCJmaWx0ZXJcIiB0byBlbXVsYXRlIHRoZSBiZWhhdmlvciBvZiBtb2Rlcm4gZGF5IGJyb3dzZXIgdHJhbnNmb3Jtcylcblx0XHRcdF9zZXRJRVRyYW5zZm9ybVJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR2YXIgdCA9IHRoaXMuZGF0YSwgLy9yZWZlcnMgdG8gdGhlIGVsZW1lbnQncyBfZ3NUcmFuc2Zvcm0gb2JqZWN0XG5cdFx0XHRcdFx0YW5nID0gLXQucm90YXRpb24gKiBfREVHMlJBRCxcblx0XHRcdFx0XHRza2V3ID0gYW5nICsgdC5za2V3WCAqIF9ERUcyUkFELFxuXHRcdFx0XHRcdHJuZCA9IDEwMDAwMCxcblx0XHRcdFx0XHRhID0gKChNYXRoLmNvcyhhbmcpICogdC5zY2FsZVggKiBybmQpIHwgMCkgLyBybmQsXG5cdFx0XHRcdFx0YiA9ICgoTWF0aC5zaW4oYW5nKSAqIHQuc2NhbGVYICogcm5kKSB8IDApIC8gcm5kLFxuXHRcdFx0XHRcdGMgPSAoKE1hdGguc2luKHNrZXcpICogLXQuc2NhbGVZICogcm5kKSB8IDApIC8gcm5kLFxuXHRcdFx0XHRcdGQgPSAoKE1hdGguY29zKHNrZXcpICogdC5zY2FsZVkgKiBybmQpIHwgMCkgLyBybmQsXG5cdFx0XHRcdFx0c3R5bGUgPSB0aGlzLnQuc3R5bGUsXG5cdFx0XHRcdFx0Y3MgPSB0aGlzLnQuY3VycmVudFN0eWxlLFxuXHRcdFx0XHRcdGZpbHRlcnMsIHZhbDtcblx0XHRcdFx0aWYgKCFjcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWwgPSBiOyAvL2p1c3QgZm9yIHN3YXBwaW5nIHRoZSB2YXJpYWJsZXMgYW4gaW52ZXJ0aW5nIHRoZW0gKHJldXNlZCBcInZhbFwiIHRvIGF2b2lkIGNyZWF0aW5nIGFub3RoZXIgdmFyaWFibGUgaW4gbWVtb3J5KS4gSUUncyBmaWx0ZXIgbWF0cml4IHVzZXMgYSBub24tc3RhbmRhcmQgbWF0cml4IGNvbmZpZ3VyYXRpb24gKGFuZ2xlIGdvZXMgdGhlIG9wcG9zaXRlIHdheSwgYW5kIGIgYW5kIGMgYXJlIHJldmVyc2VkIGFuZCBpbnZlcnRlZClcblx0XHRcdFx0YiA9IC1jO1xuXHRcdFx0XHRjID0gLXZhbDtcblx0XHRcdFx0ZmlsdGVycyA9IGNzLmZpbHRlcjtcblx0XHRcdFx0c3R5bGUuZmlsdGVyID0gXCJcIjsgLy9yZW1vdmUgZmlsdGVycyBzbyB0aGF0IHdlIGNhbiBhY2N1cmF0ZWx5IG1lYXN1cmUgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0XG5cdFx0XHRcdHZhciB3ID0gdGhpcy50Lm9mZnNldFdpZHRoLFxuXHRcdFx0XHRcdGggPSB0aGlzLnQub2Zmc2V0SGVpZ2h0LFxuXHRcdFx0XHRcdGNsaXAgPSAoY3MucG9zaXRpb24gIT09IFwiYWJzb2x1dGVcIiksXG5cdFx0XHRcdFx0bSA9IFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9XCIgKyBhICsgXCIsIE0xMj1cIiArIGIgKyBcIiwgTTIxPVwiICsgYyArIFwiLCBNMjI9XCIgKyBkLFxuXHRcdFx0XHRcdG94ID0gdC54ICsgKHcgKiB0LnhQZXJjZW50IC8gMTAwKSxcblx0XHRcdFx0XHRveSA9IHQueSArIChoICogdC55UGVyY2VudCAvIDEwMCksXG5cdFx0XHRcdFx0ZHgsIGR5O1xuXG5cdFx0XHRcdC8vaWYgdHJhbnNmb3JtT3JpZ2luIGlzIGJlaW5nIHVzZWQsIGFkanVzdCB0aGUgb2Zmc2V0IHggYW5kIHlcblx0XHRcdFx0aWYgKHQub3ggIT0gbnVsbCkge1xuXHRcdFx0XHRcdGR4ID0gKCh0Lm94cCkgPyB3ICogdC5veCAqIDAuMDEgOiB0Lm94KSAtIHcgLyAyO1xuXHRcdFx0XHRcdGR5ID0gKCh0Lm95cCkgPyBoICogdC5veSAqIDAuMDEgOiB0Lm95KSAtIGggLyAyO1xuXHRcdFx0XHRcdG94ICs9IGR4IC0gKGR4ICogYSArIGR5ICogYik7XG5cdFx0XHRcdFx0b3kgKz0gZHkgLSAoZHggKiBjICsgZHkgKiBkKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghY2xpcCkge1xuXHRcdFx0XHRcdG0gKz0gXCIsIHNpemluZ01ldGhvZD0nYXV0byBleHBhbmQnKVwiO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGR4ID0gKHcgLyAyKTtcblx0XHRcdFx0XHRkeSA9IChoIC8gMik7XG5cdFx0XHRcdFx0Ly90cmFuc2xhdGUgdG8gZW5zdXJlIHRoYXQgdHJhbnNmb3JtYXRpb25zIG9jY3VyIGFyb3VuZCB0aGUgY29ycmVjdCBvcmlnaW4gKGRlZmF1bHQgaXMgY2VudGVyKS5cblx0XHRcdFx0XHRtICs9IFwiLCBEeD1cIiArIChkeCAtIChkeCAqIGEgKyBkeSAqIGIpICsgb3gpICsgXCIsIER5PVwiICsgKGR5IC0gKGR4ICogYyArIGR5ICogZCkgKyBveSkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZmlsdGVycy5pbmRleE9mKFwiRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRzdHlsZS5maWx0ZXIgPSBmaWx0ZXJzLnJlcGxhY2UoX2llU2V0TWF0cml4RXhwLCBtKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZS5maWx0ZXIgPSBtICsgXCIgXCIgKyBmaWx0ZXJzOyAvL3dlIG11c3QgYWx3YXlzIHB1dCB0aGUgdHJhbnNmb3JtL21hdHJpeCBGSVJTVCAoYmVmb3JlIGFscGhhKG9wYWNpdHk9eHgpKSB0byBhdm9pZCBhbiBJRSBidWcgdGhhdCBzbGljZXMgcGFydCBvZiB0aGUgb2JqZWN0IHdoZW4gcm90YXRpb24gaXMgYXBwbGllZCB3aXRoIGFscGhhLlxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9hdCB0aGUgZW5kIG9yIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4sIGlmIHRoZSBtYXRyaXggaXMgbm9ybWFsICgxLCAwLCAwLCAxKSBhbmQgb3BhY2l0eSBpcyAxMDAgKG9yIGRvZXNuJ3QgZXhpc3QpLCByZW1vdmUgdGhlIGZpbHRlciB0byBpbXByb3ZlIGJyb3dzZXIgcGVyZm9ybWFuY2UuXG5cdFx0XHRcdGlmICh2ID09PSAwIHx8IHYgPT09IDEpIGlmIChhID09PSAxKSBpZiAoYiA9PT0gMCkgaWYgKGMgPT09IDApIGlmIChkID09PSAxKSBpZiAoIWNsaXAgfHwgbS5pbmRleE9mKFwiRHg9MCwgRHk9MFwiKSAhPT0gLTEpIGlmICghX29wYWNpdHlFeHAudGVzdChmaWx0ZXJzKSB8fCBwYXJzZUZsb2F0KFJlZ0V4cC4kMSkgPT09IDEwMCkgaWYgKGZpbHRlcnMuaW5kZXhPZihcImdyYWRpZW50KFwiICYmIGZpbHRlcnMuaW5kZXhPZihcIkFscGhhXCIpKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL3dlIG11c3Qgc2V0IHRoZSBtYXJnaW5zIEFGVEVSIGFwcGx5aW5nIHRoZSBmaWx0ZXIgaW4gb3JkZXIgdG8gYXZvaWQgc29tZSBidWdzIGluIElFOCB0aGF0IGNvdWxkIChpbiByYXJlIHNjZW5hcmlvcykgY2F1c2UgdGhlbSB0byBiZSBpZ25vcmVkIGludGVybWl0dGVudGx5ICh2aWJyYXRpb24pLlxuXHRcdFx0XHRpZiAoIWNsaXApIHtcblx0XHRcdFx0XHR2YXIgbXVsdCA9IChfaWVWZXJzIDwgOCkgPyAxIDogLTEsIC8vaW4gSW50ZXJuZXQgRXhwbG9yZXIgNyBhbmQgYmVmb3JlLCB0aGUgYm94IG1vZGVsIGlzIGJyb2tlbiwgY2F1c2luZyB0aGUgYnJvd3NlciB0byB0cmVhdCB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBhY3R1YWwgcm90YXRlZCBmaWx0ZXJlZCBpbWFnZSBhcyB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBib3ggaXRzZWxmLCBidXQgTWljcm9zb2Z0IGNvcnJlY3RlZCB0aGF0IGluIElFOC4gV2UgbXVzdCB1c2UgYSBuZWdhdGl2ZSBvZmZzZXQgaW4gSUU4IG9uIHRoZSByaWdodC9ib3R0b21cblx0XHRcdFx0XHRcdG1hcmcsIHByb3AsIGRpZjtcblx0XHRcdFx0XHRkeCA9IHQuaWVPZmZzZXRYIHx8IDA7XG5cdFx0XHRcdFx0ZHkgPSB0LmllT2Zmc2V0WSB8fCAwO1xuXHRcdFx0XHRcdHQuaWVPZmZzZXRYID0gTWF0aC5yb3VuZCgodyAtICgoYSA8IDAgPyAtYSA6IGEpICogdyArIChiIDwgMCA/IC1iIDogYikgKiBoKSkgLyAyICsgb3gpO1xuXHRcdFx0XHRcdHQuaWVPZmZzZXRZID0gTWF0aC5yb3VuZCgoaCAtICgoZCA8IDAgPyAtZCA6IGQpICogaCArIChjIDwgMCA/IC1jIDogYykgKiB3KSkgLyAyICsgb3kpO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdFx0XHRcdHByb3AgPSBfbWFyZ2luc1tpXTtcblx0XHRcdFx0XHRcdG1hcmcgPSBjc1twcm9wXTtcblx0XHRcdFx0XHRcdC8vd2UgbmVlZCB0byBnZXQgdGhlIGN1cnJlbnQgbWFyZ2luIGluIGNhc2UgaXQgaXMgYmVpbmcgdHdlZW5lZCBzZXBhcmF0ZWx5ICh3ZSB3YW50IHRvIHJlc3BlY3QgdGhhdCB0d2VlbidzIGNoYW5nZXMpXG5cdFx0XHRcdFx0XHR2YWwgPSAobWFyZy5pbmRleE9mKFwicHhcIikgIT09IC0xKSA/IHBhcnNlRmxvYXQobWFyZykgOiBfY29udmVydFRvUGl4ZWxzKHRoaXMudCwgcHJvcCwgcGFyc2VGbG9hdChtYXJnKSwgbWFyZy5yZXBsYWNlKF9zdWZmaXhFeHAsIFwiXCIpKSB8fCAwO1xuXHRcdFx0XHRcdFx0aWYgKHZhbCAhPT0gdFtwcm9wXSkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoaSA8IDIpID8gLXQuaWVPZmZzZXRYIDogLXQuaWVPZmZzZXRZOyAvL2lmIGFub3RoZXIgdHdlZW4gaXMgY29udHJvbGxpbmcgYSBtYXJnaW4sIHdlIGNhbm5vdCBvbmx5IGFwcGx5IHRoZSBkaWZmZXJlbmNlIGluIHRoZSBpZU9mZnNldHMsIHNvIHdlIGVzc2VudGlhbGx5IHplcm8tb3V0IHRoZSBkeCBhbmQgZHkgaGVyZSBpbiB0aGF0IGNhc2UuIFdlIHJlY29yZCB0aGUgbWFyZ2luKHMpIGxhdGVyIHNvIHRoYXQgd2UgY2FuIGtlZXAgY29tcGFyaW5nIHRoZW0sIG1ha2luZyB0aGlzIGNvZGUgdmVyeSBmbGV4aWJsZS5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9IChpIDwgMikgPyBkeCAtIHQuaWVPZmZzZXRYIDogZHkgLSB0LmllT2Zmc2V0WTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHN0eWxlW3Byb3BdID0gKHRbcHJvcF0gPSBNYXRoLnJvdW5kKCB2YWwgLSBkaWYgKiAoKGkgPT09IDAgfHwgaSA9PT0gMikgPyAxIDogbXVsdCkgKSkgKyBcInB4XCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKiB0cmFuc2xhdGVzIGEgc3VwZXIgc21hbGwgZGVjaW1hbCB0byBhIHN0cmluZyBXSVRIT1VUIHNjaWVudGlmaWMgbm90YXRpb25cblx0XHRcdF9zYWZlRGVjaW1hbCA9IGZ1bmN0aW9uKG4pIHtcblx0XHRcdFx0dmFyIHMgPSAobiA8IDAgPyAtbiA6IG4pICsgXCJcIixcblx0XHRcdFx0XHRhID0gcy5zcGxpdChcImUtXCIpO1xuXHRcdFx0XHRyZXR1cm4gKG4gPCAwID8gXCItMC5cIiA6IFwiMC5cIikgKyBuZXcgQXJyYXkocGFyc2VJbnQoYVsxXSwgMTApIHx8IDApLmpvaW4oXCIwXCIpICsgYVswXS5zcGxpdChcIi5cIikuam9pbihcIlwiKTtcblx0XHRcdH0sXG5cdFx0XHQqL1xuXG5cdFx0XHRfc2V0VHJhbnNmb3JtUmF0aW8gPSBfaW50ZXJuYWxzLnNldDNEVHJhbnNmb3JtUmF0aW8gPSBfaW50ZXJuYWxzLnNldFRyYW5zZm9ybVJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR2YXIgdCA9IHRoaXMuZGF0YSwgLy9yZWZlcnMgdG8gdGhlIGVsZW1lbnQncyBfZ3NUcmFuc2Zvcm0gb2JqZWN0XG5cdFx0XHRcdFx0c3R5bGUgPSB0aGlzLnQuc3R5bGUsXG5cdFx0XHRcdFx0YW5nbGUgPSB0LnJvdGF0aW9uLFxuXHRcdFx0XHRcdHJvdGF0aW9uWCA9IHQucm90YXRpb25YLFxuXHRcdFx0XHRcdHJvdGF0aW9uWSA9IHQucm90YXRpb25ZLFxuXHRcdFx0XHRcdHN4ID0gdC5zY2FsZVgsXG5cdFx0XHRcdFx0c3kgPSB0LnNjYWxlWSxcblx0XHRcdFx0XHRzeiA9IHQuc2NhbGVaLFxuXHRcdFx0XHRcdHggPSB0LngsXG5cdFx0XHRcdFx0eSA9IHQueSxcblx0XHRcdFx0XHR6ID0gdC56LFxuXHRcdFx0XHRcdGlzU1ZHID0gdC5zdmcsXG5cdFx0XHRcdFx0cGVyc3BlY3RpdmUgPSB0LnBlcnNwZWN0aXZlLFxuXHRcdFx0XHRcdGZvcmNlM0QgPSB0LmZvcmNlM0QsXG5cdFx0XHRcdFx0c2tld1kgPSB0LnNrZXdZLFxuXHRcdFx0XHRcdHNrZXdYID0gdC5za2V3WCxcblx0XHRcdFx0XHR0MSxcdGExMSwgYTEyLCBhMTMsIGEyMSwgYTIyLCBhMjMsIGEzMSwgYTMyLCBhMzMsIGE0MSwgYTQyLCBhNDMsXG5cdFx0XHRcdFx0ek9yaWdpbiwgbWluLCBjb3MsIHNpbiwgdDIsIHRyYW5zZm9ybSwgY29tbWEsIHplcm8sIHNrZXcsIHJuZDtcblx0XHRcdFx0aWYgKHNrZXdZKSB7IC8vZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIGNvbWJpbmUgYWxsIHNrZXdpbmcgaW50byB0aGUgc2tld1ggYW5kIHJvdGF0aW9uIHZhbHVlcy4gUmVtZW1iZXIsIGEgc2tld1kgb2YgMTAgZGVncmVlcyBsb29rcyB0aGUgc2FtZSBhcyBhIHJvdGF0aW9uIG9mIDEwIGRlZ3JlZXMgcGx1cyBhIHNrZXdYIG9mIDEwIGRlZ3JlZXMuXG5cdFx0XHRcdFx0c2tld1ggKz0gc2tld1k7XG5cdFx0XHRcdFx0YW5nbGUgKz0gc2tld1k7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL2NoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgcmVuZGVyIGFzIDJEIChhbmQgU1ZHcyBtdXN0IHVzZSAyRCB3aGVuIF91c2VTVkdUcmFuc2Zvcm1BdHRyIGlzIHRydWUpXG5cdFx0XHRcdGlmICgoKCgodiA9PT0gMSB8fCB2ID09PSAwKSAmJiBmb3JjZTNEID09PSBcImF1dG9cIiAmJiAodGhpcy50d2Vlbi5fdG90YWxUaW1lID09PSB0aGlzLnR3ZWVuLl90b3RhbER1cmF0aW9uIHx8ICF0aGlzLnR3ZWVuLl90b3RhbFRpbWUpKSB8fCAhZm9yY2UzRCkgJiYgIXogJiYgIXBlcnNwZWN0aXZlICYmICFyb3RhdGlvblkgJiYgIXJvdGF0aW9uWCAmJiBzeiA9PT0gMSkgfHwgKF91c2VTVkdUcmFuc2Zvcm1BdHRyICYmIGlzU1ZHKSB8fCAhX3N1cHBvcnRzM0QpIHsgLy9vbiB0aGUgZmluYWwgcmVuZGVyICh3aGljaCBjb3VsZCBiZSAwIGZvciBhIGZyb20gdHdlZW4pLCBpZiB0aGVyZSBhcmUgbm8gM0QgYXNwZWN0cywgcmVuZGVyIGluIDJEIHRvIGZyZWUgdXAgbWVtb3J5IGFuZCBpbXByb3ZlIHBlcmZvcm1hbmNlIGVzcGVjaWFsbHkgb24gbW9iaWxlIGRldmljZXMuIENoZWNrIHRoZSB0d2VlbidzIHRvdGFsVGltZS90b3RhbER1cmF0aW9uIHRvbyBpbiBvcmRlciB0byBtYWtlIHN1cmUgaXQgZG9lc24ndCBoYXBwZW4gYmV0d2VlbiByZXBlYXRzIGlmIGl0J3MgYSByZXBlYXRpbmcgdHdlZW4uXG5cblx0XHRcdFx0XHQvLzJEXG5cdFx0XHRcdFx0aWYgKGFuZ2xlIHx8IHNrZXdYIHx8IGlzU1ZHKSB7XG5cdFx0XHRcdFx0XHRhbmdsZSAqPSBfREVHMlJBRDtcblx0XHRcdFx0XHRcdHNrZXcgPSBza2V3WCAqIF9ERUcyUkFEO1xuXHRcdFx0XHRcdFx0cm5kID0gMTAwMDAwO1xuXHRcdFx0XHRcdFx0YTExID0gTWF0aC5jb3MoYW5nbGUpICogc3g7XG5cdFx0XHRcdFx0XHRhMjEgPSBNYXRoLnNpbihhbmdsZSkgKiBzeDtcblx0XHRcdFx0XHRcdGExMiA9IE1hdGguc2luKGFuZ2xlIC0gc2tldykgKiAtc3k7XG5cdFx0XHRcdFx0XHRhMjIgPSBNYXRoLmNvcyhhbmdsZSAtIHNrZXcpICogc3k7XG5cdFx0XHRcdFx0XHRpZiAoc2tldyAmJiB0LnNrZXdUeXBlID09PSBcInNpbXBsZVwiKSB7IC8vYnkgZGVmYXVsdCwgd2UgY29tcGVuc2F0ZSBza2V3aW5nIG9uIHRoZSBvdGhlciBheGlzIHRvIG1ha2UgaXQgbG9vayBtb3JlIG5hdHVyYWwsIGJ1dCB5b3UgY2FuIHNldCB0aGUgc2tld1R5cGUgdG8gXCJzaW1wbGVcIiB0byB1c2UgdGhlIHVuY29tcGVuc2F0ZWQgc2tld2luZyB0aGF0IENTUyBkb2VzXG5cdFx0XHRcdFx0XHRcdHQxID0gTWF0aC50YW4oc2tldyAtIHNrZXdZICogX0RFRzJSQUQpO1xuXHRcdFx0XHRcdFx0XHR0MSA9IE1hdGguc3FydCgxICsgdDEgKiB0MSk7XG5cdFx0XHRcdFx0XHRcdGExMiAqPSB0MTtcblx0XHRcdFx0XHRcdFx0YTIyICo9IHQxO1xuXHRcdFx0XHRcdFx0XHRpZiAoc2tld1kpIHtcblx0XHRcdFx0XHRcdFx0XHR0MSA9IE1hdGgudGFuKHNrZXdZICogX0RFRzJSQUQpO1xuXHRcdFx0XHRcdFx0XHRcdHQxID0gTWF0aC5zcXJ0KDEgKyB0MSAqIHQxKTtcblx0XHRcdFx0XHRcdFx0XHRhMTEgKj0gdDE7XG5cdFx0XHRcdFx0XHRcdFx0YTIxICo9IHQxO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoaXNTVkcpIHtcblx0XHRcdFx0XHRcdFx0eCArPSB0LnhPcmlnaW4gLSAodC54T3JpZ2luICogYTExICsgdC55T3JpZ2luICogYTEyKSArIHQueE9mZnNldDtcblx0XHRcdFx0XHRcdFx0eSArPSB0LnlPcmlnaW4gLSAodC54T3JpZ2luICogYTIxICsgdC55T3JpZ2luICogYTIyKSArIHQueU9mZnNldDtcblx0XHRcdFx0XHRcdFx0aWYgKF91c2VTVkdUcmFuc2Zvcm1BdHRyICYmICh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpKSB7IC8vVGhlIFNWRyBzcGVjIGRvZXNuJ3Qgc3VwcG9ydCBwZXJjZW50YWdlLWJhc2VkIHRyYW5zbGF0aW9uIGluIHRoZSBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSwgc28gd2UgbWVyZ2UgaXQgaW50byB0aGUgbWF0cml4IHRvIHNpbXVsYXRlIGl0LlxuXHRcdFx0XHRcdFx0XHRcdG1pbiA9IHRoaXMudC5nZXRCQm94KCk7XG5cdFx0XHRcdFx0XHRcdFx0eCArPSB0LnhQZXJjZW50ICogMC4wMSAqIG1pbi53aWR0aDtcblx0XHRcdFx0XHRcdFx0XHR5ICs9IHQueVBlcmNlbnQgKiAwLjAxICogbWluLmhlaWdodDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRtaW4gPSAwLjAwMDAwMTtcblx0XHRcdFx0XHRcdFx0aWYgKHggPCBtaW4pIGlmICh4ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0XHRcdHggPSAwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICh5IDwgbWluKSBpZiAoeSA+IC1taW4pIHtcblx0XHRcdFx0XHRcdFx0XHR5ID0gMDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHJhbnNmb3JtID0gKCgoYTExICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgKCgoYTIxICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgKCgoYTEyICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgKCgoYTIyICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgeCArIFwiLFwiICsgeSArIFwiKVwiO1xuXHRcdFx0XHRcdFx0aWYgKGlzU1ZHICYmIF91c2VTVkdUcmFuc2Zvcm1BdHRyKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMudC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJtYXRyaXgoXCIgKyB0cmFuc2Zvcm0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly9zb21lIGJyb3dzZXJzIGhhdmUgYSBoYXJkIHRpbWUgd2l0aCB2ZXJ5IHNtYWxsIHZhbHVlcyBsaWtlIDIuNDQ5MjkzNTk4Mjk0NzA2NGUtMTYgKG5vdGljZSB0aGUgXCJlLVwiIHRvd2FyZHMgdGhlIGVuZCkgYW5kIHdvdWxkIHJlbmRlciB0aGUgb2JqZWN0IHNsaWdodGx5IG9mZi4gU28gd2Ugcm91bmQgdG8gNSBkZWNpbWFsIHBsYWNlcy5cblx0XHRcdFx0XHRcdFx0c3R5bGVbX3RyYW5zZm9ybVByb3BdID0gKCh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpID8gXCJ0cmFuc2xhdGUoXCIgKyB0LnhQZXJjZW50ICsgXCIlLFwiICsgdC55UGVyY2VudCArIFwiJSkgbWF0cml4KFwiIDogXCJtYXRyaXgoXCIpICsgdHJhbnNmb3JtO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSAoKHQueFBlcmNlbnQgfHwgdC55UGVyY2VudCkgPyBcInRyYW5zbGF0ZShcIiArIHQueFBlcmNlbnQgKyBcIiUsXCIgKyB0LnlQZXJjZW50ICsgXCIlKSBtYXRyaXgoXCIgOiBcIm1hdHJpeChcIikgKyBzeCArIFwiLDAsMCxcIiArIHN5ICsgXCIsXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfaXNGaXJlZm94KSB7IC8vRmlyZWZveCBoYXMgYSBidWcgKGF0IGxlYXN0IGluIHYyNSkgdGhhdCBjYXVzZXMgaXQgdG8gcmVuZGVyIHRoZSB0cmFuc3BhcmVudCBwYXJ0IG9mIDMyLWJpdCBQTkcgaW1hZ2VzIGFzIGJsYWNrIHdoZW4gZGlzcGxheWVkIGluc2lkZSBhbiBpZnJhbWUgYW5kIHRoZSAzRCBzY2FsZSBpcyB2ZXJ5IHNtYWxsIGFuZCBkb2Vzbid0IGNoYW5nZSBzdWZmaWNpZW50bHkgZW5vdWdoIGJldHdlZW4gcmVuZGVycyAobGlrZSBpZiB5b3UgdXNlIGEgUG93ZXI0LmVhc2VJbk91dCB0byBzY2FsZSBmcm9tIDAgdG8gMSB3aGVyZSB0aGUgYmVnaW5uaW5nIHZhbHVlcyBvbmx5IGNoYW5nZSBhIHRpbnkgYW1vdW50IHRvIGJlZ2luIHRoZSB0d2VlbiBiZWZvcmUgYWNjZWxlcmF0aW5nKS4gSW4gdGhpcyBjYXNlLCB3ZSBmb3JjZSB0aGUgc2NhbGUgdG8gYmUgMC4wMDAwMiBpbnN0ZWFkIHdoaWNoIGlzIHZpc3VhbGx5IHRoZSBzYW1lIGJ1dCB3b3JrcyBhcm91bmQgdGhlIEZpcmVmb3ggaXNzdWUuXG5cdFx0XHRcdFx0bWluID0gMC4wMDAxO1xuXHRcdFx0XHRcdGlmIChzeCA8IG1pbiAmJiBzeCA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHN4ID0gc3ogPSAwLjAwMDAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc3kgPCBtaW4gJiYgc3kgPiAtbWluKSB7XG5cdFx0XHRcdFx0XHRzeSA9IHN6ID0gMC4wMDAwMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBlcnNwZWN0aXZlICYmICF0LnogJiYgIXQucm90YXRpb25YICYmICF0LnJvdGF0aW9uWSkgeyAvL0ZpcmVmb3ggaGFzIGEgYnVnIHRoYXQgY2F1c2VzIGVsZW1lbnRzIHRvIGhhdmUgYW4gb2RkIHN1cGVyLXRoaW4sIGJyb2tlbi9kb3R0ZWQgYmxhY2sgYm9yZGVyIG9uIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIHBlcnNwZWN0aXZlIHNldCBidXQgYXJlbid0IHV0aWxpemluZyAzRCBzcGFjZSAobm8gcm90YXRpb25YLCByb3RhdGlvblksIG9yIHopLlxuXHRcdFx0XHRcdFx0cGVyc3BlY3RpdmUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYW5nbGUgfHwgc2tld1gpIHtcblx0XHRcdFx0XHRhbmdsZSAqPSBfREVHMlJBRDtcblx0XHRcdFx0XHRjb3MgPSBhMTEgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRcdFx0c2luID0gYTIxID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdGlmIChza2V3WCkge1xuXHRcdFx0XHRcdFx0YW5nbGUgLT0gc2tld1ggKiBfREVHMlJBRDtcblx0XHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHRcdFx0XHRcdGlmICh0LnNrZXdUeXBlID09PSBcInNpbXBsZVwiKSB7IC8vYnkgZGVmYXVsdCwgd2UgY29tcGVuc2F0ZSBza2V3aW5nIG9uIHRoZSBvdGhlciBheGlzIHRvIG1ha2UgaXQgbG9vayBtb3JlIG5hdHVyYWwsIGJ1dCB5b3UgY2FuIHNldCB0aGUgc2tld1R5cGUgdG8gXCJzaW1wbGVcIiB0byB1c2UgdGhlIHVuY29tcGVuc2F0ZWQgc2tld2luZyB0aGF0IENTUyBkb2VzXG5cdFx0XHRcdFx0XHRcdHQxID0gTWF0aC50YW4oKHNrZXdYIC0gc2tld1kpICogX0RFRzJSQUQpO1xuXHRcdFx0XHRcdFx0XHR0MSA9IE1hdGguc3FydCgxICsgdDEgKiB0MSk7XG5cdFx0XHRcdFx0XHRcdGNvcyAqPSB0MTtcblx0XHRcdFx0XHRcdFx0c2luICo9IHQxO1xuXHRcdFx0XHRcdFx0XHRpZiAodC5za2V3WSkge1xuXHRcdFx0XHRcdFx0XHRcdHQxID0gTWF0aC50YW4oc2tld1kgKiBfREVHMlJBRCk7XG5cdFx0XHRcdFx0XHRcdFx0dDEgPSBNYXRoLnNxcnQoMSArIHQxICogdDEpO1xuXHRcdFx0XHRcdFx0XHRcdGExMSAqPSB0MTtcblx0XHRcdFx0XHRcdFx0XHRhMjEgKj0gdDE7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YTEyID0gLXNpbjtcblx0XHRcdFx0XHRhMjIgPSBjb3M7XG5cblx0XHRcdFx0fSBlbHNlIGlmICghcm90YXRpb25ZICYmICFyb3RhdGlvblggJiYgc3ogPT09IDEgJiYgIXBlcnNwZWN0aXZlICYmICFpc1NWRykgeyAvL2lmIHdlJ3JlIG9ubHkgdHJhbnNsYXRpbmcgYW5kL29yIDJEIHNjYWxpbmcsIHRoaXMgaXMgZmFzdGVyLi4uXG5cdFx0XHRcdFx0c3R5bGVbX3RyYW5zZm9ybVByb3BdID0gKCh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpID8gXCJ0cmFuc2xhdGUoXCIgKyB0LnhQZXJjZW50ICsgXCIlLFwiICsgdC55UGVyY2VudCArIFwiJSkgdHJhbnNsYXRlM2QoXCIgOiBcInRyYW5zbGF0ZTNkKFwiKSArIHggKyBcInB4LFwiICsgeSArIFwicHgsXCIgKyB6ICtcInB4KVwiICsgKChzeCAhPT0gMSB8fCBzeSAhPT0gMSkgPyBcIiBzY2FsZShcIiArIHN4ICsgXCIsXCIgKyBzeSArIFwiKVwiIDogXCJcIik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGExMSA9IGEyMiA9IDE7XG5cdFx0XHRcdFx0YTEyID0gYTIxID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBLRVkgIElOREVYICAgQUZGRUNUUyBhW3Jvd11bY29sdW1uXVxuXHRcdFx0XHQvLyBhMTEgIDAgICAgICAgcm90YXRpb24sIHJvdGF0aW9uWSwgc2NhbGVYXG5cdFx0XHRcdC8vIGEyMSAgMSAgICAgICByb3RhdGlvbiwgcm90YXRpb25ZLCBzY2FsZVhcblx0XHRcdFx0Ly8gYTMxICAyICAgICAgIHJvdGF0aW9uWSwgc2NhbGVYXG5cdFx0XHRcdC8vIGE0MSAgMyAgICAgICByb3RhdGlvblksIHNjYWxlWFxuXHRcdFx0XHQvLyBhMTIgIDQgICAgICAgcm90YXRpb24sIHNrZXdYLCByb3RhdGlvblgsIHNjYWxlWVxuXHRcdFx0XHQvLyBhMjIgIDUgICAgICAgcm90YXRpb24sIHNrZXdYLCByb3RhdGlvblgsIHNjYWxlWVxuXHRcdFx0XHQvLyBhMzIgIDYgICAgICAgcm90YXRpb25YLCBzY2FsZVlcblx0XHRcdFx0Ly8gYTQyICA3ICAgICAgIHJvdGF0aW9uWCwgc2NhbGVZXG5cdFx0XHRcdC8vIGExMyAgOCAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGEyMyAgOSAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGEzMyAgMTAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGE0MyAgMTEgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgcGVyc3BlY3RpdmUsIHNjYWxlWlxuXHRcdFx0XHQvLyBhMTQgIDEyICAgICAgeCwgek9yaWdpbiwgc3ZnT3JpZ2luXG5cdFx0XHRcdC8vIGEyNCAgMTMgICAgICB5LCB6T3JpZ2luLCBzdmdPcmlnaW5cblx0XHRcdFx0Ly8gYTM0ICAxNCAgICAgIHosIHpPcmlnaW5cblx0XHRcdFx0Ly8gYTQ0ICAxNVxuXHRcdFx0XHQvLyByb3RhdGlvbjogTWF0aC5hdGFuMihhMjEsIGExMSlcblx0XHRcdFx0Ly8gcm90YXRpb25ZOiBNYXRoLmF0YW4yKGExMywgYTMzKSAob3IgTWF0aC5hdGFuMihhMTMsIGExMSkpXG5cdFx0XHRcdC8vIHJvdGF0aW9uWDogTWF0aC5hdGFuMihhMzIsIGEzMylcblx0XHRcdFx0YTMzID0gMTtcblx0XHRcdFx0YTEzID0gYTIzID0gYTMxID0gYTMyID0gYTQxID0gYTQyID0gMDtcblx0XHRcdFx0YTQzID0gKHBlcnNwZWN0aXZlKSA/IC0xIC8gcGVyc3BlY3RpdmUgOiAwO1xuXHRcdFx0XHR6T3JpZ2luID0gdC56T3JpZ2luO1xuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMTsgLy90aHJlc2hvbGQgYmVsb3cgd2hpY2ggYnJvd3NlcnMgdXNlIHNjaWVudGlmaWMgbm90YXRpb24gd2hpY2ggd29uJ3Qgd29yay5cblx0XHRcdFx0Y29tbWEgPSBcIixcIjtcblx0XHRcdFx0emVybyA9IFwiMFwiO1xuXHRcdFx0XHRhbmdsZSA9IHJvdGF0aW9uWSAqIF9ERUcyUkFEO1xuXHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdGEzMSA9IC1zaW47XG5cdFx0XHRcdFx0YTQxID0gYTQzKi1zaW47XG5cdFx0XHRcdFx0YTEzID0gYTExKnNpbjtcblx0XHRcdFx0XHRhMjMgPSBhMjEqc2luO1xuXHRcdFx0XHRcdGEzMyA9IGNvcztcblx0XHRcdFx0XHRhNDMgKj0gY29zO1xuXHRcdFx0XHRcdGExMSAqPSBjb3M7XG5cdFx0XHRcdFx0YTIxICo9IGNvcztcblx0XHRcdFx0fVxuXHRcdFx0XHRhbmdsZSA9IHJvdGF0aW9uWCAqIF9ERUcyUkFEO1xuXHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdHQxID0gYTEyKmNvcythMTMqc2luO1xuXHRcdFx0XHRcdHQyID0gYTIyKmNvcythMjMqc2luO1xuXHRcdFx0XHRcdGEzMiA9IGEzMypzaW47XG5cdFx0XHRcdFx0YTQyID0gYTQzKnNpbjtcblx0XHRcdFx0XHRhMTMgPSBhMTIqLXNpbithMTMqY29zO1xuXHRcdFx0XHRcdGEyMyA9IGEyMiotc2luK2EyMypjb3M7XG5cdFx0XHRcdFx0YTMzID0gYTMzKmNvcztcblx0XHRcdFx0XHRhNDMgPSBhNDMqY29zO1xuXHRcdFx0XHRcdGExMiA9IHQxO1xuXHRcdFx0XHRcdGEyMiA9IHQyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzeiAhPT0gMSkge1xuXHRcdFx0XHRcdGExMyo9c3o7XG5cdFx0XHRcdFx0YTIzKj1zejtcblx0XHRcdFx0XHRhMzMqPXN6O1xuXHRcdFx0XHRcdGE0Myo9c3o7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHN5ICE9PSAxKSB7XG5cdFx0XHRcdFx0YTEyKj1zeTtcblx0XHRcdFx0XHRhMjIqPXN5O1xuXHRcdFx0XHRcdGEzMio9c3k7XG5cdFx0XHRcdFx0YTQyKj1zeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc3ggIT09IDEpIHtcblx0XHRcdFx0XHRhMTEqPXN4O1xuXHRcdFx0XHRcdGEyMSo9c3g7XG5cdFx0XHRcdFx0YTMxKj1zeDtcblx0XHRcdFx0XHRhNDEqPXN4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHpPcmlnaW4gfHwgaXNTVkcpIHtcblx0XHRcdFx0XHRpZiAoek9yaWdpbikge1xuXHRcdFx0XHRcdFx0eCArPSBhMTMqLXpPcmlnaW47XG5cdFx0XHRcdFx0XHR5ICs9IGEyMyotek9yaWdpbjtcblx0XHRcdFx0XHRcdHogKz0gYTMzKi16T3JpZ2luK3pPcmlnaW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChpc1NWRykgeyAvL2R1ZSB0byBidWdzIGluIHNvbWUgYnJvd3NlcnMsIHdlIG5lZWQgdG8gbWFuYWdlIHRoZSB0cmFuc2Zvcm0tb3JpZ2luIG9mIFNWRyBtYW51YWxseVxuXHRcdFx0XHRcdFx0eCArPSB0LnhPcmlnaW4gLSAodC54T3JpZ2luICogYTExICsgdC55T3JpZ2luICogYTEyKSArIHQueE9mZnNldDtcblx0XHRcdFx0XHRcdHkgKz0gdC55T3JpZ2luIC0gKHQueE9yaWdpbiAqIGEyMSArIHQueU9yaWdpbiAqIGEyMikgKyB0LnlPZmZzZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh4IDwgbWluICYmIHggPiAtbWluKSB7XG5cdFx0XHRcdFx0XHR4ID0gemVybztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHkgPCBtaW4gJiYgeSA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHkgPSB6ZXJvO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoeiA8IG1pbiAmJiB6ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0eiA9IDA7IC8vZG9uJ3QgdXNlIHN0cmluZyBiZWNhdXNlIHdlIGNhbGN1bGF0ZSBwZXJzcGVjdGl2ZSBsYXRlciBhbmQgbmVlZCB0aGUgbnVtYmVyLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vb3B0aW1pemVkIHdheSBvZiBjb25jYXRlbmF0aW5nIGFsbCB0aGUgdmFsdWVzIGludG8gYSBzdHJpbmcuIElmIHdlIGRvIGl0IGFsbCBpbiBvbmUgc2hvdCwgaXQncyBzbG93ZXIgYmVjYXVzZSBvZiB0aGUgd2F5IGJyb3dzZXJzIGhhdmUgdG8gY3JlYXRlIHRlbXAgc3RyaW5ncyBhbmQgdGhlIHdheSBpdCBhZmZlY3RzIG1lbW9yeS4gSWYgd2UgZG8gaXQgcGllY2UtYnktcGllY2Ugd2l0aCArPSwgaXQncyBhIGJpdCBzbG93ZXIgdG9vLiBXZSBmb3VuZCB0aGF0IGRvaW5nIGl0IGluIHRoZXNlIHNpemVkIGNodW5rcyB3b3JrcyBiZXN0IG92ZXJhbGw6XG5cdFx0XHRcdHRyYW5zZm9ybSA9ICgodC54UGVyY2VudCB8fCB0LnlQZXJjZW50KSA/IFwidHJhbnNsYXRlKFwiICsgdC54UGVyY2VudCArIFwiJSxcIiArIHQueVBlcmNlbnQgKyBcIiUpIG1hdHJpeDNkKFwiIDogXCJtYXRyaXgzZChcIik7XG5cdFx0XHRcdHRyYW5zZm9ybSArPSAoKGExMSA8IG1pbiAmJiBhMTEgPiAtbWluKSA/IHplcm8gOiBhMTEpICsgY29tbWEgKyAoKGEyMSA8IG1pbiAmJiBhMjEgPiAtbWluKSA/IHplcm8gOiBhMjEpICsgY29tbWEgKyAoKGEzMSA8IG1pbiAmJiBhMzEgPiAtbWluKSA/IHplcm8gOiBhMzEpO1xuXHRcdFx0XHR0cmFuc2Zvcm0gKz0gY29tbWEgKyAoKGE0MSA8IG1pbiAmJiBhNDEgPiAtbWluKSA/IHplcm8gOiBhNDEpICsgY29tbWEgKyAoKGExMiA8IG1pbiAmJiBhMTIgPiAtbWluKSA/IHplcm8gOiBhMTIpICsgY29tbWEgKyAoKGEyMiA8IG1pbiAmJiBhMjIgPiAtbWluKSA/IHplcm8gOiBhMjIpO1xuXHRcdFx0XHRpZiAocm90YXRpb25YIHx8IHJvdGF0aW9uWSB8fCBzeiAhPT0gMSkgeyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiAob2Z0ZW4gdGhlcmUncyBubyByb3RhdGlvblggb3Igcm90YXRpb25ZLCBzbyB3ZSBjYW4gc2tpcCB0aGVzZSBjYWxjdWxhdGlvbnMpXG5cdFx0XHRcdFx0dHJhbnNmb3JtICs9IGNvbW1hICsgKChhMzIgPCBtaW4gJiYgYTMyID4gLW1pbikgPyB6ZXJvIDogYTMyKSArIGNvbW1hICsgKChhNDIgPCBtaW4gJiYgYTQyID4gLW1pbikgPyB6ZXJvIDogYTQyKSArIGNvbW1hICsgKChhMTMgPCBtaW4gJiYgYTEzID4gLW1pbikgPyB6ZXJvIDogYTEzKTtcblx0XHRcdFx0XHR0cmFuc2Zvcm0gKz0gY29tbWEgKyAoKGEyMyA8IG1pbiAmJiBhMjMgPiAtbWluKSA/IHplcm8gOiBhMjMpICsgY29tbWEgKyAoKGEzMyA8IG1pbiAmJiBhMzMgPiAtbWluKSA/IHplcm8gOiBhMzMpICsgY29tbWEgKyAoKGE0MyA8IG1pbiAmJiBhNDMgPiAtbWluKSA/IHplcm8gOiBhNDMpICsgY29tbWE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dHJhbnNmb3JtICs9IFwiLDAsMCwwLDAsMSwwLFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRyYW5zZm9ybSArPSB4ICsgY29tbWEgKyB5ICsgY29tbWEgKyB6ICsgY29tbWEgKyAocGVyc3BlY3RpdmUgPyAoMSArICgteiAvIHBlcnNwZWN0aXZlKSkgOiAxKSArIFwiKVwiO1xuXG5cdFx0XHRcdHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybTtcblx0XHRcdH07XG5cblx0XHRwID0gVHJhbnNmb3JtLnByb3RvdHlwZTtcblx0XHRwLnggPSBwLnkgPSBwLnogPSBwLnNrZXdYID0gcC5za2V3WSA9IHAucm90YXRpb24gPSBwLnJvdGF0aW9uWCA9IHAucm90YXRpb25ZID0gcC56T3JpZ2luID0gcC54UGVyY2VudCA9IHAueVBlcmNlbnQgPSBwLnhPZmZzZXQgPSBwLnlPZmZzZXQgPSAwO1xuXHRcdHAuc2NhbGVYID0gcC5zY2FsZVkgPSBwLnNjYWxlWiA9IDE7XG5cblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJ0cmFuc2Zvcm0sc2NhbGUsc2NhbGVYLHNjYWxlWSxzY2FsZVoseCx5LHoscm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxyb3RhdGlvblosc2tld1gsc2tld1ksc2hvcnRSb3RhdGlvbixzaG9ydFJvdGF0aW9uWCxzaG9ydFJvdGF0aW9uWSxzaG9ydFJvdGF0aW9uWix0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luLHRyYW5zZm9ybVBlcnNwZWN0aXZlLGRpcmVjdGlvbmFsUm90YXRpb24scGFyc2VUcmFuc2Zvcm0sZm9yY2UzRCxza2V3VHlwZSx4UGVyY2VudCx5UGVyY2VudCxzbW9vdGhPcmlnaW5cIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwYXJzaW5nUHJvcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0aWYgKGNzc3AuX2xhc3RQYXJzZWRUcmFuc2Zvcm0gPT09IHZhcnMpIHsgcmV0dXJuIHB0OyB9IC8vb25seSBuZWVkIHRvIHBhcnNlIHRoZSB0cmFuc2Zvcm0gb25jZSwgYW5kIG9ubHkgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgaXQuXG5cdFx0XHRjc3NwLl9sYXN0UGFyc2VkVHJhbnNmb3JtID0gdmFycztcblx0XHRcdHZhciBzY2FsZUZ1bmMgPSAodmFycy5zY2FsZSAmJiB0eXBlb2YodmFycy5zY2FsZSkgPT09IFwiZnVuY3Rpb25cIikgPyB2YXJzLnNjYWxlIDogMCwgLy9pZiB0aGVyZSdzIGEgZnVuY3Rpb24tYmFzZWQgXCJzY2FsZVwiIHZhbHVlLCBzd2FwIGluIHRoZSByZXN1bHRpbmcgbnVtZXJpYyB2YWx1ZSB0ZW1wb3JhcmlseS4gT3RoZXJ3aXNlLCBpZiBpdCdzIGNhbGxlZCBmb3IgYm90aCBzY2FsZVggYW5kIHNjYWxlWSBpbmRlcGVuZGVudGx5LCB0aGV5IG1heSBub3QgbWF0Y2ggKGxpa2UgaWYgdGhlIGZ1bmN0aW9uIHVzZXMgTWF0aC5yYW5kb20oKSkuXG5cdFx0XHRcdHN3YXBGdW5jO1xuXHRcdFx0aWYgKHR5cGVvZih2YXJzW3BhcnNpbmdQcm9wXSkgPT09IFwiZnVuY3Rpb25cIikgeyAvL3doYXRldmVyIHByb3BlcnR5IHRyaWdnZXJzIHRoZSBpbml0aWFsIHBhcnNpbmcgbWlnaHQgYmUgYSBmdW5jdGlvbi1iYXNlZCB2YWx1ZSBpbiB3aGljaCBjYXNlIGl0IGFscmVhZHkgZ290IGNhbGxlZCBpbiBwYXJzZSgpLCB0aHVzIHdlIGRvbid0IHdhbnQgdG8gY2FsbCBpdCBhZ2FpbiBpbiBoZXJlLiBUaGUgbW9zdCBlZmZpY2llbnQgd2F5IHRvIGF2b2lkIHRoaXMgaXMgdG8gdGVtcG9yYXJpbHkgc3dhcCB0aGUgdmFsdWUgZGlyZWN0bHkgaW50byB0aGUgdmFycyBvYmplY3QsIGFuZCB0aGVuIGFmdGVyIHdlIGRvIGFsbCBvdXIgcGFyc2luZyBpbiB0aGlzIGZ1bmN0aW9uLCB3ZSdsbCBzd2FwIGl0IGJhY2sgYWdhaW4uXG5cdFx0XHRcdHN3YXBGdW5jID0gdmFyc1twYXJzaW5nUHJvcF07XG5cdFx0XHRcdHZhcnNbcGFyc2luZ1Byb3BdID0gZTtcblx0XHRcdH1cblx0XHRcdGlmIChzY2FsZUZ1bmMpIHtcblx0XHRcdFx0dmFycy5zY2FsZSA9IHNjYWxlRnVuYyhfaW5kZXgsIHQpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG9yaWdpbmFsR1NUcmFuc2Zvcm0gPSB0Ll9nc1RyYW5zZm9ybSxcblx0XHRcdFx0c3R5bGUgPSB0LnN0eWxlLFxuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0aSA9IF90cmFuc2Zvcm1Qcm9wcy5sZW5ndGgsXG5cdFx0XHRcdHYgPSB2YXJzLFxuXHRcdFx0XHRlbmRSb3RhdGlvbnMgPSB7fSxcblx0XHRcdFx0dHJhbnNmb3JtT3JpZ2luU3RyaW5nID0gXCJ0cmFuc2Zvcm1PcmlnaW5cIixcblx0XHRcdFx0bTEgPSBfZ2V0VHJhbnNmb3JtKHQsIF9jcywgdHJ1ZSwgdi5wYXJzZVRyYW5zZm9ybSksXG5cdFx0XHRcdG9yaWcgPSB2LnRyYW5zZm9ybSAmJiAoKHR5cGVvZih2LnRyYW5zZm9ybSkgPT09IFwiZnVuY3Rpb25cIikgPyB2LnRyYW5zZm9ybShfaW5kZXgsIF90YXJnZXQpIDogdi50cmFuc2Zvcm0pLFxuXHRcdFx0XHRtMiwgY29weSwgaGFzM0QsIGhhc0NoYW5nZSwgZHIsIHgsIHksIG1hdHJpeCwgcDtcblx0XHRcdG0xLnNrZXdUeXBlID0gdi5za2V3VHlwZSB8fCBtMS5za2V3VHlwZSB8fCBDU1NQbHVnaW4uZGVmYXVsdFNrZXdUeXBlO1xuXHRcdFx0Y3NzcC5fdHJhbnNmb3JtID0gbTE7XG5cdFx0XHRpZiAoXCJyb3RhdGlvblpcIiBpbiB2KSB7XG5cdFx0XHRcdHYucm90YXRpb24gPSB2LnJvdGF0aW9uWjtcblx0XHRcdH1cblx0XHRcdGlmIChvcmlnICYmIHR5cGVvZihvcmlnKSA9PT0gXCJzdHJpbmdcIiAmJiBfdHJhbnNmb3JtUHJvcCkgeyAvL2ZvciB2YWx1ZXMgbGlrZSB0cmFuc2Zvcm06XCJyb3RhdGUoNjBkZWcpIHNjYWxlKDAuNSwgMC44KVwiXG5cdFx0XHRcdGNvcHkgPSBfdGVtcERpdi5zdHlsZTsgLy9kb24ndCB1c2UgdGhlIG9yaWdpbmFsIHRhcmdldCBiZWNhdXNlIGl0IG1pZ2h0IGJlIFNWRyBpbiB3aGljaCBjYXNlIHNvbWUgYnJvd3NlcnMgZG9uJ3QgcmVwb3J0IGNvbXB1dGVkIHN0eWxlIGNvcnJlY3RseS5cblx0XHRcdFx0Y29weVtfdHJhbnNmb3JtUHJvcF0gPSBvcmlnO1xuXHRcdFx0XHRjb3B5LmRpc3BsYXkgPSBcImJsb2NrXCI7IC8vaWYgZGlzcGxheSBpcyBcIm5vbmVcIiwgdGhlIGJyb3dzZXIgb2Z0ZW4gcmVmdXNlcyB0byByZXBvcnQgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIGNvcnJlY3RseS5cblx0XHRcdFx0Y29weS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRcdFx0aWYgKG9yaWcuaW5kZXhPZihcIiVcIikgIT09IC0xKSB7IC8vJS1iYXNlZCB0cmFuc2xhdGlvbnMgd2lsbCBmYWlsIHVubGVzcyB3ZSBzZXQgdGhlIHdpZHRoL2hlaWdodCB0byBtYXRjaCB0aGUgb3JpZ2luYWwgdGFyZ2V0Li4uXG5cdFx0XHRcdFx0Y29weS53aWR0aCA9IF9nZXRTdHlsZSh0LCBcIndpZHRoXCIpO1xuXHRcdFx0XHRcdGNvcHkuaGVpZ2h0ID0gX2dldFN0eWxlKHQsIFwiaGVpZ2h0XCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9kb2MuYm9keS5hcHBlbmRDaGlsZChfdGVtcERpdik7XG5cdFx0XHRcdG0yID0gX2dldFRyYW5zZm9ybShfdGVtcERpdiwgbnVsbCwgZmFsc2UpO1xuXHRcdFx0XHRpZiAobTEuc2tld1R5cGUgPT09IFwic2ltcGxlXCIpIHsgLy90aGUgZGVmYXVsdCBfZ2V0VHJhbnNmb3JtKCkgcmVwb3J0cyB0aGUgc2tld1gvc2NhbGVZIGFzIGlmIHNrZXdUeXBlIGlzIFwiY29tcGVuc2F0ZWRcIiwgdGh1cyB3ZSBuZWVkIHRvIGFkanVzdCB0aGF0IGhlcmUgaWYgc2tld1R5cGUgaXMgXCJzaW1wbGVcIi5cblx0XHRcdFx0XHRtMi5zY2FsZVkgKj0gTWF0aC5jb3MobTIuc2tld1ggKiBfREVHMlJBRCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG0xLnN2ZykgeyAvL2lmIGl0J3MgYW4gU1ZHIGVsZW1lbnQsIHgveSBwYXJ0IG9mIHRoZSBtYXRyaXggd2lsbCBiZSBhZmZlY3RlZCBieSB3aGF0ZXZlciB3ZSB1c2UgYXMgdGhlIG9yaWdpbiBhbmQgdGhlIG9mZnNldHMsIHNvIGNvbXBlbnNhdGUgaGVyZS4uLlxuXHRcdFx0XHRcdHggPSBtMS54T3JpZ2luO1xuXHRcdFx0XHRcdHkgPSBtMS55T3JpZ2luO1xuXHRcdFx0XHRcdG0yLnggLT0gbTEueE9mZnNldDtcblx0XHRcdFx0XHRtMi55IC09IG0xLnlPZmZzZXQ7XG5cdFx0XHRcdFx0aWYgKHYudHJhbnNmb3JtT3JpZ2luIHx8IHYuc3ZnT3JpZ2luKSB7IC8vaWYgdGhpcyB0d2VlbiBpcyBhbHRlcmluZyB0aGUgb3JpZ2luLCB3ZSBtdXN0IGZhY3RvciB0aGF0IGluIGhlcmUuIFRoZSBhY3R1YWwgd29yayBvZiByZWNvcmRpbmcgdGhlIHRyYW5zZm9ybU9yaWdpbiB2YWx1ZXMgYW5kIHNldHRpbmcgdXAgdGhlIFByb3BUd2VlbiBpcyBkb25lIGxhdGVyIChzdGlsbCBpbnNpZGUgdGhpcyBmdW5jdGlvbikgc28gd2UgY2Fubm90IGxlYXZlIHRoZSBjaGFuZ2VzIGludGFjdCBoZXJlIC0gd2Ugb25seSB3YW50IHRvIHVwZGF0ZSB0aGUgeC95IGFjY29yZGluZ2x5LlxuXHRcdFx0XHRcdFx0b3JpZyA9IHt9O1xuXHRcdFx0XHRcdFx0X3BhcnNlU1ZHT3JpZ2luKHQsIF9wYXJzZVBvc2l0aW9uKHYudHJhbnNmb3JtT3JpZ2luKSwgb3JpZywgdi5zdmdPcmlnaW4sIHYuc21vb3RoT3JpZ2luLCB0cnVlKTtcblx0XHRcdFx0XHRcdHggPSBvcmlnLnhPcmlnaW47XG5cdFx0XHRcdFx0XHR5ID0gb3JpZy55T3JpZ2luO1xuXHRcdFx0XHRcdFx0bTIueCAtPSBvcmlnLnhPZmZzZXQgLSBtMS54T2Zmc2V0O1xuXHRcdFx0XHRcdFx0bTIueSAtPSBvcmlnLnlPZmZzZXQgLSBtMS55T2Zmc2V0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoeCB8fCB5KSB7XG5cdFx0XHRcdFx0XHRtYXRyaXggPSBfZ2V0TWF0cml4KF90ZW1wRGl2LCB0cnVlKTtcblx0XHRcdFx0XHRcdG0yLnggLT0geCAtICh4ICogbWF0cml4WzBdICsgeSAqIG1hdHJpeFsyXSk7XG5cdFx0XHRcdFx0XHRtMi55IC09IHkgLSAoeCAqIG1hdHJpeFsxXSArIHkgKiBtYXRyaXhbM10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRfZG9jLmJvZHkucmVtb3ZlQ2hpbGQoX3RlbXBEaXYpO1xuXHRcdFx0XHRpZiAoIW0yLnBlcnNwZWN0aXZlKSB7XG5cdFx0XHRcdFx0bTIucGVyc3BlY3RpdmUgPSBtMS5wZXJzcGVjdGl2ZTsgLy90d2VlbmluZyB0byBubyBwZXJzcGVjdGl2ZSBnaXZlcyB2ZXJ5IHVuaW50dWl0aXZlIHJlc3VsdHMgLSBqdXN0IGtlZXAgdGhlIHNhbWUgcGVyc3BlY3RpdmUgaW4gdGhhdCBjYXNlLlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2LnhQZXJjZW50ICE9IG51bGwpIHtcblx0XHRcdFx0XHRtMi54UGVyY2VudCA9IF9wYXJzZVZhbCh2LnhQZXJjZW50LCBtMS54UGVyY2VudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYueVBlcmNlbnQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdG0yLnlQZXJjZW50ID0gX3BhcnNlVmFsKHYueVBlcmNlbnQsIG0xLnlQZXJjZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodikgPT09IFwib2JqZWN0XCIpIHsgLy9mb3IgdmFsdWVzIGxpa2Ugc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCB4LCB5LCBza2V3WCwgYW5kIHNrZXdZIG9yIHRyYW5zZm9ybTp7Li4ufSAob2JqZWN0KVxuXHRcdFx0XHRtMiA9IHtzY2FsZVg6X3BhcnNlVmFsKCh2LnNjYWxlWCAhPSBudWxsKSA/IHYuc2NhbGVYIDogdi5zY2FsZSwgbTEuc2NhbGVYKSxcblx0XHRcdFx0XHRzY2FsZVk6X3BhcnNlVmFsKCh2LnNjYWxlWSAhPSBudWxsKSA/IHYuc2NhbGVZIDogdi5zY2FsZSwgbTEuc2NhbGVZKSxcblx0XHRcdFx0XHRzY2FsZVo6X3BhcnNlVmFsKHYuc2NhbGVaLCBtMS5zY2FsZVopLFxuXHRcdFx0XHRcdHg6X3BhcnNlVmFsKHYueCwgbTEueCksXG5cdFx0XHRcdFx0eTpfcGFyc2VWYWwodi55LCBtMS55KSxcblx0XHRcdFx0XHR6Ol9wYXJzZVZhbCh2LnosIG0xLnopLFxuXHRcdFx0XHRcdHhQZXJjZW50Ol9wYXJzZVZhbCh2LnhQZXJjZW50LCBtMS54UGVyY2VudCksXG5cdFx0XHRcdFx0eVBlcmNlbnQ6X3BhcnNlVmFsKHYueVBlcmNlbnQsIG0xLnlQZXJjZW50KSxcblx0XHRcdFx0XHRwZXJzcGVjdGl2ZTpfcGFyc2VWYWwodi50cmFuc2Zvcm1QZXJzcGVjdGl2ZSwgbTEucGVyc3BlY3RpdmUpfTtcblx0XHRcdFx0ZHIgPSB2LmRpcmVjdGlvbmFsUm90YXRpb247XG5cdFx0XHRcdGlmIChkciAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZihkcikgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0XHRcdGZvciAoY29weSBpbiBkcikge1xuXHRcdFx0XHRcdFx0XHR2W2NvcHldID0gZHJbY29weV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHYucm90YXRpb24gPSBkcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGVvZih2LngpID09PSBcInN0cmluZ1wiICYmIHYueC5pbmRleE9mKFwiJVwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRtMi54ID0gMDtcblx0XHRcdFx0XHRtMi54UGVyY2VudCA9IF9wYXJzZVZhbCh2LngsIG0xLnhQZXJjZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZW9mKHYueSkgPT09IFwic3RyaW5nXCIgJiYgdi55LmluZGV4T2YoXCIlXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdG0yLnkgPSAwO1xuXHRcdFx0XHRcdG0yLnlQZXJjZW50ID0gX3BhcnNlVmFsKHYueSwgbTEueVBlcmNlbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bTIucm90YXRpb24gPSBfcGFyc2VBbmdsZSgoXCJyb3RhdGlvblwiIGluIHYpID8gdi5yb3RhdGlvbiA6IChcInNob3J0Um90YXRpb25cIiBpbiB2KSA/IHYuc2hvcnRSb3RhdGlvbiArIFwiX3Nob3J0XCIgOiBtMS5yb3RhdGlvbiwgbTEucm90YXRpb24sIFwicm90YXRpb25cIiwgZW5kUm90YXRpb25zKTtcblx0XHRcdFx0aWYgKF9zdXBwb3J0czNEKSB7XG5cdFx0XHRcdFx0bTIucm90YXRpb25YID0gX3BhcnNlQW5nbGUoKFwicm90YXRpb25YXCIgaW4gdikgPyB2LnJvdGF0aW9uWCA6IChcInNob3J0Um90YXRpb25YXCIgaW4gdikgPyB2LnNob3J0Um90YXRpb25YICsgXCJfc2hvcnRcIiA6IG0xLnJvdGF0aW9uWCB8fCAwLCBtMS5yb3RhdGlvblgsIFwicm90YXRpb25YXCIsIGVuZFJvdGF0aW9ucyk7XG5cdFx0XHRcdFx0bTIucm90YXRpb25ZID0gX3BhcnNlQW5nbGUoKFwicm90YXRpb25ZXCIgaW4gdikgPyB2LnJvdGF0aW9uWSA6IChcInNob3J0Um90YXRpb25ZXCIgaW4gdikgPyB2LnNob3J0Um90YXRpb25ZICsgXCJfc2hvcnRcIiA6IG0xLnJvdGF0aW9uWSB8fCAwLCBtMS5yb3RhdGlvblksIFwicm90YXRpb25ZXCIsIGVuZFJvdGF0aW9ucyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bTIuc2tld1ggPSBfcGFyc2VBbmdsZSh2LnNrZXdYLCBtMS5za2V3WCk7XG5cdFx0XHRcdG0yLnNrZXdZID0gX3BhcnNlQW5nbGUodi5za2V3WSwgbTEuc2tld1kpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKF9zdXBwb3J0czNEICYmIHYuZm9yY2UzRCAhPSBudWxsKSB7XG5cdFx0XHRcdG0xLmZvcmNlM0QgPSB2LmZvcmNlM0Q7XG5cdFx0XHRcdGhhc0NoYW5nZSA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGhhczNEID0gKG0xLmZvcmNlM0QgfHwgbTEueiB8fCBtMS5yb3RhdGlvblggfHwgbTEucm90YXRpb25ZIHx8IG0yLnogfHwgbTIucm90YXRpb25YIHx8IG0yLnJvdGF0aW9uWSB8fCBtMi5wZXJzcGVjdGl2ZSk7XG5cdFx0XHRpZiAoIWhhczNEICYmIHYuc2NhbGUgIT0gbnVsbCkge1xuXHRcdFx0XHRtMi5zY2FsZVogPSAxOyAvL25vIG5lZWQgdG8gdHdlZW4gc2NhbGVaLlxuXHRcdFx0fVxuXG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0cCA9IF90cmFuc2Zvcm1Qcm9wc1tpXTtcblx0XHRcdFx0b3JpZyA9IG0yW3BdIC0gbTFbcF07XG5cdFx0XHRcdGlmIChvcmlnID4gbWluIHx8IG9yaWcgPCAtbWluIHx8IHZbcF0gIT0gbnVsbCB8fCBfZm9yY2VQVFtwXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aGFzQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4obTEsIHAsIG0xW3BdLCBvcmlnLCBwdCk7XG5cdFx0XHRcdFx0aWYgKHAgaW4gZW5kUm90YXRpb25zKSB7XG5cdFx0XHRcdFx0XHRwdC5lID0gZW5kUm90YXRpb25zW3BdOyAvL2RpcmVjdGlvbmFsIHJvdGF0aW9ucyB0eXBpY2FsbHkgaGF2ZSBjb21wZW5zYXRlZCB2YWx1ZXMgZHVyaW5nIHRoZSB0d2VlbiwgYnV0IHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZXkgZW5kIGF0IGV4YWN0bHkgd2hhdCB0aGUgdXNlciByZXF1ZXN0ZWRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQueHMwID0gMDsgLy9lbnN1cmVzIHRoZSB2YWx1ZSBzdGF5cyBudW1lcmljIGluIHNldFJhdGlvKClcblx0XHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdFx0Y3NzcC5fb3ZlcndyaXRlUHJvcHMucHVzaChwdC5uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRvcmlnID0gdi50cmFuc2Zvcm1PcmlnaW47XG5cdFx0XHRpZiAobTEuc3ZnICYmIChvcmlnIHx8IHYuc3ZnT3JpZ2luKSkge1xuXHRcdFx0XHR4ID0gbTEueE9mZnNldDsgLy93aGVuIHdlIGNoYW5nZSB0aGUgb3JpZ2luLCBpbiBvcmRlciB0byBwcmV2ZW50IHRoaW5ncyBmcm9tIGp1bXBpbmcgd2UgYWRqdXN0IHRoZSB4L3kgc28gd2UgbXVzdCByZWNvcmQgdGhvc2UgaGVyZSBzbyB0aGF0IHdlIGNhbiBjcmVhdGUgUHJvcFR3ZWVucyBmb3IgdGhlbSBhbmQgZmxpcCB0aGVtIGF0IHRoZSBzYW1lIHRpbWUgYXMgdGhlIG9yaWdpblxuXHRcdFx0XHR5ID0gbTEueU9mZnNldDtcblx0XHRcdFx0X3BhcnNlU1ZHT3JpZ2luKHQsIF9wYXJzZVBvc2l0aW9uKG9yaWcpLCBtMiwgdi5zdmdPcmlnaW4sIHYuc21vb3RoT3JpZ2luKTtcblx0XHRcdFx0cHQgPSBfYWRkTm9uVHdlZW5pbmdOdW1lcmljUFQobTEsIFwieE9yaWdpblwiLCAob3JpZ2luYWxHU1RyYW5zZm9ybSA/IG0xIDogbTIpLnhPcmlnaW4sIG0yLnhPcmlnaW4sIHB0LCB0cmFuc2Zvcm1PcmlnaW5TdHJpbmcpOyAvL25vdGU6IGlmIHRoZXJlIHdhc24ndCBhIHRyYW5zZm9ybU9yaWdpbiBkZWZpbmVkIHlldCwganVzdCBzdGFydCB3aXRoIHRoZSBkZXN0aW5hdGlvbiBvbmU7IGl0J3Mgd2FzdGVmdWwgb3RoZXJ3aXNlLCBhbmQgaXQgY2F1c2VzIHByb2JsZW1zIHdpdGggZnJvbVRvKCkgdHdlZW5zLiBGb3IgZXhhbXBsZSwgVHdlZW5MaXRlLnRvKFwiI3doZWVsXCIsIDMsIHtyb3RhdGlvbjoxODAsIHRyYW5zZm9ybU9yaWdpbjpcIjUwJSA1MCVcIiwgZGVsYXk6MX0pOyBUd2VlbkxpdGUuZnJvbVRvKFwiI3doZWVsXCIsIDMsIHtzY2FsZTowLjUsIHRyYW5zZm9ybU9yaWdpbjpcIjUwJSA1MCVcIn0sIHtzY2FsZToxLCBkZWxheToyfSk7IHdvdWxkIGNhdXNlIGEganVtcCB3aGVuIHRoZSBmcm9tIHZhbHVlcyByZXZlcnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgMm5kIHR3ZWVuLlxuXHRcdFx0XHRwdCA9IF9hZGROb25Ud2VlbmluZ051bWVyaWNQVChtMSwgXCJ5T3JpZ2luXCIsIChvcmlnaW5hbEdTVHJhbnNmb3JtID8gbTEgOiBtMikueU9yaWdpbiwgbTIueU9yaWdpbiwgcHQsIHRyYW5zZm9ybU9yaWdpblN0cmluZyk7XG5cdFx0XHRcdGlmICh4ICE9PSBtMS54T2Zmc2V0IHx8IHkgIT09IG0xLnlPZmZzZXQpIHtcblx0XHRcdFx0XHRwdCA9IF9hZGROb25Ud2VlbmluZ051bWVyaWNQVChtMSwgXCJ4T2Zmc2V0XCIsIChvcmlnaW5hbEdTVHJhbnNmb3JtID8geCA6IG0xLnhPZmZzZXQpLCBtMS54T2Zmc2V0LCBwdCwgdHJhbnNmb3JtT3JpZ2luU3RyaW5nKTtcblx0XHRcdFx0XHRwdCA9IF9hZGROb25Ud2VlbmluZ051bWVyaWNQVChtMSwgXCJ5T2Zmc2V0XCIsIChvcmlnaW5hbEdTVHJhbnNmb3JtID8geSA6IG0xLnlPZmZzZXQpLCBtMS55T2Zmc2V0LCBwdCwgdHJhbnNmb3JtT3JpZ2luU3RyaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcmlnID0gXCIwcHggMHB4XCI7IC8vY2VydGFpbiBicm93c2VycyAobGlrZSBmaXJlZm94KSBjb21wbGV0ZWx5IGJvdGNoIHRyYW5zZm9ybS1vcmlnaW4sIHNvIHdlIG11c3QgcmVtb3ZlIGl0IHRvIHByZXZlbnQgaXQgZnJvbSBjb250YW1pbmF0aW5nIHRyYW5zZm9ybXMuIFdlIG1hbmFnZSBpdCBvdXJzZWx2ZXMgd2l0aCB4T3JpZ2luIGFuZCB5T3JpZ2luXG5cdFx0XHR9XG5cdFx0XHRpZiAob3JpZyB8fCAoX3N1cHBvcnRzM0QgJiYgaGFzM0QgJiYgbTEuek9yaWdpbikpIHsgLy9pZiBhbnl0aGluZyAzRCBpcyBoYXBwZW5pbmcgYW5kIHRoZXJlJ3MgYSB0cmFuc2Zvcm1PcmlnaW4gd2l0aCBhIHogY29tcG9uZW50IHRoYXQncyBub24temVybywgd2UgbXVzdCBlbnN1cmUgdGhhdCB0aGUgdHJhbnNmb3JtT3JpZ2luJ3Mgei1jb21wb25lbnQgaXMgc2V0IHRvIDAgc28gdGhhdCB3ZSBjYW4gbWFudWFsbHkgZG8gdGhvc2UgY2FsY3VsYXRpb25zIHRvIGdldCBhcm91bmQgU2FmYXJpIGJ1Z3MuIEV2ZW4gaWYgdGhlIHVzZXIgZGlkbid0IHNwZWNpZmljYWxseSBkZWZpbmUgYSBcInRyYW5zZm9ybU9yaWdpblwiIGluIHRoaXMgcGFydGljdWxhciB0d2VlbiAobWF5YmUgdGhleSBkaWQgaXQgdmlhIGNzcyBkaXJlY3RseSkuXG5cdFx0XHRcdGlmIChfdHJhbnNmb3JtUHJvcCkge1xuXHRcdFx0XHRcdGhhc0NoYW5nZSA9IHRydWU7XG5cdFx0XHRcdFx0cCA9IF90cmFuc2Zvcm1PcmlnaW5Qcm9wO1xuXHRcdFx0XHRcdG9yaWcgPSAob3JpZyB8fCBfZ2V0U3R5bGUodCwgcCwgX2NzLCBmYWxzZSwgXCI1MCUgNTAlXCIpKSArIFwiXCI7IC8vY2FzdCBhcyBzdHJpbmcgdG8gYXZvaWQgZXJyb3JzXG5cdFx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHN0eWxlLCBwLCAwLCAwLCBwdCwgLTEsIHRyYW5zZm9ybU9yaWdpblN0cmluZyk7XG5cdFx0XHRcdFx0cHQuYiA9IHN0eWxlW3BdO1xuXHRcdFx0XHRcdHB0LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0XHRpZiAoX3N1cHBvcnRzM0QpIHtcblx0XHRcdFx0XHRcdGNvcHkgPSBtMS56T3JpZ2luO1xuXHRcdFx0XHRcdFx0b3JpZyA9IG9yaWcuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdFx0bTEuek9yaWdpbiA9ICgob3JpZy5sZW5ndGggPiAyICYmICEoY29weSAhPT0gMCAmJiBvcmlnWzJdID09PSBcIjBweFwiKSkgPyBwYXJzZUZsb2F0KG9yaWdbMl0pIDogY29weSkgfHwgMDsgLy9TYWZhcmkgZG9lc24ndCBoYW5kbGUgdGhlIHogcGFydCBvZiB0cmFuc2Zvcm1PcmlnaW4gY29ycmVjdGx5LCBzbyB3ZSdsbCBtYW51YWxseSBoYW5kbGUgaXQgaW4gdGhlIF9zZXQzRFRyYW5zZm9ybVJhdGlvKCkgbWV0aG9kLlxuXHRcdFx0XHRcdFx0cHQueHMwID0gcHQuZSA9IG9yaWdbMF0gKyBcIiBcIiArIChvcmlnWzFdIHx8IFwiNTAlXCIpICsgXCIgMHB4XCI7IC8vd2UgbXVzdCBkZWZpbmUgYSB6IHZhbHVlIG9mIDBweCBzcGVjaWZpY2FsbHkgb3RoZXJ3aXNlIGlPUyA1IFNhZmFyaSB3aWxsIHN0aWNrIHdpdGggdGhlIG9sZCBvbmUgKGlmIG9uZSB3YXMgZGVmaW5lZCkhXG5cdFx0XHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4obTEsIFwiek9yaWdpblwiLCAwLCAwLCBwdCwgLTEsIHB0Lm4pOyAvL3dlIG11c3QgY3JlYXRlIGEgQ1NTUHJvcFR3ZWVuIGZvciB0aGUgX2dzVHJhbnNmb3JtLnpPcmlnaW4gc28gdGhhdCBpdCBnZXRzIHJlc2V0IHByb3Blcmx5IGF0IHRoZSBiZWdpbm5pbmcgaWYgdGhlIHR3ZWVuIHJ1bnMgYmFja3dhcmQgKGFzIG9wcG9zZWQgdG8ganVzdCBzZXR0aW5nIG0xLnpPcmlnaW4gaGVyZSlcblx0XHRcdFx0XHRcdHB0LmIgPSBjb3B5O1xuXHRcdFx0XHRcdFx0cHQueHMwID0gcHQuZSA9IG0xLnpPcmlnaW47XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0LnhzMCA9IHB0LmUgPSBvcmlnO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vZm9yIG9sZGVyIHZlcnNpb25zIG9mIElFICg2LTgpLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IGNhbGN1bGF0ZSB0aGluZ3MgaW5zaWRlIHRoZSBzZXRSYXRpbygpIGZ1bmN0aW9uLiBXZSByZWNvcmQgb3JpZ2luIHggYW5kIHkgKG94IGFuZCBveSkgYW5kIHdoZXRoZXIgb3Igbm90IHRoZSB2YWx1ZXMgYXJlIHBlcmNlbnRhZ2VzIChveHAgYW5kIG95cCkuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X3BhcnNlUG9zaXRpb24ob3JpZyArIFwiXCIsIG0xKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc0NoYW5nZSkge1xuXHRcdFx0XHRjc3NwLl90cmFuc2Zvcm1UeXBlID0gKCEobTEuc3ZnICYmIF91c2VTVkdUcmFuc2Zvcm1BdHRyKSAmJiAoaGFzM0QgfHwgdGhpcy5fdHJhbnNmb3JtVHlwZSA9PT0gMykpID8gMyA6IDI7IC8vcXVpY2tlciB0aGFuIGNhbGxpbmcgY3NzcC5fZW5hYmxlVHJhbnNmb3JtcygpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN3YXBGdW5jKSB7XG5cdFx0XHRcdHZhcnNbcGFyc2luZ1Byb3BdID0gc3dhcEZ1bmM7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2NhbGVGdW5jKSB7XG5cdFx0XHRcdHZhcnMuc2NhbGUgPSBzY2FsZUZ1bmM7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fSwgcHJlZml4OnRydWV9KTtcblxuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJveFNoYWRvd1wiLCB7ZGVmYXVsdFZhbHVlOlwiMHB4IDBweCAwcHggMHB4ICM5OTlcIiwgcHJlZml4OnRydWUsIGNvbG9yOnRydWUsIG11bHRpOnRydWUsIGtleXdvcmQ6XCJpbnNldFwifSk7XG5cblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJib3JkZXJSYWRpdXNcIiwge2RlZmF1bHRWYWx1ZTpcIjBweFwiLCBwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0ZSA9IHRoaXMuZm9ybWF0KGUpO1xuXHRcdFx0dmFyIHByb3BzID0gW1wiYm9yZGVyVG9wTGVmdFJhZGl1c1wiLFwiYm9yZGVyVG9wUmlnaHRSYWRpdXNcIixcImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCIsXCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzXCJdLFxuXHRcdFx0XHRzdHlsZSA9IHQuc3R5bGUsXG5cdFx0XHRcdGVhMSwgaSwgZXMyLCBiczIsIGJzLCBlcywgYm4sIGVuLCB3LCBoLCBlc2Z4LCBic2Z4LCByZWwsIGhuLCB2biwgZW07XG5cdFx0XHR3ID0gcGFyc2VGbG9hdCh0Lm9mZnNldFdpZHRoKTtcblx0XHRcdGggPSBwYXJzZUZsb2F0KHQub2Zmc2V0SGVpZ2h0KTtcblx0XHRcdGVhMSA9IGUuc3BsaXQoXCIgXCIpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IC8vaWYgd2UncmUgZGVhbGluZyB3aXRoIHBlcmNlbnRhZ2VzLCB3ZSBtdXN0IGNvbnZlcnQgdGhpbmdzIHNlcGFyYXRlbHkgZm9yIHRoZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBheGlzIVxuXHRcdFx0XHRpZiAodGhpcy5wLmluZGV4T2YoXCJib3JkZXJcIikpIHsgLy9vbGRlciBicm93c2VycyB1c2VkIGEgcHJlZml4XG5cdFx0XHRcdFx0cHJvcHNbaV0gPSBfY2hlY2tQcm9wUHJlZml4KHByb3BzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicyA9IGJzMiA9IF9nZXRTdHlsZSh0LCBwcm9wc1tpXSwgX2NzLCBmYWxzZSwgXCIwcHhcIik7XG5cdFx0XHRcdGlmIChicy5pbmRleE9mKFwiIFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRiczIgPSBicy5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0YnMgPSBiczJbMF07XG5cdFx0XHRcdFx0YnMyID0gYnMyWzFdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVzID0gZXMyID0gZWExW2ldO1xuXHRcdFx0XHRibiA9IHBhcnNlRmxvYXQoYnMpO1xuXHRcdFx0XHRic2Z4ID0gYnMuc3Vic3RyKChibiArIFwiXCIpLmxlbmd0aCk7XG5cdFx0XHRcdHJlbCA9IChlcy5jaGFyQXQoMSkgPT09IFwiPVwiKTtcblx0XHRcdFx0aWYgKHJlbCkge1xuXHRcdFx0XHRcdGVuID0gcGFyc2VJbnQoZXMuY2hhckF0KDApK1wiMVwiLCAxMCk7XG5cdFx0XHRcdFx0ZXMgPSBlcy5zdWJzdHIoMik7XG5cdFx0XHRcdFx0ZW4gKj0gcGFyc2VGbG9hdChlcyk7XG5cdFx0XHRcdFx0ZXNmeCA9IGVzLnN1YnN0cigoZW4gKyBcIlwiKS5sZW5ndGggLSAoZW4gPCAwID8gMSA6IDApKSB8fCBcIlwiO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVuID0gcGFyc2VGbG9hdChlcyk7XG5cdFx0XHRcdFx0ZXNmeCA9IGVzLnN1YnN0cigoZW4gKyBcIlwiKS5sZW5ndGgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlc2Z4ID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0ZXNmeCA9IF9zdWZmaXhNYXBbcF0gfHwgYnNmeDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZXNmeCAhPT0gYnNmeCkge1xuXHRcdFx0XHRcdGhuID0gX2NvbnZlcnRUb1BpeGVscyh0LCBcImJvcmRlckxlZnRcIiwgYm4sIGJzZngpOyAvL2hvcml6b250YWwgbnVtYmVyICh3ZSB1c2UgYSBib2d1cyBcImJvcmRlckxlZnRcIiBwcm9wZXJ0eSBqdXN0IGJlY2F1c2UgdGhlIF9jb252ZXJ0VG9QaXhlbHMoKSBtZXRob2Qgc2VhcmNoZXMgZm9yIHRoZSBrZXl3b3JkcyBcIkxlZnRcIiwgXCJSaWdodFwiLCBcIlRvcFwiLCBhbmQgXCJCb3R0b21cIiB0byBkZXRlcm1pbmUgb2YgaXQncyBhIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydHksIGFuZCB3ZSBuZWVkIFwiYm9yZGVyXCIgaW4gdGhlIG5hbWUgc28gdGhhdCBpdCBrbm93cyBpdCBzaG91bGQgbWVhc3VyZSByZWxhdGl2ZSB0byB0aGUgZWxlbWVudCBpdHNlbGYsIG5vdCBpdHMgcGFyZW50LlxuXHRcdFx0XHRcdHZuID0gX2NvbnZlcnRUb1BpeGVscyh0LCBcImJvcmRlclRvcFwiLCBibiwgYnNmeCk7IC8vdmVydGljYWwgbnVtYmVyXG5cdFx0XHRcdFx0aWYgKGVzZnggPT09IFwiJVwiKSB7XG5cdFx0XHRcdFx0XHRicyA9IChobiAvIHcgKiAxMDApICsgXCIlXCI7XG5cdFx0XHRcdFx0XHRiczIgPSAodm4gLyBoICogMTAwKSArIFwiJVwiO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZXNmeCA9PT0gXCJlbVwiKSB7XG5cdFx0XHRcdFx0XHRlbSA9IF9jb252ZXJ0VG9QaXhlbHModCwgXCJib3JkZXJMZWZ0XCIsIDEsIFwiZW1cIik7XG5cdFx0XHRcdFx0XHRicyA9IChobiAvIGVtKSArIFwiZW1cIjtcblx0XHRcdFx0XHRcdGJzMiA9ICh2biAvIGVtKSArIFwiZW1cIjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YnMgPSBobiArIFwicHhcIjtcblx0XHRcdFx0XHRcdGJzMiA9IHZuICsgXCJweFwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocmVsKSB7XG5cdFx0XHRcdFx0XHRlcyA9IChwYXJzZUZsb2F0KGJzKSArIGVuKSArIGVzZng7XG5cdFx0XHRcdFx0XHRlczIgPSAocGFyc2VGbG9hdChiczIpICsgZW4pICsgZXNmeDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBfcGFyc2VDb21wbGV4KHN0eWxlLCBwcm9wc1tpXSwgYnMgKyBcIiBcIiArIGJzMiwgZXMgKyBcIiBcIiArIGVzMiwgZmFsc2UsIFwiMHB4XCIsIHB0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwdDtcblx0XHR9LCBwcmVmaXg6dHJ1ZSwgZm9ybWF0dGVyOl9nZXRGb3JtYXR0ZXIoXCIwcHggMHB4IDBweCAwcHhcIiwgZmFsc2UsIHRydWUpfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYm9yZGVyQm90dG9tTGVmdFJhZGl1cyxib3JkZXJCb3R0b21SaWdodFJhZGl1cyxib3JkZXJUb3BMZWZ0UmFkaXVzLGJvcmRlclRvcFJpZ2h0UmFkaXVzXCIsIHtkZWZhdWx0VmFsdWU6XCIwcHhcIiwgcGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdHJldHVybiBfcGFyc2VDb21wbGV4KHQuc3R5bGUsIHAsIHRoaXMuZm9ybWF0KF9nZXRTdHlsZSh0LCBwLCBfY3MsIGZhbHNlLCBcIjBweCAwcHhcIikpLCB0aGlzLmZvcm1hdChlKSwgZmFsc2UsIFwiMHB4XCIsIHB0KTtcblx0XHR9LCBwcmVmaXg6dHJ1ZSwgZm9ybWF0dGVyOl9nZXRGb3JtYXR0ZXIoXCIwcHggMHB4XCIsIGZhbHNlLCB0cnVlKX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJhY2tncm91bmRQb3NpdGlvblwiLCB7ZGVmYXVsdFZhbHVlOlwiMCAwXCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgYnAgPSBcImJhY2tncm91bmQtcG9zaXRpb25cIixcblx0XHRcdFx0Y3MgPSAoX2NzIHx8IF9nZXRDb21wdXRlZFN0eWxlKHQsIG51bGwpKSxcblx0XHRcdFx0YnMgPSB0aGlzLmZvcm1hdCggKChjcykgPyBfaWVWZXJzID8gY3MuZ2V0UHJvcGVydHlWYWx1ZShicCArIFwiLXhcIikgKyBcIiBcIiArIGNzLmdldFByb3BlcnR5VmFsdWUoYnAgKyBcIi15XCIpIDogY3MuZ2V0UHJvcGVydHlWYWx1ZShicCkgOiB0LmN1cnJlbnRTdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb25YICsgXCIgXCIgKyB0LmN1cnJlbnRTdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb25ZKSB8fCBcIjAgMFwiKSwgLy9JbnRlcm5ldCBFeHBsb3JlciBkb2Vzbid0IHJlcG9ydCBiYWNrZ3JvdW5kLXBvc2l0aW9uIGNvcnJlY3RseSAtIHdlIG11c3QgcXVlcnkgYmFja2dyb3VuZC1wb3NpdGlvbi14IGFuZCBiYWNrZ3JvdW5kLXBvc2l0aW9uLXkgYW5kIGNvbWJpbmUgdGhlbSAoZXZlbiBpbiBJRTEwKS4gQmVmb3JlIElFOSwgd2UgbXVzdCBkbyB0aGUgc2FtZSB3aXRoIHRoZSBjdXJyZW50U3R5bGUgb2JqZWN0IGFuZCB1c2UgY2FtZWxDYXNlXG5cdFx0XHRcdGVzID0gdGhpcy5mb3JtYXQoZSksXG5cdFx0XHRcdGJhLCBlYSwgaSwgcGN0LCBvdmVybGFwLCBzcmM7XG5cdFx0XHRpZiAoKGJzLmluZGV4T2YoXCIlXCIpICE9PSAtMSkgIT09IChlcy5pbmRleE9mKFwiJVwiKSAhPT0gLTEpICYmIGVzLnNwbGl0KFwiLFwiKS5sZW5ndGggPCAyKSB7XG5cdFx0XHRcdHNyYyA9IF9nZXRTdHlsZSh0LCBcImJhY2tncm91bmRJbWFnZVwiKS5yZXBsYWNlKF91cmxFeHAsIFwiXCIpO1xuXHRcdFx0XHRpZiAoc3JjICYmIHNyYyAhPT0gXCJub25lXCIpIHtcblx0XHRcdFx0XHRiYSA9IGJzLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRlYSA9IGVzLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRfdGVtcEltZy5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgc3JjKTsgLy9zZXQgdGhlIHRlbXAgSU1HJ3Mgc3JjIHRvIHRoZSBiYWNrZ3JvdW5kLWltYWdlIHNvIHRoYXQgd2UgY2FuIG1lYXN1cmUgaXRzIHdpZHRoL2hlaWdodFxuXHRcdFx0XHRcdGkgPSAyO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0YnMgPSBiYVtpXTtcblx0XHRcdFx0XHRcdHBjdCA9IChicy5pbmRleE9mKFwiJVwiKSAhPT0gLTEpO1xuXHRcdFx0XHRcdFx0aWYgKHBjdCAhPT0gKGVhW2ldLmluZGV4T2YoXCIlXCIpICE9PSAtMSkpIHtcblx0XHRcdFx0XHRcdFx0b3ZlcmxhcCA9IChpID09PSAwKSA/IHQub2Zmc2V0V2lkdGggLSBfdGVtcEltZy53aWR0aCA6IHQub2Zmc2V0SGVpZ2h0IC0gX3RlbXBJbWcuaGVpZ2h0O1xuXHRcdFx0XHRcdFx0XHRiYVtpXSA9IHBjdCA/IChwYXJzZUZsb2F0KGJzKSAvIDEwMCAqIG92ZXJsYXApICsgXCJweFwiIDogKHBhcnNlRmxvYXQoYnMpIC8gb3ZlcmxhcCAqIDEwMCkgKyBcIiVcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnMgPSBiYS5qb2luKFwiIFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KHQuc3R5bGUsIGJzLCBlcywgcHQsIHBsdWdpbik7XG5cdFx0fSwgZm9ybWF0dGVyOl9wYXJzZVBvc2l0aW9ufSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYmFja2dyb3VuZFNpemVcIiwge2RlZmF1bHRWYWx1ZTpcIjAgMFwiLCBmb3JtYXR0ZXI6ZnVuY3Rpb24odikge1xuXHRcdFx0diArPSBcIlwiOyAvL2Vuc3VyZSBpdCdzIGEgc3RyaW5nXG5cdFx0XHRyZXR1cm4gKHYuc3Vic3RyKDAsMikgPT09IFwiY29cIikgPyB2IDogX3BhcnNlUG9zaXRpb24odi5pbmRleE9mKFwiIFwiKSA9PT0gLTEgPyB2ICsgXCIgXCIgKyB2IDogdik7IC8vaWYgc2V0IHRvIHNvbWV0aGluZyBsaWtlIFwiMTAwJSAxMDAlXCIsIFNhZmFyaSB0eXBpY2FsbHkgcmVwb3J0cyB0aGUgY29tcHV0ZWQgc3R5bGUgYXMganVzdCBcIjEwMCVcIiAobm8gMm5kIHZhbHVlKSwgYnV0IHdlIHNob3VsZCBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgdHdvIHZhbHVlcywgc28gY29weSB0aGUgZmlyc3Qgb25lLiBPdGhlcndpc2UsIGl0J2QgYmUgaW50ZXJwcmV0ZWQgYXMgXCIxMDAlIDBcIiAod3JvbmcpLiBBbHNvIHJlbWVtYmVyIHRoYXQgaXQgY291bGQgYmUgXCJjb3ZlclwiIG9yIFwiY29udGFpblwiIHdoaWNoIHdlIGNhbid0IHR3ZWVuIGJ1dCBzaG91bGQgYmUgYWJsZSB0byBzZXQuXG5cdFx0fX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInBlcnNwZWN0aXZlXCIsIHtkZWZhdWx0VmFsdWU6XCIwcHhcIiwgcHJlZml4OnRydWV9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJwZXJzcGVjdGl2ZU9yaWdpblwiLCB7ZGVmYXVsdFZhbHVlOlwiNTAlIDUwJVwiLCBwcmVmaXg6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInRyYW5zZm9ybVN0eWxlXCIsIHtwcmVmaXg6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJhY2tmYWNlVmlzaWJpbGl0eVwiLCB7cHJlZml4OnRydWV9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJ1c2VyU2VsZWN0XCIsIHtwcmVmaXg6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcIm1hcmdpblwiLCB7cGFyc2VyOl9nZXRFZGdlUGFyc2VyKFwibWFyZ2luVG9wLG1hcmdpblJpZ2h0LG1hcmdpbkJvdHRvbSxtYXJnaW5MZWZ0XCIpfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwicGFkZGluZ1wiLCB7cGFyc2VyOl9nZXRFZGdlUGFyc2VyKFwicGFkZGluZ1RvcCxwYWRkaW5nUmlnaHQscGFkZGluZ0JvdHRvbSxwYWRkaW5nTGVmdFwiKX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImNsaXBcIiwge2RlZmF1bHRWYWx1ZTpcInJlY3QoMHB4LDBweCwwcHgsMHB4KVwiLCBwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbil7XG5cdFx0XHR2YXIgYiwgY3MsIGRlbGltO1xuXHRcdFx0aWYgKF9pZVZlcnMgPCA5KSB7IC8vSUU4IGFuZCBlYXJsaWVyIGRvbid0IHJlcG9ydCBhIFwiY2xpcFwiIHZhbHVlIGluIHRoZSBjdXJyZW50U3R5bGUgLSBpbnN0ZWFkLCB0aGUgdmFsdWVzIGFyZSBzcGxpdCBhcGFydCBpbnRvIGNsaXBUb3AsIGNsaXBSaWdodCwgY2xpcEJvdHRvbSwgYW5kIGNsaXBMZWZ0LiBBbHNvLCBpbiBJRTcgYW5kIGVhcmxpZXIsIHRoZSB2YWx1ZXMgaW5zaWRlIHJlY3QoKSBhcmUgc3BhY2UtZGVsaW1pdGVkLCBub3QgY29tbWEtZGVsaW1pdGVkLlxuXHRcdFx0XHRjcyA9IHQuY3VycmVudFN0eWxlO1xuXHRcdFx0XHRkZWxpbSA9IF9pZVZlcnMgPCA4ID8gXCIgXCIgOiBcIixcIjtcblx0XHRcdFx0YiA9IFwicmVjdChcIiArIGNzLmNsaXBUb3AgKyBkZWxpbSArIGNzLmNsaXBSaWdodCArIGRlbGltICsgY3MuY2xpcEJvdHRvbSArIGRlbGltICsgY3MuY2xpcExlZnQgKyBcIilcIjtcblx0XHRcdFx0ZSA9IHRoaXMuZm9ybWF0KGUpLnNwbGl0KFwiLFwiKS5qb2luKGRlbGltKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGIgPSB0aGlzLmZvcm1hdChfZ2V0U3R5bGUodCwgdGhpcy5wLCBfY3MsIGZhbHNlLCB0aGlzLmRmbHQpKTtcblx0XHRcdFx0ZSA9IHRoaXMuZm9ybWF0KGUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KHQuc3R5bGUsIGIsIGUsIHB0LCBwbHVnaW4pO1xuXHRcdH19KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJ0ZXh0U2hhZG93XCIsIHtkZWZhdWx0VmFsdWU6XCIwcHggMHB4IDBweCAjOTk5XCIsIGNvbG9yOnRydWUsIG11bHRpOnRydWV9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJhdXRvUm91bmQsc3RyaWN0VW5pdHNcIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCkge3JldHVybiBwdDt9fSk7IC8vanVzdCBzbyB0aGF0IHdlIGNhbiBpZ25vcmUgdGhlc2UgcHJvcGVydGllcyAobm90IHR3ZWVuIHRoZW0pXG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYm9yZGVyXCIsIHtkZWZhdWx0VmFsdWU6XCIwcHggc29saWQgIzAwMFwiLCBwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0dmFyIGJ3ID0gX2dldFN0eWxlKHQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgX2NzLCBmYWxzZSwgXCIwcHhcIiksXG5cdFx0XHRcdGVuZCA9IHRoaXMuZm9ybWF0KGUpLnNwbGl0KFwiIFwiKSxcblx0XHRcdFx0ZXNmeCA9IGVuZFswXS5yZXBsYWNlKF9zdWZmaXhFeHAsIFwiXCIpO1xuXHRcdFx0aWYgKGVzZnggIT09IFwicHhcIikgeyAvL2lmIHdlJ3JlIGFuaW1hdGluZyB0byBhIG5vbi1weCB2YWx1ZSwgd2UgbmVlZCB0byBjb252ZXJ0IHRoZSBiZWdpbm5pbmcgd2lkdGggdG8gdGhhdCB1bml0LlxuXHRcdFx0XHRidyA9IChwYXJzZUZsb2F0KGJ3KSAvIF9jb252ZXJ0VG9QaXhlbHModCwgXCJib3JkZXJUb3BXaWR0aFwiLCAxLCBlc2Z4KSkgKyBlc2Z4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KHQuc3R5bGUsIHRoaXMuZm9ybWF0KGJ3ICsgXCIgXCIgKyBfZ2V0U3R5bGUodCwgXCJib3JkZXJUb3BTdHlsZVwiLCBfY3MsIGZhbHNlLCBcInNvbGlkXCIpICsgXCIgXCIgKyBfZ2V0U3R5bGUodCwgXCJib3JkZXJUb3BDb2xvclwiLCBfY3MsIGZhbHNlLCBcIiMwMDBcIikpLCBlbmQuam9pbihcIiBcIiksIHB0LCBwbHVnaW4pO1xuXHRcdFx0fSwgY29sb3I6dHJ1ZSwgZm9ybWF0dGVyOmZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0dmFyIGEgPSB2LnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0cmV0dXJuIGFbMF0gKyBcIiBcIiArIChhWzFdIHx8IFwic29saWRcIikgKyBcIiBcIiArICh2Lm1hdGNoKF9jb2xvckV4cCkgfHwgW1wiIzAwMFwiXSlbMF07XG5cdFx0XHR9fSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYm9yZGVyV2lkdGhcIiwge3BhcnNlcjpfZ2V0RWRnZVBhcnNlcihcImJvcmRlclRvcFdpZHRoLGJvcmRlclJpZ2h0V2lkdGgsYm9yZGVyQm90dG9tV2lkdGgsYm9yZGVyTGVmdFdpZHRoXCIpfSk7IC8vRmlyZWZveCBkb2Vzbid0IHBpY2sgdXAgb24gYm9yZGVyV2lkdGggc2V0IGluIHN0eWxlIHNoZWV0cyAob25seSBpbmxpbmUpLlxuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImZsb2F0LGNzc0Zsb2F0LHN0eWxlRmxvYXRcIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgcyA9IHQuc3R5bGUsXG5cdFx0XHRcdHByb3AgPSAoXCJjc3NGbG9hdFwiIGluIHMpID8gXCJjc3NGbG9hdFwiIDogXCJzdHlsZUZsb2F0XCI7XG5cdFx0XHRyZXR1cm4gbmV3IENTU1Byb3BUd2VlbihzLCBwcm9wLCAwLCAwLCBwdCwgLTEsIHAsIGZhbHNlLCAwLCBzW3Byb3BdLCBlKTtcblx0XHR9fSk7XG5cblx0XHQvL29wYWNpdHktcmVsYXRlZFxuXHRcdHZhciBfc2V0SUVPcGFjaXR5UmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciB0ID0gdGhpcy50LCAvL3JlZmVycyB0byB0aGUgZWxlbWVudCdzIHN0eWxlIHByb3BlcnR5XG5cdFx0XHRcdFx0ZmlsdGVycyA9IHQuZmlsdGVyIHx8IF9nZXRTdHlsZSh0aGlzLmRhdGEsIFwiZmlsdGVyXCIpIHx8IFwiXCIsXG5cdFx0XHRcdFx0dmFsID0gKHRoaXMucyArIHRoaXMuYyAqIHYpIHwgMCxcblx0XHRcdFx0XHRza2lwO1xuXHRcdFx0XHRpZiAodmFsID09PSAxMDApIHsgLy9mb3Igb2xkZXIgdmVyc2lvbnMgb2YgSUUgdGhhdCBuZWVkIHRvIHVzZSBhIGZpbHRlciB0byBhcHBseSBvcGFjaXR5LCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBmaWx0ZXIgaWYgb3BhY2l0eSBoaXRzIDEgaW4gb3JkZXIgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSwgYnV0IG1ha2Ugc3VyZSB0aGVyZSBpc24ndCBhIHRyYW5zZm9ybSAobWF0cml4KSBvciBncmFkaWVudCBpbiB0aGUgZmlsdGVycy5cblx0XHRcdFx0XHRpZiAoZmlsdGVycy5pbmRleE9mKFwiYXRyaXgoXCIpID09PSAtMSAmJiBmaWx0ZXJzLmluZGV4T2YoXCJyYWRpZW50KFwiKSA9PT0gLTEgJiYgZmlsdGVycy5pbmRleE9mKFwib2FkZXIoXCIpID09PSAtMSkge1xuXHRcdFx0XHRcdFx0dC5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIik7XG5cdFx0XHRcdFx0XHRza2lwID0gKCFfZ2V0U3R5bGUodGhpcy5kYXRhLCBcImZpbHRlclwiKSk7IC8vaWYgYSBjbGFzcyBpcyBhcHBsaWVkIHRoYXQgaGFzIGFuIGFscGhhIGZpbHRlciwgaXQgd2lsbCB0YWtlIGVmZmVjdCAod2UgZG9uJ3Qgd2FudCB0aGF0KSwgc28gcmUtYXBwbHkgb3VyIGFscGhhIGZpbHRlciBpbiB0aGF0IGNhc2UuIFdlIG11c3QgZmlyc3QgcmVtb3ZlIGl0IGFuZCB0aGVuIGNoZWNrLlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0LmZpbHRlciA9IGZpbHRlcnMucmVwbGFjZShfYWxwaGFGaWx0ZXJFeHAsIFwiXCIpO1xuXHRcdFx0XHRcdFx0c2tpcCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc2tpcCkge1xuXHRcdFx0XHRcdGlmICh0aGlzLnhuMSkge1xuXHRcdFx0XHRcdFx0dC5maWx0ZXIgPSBmaWx0ZXJzID0gZmlsdGVycyB8fCAoXCJhbHBoYShvcGFjaXR5PVwiICsgdmFsICsgXCIpXCIpOyAvL3dvcmtzIGFyb3VuZCBidWcgaW4gSUU3LzggdGhhdCBwcmV2ZW50cyBjaGFuZ2VzIHRvIFwidmlzaWJpbGl0eVwiIGZyb20gYmVpbmcgYXBwbGllZCBwcm9wZXJseSBpZiB0aGUgZmlsdGVyIGlzIGNoYW5nZWQgdG8gYSBkaWZmZXJlbnQgYWxwaGEgb24gdGhlIHNhbWUgZnJhbWUuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChmaWx0ZXJzLmluZGV4T2YoXCJwYWNpdHlcIikgPT09IC0xKSB7IC8vb25seSB1c2VkIGlmIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBzdGFuZGFyZCBvcGFjaXR5IHN0eWxlIHByb3BlcnR5IChJRSA3IGFuZCA4KS4gV2Ugb21pdCB0aGUgXCJPXCIgdG8gYXZvaWQgY2FzZS1zZW5zaXRpdml0eSBpc3N1ZXNcblx0XHRcdFx0XHRcdGlmICh2YWwgIT09IDAgfHwgIXRoaXMueG4xKSB7IC8vYnVncyBpbiBJRTcvOCB3b24ndCByZW5kZXIgdGhlIGZpbHRlciBwcm9wZXJseSBpZiBvcGFjaXR5IGlzIEFEREVEIG9uIHRoZSBzYW1lIGZyYW1lL3JlbmRlciBhcyBcInZpc2liaWxpdHlcIiBjaGFuZ2VzICh0aGlzLnhuMSBpcyAxIGlmIHRoaXMgdHdlZW4gaXMgYW4gXCJhdXRvQWxwaGFcIiB0d2Vlbilcblx0XHRcdFx0XHRcdFx0dC5maWx0ZXIgPSBmaWx0ZXJzICsgXCIgYWxwaGEob3BhY2l0eT1cIiArIHZhbCArIFwiKVwiOyAvL3dlIHJvdW5kIHRoZSB2YWx1ZSBiZWNhdXNlIG90aGVyd2lzZSwgYnVncyBpbiBJRTcvOCBjYW4gcHJldmVudCBcInZpc2liaWxpdHlcIiBjaGFuZ2VzIGZyb20gYmVpbmcgYXBwbGllZCBwcm9wZXJseS5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dC5maWx0ZXIgPSBmaWx0ZXJzLnJlcGxhY2UoX29wYWNpdHlFeHAsIFwib3BhY2l0eT1cIiArIHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcIm9wYWNpdHksYWxwaGEsYXV0b0FscGhhXCIsIHtkZWZhdWx0VmFsdWU6XCIxXCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgYiA9IHBhcnNlRmxvYXQoX2dldFN0eWxlKHQsIFwib3BhY2l0eVwiLCBfY3MsIGZhbHNlLCBcIjFcIikpLFxuXHRcdFx0XHRzdHlsZSA9IHQuc3R5bGUsXG5cdFx0XHRcdGlzQXV0b0FscGhhID0gKHAgPT09IFwiYXV0b0FscGhhXCIpO1xuXHRcdFx0aWYgKHR5cGVvZihlKSA9PT0gXCJzdHJpbmdcIiAmJiBlLmNoYXJBdCgxKSA9PT0gXCI9XCIpIHtcblx0XHRcdFx0ZSA9ICgoZS5jaGFyQXQoMCkgPT09IFwiLVwiKSA/IC0xIDogMSkgKiBwYXJzZUZsb2F0KGUuc3Vic3RyKDIpKSArIGI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNBdXRvQWxwaGEgJiYgYiA9PT0gMSAmJiBfZ2V0U3R5bGUodCwgXCJ2aXNpYmlsaXR5XCIsIF9jcykgPT09IFwiaGlkZGVuXCIgJiYgZSAhPT0gMCkgeyAvL2lmIHZpc2liaWxpdHkgaXMgaW5pdGlhbGx5IHNldCB0byBcImhpZGRlblwiLCB3ZSBzaG91bGQgaW50ZXJwcmV0IHRoYXQgYXMgaW50ZW50IHRvIG1ha2Ugb3BhY2l0eSAwIChhIGNvbnZlbmllbmNlKVxuXHRcdFx0XHRiID0gMDtcblx0XHRcdH1cblx0XHRcdGlmIChfc3VwcG9ydHNPcGFjaXR5KSB7XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgXCJvcGFjaXR5XCIsIGIsIGUgLSBiLCBwdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4oc3R5bGUsIFwib3BhY2l0eVwiLCBiICogMTAwLCAoZSAtIGIpICogMTAwLCBwdCk7XG5cdFx0XHRcdHB0LnhuMSA9IGlzQXV0b0FscGhhID8gMSA6IDA7IC8vd2UgbmVlZCB0byByZWNvcmQgd2hldGhlciBvciBub3QgdGhpcyBpcyBhbiBhdXRvQWxwaGEgc28gdGhhdCBpbiB0aGUgc2V0UmF0aW8oKSwgd2Uga25vdyB0byBkdXBsaWNhdGUgdGhlIHNldHRpbmcgb2YgdGhlIGFscGhhIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluIElFNyBhbmQgSUU4IHRoYXQgcHJldmVudHMgY2hhbmdlcyB0byBcInZpc2liaWxpdHlcIiBmcm9tIHRha2luZyBlZmZlY3QgaWYgdGhlIGZpbHRlciBpcyBjaGFuZ2VkIHRvIGEgZGlmZmVyZW50IGFscGhhKG9wYWNpdHkpIGF0IHRoZSBzYW1lIHRpbWUuIFNldHRpbmcgaXQgdG8gdGhlIFNBTUUgdmFsdWUgZmlyc3QsIHRoZW4gdGhlIG5ldyB2YWx1ZSB3b3JrcyBhcm91bmQgdGhlIElFNy84IGJ1Zy5cblx0XHRcdFx0c3R5bGUuem9vbSA9IDE7IC8vaGVscHMgY29ycmVjdCBhbiBJRSBpc3N1ZS5cblx0XHRcdFx0cHQudHlwZSA9IDI7XG5cdFx0XHRcdHB0LmIgPSBcImFscGhhKG9wYWNpdHk9XCIgKyBwdC5zICsgXCIpXCI7XG5cdFx0XHRcdHB0LmUgPSBcImFscGhhKG9wYWNpdHk9XCIgKyAocHQucyArIHB0LmMpICsgXCIpXCI7XG5cdFx0XHRcdHB0LmRhdGEgPSB0O1xuXHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdHB0LnNldFJhdGlvID0gX3NldElFT3BhY2l0eVJhdGlvO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlzQXV0b0FscGhhKSB7IC8vd2UgaGF2ZSB0byBjcmVhdGUgdGhlIFwidmlzaWJpbGl0eVwiIFByb3BUd2VlbiBhZnRlciB0aGUgb3BhY2l0eSBvbmUgaW4gdGhlIGxpbmtlZCBsaXN0IHNvIHRoYXQgdGhleSBydW4gaW4gdGhlIG9yZGVyIHRoYXQgd29ya3MgcHJvcGVybHkgaW4gSUU4IGFuZCBlYXJsaWVyXG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgXCJ2aXNpYmlsaXR5XCIsIDAsIDAsIHB0LCAtMSwgbnVsbCwgZmFsc2UsIDAsICgoYiAhPT0gMCkgPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCIpLCAoKGUgPT09IDApID8gXCJoaWRkZW5cIiA6IFwiaW5oZXJpdFwiKSk7XG5cdFx0XHRcdHB0LnhzMCA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0XHRjc3NwLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHB0Lm4pO1xuXHRcdFx0XHRjc3NwLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH19KTtcblxuXG5cdFx0dmFyIF9yZW1vdmVQcm9wID0gZnVuY3Rpb24ocywgcCkge1xuXHRcdFx0XHRpZiAocCkge1xuXHRcdFx0XHRcdGlmIChzLnJlbW92ZVByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHRpZiAocC5zdWJzdHIoMCwyKSA9PT0gXCJtc1wiIHx8IHAuc3Vic3RyKDAsNikgPT09IFwid2Via2l0XCIpIHsgLy9NaWNyb3NvZnQgYW5kIHNvbWUgV2Via2l0IGJyb3dzZXJzIGRvbid0IGNvbmZvcm0gdG8gdGhlIHN0YW5kYXJkIG9mIGNhcGl0YWxpemluZyB0aGUgZmlyc3QgcHJlZml4IGNoYXJhY3Rlciwgc28gd2UgYWRqdXN0IHNvIHRoYXQgd2hlbiB3ZSBwcmVmaXggdGhlIGNhcHMgd2l0aCBhIGRhc2gsIGl0J3MgY29ycmVjdCAob3RoZXJ3aXNlIGl0J2QgYmUgXCJtcy10cmFuc2Zvcm1cIiBpbnN0ZWFkIG9mIFwiLW1zLXRyYW5zZm9ybVwiIGZvciBJRTksIGZvciBleGFtcGxlKVxuXHRcdFx0XHRcdFx0XHRwID0gXCItXCIgKyBwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cy5yZW1vdmVQcm9wZXJ0eShwLnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7IC8vbm90ZTogb2xkIHZlcnNpb25zIG9mIElFIHVzZSBcInJlbW92ZUF0dHJpYnV0ZSgpXCIgaW5zdGVhZCBvZiBcInJlbW92ZVByb3BlcnR5KClcIlxuXHRcdFx0XHRcdFx0cy5yZW1vdmVBdHRyaWJ1dGUocCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3NldENsYXNzTmFtZVJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR0aGlzLnQuX2dzQ2xhc3NQVCA9IHRoaXM7XG5cdFx0XHRcdGlmICh2ID09PSAxIHx8IHYgPT09IDApIHtcblx0XHRcdFx0XHR0aGlzLnQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgKHYgPT09IDApID8gdGhpcy5iIDogdGhpcy5lKTtcblx0XHRcdFx0XHR2YXIgbXB0ID0gdGhpcy5kYXRhLCAvL2ZpcnN0IE1pbmlQcm9wVHdlZW5cblx0XHRcdFx0XHRcdHMgPSB0aGlzLnQuc3R5bGU7XG5cdFx0XHRcdFx0d2hpbGUgKG1wdCkge1xuXHRcdFx0XHRcdFx0aWYgKCFtcHQudikge1xuXHRcdFx0XHRcdFx0XHRfcmVtb3ZlUHJvcChzLCBtcHQucCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzW21wdC5wXSA9IG1wdC52O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bXB0ID0gbXB0Ll9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodiA9PT0gMSAmJiB0aGlzLnQuX2dzQ2xhc3NQVCA9PT0gdGhpcykge1xuXHRcdFx0XHRcdFx0dGhpcy50Ll9nc0NsYXNzUFQgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgIT09IHRoaXMuZSkge1xuXHRcdFx0XHRcdHRoaXMudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImNsYXNzTmFtZVwiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdHZhciBiID0gdC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiLCAvL2Rvbid0IHVzZSB0LmNsYXNzTmFtZSBiZWNhdXNlIGl0IGRvZXNuJ3Qgd29yayBjb25zaXN0ZW50bHkgb24gU1ZHIGVsZW1lbnRzOyBnZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSBhbmQgc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdmFsdWVcIikgaXMgbW9yZSByZWxpYWJsZS5cblx0XHRcdFx0Y3NzVGV4dCA9IHQuc3R5bGUuY3NzVGV4dCxcblx0XHRcdFx0ZGlmRGF0YSwgYnMsIGNucHQsIGNucHRMb29rdXAsIG1wdDtcblx0XHRcdHB0ID0gY3NzcC5fY2xhc3NOYW1lUFQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIHAsIDAsIDAsIHB0LCAyKTtcblx0XHRcdHB0LnNldFJhdGlvID0gX3NldENsYXNzTmFtZVJhdGlvO1xuXHRcdFx0cHQucHIgPSAtMTE7XG5cdFx0XHRfaGFzUHJpb3JpdHkgPSB0cnVlO1xuXHRcdFx0cHQuYiA9IGI7XG5cdFx0XHRicyA9IF9nZXRBbGxTdHlsZXModCwgX2NzKTtcblx0XHRcdC8vaWYgdGhlcmUncyBhIGNsYXNzTmFtZSB0d2VlbiBhbHJlYWR5IG9wZXJhdGluZyBvbiB0aGUgdGFyZ2V0LCBmb3JjZSBpdCB0byBpdHMgZW5kIHNvIHRoYXQgdGhlIG5lY2Vzc2FyeSBpbmxpbmUgc3R5bGVzIGFyZSByZW1vdmVkIGFuZCB0aGUgY2xhc3MgbmFtZSBpcyBhcHBsaWVkIGJlZm9yZSB3ZSBkZXRlcm1pbmUgdGhlIGVuZCBzdGF0ZSAod2UgZG9uJ3Qgd2FudCBpbmxpbmUgc3R5bGVzIGludGVyZmVyaW5nIHRoYXQgd2VyZSB0aGVyZSBqdXN0IGZvciBjbGFzcy1zcGVjaWZpYyB2YWx1ZXMpXG5cdFx0XHRjbnB0ID0gdC5fZ3NDbGFzc1BUO1xuXHRcdFx0aWYgKGNucHQpIHtcblx0XHRcdFx0Y25wdExvb2t1cCA9IHt9O1xuXHRcdFx0XHRtcHQgPSBjbnB0LmRhdGE7IC8vZmlyc3QgTWluaVByb3BUd2VlbiB3aGljaCBzdG9yZXMgdGhlIGlubGluZSBzdHlsZXMgLSB3ZSBuZWVkIHRvIGZvcmNlIHRoZXNlIHNvIHRoYXQgdGhlIGlubGluZSBzdHlsZXMgZG9uJ3QgY29udGFtaW5hdGUgdGhpbmdzLiBPdGhlcndpc2UsIHRoZXJlJ3MgYSBzbWFsbCBjaGFuY2UgdGhhdCBhIHR3ZWVuIGNvdWxkIHN0YXJ0IGFuZCB0aGUgaW5saW5lIHZhbHVlcyBtYXRjaCB0aGUgZGVzdGluYXRpb24gdmFsdWVzIGFuZCB0aGV5IG5ldmVyIGdldCBjbGVhbmVkLlxuXHRcdFx0XHR3aGlsZSAobXB0KSB7XG5cdFx0XHRcdFx0Y25wdExvb2t1cFttcHQucF0gPSAxO1xuXHRcdFx0XHRcdG1wdCA9IG1wdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRjbnB0LnNldFJhdGlvKDEpO1xuXHRcdFx0fVxuXHRcdFx0dC5fZ3NDbGFzc1BUID0gcHQ7XG5cdFx0XHRwdC5lID0gKGUuY2hhckF0KDEpICE9PSBcIj1cIikgPyBlIDogYi5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoPzpcXFxcc3xeKVwiICsgZS5zdWJzdHIoMikgKyBcIig/IVtcXFxcdy1dKVwiKSwgXCJcIikgKyAoKGUuY2hhckF0KDApID09PSBcIitcIikgPyBcIiBcIiArIGUuc3Vic3RyKDIpIDogXCJcIik7XG5cdFx0XHR0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHB0LmUpO1xuXHRcdFx0ZGlmRGF0YSA9IF9jc3NEaWYodCwgYnMsIF9nZXRBbGxTdHlsZXModCksIHZhcnMsIGNucHRMb29rdXApO1xuXHRcdFx0dC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBiKTtcblx0XHRcdHB0LmRhdGEgPSBkaWZEYXRhLmZpcnN0TVBUO1xuXHRcdFx0dC5zdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDsgLy93ZSByZWNvcmRlZCBjc3NUZXh0IGJlZm9yZSB3ZSBzd2FwcGVkIGNsYXNzZXMgYW5kIHJhbiBfZ2V0QWxsU3R5bGVzKCkgYmVjYXVzZSBpbiBjYXNlcyB3aGVuIGEgY2xhc3NOYW1lIHR3ZWVuIGlzIG92ZXJ3cml0dGVuLCB3ZSByZW1vdmUgYWxsIHRoZSByZWxhdGVkIHR3ZWVuaW5nIHByb3BlcnRpZXMgZnJvbSB0aGF0IGNsYXNzIGNoYW5nZSAob3RoZXJ3aXNlIGNsYXNzLXNwZWNpZmljIHN0dWZmIGNhbid0IG92ZXJyaWRlIHByb3BlcnRpZXMgd2UndmUgZGlyZWN0bHkgc2V0IG9uIHRoZSB0YXJnZXQncyBzdHlsZSBvYmplY3QgZHVlIHRvIHNwZWNpZmljaXR5KS5cblx0XHRcdHB0ID0gcHQueGZpcnN0ID0gY3NzcC5wYXJzZSh0LCBkaWZEYXRhLmRpZnMsIHB0LCBwbHVnaW4pOyAvL3dlIHJlY29yZCB0aGUgQ1NTUHJvcFR3ZWVuIGFzIHRoZSB4Zmlyc3Qgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIG92ZXJ3cml0aW5nIHByb3BlcnRseSAoaWYgXCJjbGFzc05hbWVcIiBnZXRzIG92ZXJ3cml0dGVuLCB3ZSBtdXN0IGtpbGwgYWxsIHRoZSBwcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2xhc3NOYW1lIHBhcnQgb2YgdGhlIHR3ZWVuLCBzbyB3ZSBjYW4gbG9vcCB0aHJvdWdoIGZyb20geGZpcnN0IHRvIHRoZSBwdCBpdHNlbGYpXG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fX0pO1xuXG5cblx0XHR2YXIgX3NldENsZWFyUHJvcHNSYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdGlmICh2ID09PSAxIHx8IHYgPT09IDApIGlmICh0aGlzLmRhdGEuX3RvdGFsVGltZSA9PT0gdGhpcy5kYXRhLl90b3RhbER1cmF0aW9uICYmIHRoaXMuZGF0YS5kYXRhICE9PSBcImlzRnJvbVN0YXJ0XCIpIHsgLy90aGlzLmRhdGEgcmVmZXJzIHRvIHRoZSB0d2Vlbi4gT25seSBjbGVhciBhdCB0aGUgRU5EIG9mIHRoZSB0d2VlbiAocmVtZW1iZXIsIGZyb20oKSB0d2VlbnMgbWFrZSB0aGUgcmF0aW8gZ28gZnJvbSAxIHRvIDAsIHNvIHdlIGNhbid0IGp1c3QgY2hlY2sgdGhhdCBhbmQgaWYgdGhlIHR3ZWVuIGlzIHRoZSB6ZXJvLWR1cmF0aW9uIG9uZSB0aGF0J3MgY3JlYXRlZCBpbnRlcm5hbGx5IHRvIHJlbmRlciB0aGUgc3RhcnRpbmcgdmFsdWVzIGluIGEgZnJvbSgpIHR3ZWVuLCBpZ25vcmUgdGhhdCBiZWNhdXNlIG90aGVyd2lzZSwgZm9yIGV4YW1wbGUsIGZyb20oLi4ue2hlaWdodDoxMDAsIGNsZWFyUHJvcHM6XCJoZWlnaHRcIiwgZGVsYXk6MX0pIHdvdWxkIHdpcGUgdGhlIGhlaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0d2VlbiBhbmQgYWZ0ZXIgMSBzZWNvbmQsIGl0J2Qga2ljayBiYWNrIGluKS5cblx0XHRcdFx0dmFyIHMgPSB0aGlzLnQuc3R5bGUsXG5cdFx0XHRcdFx0dHJhbnNmb3JtUGFyc2UgPSBfc3BlY2lhbFByb3BzLnRyYW5zZm9ybS5wYXJzZSxcblx0XHRcdFx0XHRhLCBwLCBpLCBjbGVhclRyYW5zZm9ybSwgdHJhbnNmb3JtO1xuXHRcdFx0XHRpZiAodGhpcy5lID09PSBcImFsbFwiKSB7XG5cdFx0XHRcdFx0cy5jc3NUZXh0ID0gXCJcIjtcblx0XHRcdFx0XHRjbGVhclRyYW5zZm9ybSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YSA9IHRoaXMuZS5zcGxpdChcIiBcIikuam9pbihcIlwiKS5zcGxpdChcIixcIik7XG5cdFx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0cCA9IGFbaV07XG5cdFx0XHRcdFx0XHRpZiAoX3NwZWNpYWxQcm9wc1twXSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoX3NwZWNpYWxQcm9wc1twXS5wYXJzZSA9PT0gdHJhbnNmb3JtUGFyc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRjbGVhclRyYW5zZm9ybSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0cCA9IChwID09PSBcInRyYW5zZm9ybU9yaWdpblwiKSA/IF90cmFuc2Zvcm1PcmlnaW5Qcm9wIDogX3NwZWNpYWxQcm9wc1twXS5wOyAvL2Vuc3VyZXMgdGhhdCBzcGVjaWFsIHByb3BlcnRpZXMgdXNlIHRoZSBwcm9wZXIgYnJvd3Nlci1zcGVjaWZpYyBwcm9wZXJ0eSBuYW1lLCBsaWtlIFwic2NhbGVYXCIgbWlnaHQgYmUgXCItd2Via2l0LXRyYW5zZm9ybVwiIG9yIFwiYm94U2hhZG93XCIgbWlnaHQgYmUgXCItbW96LWJveC1zaGFkb3dcIlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRfcmVtb3ZlUHJvcChzLCBwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNsZWFyVHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0X3JlbW92ZVByb3AocywgX3RyYW5zZm9ybVByb3ApO1xuXHRcdFx0XHRcdHRyYW5zZm9ybSA9IHRoaXMudC5fZ3NUcmFuc2Zvcm07XG5cdFx0XHRcdFx0aWYgKHRyYW5zZm9ybSkge1xuXHRcdFx0XHRcdFx0aWYgKHRyYW5zZm9ybS5zdmcpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKTtcblx0XHRcdFx0XHRcdFx0dGhpcy50LnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGRlbGV0ZSB0aGlzLnQuX2dzVHJhbnNmb3JtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0fTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJjbGVhclByb3BzXCIsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQpIHtcblx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2Vlbih0LCBwLCAwLCAwLCBwdCwgMik7XG5cdFx0XHRwdC5zZXRSYXRpbyA9IF9zZXRDbGVhclByb3BzUmF0aW87XG5cdFx0XHRwdC5lID0gZTtcblx0XHRcdHB0LnByID0gLTEwO1xuXHRcdFx0cHQuZGF0YSA9IGNzc3AuX3R3ZWVuO1xuXHRcdFx0X2hhc1ByaW9yaXR5ID0gdHJ1ZTtcblx0XHRcdHJldHVybiBwdDtcblx0XHR9fSk7XG5cblx0XHRwID0gXCJiZXppZXIsdGhyb3dQcm9wcyxwaHlzaWNzUHJvcHMscGh5c2ljczJEXCIuc3BsaXQoXCIsXCIpO1xuXHRcdGkgPSBwLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRfcmVnaXN0ZXJQbHVnaW5Qcm9wKHBbaV0pO1xuXHRcdH1cblxuXG5cblxuXG5cblxuXG5cdFx0cCA9IENTU1BsdWdpbi5wcm90b3R5cGU7XG5cdFx0cC5fZmlyc3RQVCA9IHAuX2xhc3RQYXJzZWRUcmFuc2Zvcm0gPSBwLl90cmFuc2Zvcm0gPSBudWxsO1xuXG5cdFx0Ly9nZXRzIGNhbGxlZCB3aGVuIHRoZSB0d2VlbiByZW5kZXJzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBraWNrcyBldmVyeXRoaW5nIG9mZiwgcmVjb3JkaW5nIHN0YXJ0L2VuZCB2YWx1ZXMsIGV0Yy5cblx0XHRwLl9vbkluaXRUd2VlbiA9IGZ1bmN0aW9uKHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4KSB7XG5cdFx0XHRpZiAoIXRhcmdldC5ub2RlVHlwZSkgeyAvL2NzcyBpcyBvbmx5IGZvciBkb20gZWxlbWVudHNcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdGFyZ2V0ID0gX3RhcmdldCA9IHRhcmdldDtcblx0XHRcdHRoaXMuX3R3ZWVuID0gdHdlZW47XG5cdFx0XHR0aGlzLl92YXJzID0gdmFycztcblx0XHRcdF9pbmRleCA9IGluZGV4O1xuXHRcdFx0X2F1dG9Sb3VuZCA9IHZhcnMuYXV0b1JvdW5kO1xuXHRcdFx0X2hhc1ByaW9yaXR5ID0gZmFsc2U7XG5cdFx0XHRfc3VmZml4TWFwID0gdmFycy5zdWZmaXhNYXAgfHwgQ1NTUGx1Z2luLnN1ZmZpeE1hcDtcblx0XHRcdF9jcyA9IF9nZXRDb21wdXRlZFN0eWxlKHRhcmdldCwgXCJcIik7XG5cdFx0XHRfb3ZlcndyaXRlUHJvcHMgPSB0aGlzLl9vdmVyd3JpdGVQcm9wcztcblx0XHRcdHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZSxcblx0XHRcdFx0diwgcHQsIHB0MiwgZmlyc3QsIGxhc3QsIG5leHQsIHpJbmRleCwgdHB0LCB0aHJlZUQ7XG5cdFx0XHRpZiAoX3JlcVNhZmFyaUZpeCkgaWYgKHN0eWxlLnpJbmRleCA9PT0gXCJcIikge1xuXHRcdFx0XHR2ID0gX2dldFN0eWxlKHRhcmdldCwgXCJ6SW5kZXhcIiwgX2NzKTtcblx0XHRcdFx0aWYgKHYgPT09IFwiYXV0b1wiIHx8IHYgPT09IFwiXCIpIHtcblx0XHRcdFx0XHQvL2NvcnJlY3RzIGEgYnVnIGluIFtub24tQW5kcm9pZF0gU2FmYXJpIHRoYXQgcHJldmVudHMgaXQgZnJvbSByZXBhaW50aW5nIGVsZW1lbnRzIGluIHRoZWlyIG5ldyBwb3NpdGlvbnMgaWYgdGhleSBkb24ndCBoYXZlIGEgekluZGV4IHNldC4gV2UgYWxzbyBjYW4ndCBqdXN0IGFwcGx5IHRoaXMgaW5zaWRlIF9wYXJzZVRyYW5zZm9ybSgpIGJlY2F1c2UgYW55dGhpbmcgdGhhdCdzIG1vdmVkIGluIGFueSB3YXkgKGxpa2UgdXNpbmcgXCJsZWZ0XCIgb3IgXCJ0b3BcIiBpbnN0ZWFkIG9mIHRyYW5zZm9ybXMgbGlrZSBcInhcIiBhbmQgXCJ5XCIpIGNhbiBiZSBhZmZlY3RlZCwgc28gaXQgaXMgYmVzdCB0byBlbnN1cmUgdGhhdCBhbnl0aGluZyB0aGF0J3MgdHdlZW5pbmcgaGFzIGEgei1pbmRleC4gU2V0dGluZyBcIldlYmtpdFBlcnNwZWN0aXZlXCIgdG8gYSBub24temVybyB2YWx1ZSB3b3JrZWQgdG9vIGV4Y2VwdCB0aGF0IG9uIGlPUyBTYWZhcmkgdGhpbmdzIHdvdWxkIGZsaWNrZXIgcmFuZG9tbHkuIFBsdXMgekluZGV4IGlzIGxlc3MgbWVtb3J5LWludGVuc2l2ZS5cblx0XHRcdFx0XHR0aGlzLl9hZGRMYXp5U2V0KHN0eWxlLCBcInpJbmRleFwiLCAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mKHZhcnMpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGZpcnN0ID0gc3R5bGUuY3NzVGV4dDtcblx0XHRcdFx0diA9IF9nZXRBbGxTdHlsZXModGFyZ2V0LCBfY3MpO1xuXHRcdFx0XHRzdHlsZS5jc3NUZXh0ID0gZmlyc3QgKyBcIjtcIiArIHZhcnM7XG5cdFx0XHRcdHYgPSBfY3NzRGlmKHRhcmdldCwgdiwgX2dldEFsbFN0eWxlcyh0YXJnZXQpKS5kaWZzO1xuXHRcdFx0XHRpZiAoIV9zdXBwb3J0c09wYWNpdHkgJiYgX29wYWNpdHlWYWxFeHAudGVzdCh2YXJzKSkge1xuXHRcdFx0XHRcdHYub3BhY2l0eSA9IHBhcnNlRmxvYXQoIFJlZ0V4cC4kMSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhcnMgPSB2O1xuXHRcdFx0XHRzdHlsZS5jc3NUZXh0ID0gZmlyc3Q7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2YXJzLmNsYXNzTmFtZSkgeyAvL2NsYXNzTmFtZSB0d2VlbnMgd2lsbCBjb21iaW5lIGFueSBkaWZmZXJlbmNlcyB0aGV5IGZpbmQgaW4gdGhlIGNzcyB3aXRoIHRoZSB2YXJzIHRoYXQgYXJlIHBhc3NlZCBpbiwgc28ge2NsYXNzTmFtZTpcIm15Q2xhc3NcIiwgc2NhbGU6MC41LCBsZWZ0OjIwfSB3b3VsZCB3b3JrLlxuXHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQgPSBfc3BlY2lhbFByb3BzLmNsYXNzTmFtZS5wYXJzZSh0YXJnZXQsIHZhcnMuY2xhc3NOYW1lLCBcImNsYXNzTmFtZVwiLCB0aGlzLCBudWxsLCBudWxsLCB2YXJzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdCA9IHRoaXMucGFyc2UodGFyZ2V0LCB2YXJzLCBudWxsKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX3RyYW5zZm9ybVR5cGUpIHtcblx0XHRcdFx0dGhyZWVEID0gKHRoaXMuX3RyYW5zZm9ybVR5cGUgPT09IDMpO1xuXHRcdFx0XHRpZiAoIV90cmFuc2Zvcm1Qcm9wKSB7XG5cdFx0XHRcdFx0c3R5bGUuem9vbSA9IDE7IC8vaGVscHMgY29ycmVjdCBhbiBJRSBpc3N1ZS5cblx0XHRcdFx0fSBlbHNlIGlmIChfaXNTYWZhcmkpIHtcblx0XHRcdFx0XHRfcmVxU2FmYXJpRml4ID0gdHJ1ZTtcblx0XHRcdFx0XHQvL2lmIHpJbmRleCBpc24ndCBzZXQsIGlPUyBTYWZhcmkgZG9lc24ndCByZXBhaW50IHRoaW5ncyBjb3JyZWN0bHkgc29tZXRpbWVzIChzZWVtaW5nbHkgYXQgcmFuZG9tKS5cblx0XHRcdFx0XHRpZiAoc3R5bGUuekluZGV4ID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHR6SW5kZXggPSBfZ2V0U3R5bGUodGFyZ2V0LCBcInpJbmRleFwiLCBfY3MpO1xuXHRcdFx0XHRcdFx0aWYgKHpJbmRleCA9PT0gXCJhdXRvXCIgfHwgekluZGV4ID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2FkZExhenlTZXQoc3R5bGUsIFwiekluZGV4XCIsIDApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvL1NldHRpbmcgV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5IGNvcnJlY3RzIDMgYnVnczpcblx0XHRcdFx0XHQvLyAxKSBbbm9uLUFuZHJvaWRdIFNhZmFyaSBza2lwcyByZW5kZXJpbmcgY2hhbmdlcyB0byBcInRvcFwiIGFuZCBcImxlZnRcIiB0aGF0IGFyZSBtYWRlIG9uIHRoZSBzYW1lIGZyYW1lL3JlbmRlciBhcyBhIHRyYW5zZm9ybSB1cGRhdGUuXG5cdFx0XHRcdFx0Ly8gMikgaU9TIFNhZmFyaSBzb21ldGltZXMgbmVnbGVjdHMgdG8gcmVwYWludCBlbGVtZW50cyBpbiB0aGVpciBuZXcgcG9zaXRpb25zLiBTZXR0aW5nIFwiV2Via2l0UGVyc3BlY3RpdmVcIiB0byBhIG5vbi16ZXJvIHZhbHVlIHdvcmtlZCB0b28gZXhjZXB0IHRoYXQgb24gaU9TIFNhZmFyaSB0aGluZ3Mgd291bGQgZmxpY2tlciByYW5kb21seS5cblx0XHRcdFx0XHQvLyAzKSBTYWZhcmkgc29tZXRpbWVzIGRpc3BsYXllZCBvZGQgYXJ0aWZhY3RzIHdoZW4gdHdlZW5pbmcgdGhlIHRyYW5zZm9ybSAob3IgV2Via2l0VHJhbnNmb3JtKSBwcm9wZXJ0eSwgbGlrZSBnaG9zdHMgb2YgdGhlIGVkZ2VzIG9mIHRoZSBlbGVtZW50IHJlbWFpbmVkLiBEZWZpbml0ZWx5IGEgYnJvd3NlciBidWcuXG5cdFx0XHRcdFx0Ly9Ob3RlOiB3ZSBhbGxvdyB0aGUgdXNlciB0byBvdmVycmlkZSB0aGUgYXV0by1zZXR0aW5nIGJ5IGRlZmluaW5nIFdlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSBpbiB0aGUgdmFycyBvZiB0aGUgdHdlZW4uXG5cdFx0XHRcdFx0aWYgKF9pc1NhZmFyaUxUNikge1xuXHRcdFx0XHRcdFx0dGhpcy5fYWRkTGF6eVNldChzdHlsZSwgXCJXZWJraXRCYWNrZmFjZVZpc2liaWxpdHlcIiwgdGhpcy5fdmFycy5XZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgfHwgKHRocmVlRCA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIikpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwdDIgPSBwdDtcblx0XHRcdFx0d2hpbGUgKHB0MiAmJiBwdDIuX25leHQpIHtcblx0XHRcdFx0XHRwdDIgPSBwdDIuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHB0ID0gbmV3IENTU1Byb3BUd2Vlbih0YXJnZXQsIFwidHJhbnNmb3JtXCIsIDAsIDAsIG51bGwsIDIpO1xuXHRcdFx0XHR0aGlzLl9saW5rQ1NTUCh0cHQsIG51bGwsIHB0Mik7XG5cdFx0XHRcdHRwdC5zZXRSYXRpbyA9IF90cmFuc2Zvcm1Qcm9wID8gX3NldFRyYW5zZm9ybVJhdGlvIDogX3NldElFVHJhbnNmb3JtUmF0aW87XG5cdFx0XHRcdHRwdC5kYXRhID0gdGhpcy5fdHJhbnNmb3JtIHx8IF9nZXRUcmFuc2Zvcm0odGFyZ2V0LCBfY3MsIHRydWUpO1xuXHRcdFx0XHR0cHQudHdlZW4gPSB0d2Vlbjtcblx0XHRcdFx0dHB0LnByID0gLTE7IC8vZW5zdXJlcyB0aGF0IHRoZSB0cmFuc2Zvcm1zIGdldCBhcHBsaWVkIGFmdGVyIHRoZSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLlxuXHRcdFx0XHRfb3ZlcndyaXRlUHJvcHMucG9wKCk7IC8vd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSB0aGUgb3ZlcndyaXRlIG9mIGFsbCBcInRyYW5zZm9ybVwiIHR3ZWVucyBvZiB0aGUgdGFyZ2V0IC0gd2Ugb25seSBjYXJlIGFib3V0IGluZGl2aWR1YWwgdHJhbnNmb3JtIHByb3BlcnRpZXMgbGlrZSBzY2FsZVgsIHJvdGF0aW9uLCBldGMuIFRoZSBDU1NQcm9wVHdlZW4gY29uc3RydWN0b3IgYXV0b21hdGljYWxseSBhZGRzIHRoZSBwcm9wZXJ0eSB0byBfb3ZlcndyaXRlUHJvcHMgd2hpY2ggaXMgd2h5IHdlIG5lZWQgdG8gcG9wKCkgaGVyZS5cblx0XHRcdH1cblxuXHRcdFx0aWYgKF9oYXNQcmlvcml0eSkge1xuXHRcdFx0XHQvL3Jlb3JkZXJzIHRoZSBsaW5rZWQgbGlzdCBpbiBvcmRlciBvZiBwciAocHJpb3JpdHkpXG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdG5leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRwdDIgPSBmaXJzdDtcblx0XHRcdFx0XHR3aGlsZSAocHQyICYmIHB0Mi5wciA+IHB0LnByKSB7XG5cdFx0XHRcdFx0XHRwdDIgPSBwdDIuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgocHQuX3ByZXYgPSBwdDIgPyBwdDIuX3ByZXYgOiBsYXN0KSkge1xuXHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Zmlyc3QgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKChwdC5fbmV4dCA9IHB0MikpIHtcblx0XHRcdFx0XHRcdHB0Mi5fcHJldiA9IHB0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRsYXN0ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9maXJzdFBUID0gZmlyc3Q7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cblx0XHRwLnBhcnNlID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG5cdFx0XHRcdHAsIHNwLCBibiwgZW4sIGJzLCBlcywgYnNmeCwgZXNmeCwgaXNTdHIsIHJlbDtcblx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdGVzID0gdmFyc1twXTsgLy9lbmRpbmcgdmFsdWUgc3RyaW5nXG5cdFx0XHRcdGlmICh0eXBlb2YoZXMpID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRlcyA9IGVzKF9pbmRleCwgX3RhcmdldCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3AgPSBfc3BlY2lhbFByb3BzW3BdOyAvL1NwZWNpYWxQcm9wIGxvb2t1cC5cblx0XHRcdFx0aWYgKHNwKSB7XG5cdFx0XHRcdFx0cHQgPSBzcC5wYXJzZSh0YXJnZXQsIGVzLCBwLCB0aGlzLCBwdCwgcGx1Z2luLCB2YXJzKTtcblx0XHRcdFx0fSBlbHNlIGlmIChwLnN1YnN0cigwLDIpID09PSBcIi0tXCIpIHsgLy9mb3IgdHdlZW5pbmcgQ1NTIHZhcmlhYmxlcyAod2hpY2ggYWx3YXlzIHN0YXJ0IHdpdGggXCItLVwiKS4gVG8gbWF4aW1pemUgcGVyZm9ybWFuY2UgYW5kIHNpbXBsaWNpdHksIHdlIGJ5cGFzcyBDU1NQbHVnaW4gYWx0b2dldGhlciBhbmQganVzdCBhZGQgYSBub3JtYWwgcHJvcGVydHkgdHdlZW4gdG8gdGhlIHR3ZWVuIGluc3RhbmNlIGl0c2VsZi5cblx0XHRcdFx0XHR0aGlzLl90d2Vlbi5fcHJvcExvb2t1cFtwXSA9IHRoaXMuX2FkZFR3ZWVuLmNhbGwodGhpcy5fdHdlZW4sIHRhcmdldC5zdHlsZSwgXCJzZXRQcm9wZXJ0eVwiLCBfZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmdldFByb3BlcnR5VmFsdWUocCkgKyBcIlwiLCBlcyArIFwiXCIsIHAsIGZhbHNlLCBwKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRicyA9IF9nZXRTdHlsZSh0YXJnZXQsIHAsIF9jcykgKyBcIlwiO1xuXHRcdFx0XHRcdGlzU3RyID0gKHR5cGVvZihlcykgPT09IFwic3RyaW5nXCIpO1xuXHRcdFx0XHRcdGlmIChwID09PSBcImNvbG9yXCIgfHwgcCA9PT0gXCJmaWxsXCIgfHwgcCA9PT0gXCJzdHJva2VcIiB8fCBwLmluZGV4T2YoXCJDb2xvclwiKSAhPT0gLTEgfHwgKGlzU3RyICYmIF9yZ2Joc2xFeHAudGVzdChlcykpKSB7IC8vT3BlcmEgdXNlcyBiYWNrZ3JvdW5kOiB0byBkZWZpbmUgY29sb3Igc29tZXRpbWVzIGluIGFkZGl0aW9uIHRvIGJhY2tncm91bmRDb2xvcjpcblx0XHRcdFx0XHRcdGlmICghaXNTdHIpIHtcblx0XHRcdFx0XHRcdFx0ZXMgPSBfcGFyc2VDb2xvcihlcyk7XG5cdFx0XHRcdFx0XHRcdGVzID0gKChlcy5sZW5ndGggPiAzKSA/IFwicmdiYShcIiA6IFwicmdiKFwiKSArIGVzLmpvaW4oXCIsXCIpICsgXCIpXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwdCA9IF9wYXJzZUNvbXBsZXgoc3R5bGUsIHAsIGJzLCBlcywgdHJ1ZSwgXCJ0cmFuc3BhcmVudFwiLCBwdCwgMCwgcGx1Z2luKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaXNTdHIgJiYgX2NvbXBsZXhFeHAudGVzdChlcykpIHtcblx0XHRcdFx0XHRcdHB0ID0gX3BhcnNlQ29tcGxleChzdHlsZSwgcCwgYnMsIGVzLCB0cnVlLCBudWxsLCBwdCwgMCwgcGx1Z2luKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRibiA9IHBhcnNlRmxvYXQoYnMpO1xuXHRcdFx0XHRcdFx0YnNmeCA9IChibiB8fCBibiA9PT0gMCkgPyBicy5zdWJzdHIoKGJuICsgXCJcIikubGVuZ3RoKSA6IFwiXCI7IC8vcmVtZW1iZXIsIGJzIGNvdWxkIGJlIG5vbi1udW1lcmljIGxpa2UgXCJub3JtYWxcIiBmb3IgZm9udFdlaWdodCwgc28gd2Ugc2hvdWxkIGRlZmF1bHQgdG8gYSBibGFuayBzdWZmaXggaW4gdGhhdCBjYXNlLlxuXG5cdFx0XHRcdFx0XHRpZiAoYnMgPT09IFwiXCIgfHwgYnMgPT09IFwiYXV0b1wiKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChwID09PSBcIndpZHRoXCIgfHwgcCA9PT0gXCJoZWlnaHRcIikge1xuXHRcdFx0XHRcdFx0XHRcdGJuID0gX2dldERpbWVuc2lvbih0YXJnZXQsIHAsIF9jcyk7XG5cdFx0XHRcdFx0XHRcdFx0YnNmeCA9IFwicHhcIjtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwID09PSBcImxlZnRcIiB8fCBwID09PSBcInRvcFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ym4gPSBfY2FsY3VsYXRlT2Zmc2V0KHRhcmdldCwgcCwgX2NzKTtcblx0XHRcdFx0XHRcdFx0XHRic2Z4ID0gXCJweFwiO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGJuID0gKHAgIT09IFwib3BhY2l0eVwiKSA/IDAgOiAxO1xuXHRcdFx0XHRcdFx0XHRcdGJzZnggPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJlbCA9IChpc1N0ciAmJiBlcy5jaGFyQXQoMSkgPT09IFwiPVwiKTtcblx0XHRcdFx0XHRcdGlmIChyZWwpIHtcblx0XHRcdFx0XHRcdFx0ZW4gPSBwYXJzZUludChlcy5jaGFyQXQoMCkgKyBcIjFcIiwgMTApO1xuXHRcdFx0XHRcdFx0XHRlcyA9IGVzLnN1YnN0cigyKTtcblx0XHRcdFx0XHRcdFx0ZW4gKj0gcGFyc2VGbG9hdChlcyk7XG5cdFx0XHRcdFx0XHRcdGVzZnggPSBlcy5yZXBsYWNlKF9zdWZmaXhFeHAsIFwiXCIpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZW4gPSBwYXJzZUZsb2F0KGVzKTtcblx0XHRcdFx0XHRcdFx0ZXNmeCA9IGlzU3RyID8gZXMucmVwbGFjZShfc3VmZml4RXhwLCBcIlwiKSA6IFwiXCI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChlc2Z4ID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRcdGVzZnggPSAocCBpbiBfc3VmZml4TWFwKSA/IF9zdWZmaXhNYXBbcF0gOiBic2Z4OyAvL3BvcHVsYXRlIHRoZSBlbmQgc3VmZml4LCBwcmlvcml0aXppbmcgdGhlIG1hcCwgdGhlbiBpZiBub25lIGlzIGZvdW5kLCB1c2UgdGhlIGJlZ2lubmluZyBzdWZmaXguXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGVzID0gKGVuIHx8IGVuID09PSAwKSA/IChyZWwgPyBlbiArIGJuIDogZW4pICsgZXNmeCA6IHZhcnNbcF07IC8vZW5zdXJlcyB0aGF0IGFueSArPSBvciAtPSBwcmVmaXhlcyBhcmUgdGFrZW4gY2FyZSBvZi4gUmVjb3JkIHRoZSBlbmQgdmFsdWUgYmVmb3JlIG5vcm1hbGl6aW5nIHRoZSBzdWZmaXggYmVjYXVzZSB3ZSBhbHdheXMgd2FudCB0byBlbmQgdGhlIHR3ZWVuIG9uIGV4YWN0bHkgd2hhdCB0aGV5IGludGVuZGVkIGV2ZW4gaWYgaXQgZG9lc24ndCBtYXRjaCB0aGUgYmVnaW5uaW5nIHZhbHVlJ3Mgc3VmZml4LlxuXHRcdFx0XHRcdFx0Ly9pZiB0aGUgYmVnaW5uaW5nL2VuZGluZyBzdWZmaXhlcyBkb24ndCBtYXRjaCwgbm9ybWFsaXplIHRoZW0uLi5cblx0XHRcdFx0XHRcdGlmIChic2Z4ICE9PSBlc2Z4KSBpZiAoZXNmeCAhPT0gXCJcIiB8fCBwID09PSBcImxpbmVIZWlnaHRcIikgaWYgKGVuIHx8IGVuID09PSAwKSBpZiAoYm4pIHsgLy9ub3RlOiBpZiB0aGUgYmVnaW5uaW5nIHZhbHVlIChibikgaXMgMCwgd2UgZG9uJ3QgbmVlZCB0byBjb252ZXJ0IHVuaXRzIVxuXHRcdFx0XHRcdFx0XHRibiA9IF9jb252ZXJ0VG9QaXhlbHModGFyZ2V0LCBwLCBibiwgYnNmeCk7XG5cdFx0XHRcdFx0XHRcdGlmIChlc2Z4ID09PSBcIiVcIikge1xuXHRcdFx0XHRcdFx0XHRcdGJuIC89IF9jb252ZXJ0VG9QaXhlbHModGFyZ2V0LCBwLCAxMDAsIFwiJVwiKSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0XHRpZiAodmFycy5zdHJpY3RVbml0cyAhPT0gdHJ1ZSkgeyAvL3NvbWUgYnJvd3NlcnMgcmVwb3J0IG9ubHkgXCJweFwiIHZhbHVlcyBpbnN0ZWFkIG9mIGFsbG93aW5nIFwiJVwiIHdpdGggZ2V0Q29tcHV0ZWRTdHlsZSgpLCBzbyB3ZSBhc3N1bWUgdGhhdCBpZiB3ZSdyZSB0d2VlbmluZyB0byBhICUsIHdlIHNob3VsZCBzdGFydCB0aGVyZSB0b28gdW5sZXNzIHN0cmljdFVuaXRzOnRydWUgaXMgZGVmaW5lZC4gVGhpcyBhcHByb2FjaCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciByZXNwb25zaXZlIGRlc2lnbnMgdGhhdCB1c2UgZnJvbSgpIHR3ZWVucy5cblx0XHRcdFx0XHRcdFx0XHRcdGJzID0gYm4gKyBcIiVcIjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChlc2Z4ID09PSBcImVtXCIgfHwgZXNmeCA9PT0gXCJyZW1cIiB8fCBlc2Z4ID09PSBcInZ3XCIgfHwgZXNmeCA9PT0gXCJ2aFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ym4gLz0gX2NvbnZlcnRUb1BpeGVscyh0YXJnZXQsIHAsIDEsIGVzZngpO1xuXG5cdFx0XHRcdFx0XHRcdC8vb3RoZXJ3aXNlIGNvbnZlcnQgdG8gcGl4ZWxzLlxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGVzZnggIT09IFwicHhcIikge1xuXHRcdFx0XHRcdFx0XHRcdGVuID0gX2NvbnZlcnRUb1BpeGVscyh0YXJnZXQsIHAsIGVuLCBlc2Z4KTtcblx0XHRcdFx0XHRcdFx0XHRlc2Z4ID0gXCJweFwiOyAvL3dlIGRvbid0IHVzZSBic2Z4IGFmdGVyIHRoaXMsIHNvIHdlIGRvbid0IG5lZWQgdG8gc2V0IGl0IHRvIHB4IHRvby5cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAocmVsKSBpZiAoZW4gfHwgZW4gPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRlcyA9IChlbiArIGJuKSArIGVzZng7IC8vdGhlIGNoYW5nZXMgd2UgbWFkZSBhZmZlY3QgcmVsYXRpdmUgY2FsY3VsYXRpb25zLCBzbyBhZGp1c3QgdGhlIGVuZCB2YWx1ZSBoZXJlLlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChyZWwpIHtcblx0XHRcdFx0XHRcdFx0ZW4gKz0gYm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICgoYm4gfHwgYm4gPT09IDApICYmIChlbiB8fCBlbiA9PT0gMCkpIHsgLy9mYXN0ZXIgdGhhbiBpc05hTigpLiBBbHNvLCBwcmV2aW91c2x5IHdlIHJlcXVpcmVkIGVuICE9PSBibiBidXQgdGhhdCBkb2Vzbid0IHJlYWxseSBnYWluIG11Y2ggcGVyZm9ybWFuY2UgYW5kIGl0IHByZXZlbnRzIF9wYXJzZVRvUHJveHkoKSBmcm9tIHdvcmtpbmcgcHJvcGVybHkgaWYgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIG1hdGNoIGJ1dCBuZWVkIHRvIGdldCB0d2VlbmVkIGJ5IGFuIGV4dGVybmFsIHBsdWdpbiBhbnl3YXkuIEZvciBleGFtcGxlLCBhIGJlemllciB0d2VlbiB3aGVyZSB0aGUgdGFyZ2V0IHN0YXJ0cyBhdCBsZWZ0OjAgYW5kIGhhcyB0aGVzZSBwb2ludHM6IFt7bGVmdDo1MH0se2xlZnQ6MH1dIHdvdWxkbid0IHdvcmsgcHJvcGVybHkgYmVjYXVzZSB3aGVuIHBhcnNpbmcgdGhlIGxhc3QgcG9pbnQsIGl0J2QgbWF0Y2ggdGhlIGZpcnN0IChjdXJyZW50KSBvbmUgYW5kIGEgbm9uLXR3ZWVuaW5nIENTU1Byb3BUd2VlbiB3b3VsZCBiZSByZWNvcmRlZCB3aGVuIHdlIGFjdHVhbGx5IG5lZWQgYSBub3JtYWwgdHdlZW4gKHR5cGU6MCkgc28gdGhhdCB0aGluZ3MgZ2V0IHVwZGF0ZWQgZHVyaW5nIHRoZSB0d2VlbiBwcm9wZXJseS5cblx0XHRcdFx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHN0eWxlLCBwLCBibiwgZW4gLSBibiwgcHQsIDAsIHAsIChfYXV0b1JvdW5kICE9PSBmYWxzZSAmJiAoZXNmeCA9PT0gXCJweFwiIHx8IHAgPT09IFwiekluZGV4XCIpKSwgMCwgYnMsIGVzKTtcblx0XHRcdFx0XHRcdFx0cHQueHMwID0gZXNmeDtcblx0XHRcdFx0XHRcdFx0Ly9ERUJVRzogX2xvZyhcInR3ZWVuIFwiK3ArXCIgZnJvbSBcIitwdC5iK1wiIChcIitibitlc2Z4K1wiKSB0byBcIitwdC5lK1wiIHdpdGggc3VmZml4OiBcIitwdC54czApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzdHlsZVtwXSA9PT0gdW5kZWZpbmVkIHx8ICFlcyAmJiAoZXMgKyBcIlwiID09PSBcIk5hTlwiIHx8IGVzID09IG51bGwpKSB7XG5cdFx0XHRcdFx0XHRcdF9sb2coXCJpbnZhbGlkIFwiICsgcCArIFwiIHR3ZWVuIHZhbHVlOiBcIiArIHZhcnNbcF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHN0eWxlLCBwLCBlbiB8fCBibiB8fCAwLCAwLCBwdCwgLTEsIHAsIGZhbHNlLCAwLCBicywgZXMpO1xuXHRcdFx0XHRcdFx0XHRwdC54czAgPSAoZXMgPT09IFwibm9uZVwiICYmIChwID09PSBcImRpc3BsYXlcIiB8fCBwLmluZGV4T2YoXCJTdHlsZVwiKSAhPT0gLTEpKSA/IGJzIDogZXM7IC8vaW50ZXJtZWRpYXRlIHZhbHVlIHNob3VsZCB0eXBpY2FsbHkgYmUgc2V0IGltbWVkaWF0ZWx5IChlbmQgdmFsdWUpIGV4Y2VwdCBmb3IgXCJkaXNwbGF5XCIgb3IgdGhpbmdzIGxpa2UgYm9yZGVyVG9wU3R5bGUsIGJvcmRlckJvdHRvbVN0eWxlLCBldGMuIHdoaWNoIHNob3VsZCB1c2UgdGhlIGJlZ2lubmluZyB2YWx1ZSBkdXJpbmcgdGhlIHR3ZWVuLlxuXHRcdFx0XHRcdFx0XHQvL0RFQlVHOiBfbG9nKFwibm9uLXR3ZWVuaW5nIHZhbHVlIFwiK3ArXCI6IFwiK3B0LnhzMCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwbHVnaW4pIGlmIChwdCAmJiAhcHQucGx1Z2luKSB7XG5cdFx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fTtcblxuXG5cdFx0Ly9nZXRzIGNhbGxlZCBldmVyeSB0aW1lIHRoZSB0d2VlbiB1cGRhdGVzLCBwYXNzaW5nIHRoZSBuZXcgcmF0aW8gKHR5cGljYWxseSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgYnV0IG5vdCBhbHdheXMgKGZvciBleGFtcGxlLCBpZiBhbiBFbGFzdGljLmVhc2VPdXQgaXMgdXNlZCwgdGhlIHZhbHVlIGNhbiBqdW1wIGFib3ZlIDEgbWlkLXR3ZWVuKS4gSXQgd2lsbCBhbHdheXMgc3RhcnQgYW5kIDAgYW5kIGVuZCBhdCAxLlxuXHRcdHAuc2V0UmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHR2YXIgcHQgPSB0aGlzLl9maXJzdFBULFxuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0dmFsLCBzdHIsIGk7XG5cdFx0XHQvL2F0IHRoZSBlbmQgb2YgdGhlIHR3ZWVuLCB3ZSBzZXQgdGhlIHZhbHVlcyB0byBleGFjdGx5IHdoYXQgd2UgcmVjZWl2ZWQgaW4gb3JkZXIgdG8gbWFrZSBzdXJlIG5vbi10d2VlbmluZyB2YWx1ZXMgKGxpa2UgXCJwb3NpdGlvblwiIG9yIFwiZmxvYXRcIiBvciB3aGF0ZXZlcikgYXJlIHNldCBhbmQgc28gdGhhdCBpZiB0aGUgYmVnaW5uaW5nL2VuZGluZyBzdWZmaXhlcyAodW5pdHMpIGRpZG4ndCBtYXRjaCBhbmQgd2Ugbm9ybWFsaXplZCB0byBweCwgdGhlIHZhbHVlIHRoYXQgdGhlIHVzZXIgcGFzc2VkIGluIGlzIHVzZWQgaGVyZS4gV2UgY2hlY2sgdG8gc2VlIGlmIHRoZSB0d2VlbiBpcyBhdCBpdHMgYmVnaW5uaW5nIGluIGNhc2UgaXQncyBhIGZyb20oKSB0d2VlbiBpbiB3aGljaCBjYXNlIHRoZSByYXRpbyB3aWxsIGFjdHVhbGx5IGdvIGZyb20gMSB0byAwIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgdHdlZW4gKGJhY2t3YXJkcykuXG5cdFx0XHRpZiAodiA9PT0gMSAmJiAodGhpcy5fdHdlZW4uX3RpbWUgPT09IHRoaXMuX3R3ZWVuLl9kdXJhdGlvbiB8fCB0aGlzLl90d2Vlbi5fdGltZSA9PT0gMCkpIHtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0aWYgKHB0LnR5cGUgIT09IDIpIHtcblx0XHRcdFx0XHRcdGlmIChwdC5yICYmIHB0LnR5cGUgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHZhbCA9IHB0LnIocHQucyArIHB0LmMpO1xuXHRcdFx0XHRcdFx0XHRpZiAoIXB0LnR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gdmFsICsgcHQueHMwO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0LnR5cGUgPT09IDEpIHsgLy9jb21wbGV4IHZhbHVlIChvbmUgdGhhdCB0eXBpY2FsbHkgaGFzIG11bHRpcGxlIG51bWJlcnMgaW5zaWRlIGEgc3RyaW5nLCBsaWtlIFwicmVjdCg1cHgsMTBweCwyMHB4LDI1cHgpXCJcblx0XHRcdFx0XHRcdFx0XHRpID0gcHQubDtcblx0XHRcdFx0XHRcdFx0XHRzdHIgPSBwdC54czAgKyB2YWwgKyBwdC54czE7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChpID0gMTsgaSA8IHB0Lmw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RyICs9IHB0W1wieG5cIitpXSArIHB0W1wieHNcIisoaSsxKV07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBzdHI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC5lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdC5zZXRSYXRpbyh2KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKHYgfHwgISh0aGlzLl90d2Vlbi5fdGltZSA9PT0gdGhpcy5fdHdlZW4uX2R1cmF0aW9uIHx8IHRoaXMuX3R3ZWVuLl90aW1lID09PSAwKSB8fCB0aGlzLl90d2Vlbi5fcmF3UHJldlRpbWUgPT09IC0wLjAwMDAwMSkge1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHR2YWwgPSBwdC5jICogdiArIHB0LnM7XG5cdFx0XHRcdFx0aWYgKHB0LnIpIHtcblx0XHRcdFx0XHRcdHZhbCA9IHB0LnIodmFsKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbCA8IG1pbikgaWYgKHZhbCA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHZhbCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghcHQudHlwZSkge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHZhbCArIHB0LnhzMDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0LnR5cGUgPT09IDEpIHsgLy9jb21wbGV4IHZhbHVlIChvbmUgdGhhdCB0eXBpY2FsbHkgaGFzIG11bHRpcGxlIG51bWJlcnMgaW5zaWRlIGEgc3RyaW5nLCBsaWtlIFwicmVjdCg1cHgsMTBweCwyMHB4LDI1cHgpXCJcblx0XHRcdFx0XHRcdGkgPSBwdC5sO1xuXHRcdFx0XHRcdFx0aWYgKGkgPT09IDIpIHtcblx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnhzMCArIHZhbCArIHB0LnhzMSArIHB0LnhuMSArIHB0LnhzMjtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gMykge1xuXHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQueHMwICsgdmFsICsgcHQueHMxICsgcHQueG4xICsgcHQueHMyICsgcHQueG4yICsgcHQueHMzO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChpID09PSA0KSB7XG5cdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC54czAgKyB2YWwgKyBwdC54czEgKyBwdC54bjEgKyBwdC54czIgKyBwdC54bjIgKyBwdC54czMgKyBwdC54bjMgKyBwdC54czQ7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGkgPT09IDUpIHtcblx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnhzMCArIHZhbCArIHB0LnhzMSArIHB0LnhuMSArIHB0LnhzMiArIHB0LnhuMiArIHB0LnhzMyArIHB0LnhuMyArIHB0LnhzNCArIHB0LnhuNCArIHB0LnhzNTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHN0ciA9IHB0LnhzMCArIHZhbCArIHB0LnhzMTtcblx0XHRcdFx0XHRcdFx0Zm9yIChpID0gMTsgaSA8IHB0Lmw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHN0ciArPSBwdFtcInhuXCIraV0gKyBwdFtcInhzXCIrKGkrMSldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBzdHI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0LnR5cGUgPT09IC0xKSB7IC8vbm9uLXR3ZWVuaW5nIHZhbHVlXG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQueHMwO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwdC5zZXRSYXRpbykgeyAvL2N1c3RvbSBzZXRSYXRpbygpIGZvciB0aGluZ3MgbGlrZSBTcGVjaWFsUHJvcHMsIGV4dGVybmFsIHBsdWdpbnMsIGV0Yy5cblx0XHRcdFx0XHRcdHB0LnNldFJhdGlvKHYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vaWYgdGhlIHR3ZWVuIGlzIHJldmVyc2VkIGFsbCB0aGUgd2F5IGJhY2sgdG8gdGhlIGJlZ2lubmluZywgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCB2YWx1ZXMgd2hpY2ggbWF5IGhhdmUgZGlmZmVyZW50IHVuaXRzIChsaWtlICUgaW5zdGVhZCBvZiBweCBvciBlbSBvciB3aGF0ZXZlcikuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRpZiAocHQudHlwZSAhPT0gMikge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LmI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0LnNldFJhdGlvKHYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogRm9yY2VzIHJlbmRlcmluZyBvZiB0aGUgdGFyZ2V0J3MgdHJhbnNmb3JtcyAocm90YXRpb24sIHNjYWxlLCBldGMuKSB3aGVuZXZlciB0aGUgQ1NTUGx1Z2luJ3Mgc2V0UmF0aW8oKSBpcyBjYWxsZWQuXG5cdFx0ICogQmFzaWNhbGx5LCB0aGlzIHRlbGxzIHRoZSBDU1NQbHVnaW4gdG8gY3JlYXRlIGEgQ1NTUHJvcFR3ZWVuICh0eXBlIDIpIGFmdGVyIGluc3RhbnRpYXRpb24gdGhhdCBydW5zIGxhc3QgaW4gdGhlIGxpbmtlZFxuXHRcdCAqIGxpc3QgYW5kIGNhbGxzIHRoZSBhcHByb3ByaWF0ZSAoM0Qgb3IgMkQpIHJlbmRlcmluZyBmdW5jdGlvbi4gV2Ugc2VwYXJhdGUgdGhpcyBpbnRvIGl0cyBvd24gbWV0aG9kIHNvIHRoYXQgd2UgY2FuIGNhbGxcblx0XHQgKiBpdCBmcm9tIG90aGVyIHBsdWdpbnMgbGlrZSBCZXppZXJQbHVnaW4gaWYsIGZvciBleGFtcGxlLCBpdCBuZWVkcyB0byBhcHBseSBhbiBhdXRvUm90YXRpb24gYW5kIHRoaXMgQ1NTUGx1Z2luXG5cdFx0ICogZG9lc24ndCBoYXZlIGFueSB0cmFuc2Zvcm0tcmVsYXRlZCBwcm9wZXJ0aWVzIG9mIGl0cyBvd24uIFlvdSBjYW4gY2FsbCB0aGlzIG1ldGhvZCBhcyBtYW55IHRpbWVzIGFzIHlvdVxuXHRcdCAqIHdhbnQgYW5kIGl0IHdvbid0IGNyZWF0ZSBkdXBsaWNhdGUgQ1NTUHJvcFR3ZWVucy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gdGhyZWVEIGlmIHRydWUsIGl0IHNob3VsZCBhcHBseSAzRCB0d2VlbnMgKG90aGVyd2lzZSwganVzdCAyRCBvbmVzIGFyZSBmaW5lIGFuZCB0eXBpY2FsbHkgZmFzdGVyKVxuXHRcdCAqL1xuXHRcdHAuX2VuYWJsZVRyYW5zZm9ybXMgPSBmdW5jdGlvbih0aHJlZUQpIHtcblx0XHRcdHRoaXMuX3RyYW5zZm9ybSA9IHRoaXMuX3RyYW5zZm9ybSB8fCBfZ2V0VHJhbnNmb3JtKHRoaXMuX3RhcmdldCwgX2NzLCB0cnVlKTsgLy9lbnN1cmVzIHRoYXQgdGhlIGVsZW1lbnQgaGFzIGEgX2dzVHJhbnNmb3JtIHByb3BlcnR5IHdpdGggdGhlIGFwcHJvcHJpYXRlIHZhbHVlcy5cblx0XHRcdHRoaXMuX3RyYW5zZm9ybVR5cGUgPSAoISh0aGlzLl90cmFuc2Zvcm0uc3ZnICYmIF91c2VTVkdUcmFuc2Zvcm1BdHRyKSAmJiAodGhyZWVEIHx8IHRoaXMuX3RyYW5zZm9ybVR5cGUgPT09IDMpKSA/IDMgOiAyO1xuXHRcdH07XG5cblx0XHR2YXIgbGF6eVNldCA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdHRoaXMudFt0aGlzLnBdID0gdGhpcy5lO1xuXHRcdFx0dGhpcy5kYXRhLl9saW5rQ1NTUCh0aGlzLCB0aGlzLl9uZXh0LCBudWxsLCB0cnVlKTsgLy93ZSBwdXJwb3NlZnVsbHkga2VlcCB0aGlzLl9uZXh0IGV2ZW4gdGhvdWdoIGl0J2QgbWFrZSBzZW5zZSB0byBudWxsIGl0LCBidXQgdGhpcyBpcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiwgYXMgdGhpcyBoYXBwZW5zIGR1cmluZyB0aGUgd2hpbGUgKHB0KSB7fSBsb29wIGluIHNldFJhdGlvKCkgYXQgdGhlIGJvdHRvbSBvZiB3aGljaCBpdCBzZXRzIHB0ID0gcHQuX25leHQsIHNvIGlmIHdlIG51bGwgaXQsIHRoZSBsaW5rZWQgbGlzdCB3aWxsIGJlIGJyb2tlbiBpbiB0aGF0IGxvb3AuXG5cdFx0fTtcblx0XHQvKiogQHByaXZhdGUgR2l2ZXMgdXMgYSB3YXkgdG8gc2V0IGEgdmFsdWUgb24gdGhlIGZpcnN0IHJlbmRlciAoYW5kIG9ubHkgdGhlIGZpcnN0IHJlbmRlcikuICoqL1xuXHRcdHAuX2FkZExhenlTZXQgPSBmdW5jdGlvbih0LCBwLCB2KSB7XG5cdFx0XHR2YXIgcHQgPSB0aGlzLl9maXJzdFBUID0gbmV3IENTU1Byb3BUd2Vlbih0LCBwLCAwLCAwLCB0aGlzLl9maXJzdFBULCAyKTtcblx0XHRcdHB0LmUgPSB2O1xuXHRcdFx0cHQuc2V0UmF0aW8gPSBsYXp5U2V0O1xuXHRcdFx0cHQuZGF0YSA9IHRoaXM7XG5cdFx0fTtcblxuXHRcdC8qKiBAcHJpdmF0ZSAqKi9cblx0XHRwLl9saW5rQ1NTUCA9IGZ1bmN0aW9uKHB0LCBuZXh0LCBwcmV2LCByZW1vdmUpIHtcblx0XHRcdGlmIChwdCkge1xuXHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdG5leHQuX3ByZXYgPSBwdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHQuX25leHQpIHtcblx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0Ll9wcmV2O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwdC5fcHJldikge1xuXHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fZmlyc3RQVCA9PT0gcHQpIHtcblx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0cmVtb3ZlID0gdHJ1ZTsgLy9qdXN0IHRvIHByZXZlbnQgcmVzZXR0aW5nIHRoaXMuX2ZpcnN0UFQgNSBsaW5lcyBkb3duIGluIGNhc2UgcHQuX25leHQgaXMgbnVsbC4gKG9wdGltaXplZCBmb3Igc3BlZWQpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByZXYpIHtcblx0XHRcdFx0XHRwcmV2Ll9uZXh0ID0gcHQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIXJlbW92ZSAmJiB0aGlzLl9maXJzdFBUID09PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0Ll9uZXh0ID0gbmV4dDtcblx0XHRcdFx0cHQuX3ByZXYgPSBwcmV2O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH07XG5cblx0XHRwLl9tb2QgPSBmdW5jdGlvbihsb29rdXApIHtcblx0XHRcdHZhciBwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKHR5cGVvZihsb29rdXBbcHQucF0pID09PSBcImZ1bmN0aW9uXCIpIHsgLy9vbmx5IGdldHMgY2FsbGVkIGJ5IFJvdW5kUHJvcHNQbHVnaW4gKE1vZGlmeVBsdWdpbiBtYW5hZ2VzIGFsbCB0aGUgcmVuZGVyaW5nIGludGVybmFsbHkgZm9yIENTU1BsdWdpbiBwcm9wZXJ0aWVzIHRoYXQgbmVlZCBtb2RpZmljYXRpb24pLiBSZW1lbWJlciwgd2UgaGFuZGxlIHJvdW5kaW5nIGEgYml0IGRpZmZlcmVudGx5IGluIHRoaXMgcGx1Z2luIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBsZXZlcmFnaW5nIFwiclwiIGFzIGFuIGluZGljYXRvciB0aGF0IHRoZSB2YWx1ZSBzaG91bGQgYmUgcm91bmRlZCBpbnRlcm5hbGx5LlxuXHRcdFx0XHRcdHB0LnIgPSBsb29rdXBbcHQucF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly93ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGlmIGFscGhhIG9yIGF1dG9BbHBoYSBpcyBraWxsZWQsIG9wYWNpdHkgaXMgdG9vLiBBbmQgYXV0b0FscGhhIGFmZmVjdHMgdGhlIFwidmlzaWJpbGl0eVwiIHByb3BlcnR5LlxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbihsb29rdXApIHtcblx0XHRcdHZhciBjb3B5ID0gbG9va3VwLFxuXHRcdFx0XHRwdCwgcCwgeGZpcnN0O1xuXHRcdFx0aWYgKGxvb2t1cC5hdXRvQWxwaGEgfHwgbG9va3VwLmFscGhhKSB7XG5cdFx0XHRcdGNvcHkgPSB7fTtcblx0XHRcdFx0Zm9yIChwIGluIGxvb2t1cCkgeyAvL2NvcHkgdGhlIGxvb2t1cCBzbyB0aGF0IHdlJ3JlIG5vdCBjaGFuZ2luZyB0aGUgb3JpZ2luYWwgd2hpY2ggbWF5IGJlIHBhc3NlZCBlbHNld2hlcmUuXG5cdFx0XHRcdFx0Y29weVtwXSA9IGxvb2t1cFtwXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb3B5Lm9wYWNpdHkgPSAxO1xuXHRcdFx0XHRpZiAoY29weS5hdXRvQWxwaGEpIHtcblx0XHRcdFx0XHRjb3B5LnZpc2liaWxpdHkgPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAobG9va3VwLmNsYXNzTmFtZSAmJiAocHQgPSB0aGlzLl9jbGFzc05hbWVQVCkpIHsgLy9mb3IgY2xhc3NOYW1lIHR3ZWVucywgd2UgbmVlZCB0byBraWxsIGFueSBhc3NvY2lhdGVkIENTU1Byb3BUd2VlbnMgdG9vOyBhIGxpbmtlZCBsaXN0IHN0YXJ0cyBhdCB0aGUgY2xhc3NOYW1lJ3MgXCJ4Zmlyc3RcIi5cblx0XHRcdFx0eGZpcnN0ID0gcHQueGZpcnN0O1xuXHRcdFx0XHRpZiAoeGZpcnN0ICYmIHhmaXJzdC5fcHJldikge1xuXHRcdFx0XHRcdHRoaXMuX2xpbmtDU1NQKHhmaXJzdC5fcHJldiwgcHQuX25leHQsIHhmaXJzdC5fcHJldi5fcHJldik7IC8vYnJlYWsgb2ZmIHRoZSBwcmV2XG5cdFx0XHRcdH0gZWxzZSBpZiAoeGZpcnN0ID09PSB0aGlzLl9maXJzdFBUKSB7XG5cdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdHRoaXMuX2xpbmtDU1NQKHB0Ll9uZXh0LCBwdC5fbmV4dC5fbmV4dCwgeGZpcnN0Ll9wcmV2KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jbGFzc05hbWVQVCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKHB0LnBsdWdpbiAmJiBwdC5wbHVnaW4gIT09IHAgJiYgcHQucGx1Z2luLl9raWxsKSB7IC8vZm9yIHBsdWdpbnMgdGhhdCBhcmUgcmVnaXN0ZXJlZCB3aXRoIENTU1BsdWdpbiwgd2Ugc2hvdWxkIG5vdGlmeSB0aGVtIG9mIHRoZSBraWxsLlxuXHRcdFx0XHRcdHB0LnBsdWdpbi5fa2lsbChsb29rdXApO1xuXHRcdFx0XHRcdHAgPSBwdC5wbHVnaW47XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBUd2VlblBsdWdpbi5wcm90b3R5cGUuX2tpbGwuY2FsbCh0aGlzLCBjb3B5KTtcblx0XHR9O1xuXG5cblxuXHRcdC8vdXNlZCBieSBjYXNjYWRlVG8oKSBmb3IgZ2F0aGVyaW5nIGFsbCB0aGUgc3R5bGUgcHJvcGVydGllcyBvZiBlYWNoIGNoaWxkIGVsZW1lbnQgaW50byBhbiBhcnJheSBmb3IgY29tcGFyaXNvbi5cblx0XHR2YXIgX2dldENoaWxkU3R5bGVzID0gZnVuY3Rpb24oZSwgcHJvcHMsIHRhcmdldHMpIHtcblx0XHRcdFx0dmFyIGNoaWxkcmVuLCBpLCBjaGlsZCwgdHlwZTtcblx0XHRcdFx0aWYgKGUuc2xpY2UpIHtcblx0XHRcdFx0XHRpID0gZS5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRfZ2V0Q2hpbGRTdHlsZXMoZVtpXSwgcHJvcHMsIHRhcmdldHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hpbGRyZW4gPSBlLmNoaWxkTm9kZXM7XG5cdFx0XHRcdGkgPSBjaGlsZHJlbi5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHRcdFx0dHlwZSA9IGNoaWxkLnR5cGU7XG5cdFx0XHRcdFx0aWYgKGNoaWxkLnN0eWxlKSB7XG5cdFx0XHRcdFx0XHRwcm9wcy5wdXNoKF9nZXRBbGxTdHlsZXMoY2hpbGQpKTtcblx0XHRcdFx0XHRcdGlmICh0YXJnZXRzKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldHMucHVzaChjaGlsZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgodHlwZSA9PT0gMSB8fCB0eXBlID09PSA5IHx8IHR5cGUgPT09IDExKSAmJiBjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0X2dldENoaWxkU3R5bGVzKGNoaWxkLCBwcm9wcywgdGFyZ2V0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVHlwaWNhbGx5IG9ubHkgdXNlZnVsIGZvciBjbGFzc05hbWUgdHdlZW5zIHRoYXQgbWF5IGFmZmVjdCBjaGlsZCBlbGVtZW50cywgdGhpcyBtZXRob2QgY3JlYXRlcyBhIFR3ZWVuTGl0ZVxuXHRcdCAqIGFuZCB0aGVuIGNvbXBhcmVzIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIG9mIGFsbCB0aGUgdGFyZ2V0J3MgY2hpbGQgZWxlbWVudHMgYXQgdGhlIHR3ZWVuJ3Mgc3RhcnQgYW5kIGVuZCwgYW5kXG5cdFx0ICogaWYgYW55IGFyZSBkaWZmZXJlbnQsIGl0IGFsc28gY3JlYXRlcyB0d2VlbnMgZm9yIHRob3NlIGFuZCByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgQUxMIG9mIHRoZSByZXN1bHRpbmdcblx0XHQgKiB0d2VlbnMgKHNvIHRoYXQgeW91IGNhbiBlYXNpbHkgYWRkKCkgdGhlbSB0byBhIFRpbWVsaW5lTGl0ZSwgZm9yIGV4YW1wbGUpLiBUaGUgcmVhc29uIHRoaXMgZnVuY3Rpb25hbGl0eSBpc1xuXHRcdCAqIHdyYXBwZWQgaW50byBhIHNlcGFyYXRlIHN0YXRpYyBtZXRob2Qgb2YgQ1NTUGx1Z2luIGluc3RlYWQgb2YgYmVpbmcgaW50ZWdyYXRlZCBpbnRvIGFsbCByZWd1bGFyIGNsYXNzTmFtZSB0d2VlbnNcblx0XHQgKiBpcyBiZWNhdXNlIGl0IGNyZWF0ZXMgZW50aXJlbHkgbmV3IHR3ZWVucyB0aGF0IG1heSBoYXZlIGNvbXBsZXRlbHkgZGlmZmVyZW50IHRhcmdldHMgdGhhbiB0aGUgb3JpZ2luYWwgdHdlZW4sXG5cdFx0ICogc28gaWYgdGhleSB3ZXJlIGFsbCBsdW1wZWQgaW50byB0aGUgb3JpZ2luYWwgdHdlZW4gaW5zdGFuY2UsIGl0IHdvdWxkIGJlIGluY29uc2lzdGVudCB3aXRoIHRoZSByZXN0IG9mIHRoZSBBUElcblx0XHQgKiBhbmQgaXQgd291bGQgY3JlYXRlIG90aGVyIHByb2JsZW1zLiBGb3IgZXhhbXBsZTpcblx0XHQgKiAgLSBJZiBJIGNyZWF0ZSBhIHR3ZWVuIG9mIGVsZW1lbnRBLCB0aGF0IHR3ZWVuIGluc3RhbmNlIG1heSBzdWRkZW5seSBjaGFuZ2UgaXRzIHRhcmdldCB0byBpbmNsdWRlIDUwIG90aGVyIGVsZW1lbnRzICh1bmludHVpdGl2ZSBpZiBJIHNwZWNpZmljYWxseSBkZWZpbmVkIHRoZSB0YXJnZXQgSSB3YW50ZWQpXG5cdFx0ICogIC0gV2UgY2FuJ3QganVzdCBjcmVhdGUgbmV3IGluZGVwZW5kZW50IHR3ZWVucyBiZWNhdXNlIG90aGVyd2lzZSwgd2hhdCBoYXBwZW5zIGlmIHRoZSBvcmlnaW5hbC9wYXJlbnQgdHdlZW4gaXMgcmV2ZXJzZWQgb3IgcGF1c2Ugb3IgZHJvcHBlZCBpbnRvIGEgVGltZWxpbmVMaXRlIGZvciB0aWdodCBjb250cm9sPyBZb3UnZCBleHBlY3QgdGhhdCB0d2VlbidzIGJlaGF2aW9yIHRvIGFmZmVjdCBhbGwgdGhlIG90aGVycy5cblx0XHQgKiAgLSBBbmFseXppbmcgZXZlcnkgc3R5bGUgcHJvcGVydHkgb2YgZXZlcnkgY2hpbGQgYmVmb3JlIGFuZCBhZnRlciB0aGUgdHdlZW4gaXMgYW4gZXhwZW5zaXZlIG9wZXJhdGlvbiB3aGVuIHRoZXJlIGFyZSBtYW55IGNoaWxkcmVuLCBzbyB0aGlzIGJlaGF2aW9yIHNob3VsZG4ndCBiZSBpbXBvc2VkIG9uIGFsbCBjbGFzc05hbWUgdHdlZW5zIGJ5IGRlZmF1bHQsIGVzcGVjaWFsbHkgc2luY2UgaXQncyBwcm9iYWJseSByYXJlIHRoYXQgdGhpcyBleHRyYSBmdW5jdGlvbmFsaXR5IGlzIG5lZWRlZC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgb2JqZWN0IHRvIGJlIHR3ZWVuZWRcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gRHVyYXRpb24gaW4gc2Vjb25kcyAob3IgZnJhbWVzIGZvciBmcmFtZXMtYmFzZWQgdHdlZW5zKVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgZW5kIHZhbHVlcywgbGlrZSB7Y2xhc3NOYW1lOlwibmV3Q2xhc3NcIiwgZWFzZTpMaW5lYXIuZWFzZU5vbmV9XG5cdFx0ICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIFR3ZWVuTGl0ZSBpbnN0YW5jZXNcblx0XHQgKi9cblx0XHRDU1NQbHVnaW4uY2FzY2FkZVRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0dmFyIHR3ZWVuID0gVHdlZW5MaXRlLnRvKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpLFxuXHRcdFx0XHRyZXN1bHRzID0gW3R3ZWVuXSxcblx0XHRcdFx0YiA9IFtdLFxuXHRcdFx0XHRlID0gW10sXG5cdFx0XHRcdHRhcmdldHMgPSBbXSxcblx0XHRcdFx0X3Jlc2VydmVkUHJvcHMgPSBUd2VlbkxpdGUuX2ludGVybmFscy5yZXNlcnZlZFByb3BzLFxuXHRcdFx0XHRpLCBkaWZzLCBwLCBmcm9tO1xuXHRcdFx0dGFyZ2V0ID0gdHdlZW4uX3RhcmdldHMgfHwgdHdlZW4udGFyZ2V0O1xuXHRcdFx0X2dldENoaWxkU3R5bGVzKHRhcmdldCwgYiwgdGFyZ2V0cyk7XG5cdFx0XHR0d2Vlbi5yZW5kZXIoZHVyYXRpb24sIHRydWUsIHRydWUpO1xuXHRcdFx0X2dldENoaWxkU3R5bGVzKHRhcmdldCwgZSk7XG5cdFx0XHR0d2Vlbi5yZW5kZXIoMCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHR0d2Vlbi5fZW5hYmxlZCh0cnVlKTtcblx0XHRcdGkgPSB0YXJnZXRzLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRkaWZzID0gX2Nzc0RpZih0YXJnZXRzW2ldLCBiW2ldLCBlW2ldKTtcblx0XHRcdFx0aWYgKGRpZnMuZmlyc3RNUFQpIHtcblx0XHRcdFx0XHRkaWZzID0gZGlmcy5kaWZzO1xuXHRcdFx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdFx0XHRpZiAoX3Jlc2VydmVkUHJvcHNbcF0pIHtcblx0XHRcdFx0XHRcdFx0ZGlmc1twXSA9IHZhcnNbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZyb20gPSB7fTtcblx0XHRcdFx0XHRmb3IgKHAgaW4gZGlmcykge1xuXHRcdFx0XHRcdFx0ZnJvbVtwXSA9IGJbaV1bcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdHMucHVzaChUd2VlbkxpdGUuZnJvbVRvKHRhcmdldHNbaV0sIGR1cmF0aW9uLCBmcm9tLCBkaWZzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0XHRUd2VlblBsdWdpbi5hY3RpdmF0ZShbQ1NTUGx1Z2luXSk7XG5cdFx0cmV0dXJuIENTU1BsdWdpbjtcblxuXHR9LCB0cnVlKTtcblxuZXhwb3J0IHZhciBDU1NQbHVnaW4gPSBnbG9iYWxzLkNTU1BsdWdpbjtcbmV4cG9ydCB7IENTU1BsdWdpbiBhcyBkZWZhdWx0IH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ3NhcC9DU1NQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogVkVSU0lPTjogMC42LjFcbiAqIERBVEU6IDIwMTgtMDgtMjdcbiAqIFVQREFURVMgQU5EIERPQ1MgQVQ6IGh0dHA6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDA4LTIwMTgsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgd29yayBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIHNvZnR3YXJlIGFncmVlbWVudCB0aGF0IHdhcyBpc3N1ZWQgd2l0aCB5b3VyIG1lbWJlcnNoaXAuXG4gKiBcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICovXG5cbmltcG9ydCB7IF9nc1Njb3BlIH0gZnJvbSBcIi4vVHdlZW5MaXRlLmpzXCI7XG5cbmV4cG9ydCB2YXIgQXR0clBsdWdpbiA9IF9nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe1xuXHRwcm9wTmFtZTogXCJhdHRyXCIsXG5cdEFQSTogMixcblx0dmVyc2lvbjogXCIwLjYuMVwiLFxuXG5cdC8vY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGlzIHdoZXJlIGluaXRpYWwgdmFsdWVzIHNob3VsZCBiZSByZWNvcmRlZCBhbmQgYW55IHNldHVwIHJvdXRpbmVzIHNob3VsZCBydW4uXG5cdGluaXQ6IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUsIHR3ZWVuLCBpbmRleCkge1xuXHRcdHZhciBwLCBlbmQ7XG5cdFx0aWYgKHR5cGVvZih0YXJnZXQuc2V0QXR0cmlidXRlKSAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGZvciAocCBpbiB2YWx1ZSkge1xuXHRcdFx0ZW5kID0gdmFsdWVbcF07XG5cdFx0XHRpZiAodHlwZW9mKGVuZCkgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRlbmQgPSBlbmQoaW5kZXgsIHRhcmdldCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9hZGRUd2Vlbih0YXJnZXQsIFwic2V0QXR0cmlidXRlXCIsIHRhcmdldC5nZXRBdHRyaWJ1dGUocCkgKyBcIlwiLCBlbmQgKyBcIlwiLCBwLCBmYWxzZSwgcCk7XG5cdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHApO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG59KTtcblxuZXhwb3J0IHsgQXR0clBsdWdpbiBhcyBkZWZhdWx0IH07XG5cblxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nc2FwL0F0dHJQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogVkVSU0lPTjogMS42LjBcbiAqIERBVEU6IDIwMTgtMDgtMjdcbiAqIFVQREFURVMgQU5EIERPQ1MgQVQ6IGh0dHA6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDA4LTIwMTgsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgd29yayBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIHNvZnR3YXJlIGFncmVlbWVudCB0aGF0IHdhcyBpc3N1ZWQgd2l0aCB5b3VyIG1lbWJlcnNoaXAuXG4gKiBcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICoqL1xuaW1wb3J0IHsgX2dzU2NvcGUgfSBmcm9tIFwiLi9Ud2VlbkxpdGUuanNcIjtcblxuZXhwb3J0IHZhciBSb3VuZFByb3BzUGx1Z2luID0gX2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7XG5cdFx0XHRcdHByb3BOYW1lOiBcInJvdW5kUHJvcHNcIixcblx0XHRcdFx0dmVyc2lvbjogXCIxLjcuMFwiLFxuXHRcdFx0XHRwcmlvcml0eTogLTEsXG5cdFx0XHRcdEFQSTogMixcblxuXHRcdFx0XHQvL2NhbGxlZCB3aGVuIHRoZSB0d2VlbiByZW5kZXJzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBpcyB3aGVyZSBpbml0aWFsIHZhbHVlcyBzaG91bGQgYmUgcmVjb3JkZWQgYW5kIGFueSBzZXR1cCByb3V0aW5lcyBzaG91bGQgcnVuLlxuXHRcdFx0XHRpbml0OiBmdW5jdGlvbih0YXJnZXQsIHZhbHVlLCB0d2Vlbikge1xuXHRcdFx0XHRcdHRoaXMuX3R3ZWVuID0gdHdlZW47XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSksXG5cdFx0XHRfZ2V0Um91bmRGdW5jID0gZnVuY3Rpb24odikgeyAvL3Bhc3MgaW4gMC4xIGdldCBhIGZ1bmN0aW9uIHRoYXQnbGwgcm91bmQgdG8gdGhlIG5lYXJlc3QgdGVudGgsIG9yIDUgdG8gcm91bmQgdG8gdGhlIGNsb3Nlc3QgNSwgb3IgMC4wMDEgdG8gdGhlIGNsb3Nlc3QgMTAwMHRoLCBldGMuXG5cdFx0XHRcdHZhciBwID0gdiA8IDEgPyBNYXRoLnBvdygxMCwgKHYgKyBcIlwiKS5sZW5ndGggLSAyKSA6IDE7IC8vdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGxpa2UgMjQgKiAwLjEgPT0gMi40MDAwMDAwMDAwMDAwMDA0KSwgd2UgY2hvcCBvZmYgYXQgYSBzcGVjaWZpYyBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgKG11Y2ggZmFzdGVyIHRoYW4gdG9GaXhlZCgpXG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbihuKSB7XG5cdFx0XHRcdFx0cmV0dXJuICgoTWF0aC5yb3VuZChuIC8gdikgKiB2ICogcCkgfCAwKSAvIHA7XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0X3JvdW5kTGlua2VkTGlzdCA9IGZ1bmN0aW9uKG5vZGUsIG1vZCkge1xuXHRcdFx0XHR3aGlsZSAobm9kZSkge1xuXHRcdFx0XHRcdGlmICghbm9kZS5mICYmICFub2RlLmJsb2IpIHtcblx0XHRcdFx0XHRcdG5vZGUubSA9IG1vZCB8fCBNYXRoLnJvdW5kO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRub2RlID0gbm9kZS5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHAgPSBSb3VuZFByb3BzUGx1Z2luLnByb3RvdHlwZTtcblxuXHRcdHAuX29uSW5pdEFsbFByb3BzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl90d2Vlbixcblx0XHRcdFx0cnAgPSB0d2Vlbi52YXJzLnJvdW5kUHJvcHMsXG5cdFx0XHRcdGxvb2t1cCA9IHt9LFxuXHRcdFx0XHRycHQgPSB0d2Vlbi5fcHJvcExvb2t1cC5yb3VuZFByb3BzLFxuXHRcdFx0XHRwdCwgbmV4dCwgaSwgcDtcblx0XHRcdGlmICh0eXBlb2YocnApID09PSBcIm9iamVjdFwiICYmICFycC5wdXNoKSB7XG5cdFx0XHRcdGZvciAocCBpbiBycCkge1xuXHRcdFx0XHRcdGxvb2t1cFtwXSA9IF9nZXRSb3VuZEZ1bmMocnBbcF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodHlwZW9mKHJwKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdHJwID0gcnAuc3BsaXQoXCIsXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGkgPSBycC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGxvb2t1cFtycFtpXV0gPSBNYXRoLnJvdW5kO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAocCBpbiBsb29rdXApIHtcblx0XHRcdFx0cHQgPSB0d2Vlbi5fZmlyc3RQVDtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0bmV4dCA9IHB0Ll9uZXh0OyAvL3JlY29yZCBoZXJlLCBiZWNhdXNlIGl0IG1heSBnZXQgcmVtb3ZlZFxuXHRcdFx0XHRcdGlmIChwdC5wZykge1xuXHRcdFx0XHRcdFx0cHQudC5fbW9kKGxvb2t1cCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwdC5uID09PSBwKSB7XG5cdFx0XHRcdFx0XHRpZiAocHQuZiA9PT0gMiAmJiBwdC50KSB7IC8vYSBibG9iICh0ZXh0IGNvbnRhaW5pbmcgbXVsdGlwbGUgbnVtZXJpYyB2YWx1ZXMpXG5cdFx0XHRcdFx0XHRcdF9yb3VuZExpbmtlZExpc3QocHQudC5fZmlyc3RQVCwgbG9va3VwW3BdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2FkZChwdC50LCBwLCBwdC5zLCBwdC5jLCBsb29rdXBbcF0pO1xuXHRcdFx0XHRcdFx0XHQvL3JlbW92ZSBmcm9tIGxpbmtlZCBsaXN0XG5cdFx0XHRcdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV4dC5fcHJldiA9IHB0Ll9wcmV2O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChwdC5fcHJldikge1xuXHRcdFx0XHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gbmV4dDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fZmlyc3RQVCA9PT0gcHQpIHtcblx0XHRcdFx0XHRcdFx0XHR0d2Vlbi5fZmlyc3RQVCA9IG5leHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cHQuX25leHQgPSBwdC5fcHJldiA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLl9wcm9wTG9va3VwW3BdID0gcnB0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0cC5fYWRkID0gZnVuY3Rpb24odGFyZ2V0LCBwLCBzLCBjLCBtb2QpIHtcblx0XHRcdHRoaXMuX2FkZFR3ZWVuKHRhcmdldCwgcCwgcywgcyArIGMsIHAsIG1vZCB8fCBNYXRoLnJvdW5kKTtcblx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0fTtcblxuZXhwb3J0IHsgUm91bmRQcm9wc1BsdWdpbiBhcyBkZWZhdWx0IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nc2FwL1JvdW5kUHJvcHNQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogVkVSU0lPTjogMC4zLjFcbiAqIERBVEU6IDIwMTgtMDgtMjdcbiAqIFVQREFURVMgQU5EIERPQ1MgQVQ6IGh0dHA6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDA4LTIwMTgsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgd29yayBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIHNvZnR3YXJlIGFncmVlbWVudCB0aGF0IHdhcyBpc3N1ZWQgd2l0aCB5b3VyIG1lbWJlcnNoaXAuXG4gKiBcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICoqL1xuXG5pbXBvcnQgeyBfZ3NTY29wZSB9IGZyb20gXCIuL1R3ZWVuTGl0ZS5qc1wiO1xuXG5leHBvcnQgdmFyIERpcmVjdGlvbmFsUm90YXRpb25QbHVnaW4gPSBfZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtcblx0XHRwcm9wTmFtZTogXCJkaXJlY3Rpb25hbFJvdGF0aW9uXCIsXG5cdFx0dmVyc2lvbjogXCIwLjMuMVwiLFxuXHRcdEFQSTogMixcblxuXHRcdC8vY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGlzIHdoZXJlIGluaXRpYWwgdmFsdWVzIHNob3VsZCBiZSByZWNvcmRlZCBhbmQgYW55IHNldHVwIHJvdXRpbmVzIHNob3VsZCBydW4uXG5cdFx0aW5pdDogZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSwgdHdlZW4sIGluZGV4KSB7XG5cdFx0XHRpZiAodHlwZW9mKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHR2YWx1ZSA9IHtyb3RhdGlvbjp2YWx1ZX07XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZpbmFscyA9IHt9O1xuXHRcdFx0dmFyIGNhcCA9ICh2YWx1ZS51c2VSYWRpYW5zID09PSB0cnVlKSA/IE1hdGguUEkgKiAyIDogMzYwLFxuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0cCwgdiwgc3RhcnQsIGVuZCwgZGlmLCBzcGxpdDtcblx0XHRcdGZvciAocCBpbiB2YWx1ZSkge1xuXHRcdFx0XHRpZiAocCAhPT0gXCJ1c2VSYWRpYW5zXCIpIHtcblx0XHRcdFx0XHRlbmQgPSB2YWx1ZVtwXTtcblx0XHRcdFx0XHRpZiAodHlwZW9mKGVuZCkgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdFx0ZW5kID0gZW5kKGluZGV4LCB0YXJnZXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzcGxpdCA9IChlbmQgKyBcIlwiKS5zcGxpdChcIl9cIik7XG5cdFx0XHRcdFx0diA9IHNwbGl0WzBdO1xuXHRcdFx0XHRcdHN0YXJ0ID0gcGFyc2VGbG9hdCggKHR5cGVvZih0YXJnZXRbcF0pICE9PSBcImZ1bmN0aW9uXCIpID8gdGFyZ2V0W3BdIDogdGFyZ2V0WyAoKHAuaW5kZXhPZihcInNldFwiKSB8fCB0eXBlb2YodGFyZ2V0W1wiZ2V0XCIgKyBwLnN1YnN0cigzKV0pICE9PSBcImZ1bmN0aW9uXCIpID8gcCA6IFwiZ2V0XCIgKyBwLnN1YnN0cigzKSkgXSgpICk7XG5cdFx0XHRcdFx0ZW5kID0gdGhpcy5maW5hbHNbcF0gPSAodHlwZW9mKHYpID09PSBcInN0cmluZ1wiICYmIHYuY2hhckF0KDEpID09PSBcIj1cIikgPyBzdGFydCArIHBhcnNlSW50KHYuY2hhckF0KDApICsgXCIxXCIsIDEwKSAqIE51bWJlcih2LnN1YnN0cigyKSkgOiBOdW1iZXIodikgfHwgMDtcblx0XHRcdFx0XHRkaWYgPSBlbmQgLSBzdGFydDtcblx0XHRcdFx0XHRpZiAoc3BsaXQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR2ID0gc3BsaXQuam9pbihcIl9cIik7XG5cdFx0XHRcdFx0XHRpZiAodi5pbmRleE9mKFwic2hvcnRcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9IGRpZiAlIGNhcDtcblx0XHRcdFx0XHRcdFx0aWYgKGRpZiAhPT0gZGlmICUgKGNhcCAvIDIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGlmID0gKGRpZiA8IDApID8gZGlmICsgY2FwIDogZGlmIC0gY2FwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodi5pbmRleE9mKFwiX2N3XCIpICE9PSAtMSAmJiBkaWYgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9ICgoZGlmICsgY2FwICogOTk5OTk5OTk5OSkgJSBjYXApIC0gKChkaWYgLyBjYXApIHwgMCkgKiBjYXA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHYuaW5kZXhPZihcImNjd1wiKSAhPT0gLTEgJiYgZGlmID4gMCkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoKGRpZiAtIGNhcCAqIDk5OTk5OTk5OTkpICUgY2FwKSAtICgoZGlmIC8gY2FwKSB8IDApICogY2FwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZGlmID4gbWluIHx8IGRpZiA8IC1taW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FkZFR3ZWVuKHRhcmdldCwgcCwgc3RhcnQsIHN0YXJ0ICsgZGlmLCBwKTtcblx0XHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly9jYWxsZWQgZWFjaCB0aW1lIHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQsIGFuZCB0aGUgcmF0aW8gZ2V0cyBwYXNzZWQgYXMgdGhlIG9ubHkgcGFyYW1ldGVyICh0eXBpY2FsbHkgaXQncyBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgYnV0IGl0IGNhbiBleGNlZWQgdGhvc2Ugd2hlbiB1c2luZyBhbiBlYXNlIGxpa2UgRWxhc3RpYy5lYXNlT3V0IG9yIEJhY2suZWFzZU91dCwgZXRjLilcblx0XHRzZXQ6IGZ1bmN0aW9uKHJhdGlvKSB7XG5cdFx0XHR2YXIgcHQ7XG5cdFx0XHRpZiAocmF0aW8gIT09IDEpIHtcblx0XHRcdFx0dGhpcy5fc3VwZXIuc2V0UmF0aW8uY2FsbCh0aGlzLCByYXRpbyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdGlmIChwdC5mKSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdKHRoaXMuZmluYWxzW3B0LnBdKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHRoaXMuZmluYWxzW3B0LnBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0pO1xuXG5EaXJlY3Rpb25hbFJvdGF0aW9uUGx1Z2luLl9hdXRvQ1NTID0gdHJ1ZTtcblxuZXhwb3J0IHsgRGlyZWN0aW9uYWxSb3RhdGlvblBsdWdpbiBhcyBkZWZhdWx0IH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ3NhcC9EaXJlY3Rpb25hbFJvdGF0aW9uUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIFZFUlNJT046IDIuMC4yXG4gKiBEQVRFOiAyMDE4LTA4LTI3XG4gKiBVUERBVEVTIEFORCBET0NTIEFUOiBodHRwOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwOC0yMDE4LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHdvcmsgaXMgc3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cDovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBzb2Z0d2FyZSBhZ3JlZW1lbnQgdGhhdCB3YXMgaXNzdWVkIHdpdGggeW91ciBtZW1iZXJzaGlwLlxuICogXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiAqL1xuXG5pbXBvcnQgVHdlZW5MaXRlLCB7IF9nc1Njb3BlLCBnbG9iYWxzLCBFYXNlLCBBbmltYXRpb24gfSBmcm9tIFwiLi9Ud2VlbkxpdGUuanNcIjtcbmltcG9ydCBUaW1lbGluZUxpdGUgZnJvbSBcIi4vVGltZWxpbmVMaXRlLmpzXCI7XG5cbl9nc1Njb3BlLl9nc0RlZmluZShcIlRpbWVsaW5lTWF4XCIsIFtcIlRpbWVsaW5lTGl0ZVwiLFwiVHdlZW5MaXRlXCIsXCJlYXNpbmcuRWFzZVwiXSwgZnVuY3Rpb24oKSB7XG5cdFx0XG5cdFx0dmFyIFRpbWVsaW5lTWF4ID0gZnVuY3Rpb24odmFycykge1xuXHRcdFx0XHRUaW1lbGluZUxpdGUuY2FsbCh0aGlzLCB2YXJzKTtcblx0XHRcdFx0dGhpcy5fcmVwZWF0ID0gdGhpcy52YXJzLnJlcGVhdCB8fCAwO1xuXHRcdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHRoaXMudmFycy5yZXBlYXREZWxheSB8fCAwO1xuXHRcdFx0XHR0aGlzLl9jeWNsZSA9IDA7XG5cdFx0XHRcdHRoaXMuX3lveW8gPSAodGhpcy52YXJzLnlveW8gPT09IHRydWUpO1xuXHRcdFx0XHR0aGlzLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0X3RpbnlOdW0gPSAwLjAwMDAwMDAwMDEsXG5cdFx0XHRUd2VlbkxpdGVJbnRlcm5hbHMgPSBUd2VlbkxpdGUuX2ludGVybmFscyxcblx0XHRcdF9sYXp5VHdlZW5zID0gVHdlZW5MaXRlSW50ZXJuYWxzLmxhenlUd2VlbnMsXG5cdFx0XHRfbGF6eVJlbmRlciA9IFR3ZWVuTGl0ZUludGVybmFscy5sYXp5UmVuZGVyLFxuXHRcdFx0X2dsb2JhbHMgPSBfZ3NTY29wZS5fZ3NEZWZpbmUuZ2xvYmFscyxcblx0XHRcdF9lYXNlTm9uZSA9IG5ldyBFYXNlKG51bGwsIG51bGwsIDEsIDApLFxuXHRcdFx0cCA9IFRpbWVsaW5lTWF4LnByb3RvdHlwZSA9IG5ldyBUaW1lbGluZUxpdGUoKTtcblx0XHRcdFxuXHRcdHAuY29uc3RydWN0b3IgPSBUaW1lbGluZU1heDtcblx0XHRwLmtpbGwoKS5fZ2MgPSBmYWxzZTtcblx0XHRUaW1lbGluZU1heC52ZXJzaW9uID0gXCIyLjAuMlwiO1xuXHRcdFxuXHRcdHAuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5feW95byA9ICh0aGlzLnZhcnMueW95byA9PT0gdHJ1ZSk7XG5cdFx0XHR0aGlzLl9yZXBlYXQgPSB0aGlzLnZhcnMucmVwZWF0IHx8IDA7XG5cdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHRoaXMudmFycy5yZXBlYXREZWxheSB8fCAwO1xuXHRcdFx0dGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHRcdHJldHVybiBUaW1lbGluZUxpdGUucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAuYWRkQ2FsbGJhY2sgPSBmdW5jdGlvbihjYWxsYmFjaywgcG9zaXRpb24sIHBhcmFtcywgc2NvcGUpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCggVHdlZW5MaXRlLmRlbGF5ZWRDYWxsKDAsIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSwgcG9zaXRpb24pO1xuXHRcdH07XG5cdFx0XG5cdFx0cC5yZW1vdmVDYWxsYmFjayA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBwb3NpdGlvbikge1xuXHRcdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGlmIChwb3NpdGlvbiA9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5fa2lsbChudWxsLCBjYWxsYmFjayk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGEgPSB0aGlzLmdldFR3ZWVuc09mKGNhbGxiYWNrLCBmYWxzZSksXG5cdFx0XHRcdFx0XHRpID0gYS5sZW5ndGgsXG5cdFx0XHRcdFx0XHR0aW1lID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbik7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAoYVtpXS5fc3RhcnRUaW1lID09PSB0aW1lKSB7XG5cdFx0XHRcdFx0XHRcdGFbaV0uX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnJlbW92ZVBhdXNlID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLnJlbW92ZUNhbGxiYWNrKFRpbWVsaW5lTGl0ZS5faW50ZXJuYWxzLnBhdXNlQ2FsbGJhY2ssIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC50d2VlblRvID0gZnVuY3Rpb24ocG9zaXRpb24sIHZhcnMpIHtcblx0XHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0dmFyIGNvcHkgPSB7ZWFzZTpfZWFzZU5vbmUsIHVzZUZyYW1lczp0aGlzLnVzZXNGcmFtZXMoKSwgaW1tZWRpYXRlUmVuZGVyOmZhbHNlLCBsYXp5OmZhbHNlfSxcblx0XHRcdFx0RW5naW5lID0gKHZhcnMucmVwZWF0ICYmIF9nbG9iYWxzLlR3ZWVuTWF4KSB8fCBUd2VlbkxpdGUsXG5cdFx0XHRcdGR1cmF0aW9uLCBwLCB0O1xuXHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0Y29weVtwXSA9IHZhcnNbcF07XG5cdFx0XHR9XG5cdFx0XHRjb3B5LnRpbWUgPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uKTtcblx0XHRcdGR1cmF0aW9uID0gKE1hdGguYWJzKE51bWJlcihjb3B5LnRpbWUpIC0gdGhpcy5fdGltZSkgLyB0aGlzLl90aW1lU2NhbGUpIHx8IDAuMDAxO1xuXHRcdFx0dCA9IG5ldyBFbmdpbmUodGhpcywgZHVyYXRpb24sIGNvcHkpO1xuXHRcdFx0Y29weS5vblN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHQudGFyZ2V0LnBhdXNlZCh0cnVlKTtcblx0XHRcdFx0aWYgKHQudmFycy50aW1lICE9PSB0LnRhcmdldC50aW1lKCkgJiYgZHVyYXRpb24gPT09IHQuZHVyYXRpb24oKSAmJiAhdC5pc0Zyb21UbykgeyAvL2Rvbid0IG1ha2UgdGhlIGR1cmF0aW9uIHplcm8gLSBpZiBpdCdzIHN1cHBvc2VkIHRvIGJlIHplcm8sIGRvbid0IHdvcnJ5IGJlY2F1c2UgaXQncyBhbHJlYWR5IGluaXR0aW5nIHRoZSB0d2VlbiBhbmQgd2lsbCBjb21wbGV0ZSBpbW1lZGlhdGVseSwgZWZmZWN0aXZlbHkgbWFraW5nIHRoZSBkdXJhdGlvbiB6ZXJvIGFueXdheS4gSWYgd2UgbWFrZSBkdXJhdGlvbiB6ZXJvLCB0aGUgdHdlZW4gd29uJ3QgcnVuIGF0IGFsbC5cblx0XHRcdFx0XHR0LmR1cmF0aW9uKCBNYXRoLmFicyggdC52YXJzLnRpbWUgLSB0LnRhcmdldC50aW1lKCkpIC8gdC50YXJnZXQuX3RpbWVTY2FsZSApLnJlbmRlcih0LnRpbWUoKSwgdHJ1ZSwgdHJ1ZSk7IC8vcmVuZGVyKCkgcmlnaHQgYXdheSB0byBlbnN1cmUgdGhhdCB0aGluZ3MgbG9vayByaWdodCwgZXNwZWNpYWxseSBpbiB0aGUgY2FzZSBvZiAudHdlZW5UbygwKS5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodmFycy5vblN0YXJ0KSB7IC8vaW4gY2FzZSB0aGUgdXNlciBoYWQgYW4gb25TdGFydCBpbiB0aGUgdmFycyAtIHdlIGRvbid0IHdhbnQgdG8gb3ZlcndyaXRlIGl0LlxuXHRcdFx0XHRcdHZhcnMub25TdGFydC5hcHBseSh2YXJzLm9uU3RhcnRTY29wZSB8fCB2YXJzLmNhbGxiYWNrU2NvcGUgfHwgdCwgdmFycy5vblN0YXJ0UGFyYW1zIHx8IFtdKTsgLy9kb24ndCB1c2UgdC5fY2FsbGJhY2soXCJvblN0YXJ0XCIpIG9yIGl0J2xsIHBvaW50IHRvIHRoZSBjb3B5Lm9uU3RhcnQgYW5kIHdlJ2xsIGdldCBhIHJlY3Vyc2lvbiBlcnJvci5cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0O1xuXHRcdH07XG5cblx0XHRwLnR3ZWVuRnJvbVRvID0gZnVuY3Rpb24oZnJvbVBvc2l0aW9uLCB0b1Bvc2l0aW9uLCB2YXJzKSB7XG5cdFx0XHR2YXJzID0gdmFycyB8fCB7fTtcblx0XHRcdGZyb21Qb3NpdGlvbiA9IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwoZnJvbVBvc2l0aW9uKTtcblx0XHRcdHZhcnMuc3RhcnRBdCA9IHtvbkNvbXBsZXRlOnRoaXMuc2Vlaywgb25Db21wbGV0ZVBhcmFtczpbZnJvbVBvc2l0aW9uXSwgY2FsbGJhY2tTY29wZTp0aGlzfTtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZSk7XG5cdFx0XHR2YXIgdCA9IHRoaXMudHdlZW5Ubyh0b1Bvc2l0aW9uLCB2YXJzKTtcblx0XHRcdHQuaXNGcm9tVG8gPSAxOyAvL3RvIGVuc3VyZSB3ZSBkb24ndCBtZXNzIHdpdGggdGhlIGR1cmF0aW9uIGluIHRoZSBvblN0YXJ0ICh3ZSd2ZSBnb3QgdGhlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIGhlcmUsIHNvIGxvY2sgaXQgaW4pXG5cdFx0XHRyZXR1cm4gdC5kdXJhdGlvbigoTWF0aC5hYnMoIHQudmFycy50aW1lIC0gZnJvbVBvc2l0aW9uKSAvIHRoaXMuX3RpbWVTY2FsZSkgfHwgMC4wMDEpO1xuXHRcdH07XG5cdFx0XG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdGlmICh0aGlzLl9nYykge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdHRvdGFsRHVyID0gKCF0aGlzLl9kaXJ0eSkgPyB0aGlzLl90b3RhbER1cmF0aW9uIDogdGhpcy50b3RhbER1cmF0aW9uKCksXG5cdFx0XHRcdGR1ciA9IHRoaXMuX2R1cmF0aW9uLFxuXHRcdFx0XHRwcmV2VG90YWxUaW1lID0gdGhpcy5fdG90YWxUaW1lLFxuXHRcdFx0XHRwcmV2U3RhcnQgPSB0aGlzLl9zdGFydFRpbWUsIFxuXHRcdFx0XHRwcmV2VGltZVNjYWxlID0gdGhpcy5fdGltZVNjYWxlLCBcblx0XHRcdFx0cHJldlJhd1ByZXZUaW1lID0gdGhpcy5fcmF3UHJldlRpbWUsXG5cdFx0XHRcdHByZXZQYXVzZWQgPSB0aGlzLl9wYXVzZWQsIFxuXHRcdFx0XHRwcmV2Q3ljbGUgPSB0aGlzLl9jeWNsZSwgXG5cdFx0XHRcdHR3ZWVuLCBpc0NvbXBsZXRlLCBuZXh0LCBjYWxsYmFjaywgaW50ZXJuYWxGb3JjZSwgY3ljbGVEdXJhdGlvbiwgcGF1c2VUd2VlbiwgY3VyVGltZTtcblx0XHRcdGlmIChwcmV2VGltZSAhPT0gdGhpcy5fdGltZSkgeyAvL2lmIHRvdGFsRHVyYXRpb24oKSBmaW5kcyBhIGNoaWxkIHdpdGggYSBuZWdhdGl2ZSBzdGFydFRpbWUgYW5kIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUsIHRoaW5ncyBnZXQgc2hpZnRlZCBhcm91bmQgaW50ZXJuYWxseSBzbyB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgdGltZSBhY2NvcmRpbmdseS4gRm9yIGV4YW1wbGUsIGlmIGEgdHdlZW4gc3RhcnRzIGF0IC0zMCB3ZSBtdXN0IHNoaWZ0IEVWRVJZVEhJTkcgZm9yd2FyZCAzMCBzZWNvbmRzIGFuZCBtb3ZlIHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUgYmFja3dhcmQgYnkgMzAgc2Vjb25kcyBzbyB0aGF0IHRoaW5ncyBhbGlnbiB3aXRoIHRoZSBwbGF5aGVhZCAobm8ganVtcCkuXG5cdFx0XHRcdHRpbWUgKz0gdGhpcy5fdGltZSAtIHByZXZUaW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRpbWUgPj0gdG90YWxEdXIgLSAwLjAwMDAwMDEgJiYgdGltZSA+PSAwKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cy5cblx0XHRcdFx0aWYgKCF0aGlzLl9sb2NrZWQpIHtcblx0XHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0b3RhbER1cjtcblx0XHRcdFx0XHR0aGlzLl9jeWNsZSA9IHRoaXMuX3JlcGVhdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXRoaXMuX3JldmVyc2VkKSBpZiAoIXRoaXMuX2hhc1BhdXNlZENoaWxkKCkpIHtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25Db21wbGV0ZVwiO1xuXHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSAhIXRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbjsgLy9vdGhlcndpc2UsIGlmIHRoZSBhbmltYXRpb24gaXMgdW5wYXVzZWQvYWN0aXZhdGVkIGFmdGVyIGl0J3MgYWxyZWFkeSBmaW5pc2hlZCwgaXQgZG9lc24ndCBnZXQgcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgdGltZWxpbmUuXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2R1cmF0aW9uID09PSAwKSBpZiAoKHRpbWUgPD0gMCAmJiB0aW1lID49IC0wLjAwMDAwMDEpIHx8IHByZXZSYXdQcmV2VGltZSA8IDAgfHwgcHJldlJhd1ByZXZUaW1lID09PSBfdGlueU51bSkgaWYgKHByZXZSYXdQcmV2VGltZSAhPT0gdGltZSAmJiB0aGlzLl9maXJzdCkge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lID4gX3RpbnlOdW0pIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKHRoaXMuX2R1cmF0aW9uIHx8ICFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSBvciB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0aWYgKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGltZSA9IDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IGR1cjtcblx0XHRcdFx0XHR0aW1lID0gZHVyICsgMC4wMDAxOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIC0gc29tZXRpbWVzIGNoaWxkIHR3ZWVucy90aW1lbGluZXMgd2VyZSBub3QgYmVpbmcgZnVsbHkgY29tcGxldGVkICh0aGVpciBwcm9ncmVzcyBtaWdodCBiZSAwLjk5OTk5OTk5OTk5OTk5OCBpbnN0ZWFkIG9mIDEgYmVjYXVzZSB3aGVuIF90aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSBpcyBwZXJmb3JtZWQsIGZsb2F0aW5nIHBvaW50IGVycm9ycyB3b3VsZCByZXR1cm4gYSB2YWx1ZSB0aGF0IHdhcyBTTElHSFRMWSBvZmYpLiBUcnkgKDk5OTk5OTk5OTk5OS43IC0gOTk5OTk5OTk5OTk5KSAqIDEgPSAwLjY5OTk1MTE3MTg3NSBpbnN0ZWFkIG9mIDAuNy4gV2UgY2Fubm90IGRvIGxlc3MgdGhlbiAwLjAwMDEgYmVjYXVzZSB0aGUgc2FtZSBpc3N1ZSBjYW4gb2NjdXIgd2hlbiB0aGUgZHVyYXRpb24gaXMgZXh0cmVtZWx5IGxhcmdlIGxpa2UgOTk5OTk5OTk5OTk5IGluIHdoaWNoIGNhc2UgYWRkaW5nIDAuMDAwMDAwMDEsIGZvciBleGFtcGxlLCBjYXVzZXMgaXQgdG8gYWN0IGxpa2Ugbm90aGluZyB3YXMgYWRkZWQuXG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9IGVsc2UgaWYgKHRpbWUgPCAwLjAwMDAwMDEpIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLCByb3VuZCBzdXBlciBzbWFsbCB2YWx1ZXMgdG8gMC5cblx0XHRcdFx0aWYgKCF0aGlzLl9sb2NrZWQpIHtcblx0XHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl9jeWNsZSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fdGltZSA9IDA7XG5cdFx0XHRcdGlmIChwcmV2VGltZSAhPT0gMCB8fCAoZHVyID09PSAwICYmIHByZXZSYXdQcmV2VGltZSAhPT0gX3RpbnlOdW0gJiYgKHByZXZSYXdQcmV2VGltZSA+IDAgfHwgKHRpbWUgPCAwICYmIHByZXZSYXdQcmV2VGltZSA+PSAwKSkgJiYgIXRoaXMuX2xvY2tlZCkpIHsgLy9lZGdlIGNhc2UgZm9yIGNoZWNraW5nIHRpbWUgPCAwICYmIHByZXZSYXdQcmV2VGltZSA+PSAwOiBhIHplcm8tZHVyYXRpb24gZnJvbVRvKCkgdHdlZW4gaW5zaWRlIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSAoeWVhaCwgdmVyeSByYXJlKVxuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGltZSA8IDApIHtcblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuICYmIHRoaXMuX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gaXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHByZXZSYXdQcmV2VGltZSA+PSAwICYmIHRoaXMuX2ZpcnN0KSB7IC8vd2hlbiBnb2luZyBiYWNrIGJleW9uZCB0aGUgc3RhcnQsIGZvcmNlIGEgcmVuZGVyIHNvIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgdGhhdCBzaXQgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIHJlbmRlciB0aGVpciBzdGFydCB2YWx1ZXMgcHJvcGVybHkuIE90aGVyd2lzZSwgaWYgdGhlIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGxhbmRzIGV4YWN0bHkgYXQgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSwgYW5kIHRoZW4gbW92ZXMgYmFja3dhcmRzLCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIGJlZ2lubmluZyB3b3VsZCBzdGlsbCBiZSBhdCB0aGVpciBlbmQgc3RhdGUuXG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSB0aW1lO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKGR1ciB8fCAhc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCB0aGlzLl9yYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUgb3IgdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdFx0aWYgKHRpbWUgPT09IDAgJiYgaXNDb21wbGV0ZSkgeyAvL2lmIHRoZXJlJ3MgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiBhIHRpbWVsaW5lIGFuZCB0aGUgcGxheWhlYWQgbGFuZHMgRVhBQ1RMWSBhdCB0aW1lIDAsIHRoYXQgdHdlZW4gd2lsbCBjb3JyZWN0bHkgcmVuZGVyIGl0cyBlbmQgdmFsdWVzLCBidXQgd2UgbmVlZCB0byBrZWVwIHRoZSB0aW1lbGluZSBhbGl2ZSBmb3Igb25lIG1vcmUgcmVuZGVyIHNvIHRoYXQgdGhlIGJlZ2lubmluZyB2YWx1ZXMgcmVuZGVyIHByb3Blcmx5IGFzIHRoZSBwYXJlbnQncyBwbGF5aGVhZCBrZWVwcyBtb3ZpbmcgYmV5b25kIHRoZSBiZWdpbmluZy4gSW1hZ2luZSBvYmoueCBzdGFydHMgYXQgMCBhbmQgdGhlbiB3ZSBkbyB0bC5zZXQob2JqLCB7eDoxMDB9KS50byhvYmosIDEsIHt4OjIwMH0pIGFuZCB0aGVuIGxhdGVyIHdlIHRsLnJldmVyc2UoKS4uLnRoZSBnb2FsIGlzIHRvIGhhdmUgb2JqLnggcmV2ZXJ0IHRvIDAuIElmIHRoZSBwbGF5aGVhZCBoYXBwZW5zIHRvIGxhbmQgb24gZXhhY3RseSAwLCB3aXRob3V0IHRoaXMgY2h1bmsgb2YgY29kZSwgaXQnZCBjb21wbGV0ZSB0aGUgdGltZWxpbmUgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSByZW5kZXJpbmcgcXVldWUgKG5vdCBnb29kKS5cblx0XHRcdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdFx0XHR3aGlsZSAodHdlZW4gJiYgdHdlZW4uX3N0YXJ0VGltZSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9kdXJhdGlvbikge1xuXHRcdFx0XHRcdFx0XHRcdGlzQ29tcGxldGUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aW1lID0gMDsgLy90byBhdm9pZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyAoY291bGQgY2F1c2UgcHJvYmxlbXMgZXNwZWNpYWxseSB3aXRoIHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiB0aGUgdGltZWxpbmUpXG5cdFx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoZHVyID09PSAwICYmIHByZXZSYXdQcmV2VGltZSA8IDApIHsgLy93aXRob3V0IHRoaXMsIHplcm8tZHVyYXRpb24gcmVwZWF0aW5nIHRpbWVsaW5lcyAobGlrZSB3aXRoIGEgc2ltcGxlIGNhbGxiYWNrIG5lc3RlZCBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgYW5kIGEgcmVwZWF0RGVsYXkpIHdvdWxkbid0IHJlbmRlciB0aGUgZmlyc3QgdGltZSB0aHJvdWdoLlxuXHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHRcdGlmICghdGhpcy5fbG9ja2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGltZTtcblx0XHRcdFx0XHRpZiAodGhpcy5fcmVwZWF0ICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fcmVwZWF0RGVsYXk7XG5cdFx0XHRcdFx0XHR0aGlzLl9jeWNsZSA9ICh0aGlzLl90b3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uKSA+PiAwOyAvL29yaWdpbmFsbHkgX3RvdGFsVGltZSAlIGN5Y2xlRHVyYXRpb24gYnV0IGZsb2F0aW5nIHBvaW50IGVycm9ycyBjYXVzZWQgcHJvYmxlbXMsIHNvIEkgbm9ybWFsaXplZCBpdC4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IGl0IGdldHMgcmVwb3J0ZWQgYXMgMC43OTk5OTk5OSEpXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fY3ljbGUgIT09IDApIGlmICh0aGlzLl9jeWNsZSA9PT0gdGhpcy5fdG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbiAmJiBwcmV2VG90YWxUaW1lIDw9IHRpbWUpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fY3ljbGUtLTsgLy9vdGhlcndpc2Ugd2hlbiByZW5kZXJlZCBleGFjdGx5IGF0IHRoZSBlbmQgdGltZSwgaXQgd2lsbCBhY3QgYXMgdGhvdWdoIGl0IGlzIHJlcGVhdGluZyAoYXQgdGhlIGJlZ2lubmluZylcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgLSAodGhpcy5fY3ljbGUgKiBjeWNsZUR1cmF0aW9uKTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLl95b3lvKSBpZiAoKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IGR1ciAtIHRoaXMuX3RpbWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSA+IGR1cikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyO1xuXHRcdFx0XHRcdFx0XHR0aW1lID0gZHVyICsgMC4wMDAxOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3Jcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fdGltZSA8IDApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRpbWUgPSAwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuX2hhc1BhdXNlICYmICF0aGlzLl9mb3JjaW5nUGxheWhlYWQgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdFx0dGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHRcdFx0aWYgKHRpbWUgPj0gcHJldlRpbWUgfHwgKHRoaXMuX3JlcGVhdCAmJiBwcmV2Q3ljbGUgIT09IHRoaXMuX2N5Y2xlKSkge1xuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0XHRcdHdoaWxlICh0d2VlbiAmJiB0d2Vlbi5fc3RhcnRUaW1lIDw9IHRpbWUgJiYgIXBhdXNlVHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fZHVyYXRpb24pIGlmICh0d2Vlbi5kYXRhID09PSBcImlzUGF1c2VcIiAmJiAhdHdlZW4ucmF0aW8gJiYgISh0d2Vlbi5fc3RhcnRUaW1lID09PSAwICYmIHRoaXMuX3Jhd1ByZXZUaW1lID09PSAwKSkge1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSB0d2Vlbjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRcdFx0XHR3aGlsZSAodHdlZW4gJiYgdHdlZW4uX3N0YXJ0VGltZSA+PSB0aW1lICYmICFwYXVzZVR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdHdlZW4uX2R1cmF0aW9uKSBpZiAodHdlZW4uZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgdHdlZW4uX3Jhd1ByZXZUaW1lID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSB0d2Vlbjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9wcmV2O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGF1c2VUd2VlbiAmJiBwYXVzZVR3ZWVuLl9zdGFydFRpbWUgPCBkdXIpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aW1lID0gcGF1c2VUd2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGltZSArICh0aGlzLl9jeWNsZSAqICh0aGlzLl90b3RhbER1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5fY3ljbGUgIT09IHByZXZDeWNsZSkgaWYgKCF0aGlzLl9sb2NrZWQpIHtcblx0XHRcdFx0Lypcblx0XHRcdFx0bWFrZSBzdXJlIGNoaWxkcmVuIGF0IHRoZSBlbmQvYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSBhcmUgcmVuZGVyZWQgcHJvcGVybHkuIElmLCBmb3IgZXhhbXBsZSwgXG5cdFx0XHRcdGEgMy1zZWNvbmQgbG9uZyB0aW1lbGluZSByZW5kZXJlZCBhdCAyLjkgc2Vjb25kcyBwcmV2aW91c2x5LCBhbmQgbm93IHJlbmRlcnMgYXQgMy4yIHNlY29uZHMgKHdoaWNoXG5cdFx0XHRcdHdvdWxkIGdldCB0cmFuc2F0ZWQgdG8gMi44IHNlY29uZHMgaWYgdGhlIHRpbWVsaW5lIHlveW9zIG9yIDAuMiBzZWNvbmRzIGlmIGl0IGp1c3QgcmVwZWF0cyksIHRoZXJlXG5cdFx0XHRcdGNvdWxkIGJlIGEgY2FsbGJhY2sgb3IgYSBzaG9ydCB0d2VlbiB0aGF0J3MgYXQgMi45NSBvciAzIHNlY29uZHMgaW4gd2hpY2ggd291bGRuJ3QgcmVuZGVyLiBTbyBcblx0XHRcdFx0d2UgbmVlZCB0byBwdXNoIHRoZSB0aW1lbGluZSB0byB0aGUgZW5kIChhbmQvb3IgYmVnaW5uaW5nIGRlcGVuZGluZyBvbiBpdHMgeW95byB2YWx1ZSkuIEFsc28gd2UgbXVzdFxuXHRcdFx0XHRlbnN1cmUgdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb3IgZW5kIG9mIHRoZSBUaW1lbGluZU1heCB3b3JrLiBcblx0XHRcdFx0Ki9cblx0XHRcdFx0dmFyIGJhY2t3YXJkcyA9ICh0aGlzLl95b3lvICYmIChwcmV2Q3ljbGUgJiAxKSAhPT0gMCksXG5cdFx0XHRcdFx0d3JhcCA9IChiYWNrd2FyZHMgPT09ICh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSksXG5cdFx0XHRcdFx0cmVjVG90YWxUaW1lID0gdGhpcy5fdG90YWxUaW1lLFxuXHRcdFx0XHRcdHJlY0N5Y2xlID0gdGhpcy5fY3ljbGUsXG5cdFx0XHRcdFx0cmVjUmF3UHJldlRpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSxcblx0XHRcdFx0XHRyZWNUaW1lID0gdGhpcy5fdGltZTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHByZXZDeWNsZSAqIGR1cjtcblx0XHRcdFx0aWYgKHRoaXMuX2N5Y2xlIDwgcHJldkN5Y2xlKSB7XG5cdFx0XHRcdFx0YmFja3dhcmRzID0gIWJhY2t3YXJkcztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgKz0gZHVyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSBwcmV2VGltZTsgLy90ZW1wb3JhcmlseSByZXZlcnQgX3RpbWUgc28gdGhhdCByZW5kZXIoKSByZW5kZXJzIHRoZSBjaGlsZHJlbiBpbiB0aGUgY29ycmVjdCBvcmRlci4gV2l0aG91dCB0aGlzLCB0d2VlbnMgd29uJ3QgcmV3aW5kIGNvcnJlY3RseS4gV2UgY291bGQgYXJoaWN0ZWN0IHRoaW5ncyBpbiBhIFwiY2xlYW5lclwiIHdheSBieSBzcGxpdHRpbmcgb3V0IHRoZSByZW5kZXJpbmcgcXVldWUgaW50byBhIHNlcGFyYXRlIG1ldGhvZCBidXQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIGtlcHQgaXQgYWxsIGluc2lkZSB0aGlzIG1ldGhvZC5cblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKGR1ciA9PT0gMCkgPyBwcmV2UmF3UHJldlRpbWUgLSAwLjAwMDEgOiBwcmV2UmF3UHJldlRpbWU7XG5cdFx0XHRcdHRoaXMuX2N5Y2xlID0gcHJldkN5Y2xlO1xuXHRcdFx0XHR0aGlzLl9sb2NrZWQgPSB0cnVlOyAvL3ByZXZlbnRzIGNoYW5nZXMgdG8gdG90YWxUaW1lIGFuZCBza2lwcyByZXBlYXQveW95byBiZWhhdmlvciB3aGVuIHdlIHJlY3Vyc2l2ZWx5IGNhbGwgcmVuZGVyKClcblx0XHRcdFx0cHJldlRpbWUgPSAoYmFja3dhcmRzKSA/IDAgOiBkdXI7XG5cdFx0XHRcdHRoaXMucmVuZGVyKHByZXZUaW1lLCBzdXBwcmVzc0V2ZW50cywgKGR1ciA9PT0gMCkpO1xuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzKSBpZiAoIXRoaXMuX2djKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMudmFycy5vblJlcGVhdCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fY3ljbGUgPSByZWNDeWNsZTsgLy9pbiBjYXNlIHRoZSBvblJlcGVhdCBhbHRlcnMgdGhlIHBsYXloZWFkIG9yIGludmFsaWRhdGVzKCksIHdlIHNob3VsZG4ndCBzdGF5IGxvY2tlZCBvciB1c2UgdGhlIHByZXZpb3VzIGN5Y2xlLlxuXHRcdFx0XHRcdFx0dGhpcy5fbG9ja2VkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uUmVwZWF0XCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJldlRpbWUgIT09IHRoaXMuX3RpbWUpIHsgLy9pbiBjYXNlIHRoZXJlJ3MgYSBjYWxsYmFjayBsaWtlIG9uQ29tcGxldGUgaW4gYSBuZXN0ZWQgdHdlZW4vdGltZWxpbmUgdGhhdCBjaGFuZ2VzIHRoZSBwbGF5aGVhZCBwb3NpdGlvbiwgbGlrZSB2aWEgc2VlaygpLCB3ZSBzaG91bGQganVzdCBhYm9ydC5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHdyYXApIHtcblx0XHRcdFx0XHR0aGlzLl9jeWNsZSA9IHByZXZDeWNsZTsgLy9pZiB0aGVyZSdzIGFuIG9uUmVwZWF0LCB3ZSByZXZlcnRlZCB0aGlzIGFib3ZlLCBzbyBtYWtlIHN1cmUgaXQncyBzZXQgcHJvcGVybHkgYWdhaW4uIFdlIGFsc28gdW5sb2NrZWQgaW4gdGhhdCBzY2VuYXJpbywgc28gcmVzZXQgdGhhdCB0b28uXG5cdFx0XHRcdFx0dGhpcy5fbG9ja2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRwcmV2VGltZSA9IChiYWNrd2FyZHMpID8gZHVyICsgMC4wMDAxIDogLTAuMDAwMTtcblx0XHRcdFx0XHR0aGlzLnJlbmRlcihwcmV2VGltZSwgdHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2xvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHRpZiAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSB7IC8vaWYgdGhlIHJlbmRlcigpIHRyaWdnZXJlZCBjYWxsYmFjayB0aGF0IHBhdXNlZCB0aGlzIHRpbWVsaW5lLCB3ZSBzaG91bGQgYWJvcnQgKHZlcnkgcmFyZSwgYnV0IHBvc3NpYmxlKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl90aW1lID0gcmVjVGltZTtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gcmVjVG90YWxUaW1lO1xuXHRcdFx0XHR0aGlzLl9jeWNsZSA9IHJlY0N5Y2xlO1xuXHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJlY1Jhd1ByZXZUaW1lO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoKHRoaXMuX3RpbWUgPT09IHByZXZUaW1lIHx8ICF0aGlzLl9maXJzdCkgJiYgIWZvcmNlICYmICFpbnRlcm5hbEZvcmNlICYmICFwYXVzZVR3ZWVuKSB7XG5cdFx0XHRcdGlmIChwcmV2VG90YWxUaW1lICE9PSB0aGlzLl90b3RhbFRpbWUpIGlmICh0aGlzLl9vblVwZGF0ZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykgeyAvL3NvIHRoYXQgb25VcGRhdGUgZmlyZXMgZXZlbiBkdXJpbmcgdGhlIHJlcGVhdERlbGF5IC0gYXMgbG9uZyBhcyB0aGUgdG90YWxUaW1lIGNoYW5nZWQsIHdlIHNob3VsZCB0cmlnZ2VyIG9uVXBkYXRlLlxuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0dGVkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9hY3RpdmUpIGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMuX3RvdGFsVGltZSAhPT0gcHJldlRvdGFsVGltZSAmJiB0aW1lID4gMCkge1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlOyAgLy9zbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgdGhlIHRpbWVsaW5lIChhcyBvcHBvc2VkIHRvIHRoZSBwYXJlbnQgdGltZWxpbmUgcmVuZGVyaW5nIGl0KSwgaXQgaXMgZm9yY2VkIHRvIHJlLXJlbmRlciBhbmQgYWxpZ24gaXQgd2l0aCB0aGUgcHJvcGVyIHRpbWUvZnJhbWUgb24gdGhlIG5leHQgcmVuZGVyaW5nIGN5Y2xlLiBNYXliZSB0aGUgdGltZWxpbmUgYWxyZWFkeSBmaW5pc2hlZCBidXQgdGhlIHVzZXIgbWFudWFsbHkgcmUtcmVuZGVycyBpdCBhcyBoYWxmd2F5IGRvbmUsIGZvciBleGFtcGxlLlxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAocHJldlRvdGFsVGltZSA9PT0gMCkgaWYgKHRoaXMudmFycy5vblN0YXJ0KSBpZiAodGhpcy5fdG90YWxUaW1lICE9PSAwIHx8ICF0aGlzLl90b3RhbER1cmF0aW9uKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25TdGFydFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Y3VyVGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHRpZiAoY3VyVGltZSA+PSBwcmV2VGltZSkge1xuXHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRuZXh0ID0gdHdlZW4uX25leHQ7IC8vcmVjb3JkIGl0IGhlcmUgYmVjYXVzZSB0aGUgdmFsdWUgY291bGQgY2hhbmdlIGFmdGVyIHJlbmRlcmluZy4uLlxuXHRcdFx0XHRcdGlmIChjdXJUaW1lICE9PSB0aGlzLl90aW1lIHx8ICh0aGlzLl9wYXVzZWQgJiYgIXByZXZQYXVzZWQpKSB7IC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4uX2FjdGl2ZSB8fCAodHdlZW4uX3N0YXJ0VGltZSA8PSB0aGlzLl90aW1lICYmICF0d2Vlbi5fcGF1c2VkICYmICF0d2Vlbi5fZ2MpKSB7XG5cdFx0XHRcdFx0XHRpZiAocGF1c2VUd2VlbiA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCgoIXR3ZWVuLl9kaXJ0eSkgPyB0d2Vlbi5fdG90YWxEdXJhdGlvbiA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSkgLSAoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fbGFzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0XHRpZiAoY3VyVGltZSAhPT0gdGhpcy5fdGltZSB8fCAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSkgeyAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgb3Igc2Vla3MgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nLCBsaWtlIGluc2lkZSBvZiBhbiBvblVwZGF0ZS9vbkNvbXBsZXRlXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuLl9hY3RpdmUgfHwgKHR3ZWVuLl9zdGFydFRpbWUgPD0gcHJldlRpbWUgJiYgIXR3ZWVuLl9wYXVzZWQgJiYgIXR3ZWVuLl9nYykpIHtcblx0XHRcdFx0XHRcdGlmIChwYXVzZVR3ZWVuID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuID0gdHdlZW4uX3ByZXY7IC8vdGhlIGxpbmtlZCBsaXN0IGlzIG9yZ2FuaXplZCBieSBfc3RhcnRUaW1lLCB0aHVzIGl0J3MgcG9zc2libGUgdGhhdCBhIHR3ZWVuIGNvdWxkIHN0YXJ0IEJFRk9SRSB0aGUgcGF1c2UgYW5kIGVuZCBhZnRlciBpdCwgaW4gd2hpY2ggY2FzZSBpdCB3b3VsZCBiZSBwb3NpdGlvbmVkIGJlZm9yZSB0aGUgcGF1c2UgdHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0LCBidXQgd2Ugc2hvdWxkIHJlbmRlciBpdCBiZWZvcmUgd2UgcGF1c2UoKSB0aGUgdGltZWxpbmUgYW5kIGNlYXNlIHJlbmRlcmluZy4gVGhpcyBpcyBvbmx5IGEgY29uY2VybiB3aGVuIGdvaW5nIGluIHJldmVyc2UuXG5cdFx0XHRcdFx0XHRcdHdoaWxlIChwYXVzZVR3ZWVuICYmIHBhdXNlVHdlZW4uZW5kVGltZSgpID4gdGhpcy5fdGltZSkge1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4ucmVuZGVyKCAocGF1c2VUd2Vlbi5fcmV2ZXJzZWQgPyBwYXVzZVR3ZWVuLnRvdGFsRHVyYXRpb24oKSAtICgodGltZSAtIHBhdXNlVHdlZW4uX3N0YXJ0VGltZSkgKiBwYXVzZVR3ZWVuLl90aW1lU2NhbGUpIDogKHRpbWUgLSBwYXVzZVR3ZWVuLl9zdGFydFRpbWUpICogcGF1c2VUd2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuID0gcGF1c2VUd2Vlbi5fcHJldjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCgoIXR3ZWVuLl9kaXJ0eSkgPyB0d2Vlbi5fdG90YWxEdXJhdGlvbiA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSkgLSAoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuX29uVXBkYXRlKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvblVwZGF0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNhbGxiYWNrKSBpZiAoIXRoaXMuX2xvY2tlZCkgaWYgKCF0aGlzLl9nYykgaWYgKHByZXZTdGFydCA9PT0gdGhpcy5fc3RhcnRUaW1lIHx8IHByZXZUaW1lU2NhbGUgIT09IHRoaXMuX3RpbWVTY2FsZSkgaWYgKHRoaXMuX3RpbWUgPT09IDAgfHwgdG90YWxEdXIgPj0gdGhpcy50b3RhbER1cmF0aW9uKCkpIHsgLy9pZiBvbmUgb2YgdGhlIHR3ZWVucyB0aGF0IHdhcyByZW5kZXJlZCBhbHRlcmVkIHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUgKGxpa2UgaWYgYW4gb25Db21wbGV0ZSByZXZlcnNlZCB0aGUgdGltZWxpbmUpLCBpdCBwcm9iYWJseSBpc24ndCBjb21wbGV0ZS4gSWYgaXQgaXMsIGRvbid0IHdvcnJ5LCBiZWNhdXNlIHdoYXRldmVyIGNhbGwgYWx0ZXJlZCB0aGUgc3RhcnRUaW1lIHdvdWxkIGNvbXBsZXRlIGlmIGl0IHdhcyBuZWNlc3NhcnkgYXQgdGhlIG5ldyB0aW1lLiBUaGUgb25seSBleGNlcHRpb24gaXMgdGhlIHRpbWVTY2FsZSBwcm9wZXJ0eS4gQWxzbyBjaGVjayBfZ2MgYmVjYXVzZSB0aGVyZSdzIGEgY2hhbmNlIHRoYXQga2lsbCgpIGNvdWxkIGJlIGNhbGxlZCBpbiBhbiBvblVwZGF0ZVxuXHRcdFx0XHRpZiAoaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvbkNvbXBsZXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblx0XHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnZhcnNbY2FsbGJhY2tdKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soY2FsbGJhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHRwLmdldEFjdGl2ZSA9IGZ1bmN0aW9uKG5lc3RlZCwgdHdlZW5zLCB0aW1lbGluZXMpIHtcblx0XHRcdGlmIChuZXN0ZWQgPT0gbnVsbCkge1xuXHRcdFx0XHRuZXN0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR3ZWVucyA9PSBudWxsKSB7XG5cdFx0XHRcdHR3ZWVucyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGltZWxpbmVzID09IG51bGwpIHtcblx0XHRcdFx0dGltZWxpbmVzID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYSA9IFtdLCBcblx0XHRcdFx0YWxsID0gdGhpcy5nZXRDaGlsZHJlbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzKSwgXG5cdFx0XHRcdGNudCA9IDAsIFxuXHRcdFx0XHRsID0gYWxsLmxlbmd0aCxcblx0XHRcdFx0aSwgdHdlZW47XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHR3ZWVuID0gYWxsW2ldO1xuXHRcdFx0XHRpZiAodHdlZW4uaXNBY3RpdmUoKSkge1xuXHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0cC5nZXRMYWJlbEFmdGVyID0gZnVuY3Rpb24odGltZSkge1xuXHRcdFx0aWYgKCF0aW1lKSBpZiAodGltZSAhPT0gMCkgeyAvL2Zhc3RlciB0aGFuIGlzTmFuKClcblx0XHRcdFx0dGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHNBcnJheSgpLFxuXHRcdFx0XHRsID0gbGFiZWxzLmxlbmd0aCxcblx0XHRcdFx0aTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aWYgKGxhYmVsc1tpXS50aW1lID4gdGltZSkge1xuXHRcdFx0XHRcdHJldHVybiBsYWJlbHNbaV0ubmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRcblx0XHRwLmdldExhYmVsQmVmb3JlID0gZnVuY3Rpb24odGltZSkge1xuXHRcdFx0aWYgKHRpbWUgPT0gbnVsbCkge1xuXHRcdFx0XHR0aW1lID0gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVsc0FycmF5KCksXG5cdFx0XHRcdGkgPSBsYWJlbHMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmIChsYWJlbHNbaV0udGltZSA8IHRpbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gbGFiZWxzW2ldLm5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0XG5cdFx0cC5nZXRMYWJlbHNBcnJheSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0Y250ID0gMCxcblx0XHRcdFx0cDtcblx0XHRcdGZvciAocCBpbiB0aGlzLl9sYWJlbHMpIHtcblx0XHRcdFx0YVtjbnQrK10gPSB7dGltZTp0aGlzLl9sYWJlbHNbcF0sIG5hbWU6cH07XG5cdFx0XHR9XG5cdFx0XHRhLnNvcnQoZnVuY3Rpb24oYSxiKSB7XG5cdFx0XHRcdHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX2xvY2tlZCA9IGZhbHNlOyAvL3VubG9jayBhbmQgc2V0IGN5Y2xlIGluIGNhc2UgaW52YWxpZGF0ZSgpIGlzIGNhbGxlZCBmcm9tIGluc2lkZSBhbiBvblJlcGVhdFxuXHRcdFx0cmV0dXJuIFRpbWVsaW5lTGl0ZS5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdH07XG5cblx0XHRcbi8vLS0tLSBHRVRURVJTIC8gU0VUVEVSUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0XG5cdFx0cC5wcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyAodGhpcy5fdGltZSAvIHRoaXMuZHVyYXRpb24oKSkgfHwgMCA6IHRoaXMudG90YWxUaW1lKCB0aGlzLmR1cmF0aW9uKCkgKiAoKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApID8gMSAtIHZhbHVlIDogdmFsdWUpICsgKHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpKSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0cC50b3RhbFByb2dyZXNzID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/ICh0aGlzLl90b3RhbFRpbWUgLyB0aGlzLnRvdGFsRHVyYXRpb24oKSkgfHwgMCA6IHRoaXMudG90YWxUaW1lKCB0aGlzLnRvdGFsRHVyYXRpb24oKSAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0VGltZWxpbmVMaXRlLnByb3RvdHlwZS50b3RhbER1cmF0aW9uLmNhbGwodGhpcyk7IC8vanVzdCBmb3JjZXMgcmVmcmVzaFxuXHRcdFx0XHRcdC8vSW5zdGVhZCBvZiBJbmZpbml0eSwgd2UgdXNlIDk5OTk5OTk5OTk5OSBzbyB0aGF0IHdlIGNhbiBhY2NvbW1vZGF0ZSByZXZlcnNlcy5cblx0XHRcdFx0XHR0aGlzLl90b3RhbER1cmF0aW9uID0gKHRoaXMuX3JlcGVhdCA9PT0gLTEpID8gOTk5OTk5OTk5OTk5IDogdGhpcy5fZHVyYXRpb24gKiAodGhpcy5fcmVwZWF0ICsgMSkgKyAodGhpcy5fcmVwZWF0RGVsYXkgKiB0aGlzLl9yZXBlYXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b3RhbER1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0aGlzLl9yZXBlYXQgPT09IC0xIHx8ICF2YWx1ZSkgPyB0aGlzIDogdGhpcy50aW1lU2NhbGUoIHRoaXMudG90YWxEdXJhdGlvbigpIC8gdmFsdWUgKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAudGltZSA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90aW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdHRoaXMudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlID4gdGhpcy5fZHVyYXRpb24pIHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLl9kdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdHZhbHVlID0gKHRoaXMuX2R1cmF0aW9uIC0gdmFsdWUpICsgKHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fcmVwZWF0ICE9PSAwKSB7XG5cdFx0XHRcdHZhbHVlICs9IHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnJlcGVhdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlcGVhdDtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlcGVhdCA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnJlcGVhdERlbGF5ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVwZWF0RGVsYXk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnlveW8gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl95b3lvO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5feW95byA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRwLmN1cnJlbnRMYWJlbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxCZWZvcmUodGhpcy5fdGltZSArIDAuMDAwMDAwMDEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuc2Vlayh2YWx1ZSwgdHJ1ZSk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gVGltZWxpbmVNYXg7XG5cdFx0XG5cdH0sIHRydWUpO1xuXG5leHBvcnQgdmFyIFRpbWVsaW5lTWF4ID0gZ2xvYmFscy5UaW1lbGluZU1heDtcbmV4cG9ydCB7IFRpbWVsaW5lTGl0ZSwgVGltZWxpbmVNYXggYXMgZGVmYXVsdCB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dzYXAvVGltZWxpbmVNYXguanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogVkVSU0lPTjogMS4zLjhcbiAqIERBVEU6IDIwMTgtMDUtMzBcbiAqIFVQREFURVMgQU5EIERPQ1MgQVQ6IGh0dHA6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDA4LTIwMTgsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgd29yayBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIHNvZnR3YXJlIGFncmVlbWVudCB0aGF0IHdhcyBpc3N1ZWQgd2l0aCB5b3VyIG1lbWJlcnNoaXAuXG4gKiBcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICoqL1xuaW1wb3J0IHsgX2dzU2NvcGUgfSBmcm9tIFwiLi9Ud2VlbkxpdGUuanNcIjtcblxuXHRcdHZhciBfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG5cdFx0XHRfcjEgPSBbXSxcblx0XHRcdF9yMiA9IFtdLFxuXHRcdFx0X3IzID0gW10sXG5cdFx0XHRfY29yUHJvcHMgPSB7fSxcblx0XHRcdF9nbG9iYWxzID0gX2dzU2NvcGUuX2dzRGVmaW5lLmdsb2JhbHMsXG5cdFx0XHRTZWdtZW50ID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuXHRcdFx0XHRpZiAoYyA9PT0gZCkgeyAvL2lmIGMgYW5kIGQgbWF0Y2gsIHRoZSBmaW5hbCBhdXRvUm90YXRlIHZhbHVlIGNvdWxkIGxvY2sgYXQgLTkwIGRlZ3JlZXMsIHNvIGRpZmZlcmVudGlhdGUgdGhlbSBzbGlnaHRseS5cblx0XHRcdFx0XHRjID0gZCAtIChkIC0gYikgLyAxMDAwMDAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhID09PSBiKSB7IC8vaWYgYSBhbmQgYiBtYXRjaCwgdGhlIHN0YXJ0aW5nIGF1dG9Sb3RhdGUgdmFsdWUgY291bGQgbG9jayBhdCAtOTAgZGVncmVlcywgc28gZGlmZmVyZW50aWF0ZSB0aGVtIHNsaWdodGx5LlxuXHRcdFx0XHRcdGIgPSBhICsgKGMgLSBhKSAvIDEwMDAwMDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hID0gYTtcblx0XHRcdFx0dGhpcy5iID0gYjtcblx0XHRcdFx0dGhpcy5jID0gYztcblx0XHRcdFx0dGhpcy5kID0gZDtcblx0XHRcdFx0dGhpcy5kYSA9IGQgLSBhO1xuXHRcdFx0XHR0aGlzLmNhID0gYyAtIGE7XG5cdFx0XHRcdHRoaXMuYmEgPSBiIC0gYTtcblx0XHRcdH0sXG5cdFx0XHRfY29ycmVsYXRlID0gXCIseCx5LHosbGVmdCx0b3AscmlnaHQsYm90dG9tLG1hcmdpblRvcCxtYXJnaW5MZWZ0LG1hcmdpblJpZ2h0LG1hcmdpbkJvdHRvbSxwYWRkaW5nTGVmdCxwYWRkaW5nVG9wLHBhZGRpbmdSaWdodCxwYWRkaW5nQm90dG9tLGJhY2tncm91bmRQb3NpdGlvbixiYWNrZ3JvdW5kUG9zaXRpb25feSxcIixcblx0XHRcdGN1YmljVG9RdWFkcmF0aWMgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG5cdFx0XHRcdHZhciBxMSA9IHthOmF9LFxuXHRcdFx0XHRcdHEyID0ge30sXG5cdFx0XHRcdFx0cTMgPSB7fSxcblx0XHRcdFx0XHRxNCA9IHtjOmR9LFxuXHRcdFx0XHRcdG1hYiA9IChhICsgYikgLyAyLFxuXHRcdFx0XHRcdG1iYyA9IChiICsgYykgLyAyLFxuXHRcdFx0XHRcdG1jZCA9IChjICsgZCkgLyAyLFxuXHRcdFx0XHRcdG1hYmMgPSAobWFiICsgbWJjKSAvIDIsXG5cdFx0XHRcdFx0bWJjZCA9IChtYmMgKyBtY2QpIC8gMixcblx0XHRcdFx0XHRtOCA9IChtYmNkIC0gbWFiYykgLyA4O1xuXHRcdFx0XHRxMS5iID0gbWFiICsgKGEgLSBtYWIpIC8gNDtcblx0XHRcdFx0cTIuYiA9IG1hYmMgKyBtODtcblx0XHRcdFx0cTEuYyA9IHEyLmEgPSAocTEuYiArIHEyLmIpIC8gMjtcblx0XHRcdFx0cTIuYyA9IHEzLmEgPSAobWFiYyArIG1iY2QpIC8gMjtcblx0XHRcdFx0cTMuYiA9IG1iY2QgLSBtODtcblx0XHRcdFx0cTQuYiA9IG1jZCArIChkIC0gbWNkKSAvIDQ7XG5cdFx0XHRcdHEzLmMgPSBxNC5hID0gKHEzLmIgKyBxNC5iKSAvIDI7XG5cdFx0XHRcdHJldHVybiBbcTEsIHEyLCBxMywgcTRdO1xuXHRcdFx0fSxcblx0XHRcdF9jYWxjdWxhdGVDb250cm9sUG9pbnRzID0gZnVuY3Rpb24oYSwgY3VydmluZXNzLCBxdWFkLCBiYXNpYywgY29ycmVsYXRlKSB7XG5cdFx0XHRcdHZhciBsID0gYS5sZW5ndGggLSAxLFxuXHRcdFx0XHRcdGlpID0gMCxcblx0XHRcdFx0XHRjcDEgPSBhWzBdLmEsXG5cdFx0XHRcdFx0aSwgcDEsIHAyLCBwMywgc2VnLCBtMSwgbTIsIG1tLCBjcDIsIHFiLCByMSwgcjIsIHRsO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0c2VnID0gYVtpaV07XG5cdFx0XHRcdFx0cDEgPSBzZWcuYTtcblx0XHRcdFx0XHRwMiA9IHNlZy5kO1xuXHRcdFx0XHRcdHAzID0gYVtpaSsxXS5kO1xuXG5cdFx0XHRcdFx0aWYgKGNvcnJlbGF0ZSkge1xuXHRcdFx0XHRcdFx0cjEgPSBfcjFbaV07XG5cdFx0XHRcdFx0XHRyMiA9IF9yMltpXTtcblx0XHRcdFx0XHRcdHRsID0gKChyMiArIHIxKSAqIGN1cnZpbmVzcyAqIDAuMjUpIC8gKGJhc2ljID8gMC41IDogX3IzW2ldIHx8IDAuNSk7XG5cdFx0XHRcdFx0XHRtMSA9IHAyIC0gKHAyIC0gcDEpICogKGJhc2ljID8gY3VydmluZXNzICogMC41IDogKHIxICE9PSAwID8gdGwgLyByMSA6IDApKTtcblx0XHRcdFx0XHRcdG0yID0gcDIgKyAocDMgLSBwMikgKiAoYmFzaWMgPyBjdXJ2aW5lc3MgKiAwLjUgOiAocjIgIT09IDAgPyB0bCAvIHIyIDogMCkpO1xuXHRcdFx0XHRcdFx0bW0gPSBwMiAtIChtMSArICgoKG0yIC0gbTEpICogKChyMSAqIDMgLyAocjEgKyByMikpICsgMC41KSAvIDQpIHx8IDApKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bTEgPSBwMiAtIChwMiAtIHAxKSAqIGN1cnZpbmVzcyAqIDAuNTtcblx0XHRcdFx0XHRcdG0yID0gcDIgKyAocDMgLSBwMikgKiBjdXJ2aW5lc3MgKiAwLjU7XG5cdFx0XHRcdFx0XHRtbSA9IHAyIC0gKG0xICsgbTIpIC8gMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bTEgKz0gbW07XG5cdFx0XHRcdFx0bTIgKz0gbW07XG5cblx0XHRcdFx0XHRzZWcuYyA9IGNwMiA9IG0xO1xuXHRcdFx0XHRcdGlmIChpICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRzZWcuYiA9IGNwMTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VnLmIgPSBjcDEgPSBzZWcuYSArIChzZWcuYyAtIHNlZy5hKSAqIDAuNjsgLy9pbnN0ZWFkIG9mIHBsYWNpbmcgYiBvbiBhIGV4YWN0bHksIHdlIG1vdmUgaXQgaW5saW5lIHdpdGggYyBzbyB0aGF0IGlmIHRoZSB1c2VyIHNwZWNpZmllcyBhbiBlYXNlIGxpa2UgQmFjay5lYXNlSW4gb3IgRWxhc3RpYy5lYXNlSW4gd2hpY2ggZ29lcyBCRVlPTkQgdGhlIGJlZ2lubmluZywgaXQgd2lsbCBkbyBzbyBzbW9vdGhseS5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzZWcuZGEgPSBwMiAtIHAxO1xuXHRcdFx0XHRcdHNlZy5jYSA9IGNwMiAtIHAxO1xuXHRcdFx0XHRcdHNlZy5iYSA9IGNwMSAtIHAxO1xuXG5cdFx0XHRcdFx0aWYgKHF1YWQpIHtcblx0XHRcdFx0XHRcdHFiID0gY3ViaWNUb1F1YWRyYXRpYyhwMSwgY3AxLCBjcDIsIHAyKTtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGlpLCAxLCBxYlswXSwgcWJbMV0sIHFiWzJdLCBxYlszXSk7XG5cdFx0XHRcdFx0XHRpaSArPSA0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpaSsrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNwMSA9IG0yO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlZyA9IGFbaWldO1xuXHRcdFx0XHRzZWcuYiA9IGNwMTtcblx0XHRcdFx0c2VnLmMgPSBjcDEgKyAoc2VnLmQgLSBjcDEpICogMC40OyAvL2luc3RlYWQgb2YgcGxhY2luZyBjIG9uIGQgZXhhY3RseSwgd2UgbW92ZSBpdCBpbmxpbmUgd2l0aCBiIHNvIHRoYXQgaWYgdGhlIHVzZXIgc3BlY2lmaWVzIGFuIGVhc2UgbGlrZSBCYWNrLmVhc2VPdXQgb3IgRWxhc3RpYy5lYXNlT3V0IHdoaWNoIGdvZXMgQkVZT05EIHRoZSBlbmQsIGl0IHdpbGwgZG8gc28gc21vb3RobHkuXG5cdFx0XHRcdHNlZy5kYSA9IHNlZy5kIC0gc2VnLmE7XG5cdFx0XHRcdHNlZy5jYSA9IHNlZy5jIC0gc2VnLmE7XG5cdFx0XHRcdHNlZy5iYSA9IGNwMSAtIHNlZy5hO1xuXHRcdFx0XHRpZiAocXVhZCkge1xuXHRcdFx0XHRcdHFiID0gY3ViaWNUb1F1YWRyYXRpYyhzZWcuYSwgY3AxLCBzZWcuYywgc2VnLmQpO1xuXHRcdFx0XHRcdGEuc3BsaWNlKGlpLCAxLCBxYlswXSwgcWJbMV0sIHFiWzJdLCBxYlszXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfcGFyc2VBbmNob3JzID0gZnVuY3Rpb24odmFsdWVzLCBwLCBjb3JyZWxhdGUsIHByZXBlbmQpIHtcblx0XHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0XHRsLCBpLCBwMSwgcDIsIHAzLCB0bXA7XG5cdFx0XHRcdGlmIChwcmVwZW5kKSB7XG5cdFx0XHRcdFx0dmFsdWVzID0gW3ByZXBlbmRdLmNvbmNhdCh2YWx1ZXMpO1xuXHRcdFx0XHRcdGkgPSB2YWx1ZXMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiggKHRtcCA9IHZhbHVlc1tpXVtwXSkgKSA9PT0gXCJzdHJpbmdcIikgaWYgKHRtcC5jaGFyQXQoMSkgPT09IFwiPVwiKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlc1tpXVtwXSA9IHByZXBlbmRbcF0gKyBOdW1iZXIodG1wLmNoYXJBdCgwKSArIHRtcC5zdWJzdHIoMikpOyAvL2FjY29tbW9kYXRlIHJlbGF0aXZlIHZhbHVlcy4gRG8gaXQgaW5saW5lIGluc3RlYWQgb2YgYnJlYWtpbmcgaXQgb3V0IGludG8gYSBmdW5jdGlvbiBmb3Igc3BlZWQgcmVhc29uc1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRsID0gdmFsdWVzLmxlbmd0aCAtIDI7XG5cdFx0XHRcdGlmIChsIDwgMCkge1xuXHRcdFx0XHRcdGFbMF0gPSBuZXcgU2VnbWVudCh2YWx1ZXNbMF1bcF0sIDAsIDAsIHZhbHVlc1swXVtwXSk7XG5cdFx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHAxID0gdmFsdWVzW2ldW3BdO1xuXHRcdFx0XHRcdHAyID0gdmFsdWVzW2krMV1bcF07XG5cdFx0XHRcdFx0YVtpXSA9IG5ldyBTZWdtZW50KHAxLCAwLCAwLCBwMik7XG5cdFx0XHRcdFx0aWYgKGNvcnJlbGF0ZSkge1xuXHRcdFx0XHRcdFx0cDMgPSB2YWx1ZXNbaSsyXVtwXTtcblx0XHRcdFx0XHRcdF9yMVtpXSA9IChfcjFbaV0gfHwgMCkgKyAocDIgLSBwMSkgKiAocDIgLSBwMSk7XG5cdFx0XHRcdFx0XHRfcjJbaV0gPSAoX3IyW2ldIHx8IDApICsgKHAzIC0gcDIpICogKHAzIC0gcDIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRhW2ldID0gbmV3IFNlZ21lbnQodmFsdWVzW2ldW3BdLCAwLCAwLCB2YWx1ZXNbaSsxXVtwXSk7XG5cdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0fSxcblx0XHRcdGJlemllclRocm91Z2ggPSBmdW5jdGlvbih2YWx1ZXMsIGN1cnZpbmVzcywgcXVhZHJhdGljLCBiYXNpYywgY29ycmVsYXRlLCBwcmVwZW5kKSB7XG5cdFx0XHRcdHZhciBvYmogPSB7fSxcblx0XHRcdFx0XHRwcm9wcyA9IFtdLFxuXHRcdFx0XHRcdGZpcnN0ID0gcHJlcGVuZCB8fCB2YWx1ZXNbMF0sXG5cdFx0XHRcdFx0aSwgcCwgYSwgaiwgciwgbCwgc2VhbWxlc3MsIGxhc3Q7XG5cdFx0XHRcdGNvcnJlbGF0ZSA9ICh0eXBlb2YoY29ycmVsYXRlKSA9PT0gXCJzdHJpbmdcIikgPyBcIixcIitjb3JyZWxhdGUrXCIsXCIgOiBfY29ycmVsYXRlO1xuXHRcdFx0XHRpZiAoY3VydmluZXNzID09IG51bGwpIHtcblx0XHRcdFx0XHRjdXJ2aW5lc3MgPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAocCBpbiB2YWx1ZXNbMF0pIHtcblx0XHRcdFx0XHRwcm9wcy5wdXNoKHApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vY2hlY2sgdG8gc2VlIGlmIHRoZSBsYXN0IGFuZCBmaXJzdCB2YWx1ZXMgYXJlIGlkZW50aWNhbCAod2VsbCwgd2l0aGluIDAuMDUpLiBJZiBzbywgbWFrZSBzZWFtbGVzcyBieSBhcHBlbmRpbmcgdGhlIHNlY29uZCBlbGVtZW50IHRvIHRoZSB2ZXJ5IGVuZCBvZiB0aGUgdmFsdWVzIGFycmF5IGFuZCB0aGUgMm5kLXRvLWxhc3QgZWxlbWVudCB0byB0aGUgdmVyeSBiZWdpbm5pbmcgKHdlJ2xsIHJlbW92ZSB0aG9zZSBzZWdtZW50cyBsYXRlcilcblx0XHRcdFx0aWYgKHZhbHVlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0bGFzdCA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0c2VhbWxlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRwID0gcHJvcHNbaV07XG5cdFx0XHRcdFx0XHRpZiAoTWF0aC5hYnMoZmlyc3RbcF0gLSBsYXN0W3BdKSA+IDAuMDUpIHsgLy9idWlsZCBpbiBhIHRvbGVyYW5jZSBvZiArLy0wLjA1IHRvIGFjY29tbW9kYXRlIHJvdW5kaW5nIGVycm9ycy5cblx0XHRcdFx0XHRcdFx0c2VhbWxlc3MgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzZWFtbGVzcykge1xuXHRcdFx0XHRcdFx0dmFsdWVzID0gdmFsdWVzLmNvbmNhdCgpOyAvL2R1cGxpY2F0ZSB0aGUgYXJyYXkgdG8gYXZvaWQgY29udGFtaW5hdGluZyB0aGUgb3JpZ2luYWwgd2hpY2ggdGhlIHVzZXIgbWF5IGJlIHJldXNpbmcgZm9yIG90aGVyIHR3ZWVuc1xuXHRcdFx0XHRcdFx0aWYgKHByZXBlbmQpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWVzLnVuc2hpZnQocHJlcGVuZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCh2YWx1ZXNbMV0pO1xuXHRcdFx0XHRcdFx0cHJlcGVuZCA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gM107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdF9yMS5sZW5ndGggPSBfcjIubGVuZ3RoID0gX3IzLmxlbmd0aCA9IDA7XG5cdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRfY29yUHJvcHNbcF0gPSAoY29ycmVsYXRlLmluZGV4T2YoXCIsXCIrcCtcIixcIikgIT09IC0xKTtcblx0XHRcdFx0XHRvYmpbcF0gPSBfcGFyc2VBbmNob3JzKHZhbHVlcywgcCwgX2NvclByb3BzW3BdLCBwcmVwZW5kKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gX3IxLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0X3IxW2ldID0gTWF0aC5zcXJ0KF9yMVtpXSk7XG5cdFx0XHRcdFx0X3IyW2ldID0gTWF0aC5zcXJ0KF9yMltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFiYXNpYykge1xuXHRcdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAoX2NvclByb3BzW3BdKSB7XG5cdFx0XHRcdFx0XHRcdGEgPSBvYmpbcHJvcHNbaV1dO1xuXHRcdFx0XHRcdFx0XHRsID0gYS5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdFx0ciA9IChhW2orMV0uZGEgLyBfcjJbal0gKyBhW2pdLmRhIC8gX3IxW2pdKSB8fCAwO1xuXHRcdFx0XHRcdFx0XHRcdF9yM1tqXSA9IChfcjNbal0gfHwgMCkgKyByICogcjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpID0gX3IzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdF9yM1tpXSA9IE1hdGguc3FydChfcjNbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRqID0gcXVhZHJhdGljID8gNCA6IDE7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRhID0gb2JqW3BdO1xuXHRcdFx0XHRcdF9jYWxjdWxhdGVDb250cm9sUG9pbnRzKGEsIGN1cnZpbmVzcywgcXVhZHJhdGljLCBiYXNpYywgX2NvclByb3BzW3BdKTsgLy90aGlzIG1ldGhvZCByZXF1aXJlcyB0aGF0IF9wYXJzZUFuY2hvcnMoKSBhbmQgX3NldFNlZ21lbnRSYXRpb3MoKSByYW4gZmlyc3Qgc28gdGhhdCBfcjEsIF9yMiwgYW5kIF9yMyB2YWx1ZXMgYXJlIHBvcHVsYXRlZCBmb3IgYWxsIHByb3BlcnRpZXNcblx0XHRcdFx0XHRpZiAoc2VhbWxlc3MpIHtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKDAsIGopO1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoYS5sZW5ndGggLSBqLCBqKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0sXG5cdFx0XHRfcGFyc2VCZXppZXJEYXRhID0gZnVuY3Rpb24odmFsdWVzLCB0eXBlLCBwcmVwZW5kKSB7XG5cdFx0XHRcdHR5cGUgPSB0eXBlIHx8IFwic29mdFwiO1xuXHRcdFx0XHR2YXIgb2JqID0ge30sXG5cdFx0XHRcdFx0aW5jID0gKHR5cGUgPT09IFwiY3ViaWNcIikgPyAzIDogMixcblx0XHRcdFx0XHRzb2Z0ID0gKHR5cGUgPT09IFwic29mdFwiKSxcblx0XHRcdFx0XHRwcm9wcyA9IFtdLFxuXHRcdFx0XHRcdGEsIGIsIGMsIGQsIGN1ciwgaSwgaiwgbCwgcCwgY250LCB0bXA7XG5cdFx0XHRcdGlmIChzb2Z0ICYmIHByZXBlbmQpIHtcblx0XHRcdFx0XHR2YWx1ZXMgPSBbcHJlcGVuZF0uY29uY2F0KHZhbHVlcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHZhbHVlcyA9PSBudWxsIHx8IHZhbHVlcy5sZW5ndGggPCBpbmMgKyAxKSB7IHRocm93IFwiaW52YWxpZCBCZXppZXIgZGF0YVwiOyB9XG5cdFx0XHRcdGZvciAocCBpbiB2YWx1ZXNbMF0pIHtcblx0XHRcdFx0XHRwcm9wcy5wdXNoKHApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRvYmpbcF0gPSBjdXIgPSBbXTtcblx0XHRcdFx0XHRjbnQgPSAwO1xuXHRcdFx0XHRcdGwgPSB2YWx1ZXMubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcblx0XHRcdFx0XHRcdGEgPSAocHJlcGVuZCA9PSBudWxsKSA/IHZhbHVlc1tqXVtwXSA6ICh0eXBlb2YoICh0bXAgPSB2YWx1ZXNbal1bcF0pICkgPT09IFwic3RyaW5nXCIgJiYgdG1wLmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gcHJlcGVuZFtwXSArIE51bWJlcih0bXAuY2hhckF0KDApICsgdG1wLnN1YnN0cigyKSkgOiBOdW1iZXIodG1wKTtcblx0XHRcdFx0XHRcdGlmIChzb2Z0KSBpZiAoaiA+IDEpIGlmIChqIDwgbCAtIDEpIHtcblx0XHRcdFx0XHRcdFx0Y3VyW2NudCsrXSA9IChhICsgY3VyW2NudC0yXSkgLyAyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y3VyW2NudCsrXSA9IGE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGwgPSBjbnQgLSBpbmMgKyAxO1xuXHRcdFx0XHRcdGNudCA9IDA7XG5cdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGw7IGogKz0gaW5jKSB7XG5cdFx0XHRcdFx0XHRhID0gY3VyW2pdO1xuXHRcdFx0XHRcdFx0YiA9IGN1cltqKzFdO1xuXHRcdFx0XHRcdFx0YyA9IGN1cltqKzJdO1xuXHRcdFx0XHRcdFx0ZCA9IChpbmMgPT09IDIpID8gMCA6IGN1cltqKzNdO1xuXHRcdFx0XHRcdFx0Y3VyW2NudCsrXSA9IHRtcCA9IChpbmMgPT09IDMpID8gbmV3IFNlZ21lbnQoYSwgYiwgYywgZCkgOiBuZXcgU2VnbWVudChhLCAoMiAqIGIgKyBhKSAvIDMsICgyICogYiArIGMpIC8gMywgYyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN1ci5sZW5ndGggPSBjbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0sXG5cdFx0XHRfYWRkQ3ViaWNMZW5ndGhzID0gZnVuY3Rpb24oYSwgc3RlcHMsIHJlc29sdXRpb24pIHtcblx0XHRcdFx0dmFyIGluYyA9IDEgLyByZXNvbHV0aW9uLFxuXHRcdFx0XHRcdGogPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRkLCBkMSwgcywgZGEsIGNhLCBiYSwgcCwgaSwgaW52LCBiZXosIGluZGV4O1xuXHRcdFx0XHR3aGlsZSAoLS1qID4gLTEpIHtcblx0XHRcdFx0XHRiZXogPSBhW2pdO1xuXHRcdFx0XHRcdHMgPSBiZXouYTtcblx0XHRcdFx0XHRkYSA9IGJlei5kIC0gcztcblx0XHRcdFx0XHRjYSA9IGJlei5jIC0gcztcblx0XHRcdFx0XHRiYSA9IGJlei5iIC0gcztcblx0XHRcdFx0XHRkID0gZDEgPSAwO1xuXHRcdFx0XHRcdGZvciAoaSA9IDE7IGkgPD0gcmVzb2x1dGlvbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRwID0gaW5jICogaTtcblx0XHRcdFx0XHRcdGludiA9IDEgLSBwO1xuXHRcdFx0XHRcdFx0ZCA9IGQxIC0gKGQxID0gKHAgKiBwICogZGEgKyAzICogaW52ICogKHAgKiBjYSArIGludiAqIGJhKSkgKiBwKTtcblx0XHRcdFx0XHRcdGluZGV4ID0gaiAqIHJlc29sdXRpb24gKyBpIC0gMTtcblx0XHRcdFx0XHRcdHN0ZXBzW2luZGV4XSA9IChzdGVwc1tpbmRleF0gfHwgMCkgKyBkICogZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfcGFyc2VMZW5ndGhEYXRhID0gZnVuY3Rpb24ob2JqLCByZXNvbHV0aW9uKSB7XG5cdFx0XHRcdHJlc29sdXRpb24gPSByZXNvbHV0aW9uID4+IDAgfHwgNjtcblx0XHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0XHRsZW5ndGhzID0gW10sXG5cdFx0XHRcdFx0ZCA9IDAsXG5cdFx0XHRcdFx0dG90YWwgPSAwLFxuXHRcdFx0XHRcdHRocmVzaG9sZCA9IHJlc29sdXRpb24gLSAxLFxuXHRcdFx0XHRcdHNlZ21lbnRzID0gW10sXG5cdFx0XHRcdFx0Y3VyTFMgPSBbXSwgLy9jdXJyZW50IGxlbmd0aCBzZWdtZW50cyBhcnJheVxuXHRcdFx0XHRcdHAsIGksIGwsIGluZGV4O1xuXHRcdFx0XHRmb3IgKHAgaW4gb2JqKSB7XG5cdFx0XHRcdFx0X2FkZEN1YmljTGVuZ3RocyhvYmpbcF0sIGEsIHJlc29sdXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGwgPSBhLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGQgKz0gTWF0aC5zcXJ0KGFbaV0pO1xuXHRcdFx0XHRcdGluZGV4ID0gaSAlIHJlc29sdXRpb247XG5cdFx0XHRcdFx0Y3VyTFNbaW5kZXhdID0gZDtcblx0XHRcdFx0XHRpZiAoaW5kZXggPT09IHRocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0dG90YWwgKz0gZDtcblx0XHRcdFx0XHRcdGluZGV4ID0gKGkgLyByZXNvbHV0aW9uKSA+PiAwO1xuXHRcdFx0XHRcdFx0c2VnbWVudHNbaW5kZXhdID0gY3VyTFM7XG5cdFx0XHRcdFx0XHRsZW5ndGhzW2luZGV4XSA9IHRvdGFsO1xuXHRcdFx0XHRcdFx0ZCA9IDA7XG5cdFx0XHRcdFx0XHRjdXJMUyA9IFtdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge2xlbmd0aDp0b3RhbCwgbGVuZ3RoczpsZW5ndGhzLCBzZWdtZW50czpzZWdtZW50c307XG5cdFx0XHR9LFxuXG5cblxuXHRcdFx0QmV6aWVyUGx1Z2luID0gX2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7XG5cdFx0XHRcdFx0cHJvcE5hbWU6IFwiYmV6aWVyXCIsXG5cdFx0XHRcdFx0cHJpb3JpdHk6IC0xLFxuXHRcdFx0XHRcdHZlcnNpb246IFwiMS4zLjhcIixcblx0XHRcdFx0XHRBUEk6IDIsXG5cdFx0XHRcdFx0Z2xvYmFsOnRydWUsXG5cblx0XHRcdFx0XHQvL2dldHMgY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGlzIHdoZXJlIGluaXRpYWwgdmFsdWVzIHNob3VsZCBiZSByZWNvcmRlZCBhbmQgYW55IHNldHVwIHJvdXRpbmVzIHNob3VsZCBydW4uXG5cdFx0XHRcdFx0aW5pdDogZnVuY3Rpb24odGFyZ2V0LCB2YXJzLCB0d2Vlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdFx0XHRcdFx0aWYgKHZhcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRcdFx0XHR2YXJzID0ge3ZhbHVlczp2YXJzfTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX2Z1bmMgPSB7fTtcblx0XHRcdFx0XHRcdHRoaXMuX21vZCA9IHt9O1xuXHRcdFx0XHRcdFx0dGhpcy5fcHJvcHMgPSBbXTtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWVSZXMgPSAodmFycy50aW1lUmVzb2x1dGlvbiA9PSBudWxsKSA/IDYgOiBwYXJzZUludCh2YXJzLnRpbWVSZXNvbHV0aW9uLCAxMCk7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gdmFycy52YWx1ZXMgfHwgW10sXG5cdFx0XHRcdFx0XHRcdGZpcnN0ID0ge30sXG5cdFx0XHRcdFx0XHRcdHNlY29uZCA9IHZhbHVlc1swXSxcblx0XHRcdFx0XHRcdFx0YXV0b1JvdGF0ZSA9IHZhcnMuYXV0b1JvdGF0ZSB8fCB0d2Vlbi52YXJzLm9yaWVudFRvQmV6aWVyLFxuXHRcdFx0XHRcdFx0XHRwLCBpc0Z1bmMsIGksIGosIHByZXBlbmQ7XG5cblx0XHRcdFx0XHRcdHRoaXMuX2F1dG9Sb3RhdGUgPSBhdXRvUm90YXRlID8gKGF1dG9Sb3RhdGUgaW5zdGFuY2VvZiBBcnJheSkgPyBhdXRvUm90YXRlIDogW1tcInhcIixcInlcIixcInJvdGF0aW9uXCIsKChhdXRvUm90YXRlID09PSB0cnVlKSA/IDAgOiBOdW1iZXIoYXV0b1JvdGF0ZSkgfHwgMCldXSA6IG51bGw7XG5cdFx0XHRcdFx0XHRmb3IgKHAgaW4gc2Vjb25kKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3Byb3BzLnB1c2gocCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGkgPSB0aGlzLl9wcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuX3Byb3BzW2ldO1xuXG5cdFx0XHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0XHRcdFx0XHRcdGlzRnVuYyA9IHRoaXMuX2Z1bmNbcF0gPSAodHlwZW9mKHRhcmdldFtwXSkgPT09IFwiZnVuY3Rpb25cIik7XG5cdFx0XHRcdFx0XHRcdGZpcnN0W3BdID0gKCFpc0Z1bmMpID8gcGFyc2VGbG9hdCh0YXJnZXRbcF0pIDogdGFyZ2V0WyAoKHAuaW5kZXhPZihcInNldFwiKSB8fCB0eXBlb2YodGFyZ2V0W1wiZ2V0XCIgKyBwLnN1YnN0cigzKV0pICE9PSBcImZ1bmN0aW9uXCIpID8gcCA6IFwiZ2V0XCIgKyBwLnN1YnN0cigzKSkgXSgpO1xuXHRcdFx0XHRcdFx0XHRpZiAoIXByZXBlbmQpIGlmIChmaXJzdFtwXSAhPT0gdmFsdWVzWzBdW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJlcGVuZCA9IGZpcnN0O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9iZXppZXJzID0gKHZhcnMudHlwZSAhPT0gXCJjdWJpY1wiICYmIHZhcnMudHlwZSAhPT0gXCJxdWFkcmF0aWNcIiAmJiB2YXJzLnR5cGUgIT09IFwic29mdFwiKSA/IGJlemllclRocm91Z2godmFsdWVzLCBpc05hTih2YXJzLmN1cnZpbmVzcykgPyAxIDogdmFycy5jdXJ2aW5lc3MsIGZhbHNlLCAodmFycy50eXBlID09PSBcInRocnVCYXNpY1wiKSwgdmFycy5jb3JyZWxhdGUsIHByZXBlbmQpIDogX3BhcnNlQmV6aWVyRGF0YSh2YWx1ZXMsIHZhcnMudHlwZSwgZmlyc3QpO1xuXHRcdFx0XHRcdFx0dGhpcy5fc2VnQ291bnQgPSB0aGlzLl9iZXppZXJzW3BdLmxlbmd0aDtcblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVSZXMpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGxkID0gX3BhcnNlTGVuZ3RoRGF0YSh0aGlzLl9iZXppZXJzLCB0aGlzLl90aW1lUmVzKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fbGVuZ3RoID0gbGQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9sZW5ndGhzID0gbGQubGVuZ3Rocztcblx0XHRcdFx0XHRcdFx0dGhpcy5fc2VnbWVudHMgPSBsZC5zZWdtZW50cztcblx0XHRcdFx0XHRcdFx0dGhpcy5fbDEgPSB0aGlzLl9saSA9IHRoaXMuX3MxID0gdGhpcy5fc2kgPSAwO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9sMiA9IHRoaXMuX2xlbmd0aHNbMF07XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2N1clNlZyA9IHRoaXMuX3NlZ21lbnRzWzBdO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9zMiA9IHRoaXMuX2N1clNlZ1swXTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fcHJlYyA9IDEgLyB0aGlzLl9jdXJTZWcubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoKGF1dG9Sb3RhdGUgPSB0aGlzLl9hdXRvUm90YXRlKSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9pbml0aWFsUm90YXRpb25zID0gW107XG5cdFx0XHRcdFx0XHRcdGlmICghKGF1dG9Sb3RhdGVbMF0gaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9hdXRvUm90YXRlID0gYXV0b1JvdGF0ZSA9IFthdXRvUm90YXRlXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpID0gYXV0b1JvdGF0ZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCAzOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdHAgPSBhdXRvUm90YXRlW2ldW2pdO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZnVuY1twXSA9ICh0eXBlb2YodGFyZ2V0W3BdKSA9PT0gXCJmdW5jdGlvblwiKSA/IHRhcmdldFsgKChwLmluZGV4T2YoXCJzZXRcIikgfHwgdHlwZW9mKHRhcmdldFtcImdldFwiICsgcC5zdWJzdHIoMyldKSAhPT0gXCJmdW5jdGlvblwiKSA/IHAgOiBcImdldFwiICsgcC5zdWJzdHIoMykpIF0gOiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cCA9IGF1dG9Sb3RhdGVbaV1bMl07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5faW5pdGlhbFJvdGF0aW9uc1tpXSA9ICh0aGlzLl9mdW5jW3BdID8gdGhpcy5fZnVuY1twXS5jYWxsKHRoaXMuX3RhcmdldCkgOiB0aGlzLl90YXJnZXRbcF0pIHx8IDA7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChwKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRSYXRpbyA9IHR3ZWVuLnZhcnMucnVuQmFja3dhcmRzID8gMSA6IDA7IC8vd2UgZGV0ZXJtaW5lIHRoZSBzdGFydGluZyByYXRpbyB3aGVuIHRoZSB0d2VlbiBpbml0cyB3aGljaCBpcyBhbHdheXMgMCB1bmxlc3MgdGhlIHR3ZWVuIGhhcyBydW5CYWNrd2FyZHM6dHJ1ZSAoaW5kaWNhdGluZyBpdCdzIGEgZnJvbSgpIHR3ZWVuKSBpbiB3aGljaCBjYXNlIGl0J3MgMS5cblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvL2NhbGxlZCBlYWNoIHRpbWUgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCwgYW5kIHRoZSByYXRpbyBnZXRzIHBhc3NlZCBhcyB0aGUgb25seSBwYXJhbWV0ZXIgKHR5cGljYWxseSBpdCdzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBidXQgaXQgY2FuIGV4Y2VlZCB0aG9zZSB3aGVuIHVzaW5nIGFuIGVhc2UgbGlrZSBFbGFzdGljLmVhc2VPdXQgb3IgQmFjay5lYXNlT3V0LCBldGMuKVxuXHRcdFx0XHRcdHNldDogZnVuY3Rpb24odikge1xuXHRcdFx0XHRcdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnQ291bnQsXG5cdFx0XHRcdFx0XHRcdGZ1bmMgPSB0aGlzLl9mdW5jLFxuXHRcdFx0XHRcdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXQsXG5cdFx0XHRcdFx0XHRcdG5vdFN0YXJ0ID0gKHYgIT09IHRoaXMuX3N0YXJ0UmF0aW8pLFxuXHRcdFx0XHRcdFx0XHRjdXJJbmRleCwgaW52LCBpLCBwLCBiLCB0LCB2YWwsIGwsIGxlbmd0aHMsIGN1clNlZztcblx0XHRcdFx0XHRcdGlmICghdGhpcy5fdGltZVJlcykge1xuXHRcdFx0XHRcdFx0XHRjdXJJbmRleCA9ICh2IDwgMCkgPyAwIDogKHYgPj0gMSkgPyBzZWdtZW50cyAtIDEgOiAoc2VnbWVudHMgKiB2KSA+PiAwO1xuXHRcdFx0XHRcdFx0XHR0ID0gKHYgLSAoY3VySW5kZXggKiAoMSAvIHNlZ21lbnRzKSkpICogc2VnbWVudHM7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsZW5ndGhzID0gdGhpcy5fbGVuZ3Rocztcblx0XHRcdFx0XHRcdFx0Y3VyU2VnID0gdGhpcy5fY3VyU2VnO1xuXHRcdFx0XHRcdFx0XHR2ICo9IHRoaXMuX2xlbmd0aDtcblx0XHRcdFx0XHRcdFx0aSA9IHRoaXMuX2xpO1xuXHRcdFx0XHRcdFx0XHQvL2ZpbmQgdGhlIGFwcHJvcHJpYXRlIHNlZ21lbnQgKGlmIHRoZSBjdXJyZW50bHkgY2FjaGVkIG9uZSBpc24ndCBjb3JyZWN0KVxuXHRcdFx0XHRcdFx0XHRpZiAodiA+IHRoaXMuX2wyICYmIGkgPCBzZWdtZW50cyAtIDEpIHtcblx0XHRcdFx0XHRcdFx0XHRsID0gc2VnbWVudHMgLSAxO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlIChpIDwgbCAmJiAodGhpcy5fbDIgPSBsZW5ndGhzWysraV0pIDw9IHYpIHtcdH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9sMSA9IGxlbmd0aHNbaS0xXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9saSA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY3VyU2VnID0gY3VyU2VnID0gdGhpcy5fc2VnbWVudHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczIgPSBjdXJTZWdbKHRoaXMuX3MxID0gdGhpcy5fc2kgPSAwKV07XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodiA8IHRoaXMuX2wxICYmIGkgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPiAwICYmICh0aGlzLl9sMSA9IGxlbmd0aHNbLS1pXSkgPj0gdikgeyB9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGkgPT09IDAgJiYgdiA8IHRoaXMuX2wxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9sMSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fbDIgPSBsZW5ndGhzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2xpID0gaTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jdXJTZWcgPSBjdXJTZWcgPSB0aGlzLl9zZWdtZW50c1tpXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMSA9IGN1clNlZ1sodGhpcy5fc2kgPSBjdXJTZWcubGVuZ3RoIC0gMSkgLSAxXSB8fCAwO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MyID0gY3VyU2VnW3RoaXMuX3NpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjdXJJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdC8vbm93IGZpbmQgdGhlIGFwcHJvcHJpYXRlIHN1Yi1zZWdtZW50ICh3ZSBzcGxpdCBpdCBpbnRvIHRoZSBudW1iZXIgb2YgcGllY2VzIHRoYXQgd2FzIGRlZmluZWQgYnkgXCJwcmVjaXNpb25cIiBhbmQgbWVhc3VyZWQgZWFjaCBvbmUpXG5cdFx0XHRcdFx0XHRcdHYgLT0gdGhpcy5fbDE7XG5cdFx0XHRcdFx0XHRcdGkgPSB0aGlzLl9zaTtcblx0XHRcdFx0XHRcdFx0aWYgKHYgPiB0aGlzLl9zMiAmJiBpIDwgY3VyU2VnLmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0XHRcdFx0XHRsID0gY3VyU2VnLmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPCBsICYmICh0aGlzLl9zMiA9IGN1clNlZ1srK2ldKSA8PSB2KSB7XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczEgPSBjdXJTZWdbaS0xXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zaSA9IGk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodiA8IHRoaXMuX3MxICYmIGkgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPiAwICYmICh0aGlzLl9zMSA9IGN1clNlZ1stLWldKSA+PSB2KSB7XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGkgPT09IDAgJiYgdiA8IHRoaXMuX3MxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczIgPSBjdXJTZWdbaV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc2kgPSBpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHQgPSAoKGkgKyAodiAtIHRoaXMuX3MxKSAvICh0aGlzLl9zMiAtIHRoaXMuX3MxKSkgKiB0aGlzLl9wcmVjKSB8fCAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aW52ID0gMSAtIHQ7XG5cblx0XHRcdFx0XHRcdGkgPSB0aGlzLl9wcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuX3Byb3BzW2ldO1xuXHRcdFx0XHRcdFx0XHRiID0gdGhpcy5fYmV6aWVyc1twXVtjdXJJbmRleF07XG5cdFx0XHRcdFx0XHRcdHZhbCA9ICh0ICogdCAqIGIuZGEgKyAzICogaW52ICogKHQgKiBiLmNhICsgaW52ICogYi5iYSkpICogdCArIGIuYTtcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuX21vZFtwXSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhbCA9IHRoaXMuX21vZFtwXSh2YWwsIHRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKGZ1bmNbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcF0odmFsKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcF0gPSB2YWw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX2F1dG9Sb3RhdGUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGFyID0gdGhpcy5fYXV0b1JvdGF0ZSxcblx0XHRcdFx0XHRcdFx0XHRiMiwgeDEsIHkxLCB4MiwgeTIsIGFkZCwgY29udjtcblx0XHRcdFx0XHRcdFx0aSA9IGFyLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0cCA9IGFyW2ldWzJdO1xuXHRcdFx0XHRcdFx0XHRcdGFkZCA9IGFyW2ldWzNdIHx8IDA7XG5cdFx0XHRcdFx0XHRcdFx0Y29udiA9IChhcltpXVs0XSA9PT0gdHJ1ZSkgPyAxIDogX1JBRDJERUc7XG5cdFx0XHRcdFx0XHRcdFx0YiA9IHRoaXMuX2JlemllcnNbYXJbaV1bMF1dO1xuXHRcdFx0XHRcdFx0XHRcdGIyID0gdGhpcy5fYmV6aWVyc1thcltpXVsxXV07XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoYiAmJiBiMikgeyAvL2luIGNhc2Ugb25lIG9mIHRoZSBwcm9wZXJ0aWVzIGdvdCBvdmVyd3JpdHRlbi5cblx0XHRcdFx0XHRcdFx0XHRcdGIgPSBiW2N1ckluZGV4XTtcblx0XHRcdFx0XHRcdFx0XHRcdGIyID0gYjJbY3VySW5kZXhdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR4MSA9IGIuYSArIChiLmIgLSBiLmEpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHgyID0gYi5iICsgKGIuYyAtIGIuYikgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eDEgKz0gKHgyIC0geDEpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHgyICs9ICgoYi5jICsgKGIuZCAtIGIuYykgKiB0KSAtIHgyKSAqIHQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHkxID0gYjIuYSArIChiMi5iIC0gYjIuYSkgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eTIgPSBiMi5iICsgKGIyLmMgLSBiMi5iKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR5MSArPSAoeTIgLSB5MSkgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eTIgKz0gKChiMi5jICsgKGIyLmQgLSBiMi5jKSAqIHQpIC0geTIpICogdDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsID0gbm90U3RhcnQgPyBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpICogY29udiArIGFkZCA6IHRoaXMuX2luaXRpYWxSb3RhdGlvbnNbaV07XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLl9tb2RbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsID0gdGhpcy5fbW9kW3BdKHZhbCwgdGFyZ2V0KTsgLy9mb3IgbW9kUHJvcHNcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGZ1bmNbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3BdKHZhbCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcF0gPSB2YWw7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0fSksXG5cdFx0XHRwID0gQmV6aWVyUGx1Z2luLnByb3RvdHlwZTtcblxuXG5cdFx0QmV6aWVyUGx1Z2luLmJlemllclRocm91Z2ggPSBiZXppZXJUaHJvdWdoO1xuXHRcdEJlemllclBsdWdpbi5jdWJpY1RvUXVhZHJhdGljID0gY3ViaWNUb1F1YWRyYXRpYztcblx0XHRCZXppZXJQbHVnaW4uX2F1dG9DU1MgPSB0cnVlOyAvL2luZGljYXRlcyB0aGF0IHRoaXMgcGx1Z2luIGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBcImNzc1wiIG9iamVjdCB1c2luZyB0aGUgYXV0b0NTUyBmZWF0dXJlIG9mIFR3ZWVuTGl0ZVxuXHRcdEJlemllclBsdWdpbi5xdWFkcmF0aWNUb0N1YmljID0gZnVuY3Rpb24oYSwgYiwgYykge1xuXHRcdFx0cmV0dXJuIG5ldyBTZWdtZW50KGEsICgyICogYiArIGEpIC8gMywgKDIgKiBiICsgYykgLyAzLCBjKTtcblx0XHR9O1xuXG5cdFx0QmV6aWVyUGx1Z2luLl9jc3NSZWdpc3RlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIENTU1BsdWdpbiA9IF9nbG9iYWxzLkNTU1BsdWdpbjtcblx0XHRcdGlmICghQ1NTUGx1Z2luKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBfaW50ZXJuYWxzID0gQ1NTUGx1Z2luLl9pbnRlcm5hbHMsXG5cdFx0XHRcdF9wYXJzZVRvUHJveHkgPSBfaW50ZXJuYWxzLl9wYXJzZVRvUHJveHksXG5cdFx0XHRcdF9zZXRQbHVnaW5SYXRpbyA9IF9pbnRlcm5hbHMuX3NldFBsdWdpblJhdGlvLFxuXHRcdFx0XHRDU1NQcm9wVHdlZW4gPSBfaW50ZXJuYWxzLkNTU1Byb3BUd2Vlbjtcblx0XHRcdF9pbnRlcm5hbHMuX3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYmV6aWVyXCIsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcHJvcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0XHRpZiAoZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdFx0ZSA9IHt2YWx1ZXM6ZX07XG5cdFx0XHRcdH1cblx0XHRcdFx0cGx1Z2luID0gbmV3IEJlemllclBsdWdpbigpO1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gZS52YWx1ZXMsXG5cdFx0XHRcdFx0bCA9IHZhbHVlcy5sZW5ndGggLSAxLFxuXHRcdFx0XHRcdHBsdWdpblZhbHVlcyA9IFtdLFxuXHRcdFx0XHRcdHYgPSB7fSxcblx0XHRcdFx0XHRpLCBwLCBkYXRhO1xuXHRcdFx0XHRpZiAobCA8IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8PSBsOyBpKyspIHtcblx0XHRcdFx0XHRkYXRhID0gX3BhcnNlVG9Qcm94eSh0LCB2YWx1ZXNbaV0sIGNzc3AsIHB0LCBwbHVnaW4sIChsICE9PSBpKSk7XG5cdFx0XHRcdFx0cGx1Z2luVmFsdWVzW2ldID0gZGF0YS5lbmQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChwIGluIGUpIHtcblx0XHRcdFx0XHR2W3BdID0gZVtwXTsgLy9kdXBsaWNhdGUgdGhlIHZhcnMgb2JqZWN0IGJlY2F1c2Ugd2UgbmVlZCB0byBhbHRlciBzb21lIHRoaW5ncyB3aGljaCB3b3VsZCBjYXVzZSBwcm9ibGVtcyBpZiB0aGUgdXNlciBwbGFucyB0byByZXVzZSB0aGUgc2FtZSB2YXJzIG9iamVjdCBmb3IgYW5vdGhlciB0d2Vlbi5cblx0XHRcdFx0fVxuXHRcdFx0XHR2LnZhbHVlcyA9IHBsdWdpblZhbHVlcztcblx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIFwiYmV6aWVyXCIsIDAsIDAsIGRhdGEucHQsIDIpO1xuXHRcdFx0XHRwdC5kYXRhID0gZGF0YTtcblx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRwdC5zZXRSYXRpbyA9IF9zZXRQbHVnaW5SYXRpbztcblx0XHRcdFx0aWYgKHYuYXV0b1JvdGF0ZSA9PT0gMCkge1xuXHRcdFx0XHRcdHYuYXV0b1JvdGF0ZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYuYXV0b1JvdGF0ZSAmJiAhKHYuYXV0b1JvdGF0ZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0XHRcdGkgPSAodi5hdXRvUm90YXRlID09PSB0cnVlKSA/IDAgOiBOdW1iZXIodi5hdXRvUm90YXRlKTtcblx0XHRcdFx0XHR2LmF1dG9Sb3RhdGUgPSAoZGF0YS5lbmQubGVmdCAhPSBudWxsKSA/IFtbXCJsZWZ0XCIsXCJ0b3BcIixcInJvdGF0aW9uXCIsaSxmYWxzZV1dIDogKGRhdGEuZW5kLnggIT0gbnVsbCkgPyBbW1wieFwiLFwieVwiLFwicm90YXRpb25cIixpLGZhbHNlXV0gOiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodi5hdXRvUm90YXRlKSB7XG5cdFx0XHRcdFx0aWYgKCFjc3NwLl90cmFuc2Zvcm0pIHtcblx0XHRcdFx0XHRcdGNzc3AuX2VuYWJsZVRyYW5zZm9ybXMoZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhLmF1dG9Sb3RhdGUgPSBjc3NwLl90YXJnZXQuX2dzVHJhbnNmb3JtO1xuXHRcdFx0XHRcdGRhdGEucHJveHkucm90YXRpb24gPSBkYXRhLmF1dG9Sb3RhdGUucm90YXRpb24gfHwgMDtcblx0XHRcdFx0XHRjc3NwLl9vdmVyd3JpdGVQcm9wcy5wdXNoKFwicm90YXRpb25cIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGx1Z2luLl9vbkluaXRUd2VlbihkYXRhLnByb3h5LCB2LCBjc3NwLl90d2Vlbik7XG5cdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdH19KTtcblx0XHR9O1xuXG5cdFx0cC5fbW9kID0gZnVuY3Rpb24obG9va3VwKSB7XG5cdFx0XHR2YXIgb3AgPSB0aGlzLl9vdmVyd3JpdGVQcm9wcyxcblx0XHRcdFx0aSA9IG9wLmxlbmd0aCxcblx0XHRcdFx0dmFsO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHZhbCA9IGxvb2t1cFtvcFtpXV07XG5cdFx0XHRcdGlmICh2YWwgJiYgdHlwZW9mKHZhbCkgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHRoaXMuX21vZFtvcFtpXV0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKGxvb2t1cCkge1xuXHRcdFx0dmFyIGEgPSB0aGlzLl9wcm9wcyxcblx0XHRcdFx0cCwgaTtcblx0XHRcdGZvciAocCBpbiB0aGlzLl9iZXppZXJzKSB7XG5cdFx0XHRcdGlmIChwIGluIGxvb2t1cCkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9iZXppZXJzW3BdO1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9mdW5jW3BdO1xuXHRcdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmIChhW2ldID09PSBwKSB7XG5cdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YSA9IHRoaXMuX2F1dG9Sb3RhdGU7XG5cdFx0XHRpZiAoYSkge1xuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmIChsb29rdXBbYVtpXVsyXV0pIHtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3N1cGVyLl9raWxsLmNhbGwodGhpcywgbG9va3VwKTtcblx0XHR9O1xuXG5leHBvcnQgeyBCZXppZXJQbHVnaW4sIEJlemllclBsdWdpbiBhcyBkZWZhdWx0IH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ3NhcC9CZXppZXJQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogVkVSU0lPTjogMS4xNi4xXG4gKiBEQVRFOiAyMDE4LTA4LTI3XG4gKiBVUERBVEVTIEFORCBET0NTIEFUOiBodHRwOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwOC0yMDE4LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHdvcmsgaXMgc3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cDovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBzb2Z0d2FyZSBhZ3JlZW1lbnQgdGhhdCB3YXMgaXNzdWVkIHdpdGggeW91ciBtZW1iZXJzaGlwLlxuICogXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiAqKi9cblxuaW1wb3J0IHsgX2dzU2NvcGUsIGdsb2JhbHMsIEVhc2UsIExpbmVhciwgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQgfSBmcm9tIFwiLi9Ud2VlbkxpdGUuanNcIjtcblxuX2dzU2NvcGUuX2dzRGVmaW5lKFwiZWFzaW5nLkJhY2tcIiwgW1wiZWFzaW5nLkVhc2VcIl0sIGZ1bmN0aW9uKCkge1xuXHRcdFxuXHRcdHZhciB3ID0gKF9nc1Njb3BlLkdyZWVuU29ja0dsb2JhbHMgfHwgX2dzU2NvcGUpLFxuXHRcdFx0Z3MgPSB3LmNvbS5ncmVlbnNvY2ssXG5cdFx0XHRfMlBJID0gTWF0aC5QSSAqIDIsXG5cdFx0XHRfSEFMRl9QSSA9IE1hdGguUEkgLyAyLFxuXHRcdFx0X2NsYXNzID0gZ3MuX2NsYXNzLFxuXHRcdFx0X2NyZWF0ZSA9IGZ1bmN0aW9uKG4sIGYpIHtcblx0XHRcdFx0dmFyIEMgPSBfY2xhc3MoXCJlYXNpbmcuXCIgKyBuLCBmdW5jdGlvbigpe30sIHRydWUpLFxuXHRcdFx0XHRcdHAgPSBDLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0XHRcdHAuY29uc3RydWN0b3IgPSBDO1xuXHRcdFx0XHRwLmdldFJhdGlvID0gZjtcblx0XHRcdFx0cmV0dXJuIEM7XG5cdFx0XHR9LFxuXHRcdFx0X2Vhc2VSZWcgPSBFYXNlLnJlZ2lzdGVyIHx8IGZ1bmN0aW9uKCl7fSwgLy9wdXQgYW4gZW1wdHkgZnVuY3Rpb24gaW4gcGxhY2UganVzdCBhcyBhIHNhZmV0eSBtZWFzdXJlIGluIGNhc2Ugc29tZW9uZSBsb2FkcyBhbiBPTEQgdmVyc2lvbiBvZiBUd2VlbkxpdGUuanMgd2hlcmUgRWFzZS5yZWdpc3RlciBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0X3dyYXAgPSBmdW5jdGlvbihuYW1lLCBFYXNlT3V0LCBFYXNlSW4sIEVhc2VJbk91dCwgYWxpYXNlcykge1xuXHRcdFx0XHR2YXIgQyA9IF9jbGFzcyhcImVhc2luZy5cIituYW1lLCB7XG5cdFx0XHRcdFx0ZWFzZU91dDpuZXcgRWFzZU91dCgpLFxuXHRcdFx0XHRcdGVhc2VJbjpuZXcgRWFzZUluKCksXG5cdFx0XHRcdFx0ZWFzZUluT3V0Om5ldyBFYXNlSW5PdXQoKVxuXHRcdFx0XHR9LCB0cnVlKTtcblx0XHRcdFx0X2Vhc2VSZWcoQywgbmFtZSk7XG5cdFx0XHRcdHJldHVybiBDO1xuXHRcdFx0fSxcblx0XHRcdEVhc2VQb2ludCA9IGZ1bmN0aW9uKHRpbWUsIHZhbHVlLCBuZXh0KSB7XG5cdFx0XHRcdHRoaXMudCA9IHRpbWU7XG5cdFx0XHRcdHRoaXMudiA9IHZhbHVlO1xuXHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdHRoaXMubmV4dCA9IG5leHQ7XG5cdFx0XHRcdFx0bmV4dC5wcmV2ID0gdGhpcztcblx0XHRcdFx0XHR0aGlzLmMgPSBuZXh0LnYgLSB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLmdhcCA9IG5leHQudCAtIHRpbWU7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vQmFja1xuXHRcdFx0X2NyZWF0ZUJhY2sgPSBmdW5jdGlvbihuLCBmKSB7XG5cdFx0XHRcdHZhciBDID0gX2NsYXNzKFwiZWFzaW5nLlwiICsgbiwgZnVuY3Rpb24ob3ZlcnNob290KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9wMSA9IChvdmVyc2hvb3QgfHwgb3ZlcnNob290ID09PSAwKSA/IG92ZXJzaG9vdCA6IDEuNzAxNTg7XG5cdFx0XHRcdFx0XHR0aGlzLl9wMiA9IHRoaXMuX3AxICogMS41MjU7XG5cdFx0XHRcdFx0fSwgdHJ1ZSksIFxuXHRcdFx0XHRcdHAgPSBDLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0XHRcdHAuY29uc3RydWN0b3IgPSBDO1xuXHRcdFx0XHRwLmdldFJhdGlvID0gZjtcblx0XHRcdFx0cC5jb25maWcgPSBmdW5jdGlvbihvdmVyc2hvb3QpIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEMob3ZlcnNob290KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIEM7XG5cdFx0XHR9LFxuXG5cdFx0XHRCYWNrID0gX3dyYXAoXCJCYWNrXCIsXG5cdFx0XHRcdF9jcmVhdGVCYWNrKFwiQmFja091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdFx0cmV0dXJuICgocCA9IHAgLSAxKSAqIHAgKiAoKHRoaXMuX3AxICsgMSkgKiBwICsgdGhpcy5fcDEpICsgMSk7XG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRfY3JlYXRlQmFjayhcIkJhY2tJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHAgKiBwICogKCh0aGlzLl9wMSArIDEpICogcCAtIHRoaXMuX3AxKTtcblx0XHRcdFx0fSksXG5cdFx0XHRcdF9jcmVhdGVCYWNrKFwiQmFja0luT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0XHRyZXR1cm4gKChwICo9IDIpIDwgMSkgPyAwLjUgKiBwICogcCAqICgodGhpcy5fcDIgKyAxKSAqIHAgLSB0aGlzLl9wMikgOiAwLjUgKiAoKHAgLT0gMikgKiBwICogKCh0aGlzLl9wMiArIDEpICogcCArIHRoaXMuX3AyKSArIDIpO1xuXHRcdFx0XHR9KVxuXHRcdFx0KSxcblxuXG5cdFx0XHQvL1Nsb3dNb1xuXHRcdFx0U2xvd01vID0gX2NsYXNzKFwiZWFzaW5nLlNsb3dNb1wiLCBmdW5jdGlvbihsaW5lYXJSYXRpbywgcG93ZXIsIHlveW9Nb2RlKSB7XG5cdFx0XHRcdHBvd2VyID0gKHBvd2VyIHx8IHBvd2VyID09PSAwKSA/IHBvd2VyIDogMC43O1xuXHRcdFx0XHRpZiAobGluZWFyUmF0aW8gPT0gbnVsbCkge1xuXHRcdFx0XHRcdGxpbmVhclJhdGlvID0gMC43O1xuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmVhclJhdGlvID4gMSkge1xuXHRcdFx0XHRcdGxpbmVhclJhdGlvID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9wID0gKGxpbmVhclJhdGlvICE9PSAxKSA/IHBvd2VyIDogMDtcblx0XHRcdFx0dGhpcy5fcDEgPSAoMSAtIGxpbmVhclJhdGlvKSAvIDI7XG5cdFx0XHRcdHRoaXMuX3AyID0gbGluZWFyUmF0aW87XG5cdFx0XHRcdHRoaXMuX3AzID0gdGhpcy5fcDEgKyB0aGlzLl9wMjtcblx0XHRcdFx0dGhpcy5fY2FsY0VuZCA9ICh5b3lvTW9kZSA9PT0gdHJ1ZSk7XG5cdFx0XHR9LCB0cnVlKSxcblx0XHRcdHAgPSBTbG93TW8ucHJvdG90eXBlID0gbmV3IEVhc2UoKSxcblx0XHRcdFN0ZXBwZWRFYXNlLCBFeHBvU2NhbGVFYXNlLCBSb3VnaEVhc2UsIF9jcmVhdGVFbGFzdGljO1xuXHRcdFx0XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFNsb3dNbztcblx0XHRwLmdldFJhdGlvID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0dmFyIHIgPSBwICsgKDAuNSAtIHApICogdGhpcy5fcDtcblx0XHRcdGlmIChwIDwgdGhpcy5fcDEpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbGNFbmQgPyAxIC0gKChwID0gMSAtIChwIC8gdGhpcy5fcDEpKSAqIHApIDogciAtICgocCA9IDEgLSAocCAvIHRoaXMuX3AxKSkgKiBwICogcCAqIHAgKiByKTtcblx0XHRcdH0gZWxzZSBpZiAocCA+IHRoaXMuX3AzKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9jYWxjRW5kID8gKHAgPT09IDEgPyAwIDogMSAtIChwID0gKHAgLSB0aGlzLl9wMykgLyB0aGlzLl9wMSkgKiBwKSA6IHIgKyAoKHAgLSByKSAqIChwID0gKHAgLSB0aGlzLl9wMykgLyB0aGlzLl9wMSkgKiBwICogcCAqIHApOyAvL2FkZGVkIHAgPT09IDEgPyAwIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBmcm9tIGFmZmVjdGluZyB0aGUgZmluYWwgdmFsdWUsIGxpa2UgMSAtIDAuNyA9IDAuMzAwMDAwMDAwMDAwMDAwMDQgaW5zdGVhZCBvZiAwLjNcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9jYWxjRW5kID8gMSA6IHI7XG5cdFx0fTtcblx0XHRTbG93TW8uZWFzZSA9IG5ldyBTbG93TW8oMC43LCAwLjcpO1xuXHRcdFxuXHRcdHAuY29uZmlnID0gU2xvd01vLmNvbmZpZyA9IGZ1bmN0aW9uKGxpbmVhclJhdGlvLCBwb3dlciwgeW95b01vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgU2xvd01vKGxpbmVhclJhdGlvLCBwb3dlciwgeW95b01vZGUpO1xuXHRcdH07XG5cblxuXHRcdC8vU3RlcHBlZEVhc2Vcblx0XHRTdGVwcGVkRWFzZSA9IF9jbGFzcyhcImVhc2luZy5TdGVwcGVkRWFzZVwiLCBmdW5jdGlvbihzdGVwcywgaW1tZWRpYXRlU3RhcnQpIHtcblx0XHRcdFx0c3RlcHMgPSBzdGVwcyB8fCAxO1xuXHRcdFx0XHR0aGlzLl9wMSA9IDEgLyBzdGVwcztcblx0XHRcdFx0dGhpcy5fcDIgPSBzdGVwcyArIChpbW1lZGlhdGVTdGFydCA/IDAgOiAxKTtcblx0XHRcdFx0dGhpcy5fcDMgPSBpbW1lZGlhdGVTdGFydCA/IDEgOiAwO1xuXHRcdFx0fSwgdHJ1ZSk7XG5cdFx0cCA9IFN0ZXBwZWRFYXNlLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XHRcblx0XHRwLmNvbnN0cnVjdG9yID0gU3RlcHBlZEVhc2U7XG5cdFx0cC5nZXRSYXRpbyA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdGlmIChwIDwgMCkge1xuXHRcdFx0XHRwID0gMDtcblx0XHRcdH0gZWxzZSBpZiAocCA+PSAxKSB7XG5cdFx0XHRcdHAgPSAwLjk5OTk5OTk5OTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAoKCh0aGlzLl9wMiAqIHApIHwgMCkgKyB0aGlzLl9wMykgKiB0aGlzLl9wMTtcblx0XHR9O1xuXHRcdHAuY29uZmlnID0gU3RlcHBlZEVhc2UuY29uZmlnID0gZnVuY3Rpb24oc3RlcHMsIGltbWVkaWF0ZVN0YXJ0KSB7XG5cdFx0XHRyZXR1cm4gbmV3IFN0ZXBwZWRFYXNlKHN0ZXBzLCBpbW1lZGlhdGVTdGFydCk7XG5cdFx0fTtcblxuXG5cdFx0Ly9FeHBvU2NhbGVFYXNlXG5cdFx0RXhwb1NjYWxlRWFzZSA9IF9jbGFzcyhcImVhc2luZy5FeHBvU2NhbGVFYXNlXCIsIGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIGVhc2UpIHtcblx0XHRcdHRoaXMuX3AxID0gTWF0aC5sb2coZW5kIC8gc3RhcnQpO1xuXHRcdFx0dGhpcy5fcDIgPSBlbmQgLSBzdGFydDtcblx0XHRcdHRoaXMuX3AzID0gc3RhcnQ7XG5cdFx0XHR0aGlzLl9lYXNlID0gZWFzZTtcblx0XHR9LCB0cnVlKTtcblx0XHRwID0gRXhwb1NjYWxlRWFzZS5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBFeHBvU2NhbGVFYXNlO1xuXHRcdHAuZ2V0UmF0aW8gPSBmdW5jdGlvbihwKSB7XG5cdFx0XHRpZiAodGhpcy5fZWFzZSkge1xuXHRcdFx0XHRwID0gdGhpcy5fZWFzZS5nZXRSYXRpbyhwKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodGhpcy5fcDMgKiBNYXRoLmV4cCh0aGlzLl9wMSAqIHApIC0gdGhpcy5fcDMpIC8gdGhpcy5fcDI7XG5cdFx0fTtcblx0XHRwLmNvbmZpZyA9IEV4cG9TY2FsZUVhc2UuY29uZmlnID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgZWFzZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBFeHBvU2NhbGVFYXNlKHN0YXJ0LCBlbmQsIGVhc2UpO1xuXHRcdH07XG5cblxuXHRcdC8vUm91Z2hFYXNlXG5cdFx0Um91Z2hFYXNlID0gX2NsYXNzKFwiZWFzaW5nLlJvdWdoRWFzZVwiLCBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHR2YXJzID0gdmFycyB8fCB7fTtcblx0XHRcdHZhciB0YXBlciA9IHZhcnMudGFwZXIgfHwgXCJub25lXCIsXG5cdFx0XHRcdGEgPSBbXSxcblx0XHRcdFx0Y250ID0gMCxcblx0XHRcdFx0cG9pbnRzID0gKHZhcnMucG9pbnRzIHx8IDIwKSB8IDAsXG5cdFx0XHRcdGkgPSBwb2ludHMsXG5cdFx0XHRcdHJhbmRvbWl6ZSA9ICh2YXJzLnJhbmRvbWl6ZSAhPT0gZmFsc2UpLFxuXHRcdFx0XHRjbGFtcCA9ICh2YXJzLmNsYW1wID09PSB0cnVlKSxcblx0XHRcdFx0dGVtcGxhdGUgPSAodmFycy50ZW1wbGF0ZSBpbnN0YW5jZW9mIEVhc2UpID8gdmFycy50ZW1wbGF0ZSA6IG51bGwsXG5cdFx0XHRcdHN0cmVuZ3RoID0gKHR5cGVvZih2YXJzLnN0cmVuZ3RoKSA9PT0gXCJudW1iZXJcIikgPyB2YXJzLnN0cmVuZ3RoICogMC40IDogMC40LFxuXHRcdFx0XHR4LCB5LCBidW1wLCBpbnZYLCBvYmosIHBudDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHR4ID0gcmFuZG9taXplID8gTWF0aC5yYW5kb20oKSA6ICgxIC8gcG9pbnRzKSAqIGk7XG5cdFx0XHRcdHkgPSB0ZW1wbGF0ZSA/IHRlbXBsYXRlLmdldFJhdGlvKHgpIDogeDtcblx0XHRcdFx0aWYgKHRhcGVyID09PSBcIm5vbmVcIikge1xuXHRcdFx0XHRcdGJ1bXAgPSBzdHJlbmd0aDtcblx0XHRcdFx0fSBlbHNlIGlmICh0YXBlciA9PT0gXCJvdXRcIikge1xuXHRcdFx0XHRcdGludlggPSAxIC0geDtcblx0XHRcdFx0XHRidW1wID0gaW52WCAqIGludlggKiBzdHJlbmd0aDtcblx0XHRcdFx0fSBlbHNlIGlmICh0YXBlciA9PT0gXCJpblwiKSB7XG5cdFx0XHRcdFx0YnVtcCA9IHggKiB4ICogc3RyZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSBpZiAoeCA8IDAuNSkgeyAgLy9cImJvdGhcIiAoc3RhcnQpXG5cdFx0XHRcdFx0aW52WCA9IHggKiAyO1xuXHRcdFx0XHRcdGJ1bXAgPSBpbnZYICogaW52WCAqIDAuNSAqIHN0cmVuZ3RoO1xuXHRcdFx0XHR9IGVsc2Uge1x0XHRcdFx0Ly9cImJvdGhcIiAoZW5kKVxuXHRcdFx0XHRcdGludlggPSAoMSAtIHgpICogMjtcblx0XHRcdFx0XHRidW1wID0gaW52WCAqIGludlggKiAwLjUgKiBzdHJlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmFuZG9taXplKSB7XG5cdFx0XHRcdFx0eSArPSAoTWF0aC5yYW5kb20oKSAqIGJ1bXApIC0gKGJ1bXAgKiAwLjUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGkgJSAyKSB7XG5cdFx0XHRcdFx0eSArPSBidW1wICogMC41O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHkgLT0gYnVtcCAqIDAuNTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2xhbXApIHtcblx0XHRcdFx0XHRpZiAoeSA+IDEpIHtcblx0XHRcdFx0XHRcdHkgPSAxO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoeSA8IDApIHtcblx0XHRcdFx0XHRcdHkgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRhW2NudCsrXSA9IHt4OngsIHk6eX07XG5cdFx0XHR9XG5cdFx0XHRhLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gYS54IC0gYi54O1xuXHRcdFx0fSk7XG5cblx0XHRcdHBudCA9IG5ldyBFYXNlUG9pbnQoMSwgMSwgbnVsbCk7XG5cdFx0XHRpID0gcG9pbnRzO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdG9iaiA9IGFbaV07XG5cdFx0XHRcdHBudCA9IG5ldyBFYXNlUG9pbnQob2JqLngsIG9iai55LCBwbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9wcmV2ID0gbmV3IEVhc2VQb2ludCgwLCAwLCAocG50LnQgIT09IDApID8gcG50IDogcG50Lm5leHQpO1xuXHRcdH0sIHRydWUpO1xuXHRcdHAgPSBSb3VnaEVhc2UucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcblx0XHRwLmNvbnN0cnVjdG9yID0gUm91Z2hFYXNlO1xuXHRcdHAuZ2V0UmF0aW8gPSBmdW5jdGlvbihwKSB7XG5cdFx0XHR2YXIgcG50ID0gdGhpcy5fcHJldjtcblx0XHRcdGlmIChwID4gcG50LnQpIHtcblx0XHRcdFx0d2hpbGUgKHBudC5uZXh0ICYmIHAgPj0gcG50LnQpIHtcblx0XHRcdFx0XHRwbnQgPSBwbnQubmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwbnQgPSBwbnQucHJldjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlIChwbnQucHJldiAmJiBwIDw9IHBudC50KSB7XG5cdFx0XHRcdFx0cG50ID0gcG50LnByZXY7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX3ByZXYgPSBwbnQ7XG5cdFx0XHRyZXR1cm4gKHBudC52ICsgKChwIC0gcG50LnQpIC8gcG50LmdhcCkgKiBwbnQuYyk7XG5cdFx0fTtcblx0XHRwLmNvbmZpZyA9IGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdHJldHVybiBuZXcgUm91Z2hFYXNlKHZhcnMpO1xuXHRcdH07XG5cdFx0Um91Z2hFYXNlLmVhc2UgPSBuZXcgUm91Z2hFYXNlKCk7XG5cblxuXHRcdC8vQm91bmNlXG5cdFx0X3dyYXAoXCJCb3VuY2VcIixcblx0XHRcdF9jcmVhdGUoXCJCb3VuY2VPdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRpZiAocCA8IDEgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIHAgKiBwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyIC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiAocCAtPSAxLjUgLyAyLjc1KSAqIHAgKyAwLjc1O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyLjUgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIChwIC09IDIuMjUgLyAyLjc1KSAqIHAgKyAwLjkzNzU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIChwIC09IDIuNjI1IC8gMi43NSkgKiBwICsgMC45ODQzNzU7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJCb3VuY2VJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdGlmICgocCA9IDEgLSBwKSA8IDEgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDEgLSAoNy41NjI1ICogcCAqIHApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyIC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiAxIC0gKDcuNTYyNSAqIChwIC09IDEuNSAvIDIuNzUpICogcCArIDAuNzUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyLjUgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDEgLSAoNy41NjI1ICogKHAgLT0gMi4yNSAvIDIuNzUpICogcCArIDAuOTM3NSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIDEgLSAoNy41NjI1ICogKHAgLT0gMi42MjUgLyAyLjc1KSAqIHAgKyAwLjk4NDM3NSk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJCb3VuY2VJbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHZhciBpbnZlcnQgPSAocCA8IDAuNSk7XG5cdFx0XHRcdGlmIChpbnZlcnQpIHtcblx0XHRcdFx0XHRwID0gMSAtIChwICogMik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cCA9IChwICogMikgLSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwIDwgMSAvIDIuNzUpIHtcblx0XHRcdFx0XHRwID0gNy41NjI1ICogcCAqIHA7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cCA9IDcuNTYyNSAqIChwIC09IDEuNSAvIDIuNzUpICogcCArIDAuNzU7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIuNSAvIDIuNzUpIHtcblx0XHRcdFx0XHRwID0gNy41NjI1ICogKHAgLT0gMi4yNSAvIDIuNzUpICogcCArIDAuOTM3NTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwID0gNy41NjI1ICogKHAgLT0gMi42MjUgLyAyLjc1KSAqIHAgKyAwLjk4NDM3NTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gaW52ZXJ0ID8gKDEgLSBwKSAqIDAuNSA6IHAgKiAwLjUgKyAwLjU7XG5cdFx0XHR9KVxuXHRcdCk7XG5cblxuXHRcdC8vQ0lSQ1xuXHRcdF93cmFwKFwiQ2lyY1wiLFxuXHRcdFx0X2NyZWF0ZShcIkNpcmNPdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KDEgLSAocCA9IHAgLSAxKSAqIHApO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiQ2lyY0luXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIC0oTWF0aC5zcXJ0KDEgLSAocCAqIHApKSAtIDEpO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiQ2lyY0luT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuICgocCo9MikgPCAxKSA/IC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBwICogcCkgLSAxKSA6IDAuNSAqIChNYXRoLnNxcnQoMSAtIChwIC09IDIpICogcCkgKyAxKTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXG5cdFx0Ly9FbGFzdGljXG5cdFx0X2NyZWF0ZUVsYXN0aWMgPSBmdW5jdGlvbihuLCBmLCBkZWYpIHtcblx0XHRcdHZhciBDID0gX2NsYXNzKFwiZWFzaW5nLlwiICsgbiwgZnVuY3Rpb24oYW1wbGl0dWRlLCBwZXJpb2QpIHtcblx0XHRcdFx0XHR0aGlzLl9wMSA9IChhbXBsaXR1ZGUgPj0gMSkgPyBhbXBsaXR1ZGUgOiAxOyAvL25vdGU6IGlmIGFtcGxpdHVkZSBpcyA8IDEsIHdlIHNpbXBseSBhZGp1c3QgdGhlIHBlcmlvZCBmb3IgYSBtb3JlIG5hdHVyYWwgZmVlbC4gT3RoZXJ3aXNlIHRoZSBtYXRoIGRvZXNuJ3Qgd29yayByaWdodCBhbmQgdGhlIGN1cnZlIHN0YXJ0cyBhdCAxLlxuXHRcdFx0XHRcdHRoaXMuX3AyID0gKHBlcmlvZCB8fCBkZWYpIC8gKGFtcGxpdHVkZSA8IDEgPyBhbXBsaXR1ZGUgOiAxKTtcblx0XHRcdFx0XHR0aGlzLl9wMyA9IHRoaXMuX3AyIC8gXzJQSSAqIChNYXRoLmFzaW4oMSAvIHRoaXMuX3AxKSB8fCAwKTtcblx0XHRcdFx0XHR0aGlzLl9wMiA9IF8yUEkgLyB0aGlzLl9wMjsgLy9wcmVjYWxjdWxhdGUgdG8gb3B0aW1pemVcblx0XHRcdFx0fSwgdHJ1ZSksXG5cdFx0XHRcdHAgPSBDLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0XHRwLmNvbnN0cnVjdG9yID0gQztcblx0XHRcdHAuZ2V0UmF0aW8gPSBmO1xuXHRcdFx0cC5jb25maWcgPSBmdW5jdGlvbihhbXBsaXR1ZGUsIHBlcmlvZCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEMoYW1wbGl0dWRlLCBwZXJpb2QpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBDO1xuXHRcdH07XG5cdFx0X3dyYXAoXCJFbGFzdGljXCIsXG5cdFx0XHRfY3JlYXRlRWxhc3RpYyhcIkVsYXN0aWNPdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcDEgKiBNYXRoLnBvdygyLCAtMTAgKiBwKSAqIE1hdGguc2luKCAocCAtIHRoaXMuX3AzKSAqIHRoaXMuX3AyICkgKyAxO1xuXHRcdFx0fSwgMC4zKSxcblx0XHRcdF9jcmVhdGVFbGFzdGljKFwiRWxhc3RpY0luXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIC0odGhpcy5fcDEgKiBNYXRoLnBvdygyLCAxMCAqIChwIC09IDEpKSAqIE1hdGguc2luKCAocCAtIHRoaXMuX3AzKSAqIHRoaXMuX3AyICkpO1xuXHRcdFx0fSwgMC4zKSxcblx0XHRcdF9jcmVhdGVFbGFzdGljKFwiRWxhc3RpY0luT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuICgocCAqPSAyKSA8IDEpID8gLTAuNSAqICh0aGlzLl9wMSAqIE1hdGgucG93KDIsIDEwICogKHAgLT0gMSkpICogTWF0aC5zaW4oIChwIC0gdGhpcy5fcDMpICogdGhpcy5fcDIpKSA6IHRoaXMuX3AxICogTWF0aC5wb3coMiwgLTEwICoocCAtPSAxKSkgKiBNYXRoLnNpbiggKHAgLSB0aGlzLl9wMykgKiB0aGlzLl9wMiApICogMC41ICsgMTtcblx0XHRcdH0sIDAuNDUpXG5cdFx0KTtcblxuXG5cdFx0Ly9FeHBvXG5cdFx0X3dyYXAoXCJFeHBvXCIsXG5cdFx0XHRfY3JlYXRlKFwiRXhwb091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAxIC0gTWF0aC5wb3coMiwgLTEwICogcCk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJFeHBvSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5wb3coMiwgMTAgKiAocCAtIDEpKSAtIDAuMDAxO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiRXhwb0luT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuICgocCAqPSAyKSA8IDEpID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAocCAtIDEpKSA6IDAuNSAqICgyIC0gTWF0aC5wb3coMiwgLTEwICogKHAgLSAxKSkpO1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cblx0XHQvL1NpbmVcblx0XHRfd3JhcChcIlNpbmVcIixcblx0XHRcdF9jcmVhdGUoXCJTaW5lT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIE1hdGguc2luKHAgKiBfSEFMRl9QSSk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJTaW5lSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLU1hdGguY29zKHAgKiBfSEFMRl9QSSkgKyAxO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiU2luZUluT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIC0wLjUgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHApIC0gMSk7XG5cdFx0XHR9KVxuXHRcdCk7XG5cblx0XHRfY2xhc3MoXCJlYXNpbmcuRWFzZUxvb2t1cFwiLCB7XG5cdFx0XHRcdGZpbmQ6ZnVuY3Rpb24ocykge1xuXHRcdFx0XHRcdHJldHVybiBFYXNlLm1hcFtzXTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdHJ1ZSk7XG5cblx0XHQvL3JlZ2lzdGVyIHRoZSBub24tc3RhbmRhcmQgZWFzZXNcblx0XHRfZWFzZVJlZyh3LlNsb3dNbywgXCJTbG93TW9cIiwgXCJlYXNlLFwiKTtcblx0XHRfZWFzZVJlZyhSb3VnaEVhc2UsIFwiUm91Z2hFYXNlXCIsIFwiZWFzZSxcIik7XG5cdFx0X2Vhc2VSZWcoU3RlcHBlZEVhc2UsIFwiU3RlcHBlZEVhc2VcIiwgXCJlYXNlLFwiKTtcblx0XHRcblx0XHRyZXR1cm4gQmFjaztcblx0XHRcblx0fSwgdHJ1ZSk7XG5cbmV4cG9ydCB2YXIgQmFjayA9IGdsb2JhbHMuQmFjaztcbmV4cG9ydCB2YXIgRWxhc3RpYyA9IGdsb2JhbHMuRWxhc3RpYztcbmV4cG9ydCB2YXIgQm91bmNlID0gZ2xvYmFscy5Cb3VuY2U7XG5leHBvcnQgdmFyIFJvdWdoRWFzZSA9IGdsb2JhbHMuUm91Z2hFYXNlO1xuZXhwb3J0IHZhciBTbG93TW8gPSBnbG9iYWxzLlNsb3dNbztcbmV4cG9ydCB2YXIgU3RlcHBlZEVhc2UgPSBnbG9iYWxzLlN0ZXBwZWRFYXNlO1xuZXhwb3J0IHZhciBDaXJjID0gZ2xvYmFscy5DaXJjO1xuZXhwb3J0IHZhciBFeHBvID0gZ2xvYmFscy5FeHBvO1xuZXhwb3J0IHZhciBTaW5lID0gZ2xvYmFscy5TaW5lO1xuZXhwb3J0IHZhciBFeHBvU2NhbGVFYXNlID0gZ2xvYmFscy5FeHBvU2NhbGVFYXNlO1xuZXhwb3J0IHsgTGluZWFyLCBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIFBvd2VyNCB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dzYXAvRWFzZVBhY2suanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2V0c0xvYWRlciA9IHJlcXVpcmUoJy4vZ3JvdXAnKTtcbmFzc2V0c0xvYWRlci5zdGF0cyA9IHJlcXVpcmUoJy4vc3RhdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3NldHNMb2FkZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hc3NldHMtbG9hZGVyL3NyYy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJy4vZW1pdHRlci5qcycpO1xudmFyIGNyZWF0ZUxvYWRlciA9IHJlcXVpcmUoJy4vbG9hZGVyJyk7XG52YXIgYXV0b0lkID0gMDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVHcm91cChjb25maWcpIHtcbiAgICB2YXIgZ3JvdXA7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIHZhciBhc3NldHMgPSBbXTtcbiAgICB2YXIgcXVldWUgPSBbXTtcbiAgICB2YXIgbnVtTG9hZGVkID0gMDtcbiAgICB2YXIgbnVtVG90YWwgPSAwO1xuICAgIHZhciBsb2FkZXJzID0ge307XG5cbiAgICB2YXIgYWRkID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAvLyBjb25zb2xlLmRlYnVnKCdhZGQnLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZm9yRWFjaChhZGQpO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0dyb3VwID0gISFvcHRpb25zLmFzc2V0cyAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMuYXNzZXRzKTtcbiAgICAgICAgLy8gY29uc29sZS5kZWJ1ZygnaXNHcm91cCcsIGlzR3JvdXApO1xuICAgICAgICB2YXIgbG9hZGVyO1xuICAgICAgICBpZiAoaXNHcm91cCkge1xuICAgICAgICAgICAgbG9hZGVyID0gY3JlYXRlR3JvdXAoY29uZmlndXJlKG9wdGlvbnMsIGNvbmZpZykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9hZGVyID0gY3JlYXRlTG9hZGVyKGNvbmZpZ3VyZShvcHRpb25zLCBjb25maWcpKTtcbiAgICAgICAgfVxuICAgICAgICBsb2FkZXIub25jZSgnZGVzdHJveScsIGRlc3Ryb3lIYW5kbGVyKTtcbiAgICAgICAgcXVldWUucHVzaChsb2FkZXIpO1xuICAgICAgICBsb2FkZXJzW2xvYWRlci5pZF0gPSBsb2FkZXI7XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICB9O1xuXG4gICAgdmFyIGdldCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzc2V0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFwW2lkXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcFtpZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvYWRlcnNbaWRdO1xuICAgIH07XG5cbiAgICB2YXIgZmluZCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmIChnZXQoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KGlkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm91bmQgPSBudWxsO1xuICAgICAgICBPYmplY3Qua2V5cyhsb2FkZXJzKS5zb21lKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgZm91bmQgPSBsb2FkZXJzW2tleV0uZmluZCAmJiBsb2FkZXJzW2tleV0uZmluZChpZCk7XG4gICAgICAgICAgICByZXR1cm4gISFmb3VuZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9O1xuXG4gICAgdmFyIGdldEV4dGVuc2lvbiA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICByZXR1cm4gdXJsICYmIHVybC5zcGxpdCgnPycpWzBdLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbmZpZ3VyZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmlzVG91Y2hMb2NrZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5pc1RvdWNoTG9ja2VkID0gZGVmYXVsdHMuaXNUb3VjaExvY2tlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmJsb2IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5ibG9iID0gZGVmYXVsdHMuYmxvYjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmJhc2VQYXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYmFzZVBhdGggPSBkZWZhdWx0cy5iYXNlUGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMuaWQgPSBvcHRpb25zLmlkIHx8IG9wdGlvbnMudXJsIHx8IFN0cmluZygrK2F1dG9JZCk7XG4gICAgICAgIG9wdGlvbnMudHlwZSA9IG9wdGlvbnMudHlwZSB8fCBnZXRFeHRlbnNpb24ob3B0aW9ucy51cmwpO1xuICAgICAgICBvcHRpb25zLmNyb3NzT3JpZ2luID0gb3B0aW9ucy5jcm9zc09yaWdpbiB8fCBkZWZhdWx0cy5jcm9zc09yaWdpbjtcbiAgICAgICAgb3B0aW9ucy53ZWJBdWRpb0NvbnRleHQgPSBvcHRpb25zLndlYkF1ZGlvQ29udGV4dCB8fCBkZWZhdWx0cy53ZWJBdWRpb0NvbnRleHQ7XG4gICAgICAgIG9wdGlvbnMubG9nID0gZGVmYXVsdHMubG9nO1xuXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH07XG5cbiAgICB2YXIgc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbnVtVG90YWwgPSBxdWV1ZS5sZW5ndGg7XG5cbiAgICAgICAgcXVldWUuZm9yRWFjaChmdW5jdGlvbihsb2FkZXIpIHtcbiAgICAgICAgICAgIGxvYWRlclxuICAgICAgICAgICAgICAgIC5vbigncHJvZ3Jlc3MnLCBwcm9ncmVzc0hhbmRsZXIpXG4gICAgICAgICAgICAgICAgLm9uY2UoJ2NvbXBsZXRlJywgY29tcGxldGVIYW5kbGVyKVxuICAgICAgICAgICAgICAgIC5vbmNlKCdlcnJvcicsIGVycm9ySGFuZGxlcilcbiAgICAgICAgICAgICAgICAuc3RhcnQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcXVldWUgPSBbXTtcblxuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfTtcblxuICAgIHZhciBwcm9ncmVzc0hhbmRsZXIgPSBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgICB2YXIgbG9hZGVkID0gbnVtTG9hZGVkICsgcHJvZ3Jlc3M7XG4gICAgICAgIGdyb3VwLmVtaXQoJ3Byb2dyZXNzJywgbG9hZGVkIC8gbnVtVG90YWwpO1xuICAgIH07XG5cbiAgICB2YXIgY29tcGxldGVIYW5kbGVyID0gZnVuY3Rpb24oYXNzZXQsIGlkLCB0eXBlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFzc2V0KSkge1xuICAgICAgICAgICAgYXNzZXQgPSB7IGlkOiBpZCwgZmlsZTogYXNzZXQsIHR5cGU6IHR5cGUgfTtcbiAgICAgICAgfVxuICAgICAgICBudW1Mb2FkZWQrKztcbiAgICAgICAgZ3JvdXAuZW1pdCgncHJvZ3Jlc3MnLCBudW1Mb2FkZWQgLyBudW1Ub3RhbCk7XG4gICAgICAgIG1hcFthc3NldC5pZF0gPSBhc3NldC5maWxlO1xuICAgICAgICBhc3NldHMucHVzaChhc3NldCk7XG4gICAgICAgIGdyb3VwLmVtaXQoJ2NoaWxkY29tcGxldGUnLCBhc3NldCk7XG4gICAgICAgIGNoZWNrQ29tcGxldGUoKTtcbiAgICB9O1xuXG4gICAgdmFyIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICBudW1Ub3RhbC0tO1xuICAgICAgICBpZiAoZ3JvdXAubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCkge1xuICAgICAgICAgICAgZ3JvdXAuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrQ29tcGxldGUoKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlc3Ryb3lIYW5kbGVyID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgbG9hZGVyc1tpZF0gPSBudWxsO1xuICAgICAgICBkZWxldGUgbG9hZGVyc1tpZF07XG5cbiAgICAgICAgbWFwW2lkXSA9IG51bGw7XG4gICAgICAgIGRlbGV0ZSBtYXBbaWRdO1xuXG4gICAgICAgIGFzc2V0cy5zb21lKGZ1bmN0aW9uKGFzc2V0LCBpKSB7XG4gICAgICAgICAgICBpZiAoYXNzZXQuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgYXNzZXRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBjaGVja0NvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChudW1Mb2FkZWQgPj0gbnVtVG90YWwpIHtcbiAgICAgICAgICAgIGdyb3VwLmVtaXQoJ2NvbXBsZXRlJywgYXNzZXRzLCBtYXAsIGNvbmZpZy5pZCwgJ2dyb3VwJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcXVldWUucG9wKCkuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGdyb3VwLm9mZignZXJyb3InKTtcbiAgICAgICAgZ3JvdXAub2ZmKCdwcm9ncmVzcycpO1xuICAgICAgICBncm91cC5vZmYoJ2NvbXBsZXRlJyk7XG4gICAgICAgIGFzc2V0cyA9IFtdO1xuICAgICAgICBtYXAgPSB7fTtcbiAgICAgICAgY29uZmlnLndlYkF1ZGlvQ29udGV4dCA9IG51bGw7XG4gICAgICAgIG51bVRvdGFsID0gMDtcbiAgICAgICAgbnVtTG9hZGVkID0gMDtcblxuICAgICAgICBPYmplY3Qua2V5cyhsb2FkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgbG9hZGVyc1trZXldLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxvYWRlcnMgPSB7fTtcblxuICAgICAgICBncm91cC5lbWl0KCdkZXN0cm95JywgZ3JvdXAuaWQpO1xuXG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICB9O1xuXG4gICAgLy8gZW1pdHM6IHByb2dyZXNzLCBlcnJvciwgY29tcGxldGUsIGRlc3Ryb3lcblxuICAgIGdyb3VwID0gT2JqZWN0LmNyZWF0ZShFbWl0dGVyLnByb3RvdHlwZSwge1xuICAgICAgICBfZXZlbnRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSxcbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkOiB7XG4gICAgICAgICAgICB2YWx1ZTogYWRkXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICB2YWx1ZTogc3RhcnRcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiB7XG4gICAgICAgICAgICB2YWx1ZTogZ2V0XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmQ6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmaW5kXG4gICAgICAgIH0sXG4gICAgICAgIGdldExvYWRlcjoge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlcnNbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsb2FkZWQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bUxvYWRlZCA+PSBudW1Ub3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmlsZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXNzZXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiB7XG4gICAgICAgICAgICB2YWx1ZTogZGVzdHJveVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25maWcgPSBjb25maWd1cmUoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgIGJhc2VQYXRoOiAnJyxcbiAgICAgICAgYmxvYjogZmFsc2UsXG4gICAgICAgIHRvdWNoTG9ja2VkOiBmYWxzZSxcbiAgICAgICAgY3Jvc3NPcmlnaW46IG51bGwsXG4gICAgICAgIHdlYkF1ZGlvQ29udGV4dDogbnVsbCxcbiAgICAgICAgbG9nOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmFzc2V0cykpIHtcbiAgICAgICAgYWRkKGNvbmZpZy5hc3NldHMpO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGdyb3VwKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hc3NldHMtbG9hZGVyL3NyYy9ncm91cC5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJy4vZW1pdHRlci5qcycpO1xudmFyIGJyb3dzZXJIYXNCbG9iID0gcmVxdWlyZSgnLi9icm93c2VyLWhhcy1ibG9iLmpzJyk7XG52YXIgc3RhdHMgPSByZXF1aXJlKCcuL3N0YXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBpZCA9IG9wdGlvbnMuaWQ7XG4gICAgdmFyIGJhc2VQYXRoID0gb3B0aW9ucy5iYXNlUGF0aCB8fCAnJztcbiAgICB2YXIgdXJsID0gb3B0aW9ucy51cmw7XG4gICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgdmFyIGNyb3NzT3JpZ2luID0gb3B0aW9ucy5jcm9zc09yaWdpbjtcbiAgICB2YXIgaXNUb3VjaExvY2tlZCA9IG9wdGlvbnMuaXNUb3VjaExvY2tlZDtcbiAgICB2YXIgYmxvYiA9IG9wdGlvbnMuYmxvYiAmJiBicm93c2VySGFzQmxvYjtcbiAgICB2YXIgd2ViQXVkaW9Db250ZXh0ID0gb3B0aW9ucy53ZWJBdWRpb0NvbnRleHQ7XG4gICAgdmFyIGxvZyA9IG9wdGlvbnMubG9nO1xuXG4gICAgdmFyIGxvYWRlcjtcbiAgICB2YXIgbG9hZEhhbmRsZXI7XG4gICAgdmFyIHJlcXVlc3Q7XG4gICAgdmFyIHN0YXJ0VGltZTtcbiAgICB2YXIgdGltZW91dDtcbiAgICB2YXIgZmlsZTtcblxuICAgIHZhciBzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgICAgICAgbG9hZEpTT04oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2pwZyc6XG4gICAgICAgICAgICBjYXNlICdwbmcnOlxuICAgICAgICAgICAgY2FzZSAnZ2lmJzpcbiAgICAgICAgICAgIGNhc2UgJ3dlYnAnOlxuICAgICAgICAgICAgICAgIGxvYWRJbWFnZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICAgIGNhc2UgJ29nZyc6XG4gICAgICAgICAgICBjYXNlICdvcHVzJzpcbiAgICAgICAgICAgIGNhc2UgJ3dhdic6XG4gICAgICAgICAgICBjYXNlICdtNGEnOlxuICAgICAgICAgICAgICAgIGxvYWRBdWRpbygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb2d2JzpcbiAgICAgICAgICAgIGNhc2UgJ21wNCc6XG4gICAgICAgICAgICBjYXNlICd3ZWJtJzpcbiAgICAgICAgICAgIGNhc2UgJ2hscyc6XG4gICAgICAgICAgICAgICAgbG9hZFZpZGVvKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiaW4nOlxuICAgICAgICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgICAgICAgICBsb2FkWEhSKCdhcnJheWJ1ZmZlcicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndHh0JzpcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgIGxvYWRYSFIoJ3RleHQnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0Fzc2V0c0xvYWRlciBFUlJPUjogVW5rbm93biB0eXBlIGZvciBmaWxlIHdpdGggVVJMOiAnICsgYmFzZVBhdGggKyB1cmwgKyAnICgnICsgdHlwZSArICcpJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZGlzcGF0Y2hDb21wbGV0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmlsZSA9IHtpZDogaWQsIGZpbGU6IGRhdGEsIHR5cGU6IHR5cGV9O1xuICAgICAgICBsb2FkZXIuZW1pdCgncHJvZ3Jlc3MnLCAxKTtcbiAgICAgICAgbG9hZGVyLmVtaXQoJ2NvbXBsZXRlJywgZmlsZSwgaWQsIHR5cGUpO1xuICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICB9O1xuXG4gICAgdmFyIGxvYWRYSFIgPSBmdW5jdGlvbihyZXNwb25zZVR5cGUsIGN1c3RvbUxvYWRIYW5kbGVyKSB7XG4gICAgICAgIGxvYWRIYW5kbGVyID0gY3VzdG9tTG9hZEhhbmRsZXIgfHwgY29tcGxldGVIYW5kbGVyO1xuXG4gICAgICAgIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBiYXNlUGF0aCArIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgcHJvZ3Jlc3NIYW5kbGVyKTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZEhhbmRsZXIpO1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgfTtcblxuICAgIHZhciBwcm9ncmVzc0hhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgICAgbG9hZGVyLmVtaXQoJ3Byb2dyZXNzJywgZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjb21wbGV0ZUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHN1Y2Nlc3MoKSkge1xuICAgICAgICAgICAgZGlzcGF0Y2hDb21wbGV0ZShyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3VjY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnc3VjY2VzcycsIHVybCwgcmVxdWVzdC5zdGF0dXMpO1xuICAgICAgICBpZiAocmVxdWVzdCAmJiByZXF1ZXN0LnN0YXR1cyA8IDQwMCkge1xuICAgICAgICAgICAgc3RhdHMudXBkYXRlKHJlcXVlc3QsIHN0YXJ0VGltZSwgdXJsLCBsb2cpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JIYW5kbGVyKHJlcXVlc3QgJiYgcmVxdWVzdC5zdGF0dXNUZXh0KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyBqc29uXG5cbiAgICB2YXIgbG9hZEpTT04gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbG9hZFhIUignanNvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MoKSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaENvbXBsZXRlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gaW1hZ2VcblxuICAgIHZhciBsb2FkSW1hZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGJsb2IpIHtcbiAgICAgICAgICAgIGxvYWRJbWFnZUJsb2IoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvYWRJbWFnZUVsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbG9hZEltYWdlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXF1ZXN0ID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGlmIChjcm9zc09yaWdpbikge1xuICAgICAgICAgICAgcmVxdWVzdC5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZWxlbWVudExvYWRIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIHJlcXVlc3Quc3JjID0gYmFzZVBhdGggKyB1cmw7XG4gICAgfTtcblxuICAgIHZhciBlbGVtZW50TG9hZEhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBpZiAoIWV2ZW50ICYmIChyZXF1ZXN0LmVycm9yIHx8ICFyZXF1ZXN0LnJlYWR5U3RhdGUpKSB7XG4gICAgICAgICAgICBlcnJvckhhbmRsZXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaENvbXBsZXRlKHJlcXVlc3QpO1xuICAgIH07XG5cbiAgICB2YXIgbG9hZEltYWdlQmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBsb2FkWEhSKCdibG9iJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoc3VjY2VzcygpKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBpbWFnZUJsb2JIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBpbWFnZUJsb2JIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHJlcXVlc3Quc3JjKTtcbiAgICAgICAgZGlzcGF0Y2hDb21wbGV0ZShyZXF1ZXN0KTtcbiAgICB9O1xuXG4gICAgLy8gYXVkaW9cblxuICAgIHZhciBsb2FkQXVkaW8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHdlYkF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgbG9hZEF1ZGlvQnVmZmVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2FkTWVkaWFFbGVtZW50KCdhdWRpbycpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHZpZGVvXG5cbiAgICB2YXIgbG9hZFZpZGVvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChibG9iKSB7XG4gICAgICAgICAgICBsb2FkWEhSKCdibG9iJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2FkTWVkaWFFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGF1ZGlvIGJ1ZmZlclxuXG4gICAgdmFyIGxvYWRBdWRpb0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBsb2FkWEhSKCdhcnJheWJ1ZmZlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MoKSkge1xuICAgICAgICAgICAgICAgIHdlYkF1ZGlvQ29udGV4dC5kZWNvZGVBdWRpb0RhdGEoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENvbXBsZXRlKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBtZWRpYSBlbGVtZW50XG5cbiAgICB2YXIgbG9hZE1lZGlhRWxlbWVudCA9IGZ1bmN0aW9uKHRhZ05hbWUpIHtcbiAgICAgICAgcmVxdWVzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG5cbiAgICAgICAgaWYgKCFpc1RvdWNoTG9ja2VkKSB7XG4gICAgICAgICAgICAvLyB0aW1lb3V0IGJlY2F1c2Ugc29tZXRpbWVzIGNhbnBsYXl0aHJvdWdoIGRvZXNuJ3QgZmlyZVxuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChlbGVtZW50TG9hZEhhbmRsZXIsIDIwMDApO1xuICAgICAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIGVsZW1lbnRMb2FkSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlciwgZmFsc2UpO1xuICAgICAgICByZXF1ZXN0LnByZWxvYWQgPSAnYXV0byc7XG4gICAgICAgIHJlcXVlc3Quc3JjID0gYmFzZVBhdGggKyB1cmw7XG4gICAgICAgIHJlcXVlc3QubG9hZCgpO1xuXG4gICAgICAgIGlmIChpc1RvdWNoTG9ja2VkKSB7XG4gICAgICAgICAgICBkaXNwYXRjaENvbXBsZXRlKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGVycm9yXG5cbiAgICB2YXIgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdlcnJvckhhbmRsZXInLCB1cmwsIGVycik7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG5cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBlcnI7XG5cbiAgICAgICAgaWYgKHJlcXVlc3QgJiYgcmVxdWVzdC50YWdOYW1lICYmIHJlcXVlc3QuZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBFUlJPUl9TVEFURSA9IFsnJywgJ0FCT1JURUQnLCAnTkVUV09SSycsICdERUNPREUnLCAnU1JDX05PVF9TVVBQT1JURUQnXTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnTWVkaWFFcnJvcjogJyArIEVSUk9SX1NUQVRFW3JlcXVlc3QuZXJyb3IuY29kZV0gKyAnICcgKyByZXF1ZXN0LnNyYztcbiAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0ICYmIHJlcXVlc3Quc3RhdHVzVGV4dCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHJlcXVlc3Quc3RhdHVzVGV4dDtcbiAgICAgICAgfSBlbHNlIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnIgJiYgZXJyLnR5cGUpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnIudHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvYWRlci5lbWl0KCdlcnJvcicsICdFcnJvciBsb2FkaW5nIFwiJyArIGJhc2VQYXRoICsgdXJsICsgJ1wiICcgKyBtZXNzYWdlKTtcblxuICAgICAgICBkZXN0cm95KCk7XG4gICAgfTtcblxuICAgIC8vIGNsZWFuIHVwXG5cbiAgICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGxvYWRlci5vZmYoJ2Vycm9yJyk7XG4gICAgICAgIGxvYWRlci5vZmYoJ3Byb2dyZXNzJyk7XG4gICAgICAgIGxvYWRlci5vZmYoJ2NvbXBsZXRlJyk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBwcm9ncmVzc0hhbmRsZXIpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZEhhbmRsZXIpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBlbGVtZW50TG9hZEhhbmRsZXIpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIGVsZW1lbnRMb2FkSGFuZGxlcik7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBpbWFnZUJsb2JIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcblxuICAgICAgICBpZiAocmVxdWVzdCAmJiByZXF1ZXN0LmFib3J0ICYmIHJlcXVlc3QucmVhZHlTdGF0ZSA8IDQpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgICB3ZWJBdWRpb0NvbnRleHQgPSBudWxsO1xuICAgICAgICBmaWxlID0gbnVsbDtcblxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgICAgIGxvYWRlci5lbWl0KCdkZXN0cm95JywgaWQpO1xuICAgIH07XG5cbiAgICAvLyBlbWl0czogcHJvZ3Jlc3MsIGVycm9yLCBjb21wbGV0ZVxuXG4gICAgbG9hZGVyID0gT2JqZWN0LmNyZWF0ZShFbWl0dGVyLnByb3RvdHlwZSwge1xuICAgICAgICBfZXZlbnRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSxcbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmlkXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICB2YWx1ZTogc3RhcnRcbiAgICAgICAgfSxcbiAgICAgICAgbG9hZGVkOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWZpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6IHtcbiAgICAgICAgICAgIHZhbHVlOiBkZXN0cm95XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGxvYWRlcik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXNzZXRzLWxvYWRlci9zcmMvbG9hZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAhIW5ldyBCbG9iKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Fzc2V0cy1sb2FkZXIvc3JjL2Jyb3dzZXItaGFzLWJsb2IuanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIExvYWRpbmdBbmltLmpzXG5cbmltcG9ydCBhbGZyaWQgZnJvbSAnYWxmcmlkJztcblxuY29uc3QgQ0FOVkFTX1NJWkUgPSAyMDA7XG5jb25zdCBDT0xPUl9CTEFDSyA9IFwiIzAwMFwiO1xuY29uc3QgQ09MT1JfV0hJVEUgPSBcIiNmZmZcIjtcblxuLy8qL1xuY29uc3QgQ09MT1JfUElOSyA9IFwiI2EwYTBhMFwiO1xuLyovXG5jb25zdCBDT0xPUl9QSU5LID0gXCIjZjY5ODgyXCI7XG4vLyovXG5cbmNsYXNzIExvYWRpbmdBbmltIGV4dGVuZHMgYWxmcmlkLkV2ZW50RGlzcGF0Y2hlciB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuY2FudmFzID0gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKCcubG9hZGluZy1hbmltJyk7XG5cdFx0dGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuXHRcdHRoaXMuX2hhc0FuaW1hdGlvbkNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2hhc0NhbGxlZENsb3NlID0gZmFsc2U7XG5cdFx0dGhpcy5zdGFydEFuaW1hdGlvbigpO1xuXHR9XG5cblxuXHRzdGFydEFuaW1hdGlvbigpIHtcblxuXHQgIGxldCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG5cdCAgbGV0IGFuaW1hdGlvbkxpc3QgPSBbXG5cdCAgICB7dHlwZTogJ2FyYycsc3RhcnQ6IDAsZW5kOiAtMzYwLCBzQW5nbGU6IDAsIHJhZGl1czogNDAwLCB4OiA0MDAseTogNDAwLGRlbGF5OiAuNTUsIGR1cmF0aW9uOiAxLGNvbG9yOiBDT0xPUl9QSU5LLCByZXZlcnNlOiB0cnVlfSxcblx0ICAgIHt0eXBlOiAnZXllJ30sXG5cdCAgICB7dHlwZTogJ2FyYycsc3RhcnQ6IDE4MCxlbmQ6IDM2MCwgc0FuZ2xlOiAxODAsIHJhZGl1czogNDA0LCB4OiA0MDAseTogNDAwLGRlbGF5OiAxLjUsIGR1cmF0aW9uOiAuODUsY29sb3I6IENPTE9SX1dISVRFLCByZXZlcnNlOiBmYWxzZX0sXG5cdCAgICB7dHlwZTogJ2FyYycsc3RhcnQ6IDAsZW5kOiAzNjAsIHNBbmdsZTogMCwgcmFkaXVzOiAxMTIsIHg6IDYyMCx5OiAzODUsZGVsYXk6IDEuNiwgZHVyYXRpb246IDEsY29sb3I6IENPTE9SX1dISVRFLCByZXZlcnNlOiBmYWxzZX0sXG5cdCAgICB7dHlwZTogJ2FyYycsc3RhcnQ6IDAsZW5kOiAtMTgwLCBzQW5nbGU6IDAsIHJhZGl1czogODMsIHg6IDQwMCx5OiA2NjcsZGVsYXk6IDEuMTUsIGR1cmF0aW9uOiAxLGNvbG9yOiBDT0xPUl9QSU5LLCByZXZlcnNlOiB0cnVlfSxcblx0ICAgIHt0eXBlOiAnYXJjJyxzdGFydDogMCxlbmQ6IC0zNjAsIHNBbmdsZTogMCwgcmFkaXVzOiAxMTIsIHg6IDE4MCx5OiAzODUsZGVsYXk6IDEuODUsIGR1cmF0aW9uOiAxLGNvbG9yOiBDT0xPUl9QSU5LLCByZXZlcnNlOiB0cnVlfSxcblx0ICAgIHt0eXBlOiAnYXJjJyxzdGFydDogMCxlbmQ6IDE4MCwgc0FuZ2xlOiAwLCByYWRpdXM6IDgzLCB4OiA0MDAseTogNjY3LGRlbGF5OiAxLjY1LCBkdXJhdGlvbjogMSxjb2xvcjogQ09MT1JfV0hJVEUsIHJldmVyc2U6IGZhbHNlfSxcblx0ICAgIHt0eXBlOiAncmFkaXVzJyxzdGFydDogMCxlbmQ6IDU0LHg6IDE4MCx5OiAzODUsZGVsYXk6IC4wMCxkdXJhdGlvbjogMSxjb2xvcjogQ09MT1JfQkxBQ0t9LFxuXHQgICAge3R5cGU6ICdyYWRpdXMnLHN0YXJ0OiAwLGVuZDogNTQseDogNjIwLHk6IDM4NSxkZWxheTogLjA2LGR1cmF0aW9uOiAxLGNvbG9yOiBDT0xPUl9CTEFDS30sXG5cdCAgICB7dHlwZTogJ3JhZGl1cycsc3RhcnQ6IDAsZW5kOiAzNCx4OiA0MDAseTogNjY3LGRlbGF5OiAuMDMsZHVyYXRpb246IDEsY29sb3I6IENPTE9SX0JMQUNLfSxcblx0ICAgIHt0eXBlOiAnYXJjJyxzdGFydDogMCxlbmQ6IC0xODAsIHNBbmdsZTogMCwgcmFkaXVzOiAyNywgeDogNDAwLHk6IDEyNSxkZWxheTogMS42NSwgZHVyYXRpb246IDEsY29sb3I6IENPTE9SX0JMQUNLLCByZXZlcnNlOiB0cnVlfSxcblx0ICAgIHt0eXBlOiAnYXJjJyxzdGFydDogMCxlbmQ6IC0xODAsIHNBbmdsZTogMCwgcmFkaXVzOiAyNywgeDogNDAwLHk6IDIxMCxkZWxheTogMS43NywgZHVyYXRpb246IDEsY29sb3I6IENPTE9SX0JMQUNLLCByZXZlcnNlOiB0cnVlfSxcblx0ICAgIHt0eXBlOiAnYXJjJyxzdGFydDogMCxlbmQ6IC0xODAsIHNBbmdsZTogMCwgcmFkaXVzOiAyNywgeDogNDAwLHk6IDI5NSxkZWxheTogMS44NSwgZHVyYXRpb246IDEsY29sb3I6IENPTE9SX0JMQUNLLCByZXZlcnNlOiB0cnVlfSxcblx0ICAgIHt0eXBlOiAnYXJjJyxzdGFydDogMCxlbmQ6IC0xODAsIHNBbmdsZTogMCwgcmFkaXVzOiAyNywgeDogNDAwLHk6IDM4MCxkZWxheTogMS45NSwgZHVyYXRpb246IDEsY29sb3I6IENPTE9SX0JMQUNLLCByZXZlcnNlOiB0cnVlfVxuXHQgIF07XG5cblx0ICBsZXQgZXllID0ge1xuXG5cdCAgICByYWRpdXM6IDgyIC8gNCxcblx0ICAgIGNlbnRlcjogeyB4OiA2MjAgLyA0LCB5OiAzODUgLyA0LCB4MTogNjIwIC8gNCwgeTE6IDM4NSAvIDQsIHgyOiA2MjAgLyA0LCB5MjogMzg1IC8gNCB9LFxuXHQgICAgc3RhcnQ6IHt4OjQ4NSAvIDQseTo1MjAgLyA0fSxcblx0ICAgIGVuZDoge3g6NzU1IC8gNCwgeToyNTAgLyA0fVxuXG5cdCAgfTtcblxuXHQgIGxldCB0aW1lbGluZSA9IG51bGw7XG5cdCAgdGltZWxpbmUgPSBuZXcgVGltZWxpbmVMaXRlKHtcblxuXHQgICAgZGVsYXk6IDEsXG5cdCAgICBvblN0YXJ0OiAoKT0+IHtcblxuXHQgICAgfSxcblx0ICAgIG9uVXBkYXRlOiAoKSA9PiB7XG5cblx0ICAgICAgYW5pbWF0aW9uTGlzdC5tYXAoaXRlbSA9PiB7XG5cdCAgICAgICAgaWYoaXRlbS50eXBlID09ICdyYWRpdXMnKSB0aGlzLmRyYXdBcmMoY29udGV4dCxpdGVtLmNvbG9yLGl0ZW0ueCxpdGVtLnksMCxpdGVtLnN0YXJ0LDAsMzYwKTtcblx0ICAgICAgICBlbHNlIGlmKGl0ZW0udHlwZSA9PSAnYXJjJykgdGhpcy5kcmF3QXJjKGNvbnRleHQsaXRlbS5jb2xvcixpdGVtLngsaXRlbS55LDAsaXRlbS5yYWRpdXMsaXRlbS5zQW5nbGUsaXRlbS5zdGFydCxpdGVtLnJldmVyc2UpO1xuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBDT0xPUl9CTEFDSztcblx0ICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cdCAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhleWUuc3RhcnQueCxleWUuc3RhcnQueSk7XG5cdCAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oZXllLmNlbnRlci54MSxleWUuY2VudGVyLnkxLGV5ZS5lbmQueCxleWUuZW5kLnkpO1xuXHQgICAgICAgICAgY29udGV4dC5tb3ZlVG8oZXllLnN0YXJ0LngsZXllLnN0YXJ0LnkpO1xuXHQgICAgICAgICAgY29udGV4dC5maWxsKCk7XG5cdCAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXHQgICAgICAgICAgY29udGV4dC5tb3ZlVG8oZXllLnN0YXJ0LngsZXllLnN0YXJ0LnkpO1xuXHQgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGV5ZS5jZW50ZXIueDIsZXllLmNlbnRlci55MixleWUuZW5kLngsZXllLmVuZC55KTtcblx0ICAgICAgICAgIGNvbnRleHQubW92ZVRvKGV5ZS5zdGFydC54LGV5ZS5zdGFydC55KTtcblx0ICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuXHQgICAgICAgIH07XG5cblx0ICAgICAgfSk7XG5cblxuXG5cdCAgICB9LFxuXHQgICAgb25Db21wbGV0ZTogKCkgPT50aGlzLm9uQW5pbWF0aW9uQ29tcGxldGUoKVxuXG5cdCAgfSk7XG5cblx0ICB0aW1lbGluZS5wYXVzZSgpO1xuXG5cdCAgYW5pbWF0aW9uTGlzdC5tYXAoaXRlbSA9PiB7XG5cblx0ICAgICAgdGltZWxpbmUuaW5zZXJ0KG5ldyBUd2VlbkxpdGUoaXRlbSxpdGVtLmR1cmF0aW9uLHtcblx0ICAgICAgICBkZWxheTogaXRlbS5kZWxheSxcblx0ICAgICAgICBzdGFydDogaXRlbS5lbmQsXG5cdCAgICAgICAgZWFzZTogRXhwby5lYXNlSW5PdXRcblx0ICAgICAgfSkpO1xuXG5cdCAgfSk7XG5cblxuXHQgIHRpbWVsaW5lLmluc2VydChuZXcgVHdlZW5MaXRlKGV5ZS5jZW50ZXIsLjc1LHtcblxuXHQgICAgZGVsYXk6IDIuMjUsXG5cdCAgICB4MTogZXllLmNlbnRlci54ICsgZXllLnJhZGl1cyxcblx0ICAgIHkxOiBleWUuY2VudGVyLnkgKyBleWUucmFkaXVzLFxuXHQgICAgeDI6IGV5ZS5jZW50ZXIueCAtIGV5ZS5yYWRpdXMsXG5cdCAgICB5MjogZXllLmNlbnRlci55IC0gZXllLnJhZGl1cyxcblx0ICAgIGVhc2U6IEV4cG8uZWFzZUluT3V0XG5cblx0ICB9KSk7XG5cblxuXHQgIHRpbWVsaW5lLnBsYXkoKTtcblxuXG5cdH1cblxuXHRvbkFuaW1hdGlvbkNvbXBsZXRlKCkge1xuXHRcdHRoaXMuX2hhc0FuaW1hdGlvbkNvbXBsZXRlZCA9IHRydWU7XG5cdH1cblxuXG5cdGNsb3NlKCkge1xuXHRcdGlmKCF0aGlzLl9oYXNBbmltYXRpb25Db21wbGV0ZWQpIHtcblx0XHRcdHRoaXMuX2hhc0NhbGxlZENsb3NlID0gdHJ1ZTtcblx0XHRcdGFsZnJpZC5TY2hlZHVsZXIubmV4dCgoKT0+dGhpcy5jbG9zZSgpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzZXRUaW1lb3V0KCgpPT4ge1xuXHRcdFx0dGhpcy5jYW52YXMuY2xhc3NMaXN0LmFkZCgnY2xvc2UnKTtcblx0XHR9LCB0aGlzLl9oYXNDYWxsZWRDbG9zZSA/IDUwMCA6IDEpO1xuXHRcdFxuXHRcdHNldFRpbWVvdXQoKCk9PiB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ29uQW5pbUNsb3NlZCcpO1xuXHRcdH0sICB0aGlzLl9oYXNDYWxsZWRDbG9zZSA/IDE1MDAgOiAxMDAwKVxuXHRcdFxuXHR9XG5cblxuXHRkcmF3QXJjKGN0eCxjb2xvcixjZW50ZXJYLGNlbnRlclksaW5uZXJSYWRpdXMsb3V0ZXJSYWRpdXMsc3RhcnRBbmdsZSxlbmRBbmdsZSxhbnRpY2xvY2t3aXNlKSB7XG5cblx0XHRjZW50ZXJYID0gY2VudGVyWCAvIDQ7XG5cdFx0Y2VudGVyWSA9IGNlbnRlclkgLyA0O1xuXHRcdGlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXMgLyA0O1xuXHRcdG91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLyA0O1xuXG5cdFx0c3RhcnRBbmdsZSAtPSA5MDtcblx0XHRlbmRBbmdsZSAtPSA5MDtcblxuXHRcdGxldCB0aDEgPSBzdGFydEFuZ2xlICogTWF0aC5QSS8xODA7XG5cdFx0bGV0IHRoMiA9IGVuZEFuZ2xlICogTWF0aC5QSS8xODA7XG5cdFx0bGV0IHN0YXJ0T2ZPdXRlckFyY1ggPSBvdXRlclJhZGl1cyAqIE1hdGguY29zKHRoMikgKyBjZW50ZXJYO1xuXHRcdGxldCBzdGFydE9mT3V0ZXJBcmNZID0gb3V0ZXJSYWRpdXMgKiBNYXRoLnNpbih0aDIpICsgY2VudGVyWTtcblxuXHRcdGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmFyYyhjZW50ZXJYLCBjZW50ZXJZLCBpbm5lclJhZGl1cywgdGgxLCB0aDIsIGFudGljbG9ja3dpc2UpO1xuXHRcdGN0eC5saW5lVG8oc3RhcnRPZk91dGVyQXJjWCwgc3RhcnRPZk91dGVyQXJjWSk7XG5cdFx0Y3R4LmFyYyhjZW50ZXJYLCBjZW50ZXJZLCBvdXRlclJhZGl1cywgdGgyLCB0aDEsICFhbnRpY2xvY2t3aXNlKTtcblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0Y3R4LmZpbGwoKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTG9hZGluZ0FuaW07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL0xvYWRpbmdBbmltLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==